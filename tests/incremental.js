/// <reference path="types.ts"/>
var ts;
(function (ts) {
    function forEach(array, callback) {
        var result;
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (result = callback(array[i])) {
                    break;
                }
            }
        }
        return result;
    }
    ts.forEach = forEach;
    function contains(array, value) {
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.contains = contains;
    function indexOf(array, value) {
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
        }
        return -1;
    }
    ts.indexOf = indexOf;
    function countWhere(array, predicate) {
        var count = 0;
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (predicate(array[i])) {
                    count++;
                }
            }
        }
        return count;
    }
    ts.countWhere = countWhere;
    function filter(array, f) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (f(item)) {
                    result.push(item);
                }
            }
        }
        return result;
    }
    ts.filter = filter;
    function map(array, f) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                result.push(f(array[i]));
            }
        }
        return result;
    }
    ts.map = map;
    function concatenate(array1, array2) {
        if (!array2 || !array2.length)
            return array1;
        if (!array1 || !array1.length)
            return array2;
        return array1.concat(array2);
    }
    ts.concatenate = concatenate;
    function deduplicate(array) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (!contains(result, item))
                    result.push(item);
            }
        }
        return result;
    }
    ts.deduplicate = deduplicate;
    function sum(array, prop) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i][prop];
        }
        return result;
    }
    ts.sum = sum;
    function binarySearch(array, value) {
        var low = 0;
        var high = array.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = array[middle];
            if (midValue === value) {
                return middle;
            }
            else if (midValue > value) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }
        return ~low;
    }
    ts.binarySearch = binarySearch;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasProperty(map, key) {
        return hasOwnProperty.call(map, key);
    }
    ts.hasProperty = hasProperty;
    function getProperty(map, key) {
        return hasOwnProperty.call(map, key) ? map[key] : undefined;
    }
    ts.getProperty = getProperty;
    function isEmpty(map) {
        for (var id in map) {
            if (hasProperty(map, id)) {
                return false;
            }
        }
        return true;
    }
    ts.isEmpty = isEmpty;
    function clone(object) {
        var result = {};
        for (var id in object) {
            result[id] = object[id];
        }
        return result;
    }
    ts.clone = clone;
    function forEachValue(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(map[id]))
                break;
        }
        return result;
    }
    ts.forEachValue = forEachValue;
    function forEachKey(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(id))
                break;
        }
        return result;
    }
    ts.forEachKey = forEachKey;
    function lookUp(map, key) {
        return hasProperty(map, key) ? map[key] : undefined;
    }
    ts.lookUp = lookUp;
    function mapToArray(map) {
        var result = [];
        for (var id in map) {
            result.push(map[id]);
        }
        return result;
    }
    ts.mapToArray = mapToArray;
    /**
     * Creates a map from the elements of an array.
     *
     * @param array the array of input elements.
     * @param makeKey a function that produces a key for a given element.
     *
     * This function makes no effort to avoid collisions; if any two elements produce
     * the same key with the given 'makeKey' function, then the element with the higher
     * index in the array will be the one associated with the produced key.
     */
    function arrayToMap(array, makeKey) {
        var result = {};
        forEach(array, function (value) {
            result[makeKey(value)] = value;
        });
        return result;
    }
    ts.arrayToMap = arrayToMap;
    function formatStringFromArgs(text, args, baseIndex) {
        baseIndex = baseIndex || 0;
        return text.replace(/{(\d+)}/g, function (match, index) { return args[+index + baseIndex]; });
    }
    ts.localizedDiagnosticMessages = undefined;
    function getLocaleSpecificMessage(message) {
        return ts.localizedDiagnosticMessages && ts.localizedDiagnosticMessages[message] ? ts.localizedDiagnosticMessages[message] : message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createFileDiagnostic(file, start, length, message) {
        Debug.assert(start >= 0, "start must be non-negative, is " + start);
        Debug.assert(length >= 0, "length must be non-negative, is " + length);
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            isEarly: message.isEarly
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code,
            isEarly: message.isEarly
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function concatenateDiagnosticMessageChains(headChain, tailChain) {
        Debug.assert(!headChain.next);
        headChain.next = tailChain;
        return headChain;
    }
    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;
    function flattenDiagnosticChain(file, start, length, diagnosticChain, newLine) {
        Debug.assert(start >= 0, "start must be non-negative, is " + start);
        Debug.assert(length >= 0, "length must be non-negative, is " + length);
        var code = diagnosticChain.code;
        var category = diagnosticChain.category;
        var messageText = "";
        var indent = 0;
        while (diagnosticChain) {
            if (indent) {
                messageText += newLine;
                for (var i = 0; i < indent; i++) {
                    messageText += "  ";
                }
            }
            messageText += diagnosticChain.messageText;
            indent++;
            diagnosticChain = diagnosticChain.next;
        }
        return {
            file: file,
            start: start,
            length: length,
            code: code,
            category: category,
            messageText: messageText
        };
    }
    ts.flattenDiagnosticChain = flattenDiagnosticChain;
    function compareValues(a, b) {
        if (a === b)
            return 0 /* EqualTo */;
        if (a === undefined)
            return -1 /* LessThan */;
        if (b === undefined)
            return 1 /* GreaterThan */;
        return a < b ? -1 /* LessThan */ : 1 /* GreaterThan */;
    }
    ts.compareValues = compareValues;
    function getDiagnosticFilename(diagnostic) {
        return diagnostic.file ? diagnostic.file.filename : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareValues(getDiagnosticFilename(d1), getDiagnosticFilename(d2)) || compareValues(d1.start, d2.start) || compareValues(d1.length, d2.length) || compareValues(d1.code, d2.code) || compareValues(d1.messageText, d2.messageText) || 0;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function deduplicateSortedDiagnostics(diagnostics) {
        if (diagnostics.length < 2) {
            return diagnostics;
        }
        var newDiagnostics = [diagnostics[0]];
        var previousDiagnostic = diagnostics[0];
        for (var i = 1; i < diagnostics.length; i++) {
            var currentDiagnostic = diagnostics[i];
            var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0 /* EqualTo */;
            if (!isDupe) {
                newDiagnostics.push(currentDiagnostic);
                previousDiagnostic = currentDiagnostic;
            }
        }
        return newDiagnostics;
    }
    ts.deduplicateSortedDiagnostics = deduplicateSortedDiagnostics;
    function normalizeSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    ts.normalizeSlashes = normalizeSlashes;
    // Returns length of path root (i.e. length of "/", "x:/", "//server/share/")
    function getRootLength(path) {
        if (path.charCodeAt(0) === 47 /* slash */) {
            if (path.charCodeAt(1) !== 47 /* slash */)
                return 1;
            var p1 = path.indexOf("/", 2);
            if (p1 < 0)
                return 2;
            var p2 = path.indexOf("/", p1 + 1);
            if (p2 < 0)
                return p1 + 1;
            return p2 + 1;
        }
        if (path.charCodeAt(1) === 58 /* colon */) {
            if (path.charCodeAt(2) === 47 /* slash */)
                return 3;
            return 2;
        }
        return 0;
    }
    ts.getRootLength = getRootLength;
    ts.directorySeparator = "/";
    function getNormalizedParts(normalizedSlashedPath, rootLength) {
        var parts = normalizedSlashedPath.substr(rootLength).split(ts.directorySeparator);
        var normalized = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== ".") {
                if (part === ".." && normalized.length > 0 && normalized[normalized.length - 1] !== "..") {
                    normalized.pop();
                }
                else {
                    normalized.push(part);
                }
            }
        }
        return normalized;
    }
    function normalizePath(path) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        var normalized = getNormalizedParts(path, rootLength);
        return path.substr(0, rootLength) + normalized.join(ts.directorySeparator);
    }
    ts.normalizePath = normalizePath;
    function getDirectoryPath(path) {
        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator)));
    }
    ts.getDirectoryPath = getDirectoryPath;
    function isUrl(path) {
        return path && !isRootedDiskPath(path) && path.indexOf("://") !== -1;
    }
    ts.isUrl = isUrl;
    function isRootedDiskPath(path) {
        return getRootLength(path) !== 0;
    }
    ts.isRootedDiskPath = isRootedDiskPath;
    function normalizedPathComponents(path, rootLength) {
        var normalizedParts = getNormalizedParts(path, rootLength);
        return [path.substr(0, rootLength)].concat(normalizedParts);
    }
    function getNormalizedPathComponents(path, currentDirectory) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        if (rootLength == 0) {
            // If the path is not rooted it is relative to current directory
            path = combinePaths(normalizeSlashes(currentDirectory), path);
            rootLength = getRootLength(path);
        }
        return normalizedPathComponents(path, rootLength);
    }
    ts.getNormalizedPathComponents = getNormalizedPathComponents;
    function getNormalizedPathFromPathComponents(pathComponents) {
        if (pathComponents && pathComponents.length) {
            return pathComponents[0] + pathComponents.slice(1).join(ts.directorySeparator);
        }
    }
    ts.getNormalizedPathFromPathComponents = getNormalizedPathFromPathComponents;
    function getNormalizedPathComponentsOfUrl(url) {
        // Get root length of http://www.website.com/folder1/foler2/
        // In this example the root is:  http://www.website.com/ 
        // normalized path components should be ["http://www.website.com/", "folder1", "folder2"]
        var urlLength = url.length;
        // Initial root length is http:// part
        var rootLength = url.indexOf("://") + "://".length;
        while (rootLength < urlLength) {
            // Consume all immediate slashes in the protocol 
            // eg.initial rootlength is just file:// but it needs to consume another "/" in file:///
            if (url.charCodeAt(rootLength) === 47 /* slash */) {
                rootLength++;
            }
            else {
                break;
            }
        }
        // there are no parts after http:// just return current string as the pathComponent
        if (rootLength === urlLength) {
            return [url];
        }
        // Find the index of "/" after website.com so the root can be http://www.website.com/ (from existing http://)
        var indexOfNextSlash = url.indexOf(ts.directorySeparator, rootLength);
        if (indexOfNextSlash !== -1) {
            // Found the "/" after the website.com so the root is length of http://www.website.com/ 
            // and get components afetr the root normally like any other folder components
            rootLength = indexOfNextSlash + 1;
            return normalizedPathComponents(url, rootLength);
        }
        else {
            // Can't find the host assume the rest of the string as component 
            // but make sure we append "/"  to it as root is not joined using "/"
            // eg. if url passed in was http://website.com we want to use root as [http://website.com/] 
            // so that other path manipulations will be correct and it can be merged with relative paths correctly
            return [url + ts.directorySeparator];
        }
    }
    function getNormalizedPathOrUrlComponents(pathOrUrl, currentDirectory) {
        if (isUrl(pathOrUrl)) {
            return getNormalizedPathComponentsOfUrl(pathOrUrl);
        }
        else {
            return getNormalizedPathComponents(pathOrUrl, currentDirectory);
        }
    }
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl) {
        var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);
        var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);
        if (directoryComponents.length > 1 && directoryComponents[directoryComponents.length - 1] === "") {
            // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name
            // that is  ["test", "cases", ""] needs to be actually ["test", "cases"]
            directoryComponents.length--;
        }
        for (var joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {
            if (getCanonicalFileName(directoryComponents[joinStartIndex]) !== getCanonicalFileName(pathComponents[joinStartIndex])) {
                break;
            }
        }
        // Get the relative path
        if (joinStartIndex) {
            var relativePath = "";
            var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);
            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {
                if (directoryComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + ".." + ts.directorySeparator;
                }
            }
            return relativePath + relativePathComponents.join(ts.directorySeparator);
        }
        // Cant find the relative path, get the absolute path
        var absolutePath = getNormalizedPathFromPathComponents(pathComponents);
        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {
            absolutePath = "file:///" + absolutePath;
        }
        return absolutePath;
    }
    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;
    function getBaseFilename(path) {
        var i = path.lastIndexOf(ts.directorySeparator);
        return i < 0 ? path : path.substring(i + 1);
    }
    ts.getBaseFilename = getBaseFilename;
    function combinePaths(path1, path2) {
        if (!(path1 && path1.length))
            return path2;
        if (!(path2 && path2.length))
            return path1;
        if (path2.charAt(0) === ts.directorySeparator)
            return path2;
        if (path1.charAt(path1.length - 1) === ts.directorySeparator)
            return path1 + path2;
        return path1 + ts.directorySeparator + path2;
    }
    ts.combinePaths = combinePaths;
    function fileExtensionIs(path, extension) {
        var pathLen = path.length;
        var extLen = extension.length;
        return pathLen > extLen && path.substr(pathLen - extLen, extLen) === extension;
    }
    ts.fileExtensionIs = fileExtensionIs;
    var supportedExtensions = [".d.ts", ".ts", ".js"];
    function removeFileExtension(path) {
        for (var i = 0; i < supportedExtensions.length; i++) {
            var ext = supportedExtensions[i];
            if (fileExtensionIs(path, ext)) {
                return path.substr(0, path.length - ext.length);
            }
        }
        return path;
    }
    ts.removeFileExtension = removeFileExtension;
    var escapedCharsRegExp = /[\t\v\f\b\0\r\n\"\\\u2028\u2029\u0085]/g;
    var escapedCharsMap = {
        "\t": "\\t",
        "\v": "\\v",
        "\f": "\\f",
        "\b": "\\b",
        "\0": "\\0",
        "\r": "\\r",
        "\n": "\\n",
        "\"": "\\\"",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029",
        "\u0085": "\\u0085" // nextLine
    };
    /** NOTE: This *does not* support the full escape characters, it only supports the subset that can be used in file names
      * or string literals. If the information encoded in the map changes, this needs to be revisited. */
    function escapeString(s) {
        return escapedCharsRegExp.test(s) ? s.replace(escapedCharsRegExp, function (c) {
            return escapedCharsMap[c] || c;
        }) : s;
    }
    ts.escapeString = escapeString;
    function Symbol(flags, name) {
        this.flags = flags;
        this.name = name;
        this.declarations = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
    }
    function Signature(checker) {
    }
    ts.objectAllocator = {
        getNodeConstructor: function (kind) {
            function Node() {
            }
            Node.prototype = {
                kind: kind,
                pos: 0,
                end: 0,
                flags: 0,
                parent: undefined
            };
            return Node;
        },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; }
    };
    var Debug;
    (function (Debug) {
        var currentAssertionLevel = 0 /* None */;
        function shouldAssert(level) {
            return currentAssertionLevel >= level;
        }
        Debug.shouldAssert = shouldAssert;
        function assert(expression, message, verboseDebugInfo) {
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information: " + verboseDebugInfo();
                }
                throw new Error("Debug Failure. False expression: " + (message || "") + verboseDebugString);
            }
        }
        Debug.assert = assert;
        function fail(message) {
            Debug.assert(false, message);
        }
        Debug.fail = fail;
    })(Debug = ts.Debug || (ts.Debug = {}));
})(ts || (ts = {}));
/// <reference path="core.ts"/>
var ts;
(function (ts) {
    // Return code used by getEmitOutput function to indicate status of the function
    (function (EmitReturnStatus) {
        EmitReturnStatus[EmitReturnStatus["Succeeded"] = 0] = "Succeeded";
        EmitReturnStatus[EmitReturnStatus["AllOutputGenerationSkipped"] = 1] = "AllOutputGenerationSkipped";
        EmitReturnStatus[EmitReturnStatus["JSGeneratedWithSemanticErrors"] = 2] = "JSGeneratedWithSemanticErrors";
        EmitReturnStatus[EmitReturnStatus["DeclarationGenerationSkipped"] = 3] = "DeclarationGenerationSkipped";
        EmitReturnStatus[EmitReturnStatus["EmitErrorsEncountered"] = 4] = "EmitErrorsEncountered";
        EmitReturnStatus[EmitReturnStatus["CompilerOptionsErrors"] = 5] = "CompilerOptionsErrors";
    })(ts.EmitReturnStatus || (ts.EmitReturnStatus = {}));
    var EmitReturnStatus = ts.EmitReturnStatus;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
    })(ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));
    var DiagnosticCategory = ts.DiagnosticCategory;
})(ts || (ts = {}));
// <auto-generated />
/// <reference path="types.ts" />
var ts;
(function (ts) {
    ts.Diagnostics = {
        Unterminated_string_literal: { code: 1002, category: 1 /* Error */, key: "Unterminated string literal." },
        Identifier_expected: { code: 1003, category: 1 /* Error */, key: "Identifier expected." },
        _0_expected: { code: 1005, category: 1 /* Error */, key: "'{0}' expected." },
        A_file_cannot_have_a_reference_to_itself: { code: 1006, category: 1 /* Error */, key: "A file cannot have a reference to itself." },
        Trailing_comma_not_allowed: { code: 1009, category: 1 /* Error */, key: "Trailing comma not allowed." },
        Asterisk_Slash_expected: { code: 1010, category: 1 /* Error */, key: "'*/' expected." },
        Unexpected_token: { code: 1012, category: 1 /* Error */, key: "Unexpected token." },
        Catch_clause_parameter_cannot_have_a_type_annotation: { code: 1013, category: 1 /* Error */, key: "Catch clause parameter cannot have a type annotation." },
        A_rest_parameter_must_be_last_in_a_parameter_list: { code: 1014, category: 1 /* Error */, key: "A rest parameter must be last in a parameter list." },
        Parameter_cannot_have_question_mark_and_initializer: { code: 1015, category: 1 /* Error */, key: "Parameter cannot have question mark and initializer." },
        A_required_parameter_cannot_follow_an_optional_parameter: { code: 1016, category: 1 /* Error */, key: "A required parameter cannot follow an optional parameter." },
        An_index_signature_cannot_have_a_rest_parameter: { code: 1017, category: 1 /* Error */, key: "An index signature cannot have a rest parameter." },
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: { code: 1018, category: 1 /* Error */, key: "An index signature parameter cannot have an accessibility modifier." },
        An_index_signature_parameter_cannot_have_a_question_mark: { code: 1019, category: 1 /* Error */, key: "An index signature parameter cannot have a question mark." },
        An_index_signature_parameter_cannot_have_an_initializer: { code: 1020, category: 1 /* Error */, key: "An index signature parameter cannot have an initializer." },
        An_index_signature_must_have_a_type_annotation: { code: 1021, category: 1 /* Error */, key: "An index signature must have a type annotation." },
        An_index_signature_parameter_must_have_a_type_annotation: { code: 1022, category: 1 /* Error */, key: "An index signature parameter must have a type annotation." },
        An_index_signature_parameter_type_must_be_string_or_number: { code: 1023, category: 1 /* Error */, key: "An index signature parameter type must be 'string' or 'number'." },
        A_class_or_interface_declaration_can_only_have_one_extends_clause: { code: 1024, category: 1 /* Error */, key: "A class or interface declaration can only have one 'extends' clause." },
        An_extends_clause_must_precede_an_implements_clause: { code: 1025, category: 1 /* Error */, key: "An 'extends' clause must precede an 'implements' clause." },
        A_class_can_only_extend_a_single_class: { code: 1026, category: 1 /* Error */, key: "A class can only extend a single class." },
        A_class_declaration_can_only_have_one_implements_clause: { code: 1027, category: 1 /* Error */, key: "A class declaration can only have one 'implements' clause." },
        Accessibility_modifier_already_seen: { code: 1028, category: 1 /* Error */, key: "Accessibility modifier already seen." },
        _0_modifier_must_precede_1_modifier: { code: 1029, category: 1 /* Error */, key: "'{0}' modifier must precede '{1}' modifier." },
        _0_modifier_already_seen: { code: 1030, category: 1 /* Error */, key: "'{0}' modifier already seen." },
        _0_modifier_cannot_appear_on_a_class_element: { code: 1031, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a class element." },
        An_interface_declaration_cannot_have_an_implements_clause: { code: 1032, category: 1 /* Error */, key: "An interface declaration cannot have an 'implements' clause." },
        super_must_be_followed_by_an_argument_list_or_member_access: { code: 1034, category: 1 /* Error */, key: "'super' must be followed by an argument list or member access." },
        Only_ambient_modules_can_use_quoted_names: { code: 1035, category: 1 /* Error */, key: "Only ambient modules can use quoted names." },
        Statements_are_not_allowed_in_ambient_contexts: { code: 1036, category: 1 /* Error */, key: "Statements are not allowed in ambient contexts." },
        A_function_implementation_cannot_be_declared_in_an_ambient_context: { code: 1037, category: 1 /* Error */, key: "A function implementation cannot be declared in an ambient context." },
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: { code: 1038, category: 1 /* Error */, key: "A 'declare' modifier cannot be used in an already ambient context." },
        Initializers_are_not_allowed_in_ambient_contexts: { code: 1039, category: 1 /* Error */, key: "Initializers are not allowed in ambient contexts." },
        _0_modifier_cannot_appear_on_a_module_element: { code: 1044, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a module element." },
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: { code: 1045, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an interface declaration." },
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: { code: 1046, category: 1 /* Error */, key: "A 'declare' modifier is required for a top level declaration in a .d.ts file." },
        A_rest_parameter_cannot_be_optional: { code: 1047, category: 1 /* Error */, key: "A rest parameter cannot be optional." },
        A_rest_parameter_cannot_have_an_initializer: { code: 1048, category: 1 /* Error */, key: "A rest parameter cannot have an initializer." },
        A_set_accessor_must_have_exactly_one_parameter: { code: 1049, category: 1 /* Error */, key: "A 'set' accessor must have exactly one parameter." },
        A_set_accessor_cannot_have_an_optional_parameter: { code: 1051, category: 1 /* Error */, key: "A 'set' accessor cannot have an optional parameter." },
        A_set_accessor_parameter_cannot_have_an_initializer: { code: 1052, category: 1 /* Error */, key: "A 'set' accessor parameter cannot have an initializer." },
        A_set_accessor_cannot_have_rest_parameter: { code: 1053, category: 1 /* Error */, key: "A 'set' accessor cannot have rest parameter." },
        A_get_accessor_cannot_have_parameters: { code: 1054, category: 1 /* Error */, key: "A 'get' accessor cannot have parameters." },
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: { code: 1056, category: 1 /* Error */, key: "Accessors are only available when targeting ECMAScript 5 and higher." },
        Enum_member_must_have_initializer: { code: 1061, category: 1 /* Error */, key: "Enum member must have initializer." },
        An_export_assignment_cannot_be_used_in_an_internal_module: { code: 1063, category: 1 /* Error */, key: "An export assignment cannot be used in an internal module." },
        Ambient_enum_elements_can_only_have_integer_literal_initializers: { code: 1066, category: 1 /* Error */, key: "Ambient enum elements can only have integer literal initializers." },
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: { code: 1068, category: 1 /* Error */, key: "Unexpected token. A constructor, method, accessor, or property was expected." },
        A_declare_modifier_cannot_be_used_with_an_import_declaration: { code: 1079, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an import declaration." },
        Invalid_reference_directive_syntax: { code: 1084, category: 1 /* Error */, key: "Invalid 'reference' directive syntax." },
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: { code: 1085, category: 1 /* Error */, key: "Octal literals are not available when targeting ECMAScript 5 and higher." },
        An_accessor_cannot_be_declared_in_an_ambient_context: { code: 1086, category: 1 /* Error */, key: "An accessor cannot be declared in an ambient context." },
        _0_modifier_cannot_appear_on_a_constructor_declaration: { code: 1089, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a constructor declaration." },
        _0_modifier_cannot_appear_on_a_parameter: { code: 1090, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a parameter." },
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: { code: 1091, category: 1 /* Error */, key: "Only a single variable declaration is allowed in a 'for...in' statement." },
        Type_parameters_cannot_appear_on_a_constructor_declaration: { code: 1092, category: 1 /* Error */, key: "Type parameters cannot appear on a constructor declaration." },
        Type_annotation_cannot_appear_on_a_constructor_declaration: { code: 1093, category: 1 /* Error */, key: "Type annotation cannot appear on a constructor declaration." },
        An_accessor_cannot_have_type_parameters: { code: 1094, category: 1 /* Error */, key: "An accessor cannot have type parameters." },
        A_set_accessor_cannot_have_a_return_type_annotation: { code: 1095, category: 1 /* Error */, key: "A 'set' accessor cannot have a return type annotation." },
        An_index_signature_must_have_exactly_one_parameter: { code: 1096, category: 1 /* Error */, key: "An index signature must have exactly one parameter." },
        _0_list_cannot_be_empty: { code: 1097, category: 1 /* Error */, key: "'{0}' list cannot be empty." },
        Type_parameter_list_cannot_be_empty: { code: 1098, category: 1 /* Error */, key: "Type parameter list cannot be empty." },
        Type_argument_list_cannot_be_empty: { code: 1099, category: 1 /* Error */, key: "Type argument list cannot be empty." },
        Invalid_use_of_0_in_strict_mode: { code: 1100, category: 1 /* Error */, key: "Invalid use of '{0}' in strict mode." },
        with_statements_are_not_allowed_in_strict_mode: { code: 1101, category: 1 /* Error */, key: "'with' statements are not allowed in strict mode." },
        delete_cannot_be_called_on_an_identifier_in_strict_mode: { code: 1102, category: 1 /* Error */, key: "'delete' cannot be called on an identifier in strict mode." },
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: { code: 1104, category: 1 /* Error */, key: "A 'continue' statement can only be used within an enclosing iteration statement." },
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: { code: 1105, category: 1 /* Error */, key: "A 'break' statement can only be used within an enclosing iteration or switch statement." },
        Jump_target_cannot_cross_function_boundary: { code: 1107, category: 1 /* Error */, key: "Jump target cannot cross function boundary." },
        A_return_statement_can_only_be_used_within_a_function_body: { code: 1108, category: 1 /* Error */, key: "A 'return' statement can only be used within a function body." },
        Expression_expected: { code: 1109, category: 1 /* Error */, key: "Expression expected." },
        Type_expected: { code: 1110, category: 1 /* Error */, key: "Type expected." },
        A_constructor_implementation_cannot_be_declared_in_an_ambient_context: { code: 1111, category: 1 /* Error */, key: "A constructor implementation cannot be declared in an ambient context." },
        A_class_member_cannot_be_declared_optional: { code: 1112, category: 1 /* Error */, key: "A class member cannot be declared optional." },
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: { code: 1113, category: 1 /* Error */, key: "A 'default' clause cannot appear more than once in a 'switch' statement." },
        Duplicate_label_0: { code: 1114, category: 1 /* Error */, key: "Duplicate label '{0}'" },
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: { code: 1115, category: 1 /* Error */, key: "A 'continue' statement can only jump to a label of an enclosing iteration statement." },
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: { code: 1116, category: 1 /* Error */, key: "A 'break' statement can only jump to a label of an enclosing statement." },
        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: { code: 1117, category: 1 /* Error */, key: "An object literal cannot have multiple properties with the same name in strict mode." },
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: { code: 1118, category: 1 /* Error */, key: "An object literal cannot have multiple get/set accessors with the same name." },
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: { code: 1119, category: 1 /* Error */, key: "An object literal cannot have property and accessor with the same name." },
        An_export_assignment_cannot_have_modifiers: { code: 1120, category: 1 /* Error */, key: "An export assignment cannot have modifiers." },
        Octal_literals_are_not_allowed_in_strict_mode: { code: 1121, category: 1 /* Error */, key: "Octal literals are not allowed in strict mode." },
        A_tuple_type_element_list_cannot_be_empty: { code: 1122, category: 1 /* Error */, key: "A tuple type element list cannot be empty." },
        Variable_declaration_list_cannot_be_empty: { code: 1123, category: 1 /* Error */, key: "Variable declaration list cannot be empty." },
        Digit_expected: { code: 1124, category: 1 /* Error */, key: "Digit expected." },
        Hexadecimal_digit_expected: { code: 1125, category: 1 /* Error */, key: "Hexadecimal digit expected." },
        Unexpected_end_of_text: { code: 1126, category: 1 /* Error */, key: "Unexpected end of text." },
        Invalid_character: { code: 1127, category: 1 /* Error */, key: "Invalid character." },
        Declaration_or_statement_expected: { code: 1128, category: 1 /* Error */, key: "Declaration or statement expected." },
        Statement_expected: { code: 1129, category: 1 /* Error */, key: "Statement expected." },
        case_or_default_expected: { code: 1130, category: 1 /* Error */, key: "'case' or 'default' expected." },
        Property_or_signature_expected: { code: 1131, category: 1 /* Error */, key: "Property or signature expected." },
        Enum_member_expected: { code: 1132, category: 1 /* Error */, key: "Enum member expected." },
        Type_reference_expected: { code: 1133, category: 1 /* Error */, key: "Type reference expected." },
        Variable_declaration_expected: { code: 1134, category: 1 /* Error */, key: "Variable declaration expected." },
        Argument_expression_expected: { code: 1135, category: 1 /* Error */, key: "Argument expression expected." },
        Property_assignment_expected: { code: 1136, category: 1 /* Error */, key: "Property assignment expected." },
        Expression_or_comma_expected: { code: 1137, category: 1 /* Error */, key: "Expression or comma expected." },
        Parameter_declaration_expected: { code: 1138, category: 1 /* Error */, key: "Parameter declaration expected." },
        Type_parameter_declaration_expected: { code: 1139, category: 1 /* Error */, key: "Type parameter declaration expected." },
        Type_argument_expected: { code: 1140, category: 1 /* Error */, key: "Type argument expected." },
        String_literal_expected: { code: 1141, category: 1 /* Error */, key: "String literal expected." },
        Line_break_not_permitted_here: { code: 1142, category: 1 /* Error */, key: "Line break not permitted here." },
        catch_or_finally_expected: { code: 1143, category: 1 /* Error */, key: "'catch' or 'finally' expected." },
        Block_or_expected: { code: 1144, category: 1 /* Error */, key: "Block or ';' expected." },
        Modifiers_not_permitted_on_index_signature_members: { code: 1145, category: 1 /* Error */, key: "Modifiers not permitted on index signature members." },
        Declaration_expected: { code: 1146, category: 1 /* Error */, key: "Declaration expected." },
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: { code: 1147, category: 1 /* Error */, key: "Import declarations in an internal module cannot reference an external module." },
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: { code: 1148, category: 1 /* Error */, key: "Cannot compile external modules unless the '--module' flag is provided." },
        Filename_0_differs_from_already_included_filename_1_only_in_casing: { code: 1149, category: 1 /* Error */, key: "Filename '{0}' differs from already included filename '{1}' only in casing" },
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: { code: 1150, category: 1 /* Error */, key: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead." },
        var_let_or_const_expected: { code: 1152, category: 1 /* Error */, key: "'var', 'let' or 'const' expected." },
        let_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1153, category: 1 /* Error */, key: "'let' declarations are only available when targeting ECMAScript 6 and higher." },
        const_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1154, category: 1 /* Error */, key: "'const' declarations are only available when targeting ECMAScript 6 and higher." },
        const_declarations_must_be_initialized: { code: 1155, category: 1 /* Error */, key: "'const' declarations must be initialized" },
        const_declarations_can_only_be_declared_inside_a_block: { code: 1156, category: 1 /* Error */, key: "'const' declarations can only be declared inside a block." },
        let_declarations_can_only_be_declared_inside_a_block: { code: 1157, category: 1 /* Error */, key: "'let' declarations can only be declared inside a block." },
        Invalid_template_literal_expected: { code: 1158, category: 1 /* Error */, key: "Invalid template literal; expected '}'" },
        Tagged_templates_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1159, category: 1 /* Error */, key: "Tagged templates are only available when targeting ECMAScript 6 and higher." },
        Duplicate_identifier_0: { code: 2300, category: 1 /* Error */, key: "Duplicate identifier '{0}'." },
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: { code: 2301, category: 1 /* Error */, key: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor." },
        Static_members_cannot_reference_class_type_parameters: { code: 2302, category: 1 /* Error */, key: "Static members cannot reference class type parameters." },
        Circular_definition_of_import_alias_0: { code: 2303, category: 1 /* Error */, key: "Circular definition of import alias '{0}'." },
        Cannot_find_name_0: { code: 2304, category: 1 /* Error */, key: "Cannot find name '{0}'." },
        Module_0_has_no_exported_member_1: { code: 2305, category: 1 /* Error */, key: "Module '{0}' has no exported member '{1}'." },
        File_0_is_not_an_external_module: { code: 2306, category: 1 /* Error */, key: "File '{0}' is not an external module." },
        Cannot_find_external_module_0: { code: 2307, category: 1 /* Error */, key: "Cannot find external module '{0}'." },
        A_module_cannot_have_more_than_one_export_assignment: { code: 2308, category: 1 /* Error */, key: "A module cannot have more than one export assignment." },
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: { code: 2309, category: 1 /* Error */, key: "An export assignment cannot be used in a module with other exported elements." },
        Type_0_recursively_references_itself_as_a_base_type: { code: 2310, category: 1 /* Error */, key: "Type '{0}' recursively references itself as a base type." },
        A_class_may_only_extend_another_class: { code: 2311, category: 1 /* Error */, key: "A class may only extend another class." },
        An_interface_may_only_extend_a_class_or_another_interface: { code: 2312, category: 1 /* Error */, key: "An interface may only extend a class or another interface." },
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: { code: 2313, category: 1 /* Error */, key: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list." },
        Generic_type_0_requires_1_type_argument_s: { code: 2314, category: 1 /* Error */, key: "Generic type '{0}' requires {1} type argument(s)." },
        Type_0_is_not_generic: { code: 2315, category: 1 /* Error */, key: "Type '{0}' is not generic." },
        Global_type_0_must_be_a_class_or_interface_type: { code: 2316, category: 1 /* Error */, key: "Global type '{0}' must be a class or interface type." },
        Global_type_0_must_have_1_type_parameter_s: { code: 2317, category: 1 /* Error */, key: "Global type '{0}' must have {1} type parameter(s)." },
        Cannot_find_global_type_0: { code: 2318, category: 1 /* Error */, key: "Cannot find global type '{0}'." },
        Named_properties_0_of_types_1_and_2_are_not_identical: { code: 2319, category: 1 /* Error */, key: "Named properties '{0}' of types '{1}' and '{2}' are not identical." },
        Interface_0_cannot_simultaneously_extend_types_1_and_2: { code: 2320, category: 1 /* Error */, key: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'." },
        Excessive_stack_depth_comparing_types_0_and_1: { code: 2321, category: 1 /* Error */, key: "Excessive stack depth comparing types '{0}' and '{1}'." },
        Type_0_is_not_assignable_to_type_1: { code: 2322, category: 1 /* Error */, key: "Type '{0}' is not assignable to type '{1}'." },
        Property_0_is_missing_in_type_1: { code: 2324, category: 1 /* Error */, key: "Property '{0}' is missing in type '{1}'." },
        Property_0_is_private_in_type_1_but_not_in_type_2: { code: 2325, category: 1 /* Error */, key: "Property '{0}' is private in type '{1}' but not in type '{2}'." },
        Types_of_property_0_are_incompatible: { code: 2326, category: 1 /* Error */, key: "Types of property '{0}' are incompatible." },
        Property_0_is_optional_in_type_1_but_required_in_type_2: { code: 2327, category: 1 /* Error */, key: "Property '{0}' is optional in type '{1}' but required in type '{2}'." },
        Types_of_parameters_0_and_1_are_incompatible: { code: 2328, category: 1 /* Error */, key: "Types of parameters '{0}' and '{1}' are incompatible." },
        Index_signature_is_missing_in_type_0: { code: 2329, category: 1 /* Error */, key: "Index signature is missing in type '{0}'." },
        Index_signatures_are_incompatible: { code: 2330, category: 1 /* Error */, key: "Index signatures are incompatible." },
        this_cannot_be_referenced_in_a_module_body: { code: 2331, category: 1 /* Error */, key: "'this' cannot be referenced in a module body." },
        this_cannot_be_referenced_in_current_location: { code: 2332, category: 1 /* Error */, key: "'this' cannot be referenced in current location." },
        this_cannot_be_referenced_in_constructor_arguments: { code: 2333, category: 1 /* Error */, key: "'this' cannot be referenced in constructor arguments." },
        this_cannot_be_referenced_in_a_static_property_initializer: { code: 2334, category: 1 /* Error */, key: "'this' cannot be referenced in a static property initializer." },
        super_can_only_be_referenced_in_a_derived_class: { code: 2335, category: 1 /* Error */, key: "'super' can only be referenced in a derived class." },
        super_cannot_be_referenced_in_constructor_arguments: { code: 2336, category: 1 /* Error */, key: "'super' cannot be referenced in constructor arguments." },
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: { code: 2337, category: 1 /* Error */, key: "Super calls are not permitted outside constructors or in nested functions inside constructors" },
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: { code: 2338, category: 1 /* Error */, key: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class" },
        Property_0_does_not_exist_on_type_1: { code: 2339, category: 1 /* Error */, key: "Property '{0}' does not exist on type '{1}'." },
        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: { code: 2340, category: 1 /* Error */, key: "Only public and protected methods of the base class are accessible via the 'super' keyword" },
        Property_0_is_private_and_only_accessible_within_class_1: { code: 2341, category: 1 /* Error */, key: "Property '{0}' is private and only accessible within class '{1}'." },
        An_index_expression_argument_must_be_of_type_string_number_or_any: { code: 2342, category: 1 /* Error */, key: "An index expression argument must be of type 'string', 'number', or 'any'." },
        Type_0_does_not_satisfy_the_constraint_1: { code: 2344, category: 1 /* Error */, key: "Type '{0}' does not satisfy the constraint '{1}'." },
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: { code: 2345, category: 1 /* Error */, key: "Argument of type '{0}' is not assignable to parameter of type '{1}'." },
        Supplied_parameters_do_not_match_any_signature_of_call_target: { code: 2346, category: 1 /* Error */, key: "Supplied parameters do not match any signature of call target." },
        Untyped_function_calls_may_not_accept_type_arguments: { code: 2347, category: 1 /* Error */, key: "Untyped function calls may not accept type arguments." },
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: { code: 2348, category: 1 /* Error */, key: "Value of type '{0}' is not callable. Did you mean to include 'new'?" },
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: { code: 2349, category: 1 /* Error */, key: "Cannot invoke an expression whose type lacks a call signature." },
        Only_a_void_function_can_be_called_with_the_new_keyword: { code: 2350, category: 1 /* Error */, key: "Only a void function can be called with the 'new' keyword." },
        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: { code: 2351, category: 1 /* Error */, key: "Cannot use 'new' with an expression whose type lacks a call or construct signature." },
        Neither_type_0_nor_type_1_is_assignable_to_the_other: { code: 2352, category: 1 /* Error */, key: "Neither type '{0}' nor type '{1}' is assignable to the other." },
        No_best_common_type_exists_among_return_expressions: { code: 2354, category: 1 /* Error */, key: "No best common type exists among return expressions." },
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2355, category: 1 /* Error */, key: "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement." },
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: { code: 2356, category: 1 /* Error */, key: "An arithmetic operand must be of type 'any', 'number' or an enum type." },
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: { code: 2357, category: 1 /* Error */, key: "The operand of an increment or decrement operator must be a variable, property or indexer." },
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2358, category: 1 /* Error */, key: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter." },
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: { code: 2359, category: 1 /* Error */, key: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type." },
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: { code: 2360, category: 1 /* Error */, key: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'." },
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2361, category: 1 /* Error */, key: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter" },
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2362, category: 1 /* Error */, key: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2363, category: 1 /* Error */, key: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        Invalid_left_hand_side_of_assignment_expression: { code: 2364, category: 1 /* Error */, key: "Invalid left-hand side of assignment expression." },
        Operator_0_cannot_be_applied_to_types_1_and_2: { code: 2365, category: 1 /* Error */, key: "Operator '{0}' cannot be applied to types '{1}' and '{2}'." },
        Type_parameter_name_cannot_be_0: { code: 2368, category: 1 /* Error */, key: "Type parameter name cannot be '{0}'" },
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: { code: 2369, category: 1 /* Error */, key: "A parameter property is only allowed in a constructor implementation." },
        A_rest_parameter_must_be_of_an_array_type: { code: 2370, category: 1 /* Error */, key: "A rest parameter must be of an array type." },
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: { code: 2371, category: 1 /* Error */, key: "A parameter initializer is only allowed in a function or constructor implementation." },
        Parameter_0_cannot_be_referenced_in_its_initializer: { code: 2372, category: 1 /* Error */, key: "Parameter '{0}' cannot be referenced in its initializer." },
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: { code: 2373, category: 1 /* Error */, key: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it." },
        Duplicate_string_index_signature: { code: 2374, category: 1 /* Error */, key: "Duplicate string index signature." },
        Duplicate_number_index_signature: { code: 2375, category: 1 /* Error */, key: "Duplicate number index signature." },
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: { code: 2376, category: 1 /* Error */, key: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties." },
        Constructors_for_derived_classes_must_contain_a_super_call: { code: 2377, category: 1 /* Error */, key: "Constructors for derived classes must contain a 'super' call." },
        A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2378, category: 1 /* Error */, key: "A 'get' accessor must return a value or consist of a single 'throw' statement." },
        Getter_and_setter_accessors_do_not_agree_in_visibility: { code: 2379, category: 1 /* Error */, key: "Getter and setter accessors do not agree in visibility." },
        get_and_set_accessor_must_have_the_same_type: { code: 2380, category: 1 /* Error */, key: "'get' and 'set' accessor must have the same type." },
        A_signature_with_an_implementation_cannot_use_a_string_literal_type: { code: 2381, category: 1 /* Error */, key: "A signature with an implementation cannot use a string literal type." },
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: { code: 2382, category: 1 /* Error */, key: "Specialized overload signature is not assignable to any non-specialized signature." },
        Overload_signatures_must_all_be_exported_or_not_exported: { code: 2383, category: 1 /* Error */, key: "Overload signatures must all be exported or not exported." },
        Overload_signatures_must_all_be_ambient_or_non_ambient: { code: 2384, category: 1 /* Error */, key: "Overload signatures must all be ambient or non-ambient." },
        Overload_signatures_must_all_be_public_private_or_protected: { code: 2385, category: 1 /* Error */, key: "Overload signatures must all be public, private or protected." },
        Overload_signatures_must_all_be_optional_or_required: { code: 2386, category: 1 /* Error */, key: "Overload signatures must all be optional or required." },
        Function_overload_must_be_static: { code: 2387, category: 1 /* Error */, key: "Function overload must be static." },
        Function_overload_must_not_be_static: { code: 2388, category: 1 /* Error */, key: "Function overload must not be static." },
        Function_implementation_name_must_be_0: { code: 2389, category: 1 /* Error */, key: "Function implementation name must be '{0}'." },
        Constructor_implementation_is_missing: { code: 2390, category: 1 /* Error */, key: "Constructor implementation is missing." },
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: { code: 2391, category: 1 /* Error */, key: "Function implementation is missing or not immediately following the declaration." },
        Multiple_constructor_implementations_are_not_allowed: { code: 2392, category: 1 /* Error */, key: "Multiple constructor implementations are not allowed." },
        Duplicate_function_implementation: { code: 2393, category: 1 /* Error */, key: "Duplicate function implementation." },
        Overload_signature_is_not_compatible_with_function_implementation: { code: 2394, category: 1 /* Error */, key: "Overload signature is not compatible with function implementation." },
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: { code: 2395, category: 1 /* Error */, key: "Individual declarations in merged declaration {0} must be all exported or all local." },
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: { code: 2396, category: 1 /* Error */, key: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters." },
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: { code: 2397, category: 1 /* Error */, key: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter." },
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: { code: 2398, category: 1 /* Error */, key: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter." },
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: { code: 2399, category: 1 /* Error */, key: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference." },
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: { code: 2400, category: 1 /* Error */, key: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference." },
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: { code: 2401, category: 1 /* Error */, key: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference." },
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: { code: 2402, category: 1 /* Error */, key: "Expression resolves to '_super' that compiler uses to capture base class reference." },
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: { code: 2403, category: 1 /* Error */, key: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'." },
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: { code: 2404, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement cannot use a type annotation." },
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: { code: 2405, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'." },
        Invalid_left_hand_side_in_for_in_statement: { code: 2406, category: 1 /* Error */, key: "Invalid left-hand side in 'for...in' statement." },
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2407, category: 1 /* Error */, key: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter." },
        Setters_cannot_return_a_value: { code: 2408, category: 1 /* Error */, key: "Setters cannot return a value." },
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: { code: 2409, category: 1 /* Error */, key: "Return type of constructor signature must be assignable to the instance type of the class" },
        All_symbols_within_a_with_block_will_be_resolved_to_any: { code: 2410, category: 1 /* Error */, key: "All symbols within a 'with' block will be resolved to 'any'." },
        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: { code: 2411, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to string index type '{2}'." },
        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: { code: 2412, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'." },
        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: { code: 2413, category: 1 /* Error */, key: "Numeric index type '{0}' is not assignable to string index type '{1}'." },
        Class_name_cannot_be_0: { code: 2414, category: 1 /* Error */, key: "Class name cannot be '{0}'" },
        Class_0_incorrectly_extends_base_class_1: { code: 2415, category: 1 /* Error */, key: "Class '{0}' incorrectly extends base class '{1}'." },
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: { code: 2417, category: 1 /* Error */, key: "Class static side '{0}' incorrectly extends base class static side '{1}'." },
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0: { code: 2419, category: 1 /* Error */, key: "Type name '{0}' in extends clause does not reference constructor function for '{0}'." },
        Class_0_incorrectly_implements_interface_1: { code: 2420, category: 1 /* Error */, key: "Class '{0}' incorrectly implements interface '{1}'." },
        A_class_may_only_implement_another_class_or_interface: { code: 2422, category: 1 /* Error */, key: "A class may only implement another class or interface." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: { code: 2423, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: { code: 2424, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property." },
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2425, category: 1 /* Error */, key: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function." },
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2426, category: 1 /* Error */, key: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function." },
        Interface_name_cannot_be_0: { code: 2427, category: 1 /* Error */, key: "Interface name cannot be '{0}'" },
        All_declarations_of_an_interface_must_have_identical_type_parameters: { code: 2428, category: 1 /* Error */, key: "All declarations of an interface must have identical type parameters." },
        Interface_0_incorrectly_extends_interface_1: { code: 2430, category: 1 /* Error */, key: "Interface '{0}' incorrectly extends interface '{1}'." },
        Enum_name_cannot_be_0: { code: 2431, category: 1 /* Error */, key: "Enum name cannot be '{0}'" },
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: { code: 2432, category: 1 /* Error */, key: "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element." },
        A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: { code: 2433, category: 1 /* Error */, key: "A module declaration cannot be in a different file from a class or function with which it is merged" },
        A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: { code: 2434, category: 1 /* Error */, key: "A module declaration cannot be located prior to a class or function with which it is merged" },
        Ambient_external_modules_cannot_be_nested_in_other_modules: { code: 2435, category: 1 /* Error */, key: "Ambient external modules cannot be nested in other modules." },
        Ambient_external_module_declaration_cannot_specify_relative_module_name: { code: 2436, category: 1 /* Error */, key: "Ambient external module declaration cannot specify relative module name." },
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: { code: 2437, category: 1 /* Error */, key: "Module '{0}' is hidden by a local declaration with the same name" },
        Import_name_cannot_be_0: { code: 2438, category: 1 /* Error */, key: "Import name cannot be '{0}'" },
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: { code: 2439, category: 1 /* Error */, key: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name." },
        Import_declaration_conflicts_with_local_declaration_of_0: { code: 2440, category: 1 /* Error */, key: "Import declaration conflicts with local declaration of '{0}'" },
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: { code: 2441, category: 1 /* Error */, key: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module." },
        Types_have_separate_declarations_of_a_private_property_0: { code: 2442, category: 1 /* Error */, key: "Types have separate declarations of a private property '{0}'." },
        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: { code: 2443, category: 1 /* Error */, key: "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'." },
        Property_0_is_protected_in_type_1_but_public_in_type_2: { code: 2444, category: 1 /* Error */, key: "Property '{0}' is protected in type '{1}' but public in type '{2}'." },
        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: { code: 2445, category: 1 /* Error */, key: "Property '{0}' is protected and only accessible within class '{1}' and its subclasses." },
        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1: { code: 2446, category: 1 /* Error */, key: "Property '{0}' is protected and only accessible through an instance of class '{1}'." },
        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: { code: 2447, category: 1 /* Error */, key: "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead." },
        Block_scoped_variable_0_used_before_its_declaration: { code: 2448, category: 1 /* Error */, key: "Block-scoped variable '{0}' used before its declaration.", isEarly: true },
        The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant: { code: 2449, category: 1 /* Error */, key: "The operand of an increment or decrement operator cannot be a constant.", isEarly: true },
        Left_hand_side_of_assignment_expression_cannot_be_a_constant: { code: 2450, category: 1 /* Error */, key: "Left-hand side of assignment expression cannot be a constant.", isEarly: true },
        Cannot_redeclare_block_scoped_variable_0: { code: 2451, category: 1 /* Error */, key: "Cannot redeclare block-scoped variable '{0}'.", isEarly: true },
        An_enum_member_cannot_have_a_numeric_name: { code: 2452, category: 1 /* Error */, key: "An enum member cannot have a numeric name." },
        The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly: { code: 2453, category: 1 /* Error */, key: "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly." },
        Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0: { code: 2455, category: 1 /* Error */, key: "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'." },
        Type_alias_0_circularly_references_itself: { code: 2456, category: 1 /* Error */, key: "Type alias '{0}' circularly references itself." },
        Type_alias_name_cannot_be_0: { code: 2457, category: 1 /* Error */, key: "Type alias name cannot be '{0}'" },
        Import_declaration_0_is_using_private_name_1: { code: 4000, category: 1 /* Error */, key: "Import declaration '{0}' is using private name '{1}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4001, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: { code: 4002, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using private name '{1}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4003, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4004, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4005, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4006, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4007, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4008, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4009, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4010, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4011, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4012, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4013, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4014, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4015, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4016, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using private name '{1}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4017, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4018, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4019, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4020, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2: { code: 4021, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: { code: 4022, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using private name '{1}'." },
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4023, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named." },
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: { code: 4024, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from private module '{2}'." },
        Exported_variable_0_has_or_is_using_private_name_1: { code: 4025, category: 1 /* Error */, key: "Exported variable '{0}' has or is using private name '{1}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4026, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4027, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4028, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using private name '{1}'." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4029, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4030, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4031, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using private name '{1}'." },
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4032, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Property_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4033, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4034, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4035, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4036, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4037, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4038, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4039, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4040, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using private name '{0}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4041, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4042, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4043, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using private name '{0}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4044, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4045, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using private name '{0}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4046, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4047, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using private name '{0}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4048, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4049, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using private name '{0}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4050, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4051, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: { code: 4052, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using private name '{0}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4053, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4054, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: { code: 4055, category: 1 /* Error */, key: "Return type of public method from exported class has or is using private name '{0}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4056, category: 1 /* Error */, key: "Return type of method from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: { code: 4057, category: 1 /* Error */, key: "Return type of method from exported interface has or is using private name '{0}'." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4058, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: { code: 4059, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from private module '{1}'." },
        Return_type_of_exported_function_has_or_is_using_private_name_0: { code: 4060, category: 1 /* Error */, key: "Return type of exported function has or is using private name '{0}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4061, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4062, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: { code: 4063, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using private name '{1}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4064, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4065, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4066, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4067, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4068, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4069, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4070, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4071, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4072, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4073, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4074, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4075, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4076, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4077, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4078, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using private name '{1}'." },
        Exported_type_alias_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4079, category: 1 /* Error */, key: "Exported type alias '{0}' has or is using name '{1}' from external module {2} but cannot be named." },
        Exported_type_alias_0_has_or_is_using_name_1_from_private_module_2: { code: 4080, category: 1 /* Error */, key: "Exported type alias '{0}' has or is using name '{1}' from private module '{2}'." },
        Exported_type_alias_0_has_or_is_using_private_name_1: { code: 4081, category: 1 /* Error */, key: "Exported type alias '{0}' has or is using private name '{1}'." },
        Enum_declarations_must_all_be_const_or_non_const: { code: 4082, category: 1 /* Error */, key: "Enum declarations must all be const or non-const." },
        In_const_enum_declarations_member_initializer_must_be_constant_expression: { code: 4083, category: 1 /* Error */, key: "In 'const' enum declarations member initializer must be constant expression.", isEarly: true },
        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment: { code: 4084, category: 1 /* Error */, key: "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment." },
        Index_expression_arguments_in_const_enums_must_be_of_type_string: { code: 4085, category: 1 /* Error */, key: "Index expression arguments in 'const' enums must be of type 'string'." },
        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: { code: 4086, category: 1 /* Error */, key: "'const' enum member initializer was evaluated to a non-finite value." },
        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: { code: 4087, category: 1 /* Error */, key: "'const' enum member initializer was evaluated to disallowed value 'NaN'." },
        The_current_host_does_not_support_the_0_option: { code: 5001, category: 1 /* Error */, key: "The current host does not support the '{0}' option." },
        Cannot_find_the_common_subdirectory_path_for_the_input_files: { code: 5009, category: 1 /* Error */, key: "Cannot find the common subdirectory path for the input files." },
        Cannot_read_file_0_Colon_1: { code: 5012, category: 1 /* Error */, key: "Cannot read file '{0}': {1}" },
        Unsupported_file_encoding: { code: 5013, category: 1 /* Error */, key: "Unsupported file encoding." },
        Unknown_compiler_option_0: { code: 5023, category: 1 /* Error */, key: "Unknown compiler option '{0}'." },
        Could_not_write_file_0_Colon_1: { code: 5033, category: 1 /* Error */, key: "Could not write file '{0}': {1}" },
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5038, category: 1 /* Error */, key: "Option mapRoot cannot be specified without specifying sourcemap option." },
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5039, category: 1 /* Error */, key: "Option sourceRoot cannot be specified without specifying sourcemap option." },
        Concatenate_and_emit_output_to_single_file: { code: 6001, category: 2 /* Message */, key: "Concatenate and emit output to single file." },
        Generates_corresponding_d_ts_file: { code: 6002, category: 2 /* Message */, key: "Generates corresponding '.d.ts' file." },
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: { code: 6003, category: 2 /* Message */, key: "Specifies the location where debugger should locate map files instead of generated locations." },
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: { code: 6004, category: 2 /* Message */, key: "Specifies the location where debugger should locate TypeScript files instead of source locations." },
        Watch_input_files: { code: 6005, category: 2 /* Message */, key: "Watch input files." },
        Redirect_output_structure_to_the_directory: { code: 6006, category: 2 /* Message */, key: "Redirect output structure to the directory." },
        Do_not_erase_const_enum_declarations_in_generated_code: { code: 6007, category: 2 /* Message */, key: "Do not erase const enum declarations in generated code." },
        Do_not_emit_comments_to_output: { code: 6009, category: 2 /* Message */, key: "Do not emit comments to output." },
        Specify_ECMAScript_target_version_Colon_ES3_default_ES5_or_ES6_experimental: { code: 6015, category: 2 /* Message */, key: "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)" },
        Specify_module_code_generation_Colon_commonjs_or_amd: { code: 6016, category: 2 /* Message */, key: "Specify module code generation: 'commonjs' or 'amd'" },
        Print_this_message: { code: 6017, category: 2 /* Message */, key: "Print this message." },
        Print_the_compiler_s_version: { code: 6019, category: 2 /* Message */, key: "Print the compiler's version." },
        Syntax_Colon_0: { code: 6023, category: 2 /* Message */, key: "Syntax: {0}" },
        options: { code: 6024, category: 2 /* Message */, key: "options" },
        file: { code: 6025, category: 2 /* Message */, key: "file" },
        Examples_Colon_0: { code: 6026, category: 2 /* Message */, key: "Examples: {0}" },
        Options_Colon: { code: 6027, category: 2 /* Message */, key: "Options:" },
        Version_0: { code: 6029, category: 2 /* Message */, key: "Version {0}" },
        Insert_command_line_options_and_files_from_a_file: { code: 6030, category: 2 /* Message */, key: "Insert command line options and files from a file." },
        File_change_detected_Compiling: { code: 6032, category: 2 /* Message */, key: "File change detected. Compiling..." },
        KIND: { code: 6034, category: 2 /* Message */, key: "KIND" },
        FILE: { code: 6035, category: 2 /* Message */, key: "FILE" },
        VERSION: { code: 6036, category: 2 /* Message */, key: "VERSION" },
        LOCATION: { code: 6037, category: 2 /* Message */, key: "LOCATION" },
        DIRECTORY: { code: 6038, category: 2 /* Message */, key: "DIRECTORY" },
        Compilation_complete_Watching_for_file_changes: { code: 6042, category: 2 /* Message */, key: "Compilation complete. Watching for file changes." },
        Generates_corresponding_map_file: { code: 6043, category: 2 /* Message */, key: "Generates corresponding '.map' file." },
        Compiler_option_0_expects_an_argument: { code: 6044, category: 1 /* Error */, key: "Compiler option '{0}' expects an argument." },
        Unterminated_quoted_string_in_response_file_0: { code: 6045, category: 1 /* Error */, key: "Unterminated quoted string in response file '{0}'." },
        Argument_for_module_option_must_be_commonjs_or_amd: { code: 6046, category: 1 /* Error */, key: "Argument for '--module' option must be 'commonjs' or 'amd'." },
        Argument_for_target_option_must_be_es3_es5_or_es6: { code: 6047, category: 1 /* Error */, key: "Argument for '--target' option must be 'es3', 'es5', or 'es6'." },
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: { code: 6048, category: 1 /* Error */, key: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'." },
        Unsupported_locale_0: { code: 6049, category: 1 /* Error */, key: "Unsupported locale '{0}'." },
        Unable_to_open_file_0: { code: 6050, category: 1 /* Error */, key: "Unable to open file '{0}'." },
        Corrupted_locale_file_0: { code: 6051, category: 1 /* Error */, key: "Corrupted locale file {0}." },
        Warn_on_expressions_and_declarations_with_an_implied_any_type: { code: 6052, category: 2 /* Message */, key: "Warn on expressions and declarations with an implied 'any' type." },
        File_0_not_found: { code: 6053, category: 1 /* Error */, key: "File '{0}' not found." },
        File_0_must_have_extension_ts_or_d_ts: { code: 6054, category: 1 /* Error */, key: "File '{0}' must have extension '.ts' or '.d.ts'." },
        Variable_0_implicitly_has_an_1_type: { code: 7005, category: 1 /* Error */, key: "Variable '{0}' implicitly has an '{1}' type." },
        Parameter_0_implicitly_has_an_1_type: { code: 7006, category: 1 /* Error */, key: "Parameter '{0}' implicitly has an '{1}' type." },
        Member_0_implicitly_has_an_1_type: { code: 7008, category: 1 /* Error */, key: "Member '{0}' implicitly has an '{1}' type." },
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: { code: 7009, category: 1 /* Error */, key: "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type." },
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: { code: 7010, category: 1 /* Error */, key: "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type." },
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: { code: 7011, category: 1 /* Error */, key: "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type." },
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7013, category: 1 /* Error */, key: "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation: { code: 7016, category: 1 /* Error */, key: "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation." },
        Index_signature_of_object_type_implicitly_has_an_any_type: { code: 7017, category: 1 /* Error */, key: "Index signature of object type implicitly has an 'any' type." },
        Object_literal_s_property_0_implicitly_has_an_1_type: { code: 7018, category: 1 /* Error */, key: "Object literal's property '{0}' implicitly has an '{1}' type." },
        Rest_parameter_0_implicitly_has_an_any_type: { code: 7019, category: 1 /* Error */, key: "Rest parameter '{0}' implicitly has an 'any[]' type." },
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7020, category: 1 /* Error */, key: "Call signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        _0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation: { code: 7021, category: 1 /* Error */, key: "'{0}' implicitly has type 'any' because it is referenced directly or indirectly in its own type annotation." },
        _0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: { code: 7022, category: 1 /* Error */, key: "'{0}' implicitly has type 'any' because it is does not have a type annotation and is referenced directly or indirectly in its own initializer." },
        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7023, category: 1 /* Error */, key: "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions." },
        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7024, category: 1 /* Error */, key: "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions." },
        You_cannot_rename_this_element: { code: 8000, category: 1 /* Error */, key: "You cannot rename this element." }
    };
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="diagnosticInformationMap.generated.ts"/>
var ts;
(function (ts) {
    var textToToken = {
        "any": 109 /* AnyKeyword */,
        "boolean": 110 /* BooleanKeyword */,
        "break": 64 /* BreakKeyword */,
        "case": 65 /* CaseKeyword */,
        "catch": 66 /* CatchKeyword */,
        "class": 67 /* ClassKeyword */,
        "continue": 69 /* ContinueKeyword */,
        "const": 68 /* ConstKeyword */,
        "constructor": 111 /* ConstructorKeyword */,
        "debugger": 70 /* DebuggerKeyword */,
        "declare": 112 /* DeclareKeyword */,
        "default": 71 /* DefaultKeyword */,
        "delete": 72 /* DeleteKeyword */,
        "do": 73 /* DoKeyword */,
        "else": 74 /* ElseKeyword */,
        "enum": 75 /* EnumKeyword */,
        "export": 76 /* ExportKeyword */,
        "extends": 77 /* ExtendsKeyword */,
        "false": 78 /* FalseKeyword */,
        "finally": 79 /* FinallyKeyword */,
        "for": 80 /* ForKeyword */,
        "function": 81 /* FunctionKeyword */,
        "get": 113 /* GetKeyword */,
        "if": 82 /* IfKeyword */,
        "implements": 100 /* ImplementsKeyword */,
        "import": 83 /* ImportKeyword */,
        "in": 84 /* InKeyword */,
        "instanceof": 85 /* InstanceOfKeyword */,
        "interface": 101 /* InterfaceKeyword */,
        "let": 102 /* LetKeyword */,
        "module": 114 /* ModuleKeyword */,
        "new": 86 /* NewKeyword */,
        "null": 87 /* NullKeyword */,
        "number": 116 /* NumberKeyword */,
        "package": 103 /* PackageKeyword */,
        "private": 104 /* PrivateKeyword */,
        "protected": 105 /* ProtectedKeyword */,
        "public": 106 /* PublicKeyword */,
        "require": 115 /* RequireKeyword */,
        "return": 88 /* ReturnKeyword */,
        "set": 117 /* SetKeyword */,
        "static": 107 /* StaticKeyword */,
        "string": 118 /* StringKeyword */,
        "super": 89 /* SuperKeyword */,
        "switch": 90 /* SwitchKeyword */,
        "this": 91 /* ThisKeyword */,
        "throw": 92 /* ThrowKeyword */,
        "true": 93 /* TrueKeyword */,
        "try": 94 /* TryKeyword */,
        "type": 119 /* TypeKeyword */,
        "typeof": 95 /* TypeOfKeyword */,
        "var": 96 /* VarKeyword */,
        "void": 97 /* VoidKeyword */,
        "while": 98 /* WhileKeyword */,
        "with": 99 /* WithKeyword */,
        "yield": 108 /* YieldKeyword */,
        "{": 13 /* OpenBraceToken */,
        "}": 14 /* CloseBraceToken */,
        "(": 15 /* OpenParenToken */,
        ")": 16 /* CloseParenToken */,
        "[": 17 /* OpenBracketToken */,
        "]": 18 /* CloseBracketToken */,
        ".": 19 /* DotToken */,
        "...": 20 /* DotDotDotToken */,
        ";": 21 /* SemicolonToken */,
        ",": 22 /* CommaToken */,
        "<": 23 /* LessThanToken */,
        ">": 24 /* GreaterThanToken */,
        "<=": 25 /* LessThanEqualsToken */,
        ">=": 26 /* GreaterThanEqualsToken */,
        "==": 27 /* EqualsEqualsToken */,
        "!=": 28 /* ExclamationEqualsToken */,
        "===": 29 /* EqualsEqualsEqualsToken */,
        "!==": 30 /* ExclamationEqualsEqualsToken */,
        "=>": 31 /* EqualsGreaterThanToken */,
        "+": 32 /* PlusToken */,
        "-": 33 /* MinusToken */,
        "*": 34 /* AsteriskToken */,
        "/": 35 /* SlashToken */,
        "%": 36 /* PercentToken */,
        "++": 37 /* PlusPlusToken */,
        "--": 38 /* MinusMinusToken */,
        "<<": 39 /* LessThanLessThanToken */,
        ">>": 40 /* GreaterThanGreaterThanToken */,
        ">>>": 41 /* GreaterThanGreaterThanGreaterThanToken */,
        "&": 42 /* AmpersandToken */,
        "|": 43 /* BarToken */,
        "^": 44 /* CaretToken */,
        "!": 45 /* ExclamationToken */,
        "~": 46 /* TildeToken */,
        "&&": 47 /* AmpersandAmpersandToken */,
        "||": 48 /* BarBarToken */,
        "?": 49 /* QuestionToken */,
        ":": 50 /* ColonToken */,
        "=": 51 /* EqualsToken */,
        "+=": 52 /* PlusEqualsToken */,
        "-=": 53 /* MinusEqualsToken */,
        "*=": 54 /* AsteriskEqualsToken */,
        "/=": 55 /* SlashEqualsToken */,
        "%=": 56 /* PercentEqualsToken */,
        "<<=": 57 /* LessThanLessThanEqualsToken */,
        ">>=": 58 /* GreaterThanGreaterThanEqualsToken */,
        ">>>=": 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
        "&=": 60 /* AmpersandEqualsToken */,
        "|=": 61 /* BarEqualsToken */,
        "^=": 62 /* CaretEqualsToken */
    };
    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart ::
            Can contain Unicode 3.0.0  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart :: =
            Can contain IdentifierStart + Unicode 3.0.0  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd), or
            Connector punctuation (Pc).

        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
        IdentifierStart ::
            Can contain Unicode 6.2  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart ::
            Can contain IdentifierStart + Unicode 6.2  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd),
            Connector punctuation (Pc),
            <ZWNJ>, or
            <ZWJ>.

        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    function lookupInUnicodeMap(code, map) {
        // Bail out quickly if it couldn't possibly be in the map.
        if (code < map[0]) {
            return false;
        }
        // Perform binary search in one of the Unicode range maps
        var lo = 0;
        var hi = map.length;
        var mid;
        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }
        return false;
    }
    function isUnicodeIdentifierStart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierStart) : lookupInUnicodeMap(code, unicodeES5IdentifierStart);
    }
    function isUnicodeIdentifierPart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierPart) : lookupInUnicodeMap(code, unicodeES5IdentifierPart);
    }
    function makeReverseMap(source) {
        var result = [];
        for (var name in source) {
            if (source.hasOwnProperty(name)) {
                result[source[name]] = name;
            }
        }
        return result;
    }
    var tokenStrings = makeReverseMap(textToToken);
    function tokenToString(t) {
        return tokenStrings[t];
    }
    ts.tokenToString = tokenToString;
    function getLineStarts(text) {
        var result = new Array();
        var pos = 0;
        var lineStart = 0;
        while (pos < text.length) {
            var ch = text.charCodeAt(pos++);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* lineFeed */) {
                        pos++;
                    }
                case 10 /* lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
    ts.getLineStarts = getLineStarts;
    function getPositionFromLineAndCharacter(lineStarts, line, character) {
        ts.Debug.assert(line > 0);
        return lineStarts[line - 1] + character - 1;
    }
    ts.getPositionFromLineAndCharacter = getPositionFromLineAndCharacter;
    function getLineAndCharacterOfPosition(lineStarts, position) {
        var lineNumber = ts.binarySearch(lineStarts, position);
        if (lineNumber < 0) {
            // If the actual position was not found, 
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return {
            line: lineNumber + 1,
            character: position - lineStarts[lineNumber] + 1
        };
    }
    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
    function positionToLineAndCharacter(text, pos) {
        var lineStarts = getLineStarts(text);
        return getLineAndCharacterOfPosition(lineStarts, pos);
    }
    ts.positionToLineAndCharacter = positionToLineAndCharacter;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ || ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ || ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    ts.isWhiteSpace = isWhiteSpace;
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */ || ch === 133 /* nextLine */;
    }
    ts.isLineBreak = isLineBreak;
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    function isOctalDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 55 /* _7 */;
    }
    ts.isOctalDigit = isOctalDigit;
    function skipTrivia(text, pos, stopAfterLineBreak) {
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (stopAfterLineBreak)
                        return pos;
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        pos++;
                        continue;
                    }
                    break;
            }
            return pos;
        }
    }
    ts.skipTrivia = skipTrivia;
    // Extract comments from the given source text starting at the given position. If trailing is false, whitespace is skipped until
    // the first line break and comments between that location and the next token are returned. If trailing is true, comments occurring
    // between the given position and the next line break are returned. The return value is an array containing a TextRange for each
    // comment. Single-line comment ranges include the beginning '//' characters but not the ending line break. Multi-line comment
    // ranges include the beginning '/* and ending '*/' characters. The return value is undefined if no comments were found.
    function getCommentRanges(text, pos, trailing) {
        var result;
        var collecting = trailing || pos === 0;
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (trailing) {
                        return result;
                    }
                    collecting = true;
                    if (result && result.length) {
                        result[result.length - 1].hasTrailingNewLine = true;
                    }
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    var nextChar = text.charCodeAt(pos + 1);
                    var hasTrailingNewLine = false;
                    if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {
                        var startPos = pos;
                        pos += 2;
                        if (nextChar === 47 /* slash */) {
                            while (pos < text.length) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    hasTrailingNewLine = true;
                                    break;
                                }
                                pos++;
                            }
                        }
                        else {
                            while (pos < text.length) {
                                if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    break;
                                }
                                pos++;
                            }
                        }
                        if (collecting) {
                            if (!result)
                                result = [];
                            result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine });
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        if (result && result.length && isLineBreak(ch)) {
                            result[result.length - 1].hasTrailingNewLine = true;
                        }
                        pos++;
                        continue;
                    }
                    break;
            }
            return result;
        }
    }
    function getLeadingCommentRanges(text, pos) {
        return getCommentRanges(text, pos, false);
    }
    ts.getLeadingCommentRanges = getLeadingCommentRanges;
    function getTrailingCommentRanges(text, pos) {
        return getCommentRanges(text, pos, true);
    }
    ts.getTrailingCommentRanges = getTrailingCommentRanges;
    function isIdentifierStart(ch, languageVersion) {
        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
    }
    ts.isIdentifierStart = isIdentifierStart;
    function isIdentifierPart(ch, languageVersion) {
        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
    }
    ts.isIdentifierPart = isIdentifierPart;
    function createScanner(languageVersion, skipTrivia, text, onError, onComment) {
        var pos; // Current position (end position of text of current token)
        var len; // Length of text
        var startPos; // Start position of whitespace before current token
        var tokenPos; // Start position of text of current token
        var token;
        var tokenValue;
        var precedingLineBreak;
        function error(message) {
            if (onError) {
                onError(message);
            }
        }
        function isIdentifierStart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
        }
        function isIdentifierPart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
        }
        function scanNumber() {
            var start = pos;
            while (isDigit(text.charCodeAt(pos)))
                pos++;
            if (text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                while (isDigit(text.charCodeAt(pos)))
                    pos++;
            }
            var end = pos;
            if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {
                pos++;
                if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)
                    pos++;
                if (isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (isDigit(text.charCodeAt(pos)))
                        pos++;
                    end = pos;
                }
                else {
                    error(ts.Diagnostics.Digit_expected);
                }
            }
            return +(text.substring(start, end));
        }
        function scanOctalDigits() {
            var start = pos;
            while (isOctalDigit(text.charCodeAt(pos))) {
                pos++;
            }
            return +(text.substring(start, pos));
        }
        function scanHexDigits(count, mustMatchCount) {
            var digits = 0;
            var value = 0;
            while (digits < count || !mustMatchCount) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function scanString() {
            var quote = text.charCodeAt(pos++);
            var result = "";
            var start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unexpected_end_of_text);
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === quote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    result += scanEscapeSequence();
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                pos++;
            }
            return result;
        }
        /**
         * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or
         * a literal component of a TemplateExpression.
         */
        function scanTemplateAndSetTokenValue() {
            var startedWithBacktick = text.charCodeAt(pos) === 96 /* backtick */;
            pos++;
            var start = pos;
            var contents = "";
            var resultingToken;
            while (true) {
                if (pos >= len) {
                    contents += text.substring(start, pos);
                    error(ts.Diagnostics.Unexpected_end_of_text);
                    resultingToken = startedWithBacktick ? 9 /* NoSubstitutionTemplateLiteral */ : 12 /* TemplateTail */;
                    break;
                }
                var currChar = text.charCodeAt(pos);
                // '`'
                if (currChar === 96 /* backtick */) {
                    contents += text.substring(start, pos);
                    pos++;
                    resultingToken = startedWithBacktick ? 9 /* NoSubstitutionTemplateLiteral */ : 12 /* TemplateTail */;
                    break;
                }
                // '${'
                if (currChar === 36 /* $ */ && pos + 1 < len && text.charCodeAt(pos + 1) === 123 /* openBrace */) {
                    contents += text.substring(start, pos);
                    pos += 2;
                    resultingToken = startedWithBacktick ? 10 /* TemplateHead */ : 11 /* TemplateMiddle */;
                    break;
                }
                // Escape character
                if (currChar === 92 /* backslash */) {
                    contents += text.substring(start, pos);
                    contents += scanEscapeSequence();
                    start = pos;
                    continue;
                }
                // Speculated ECMAScript 6 Spec 11.8.6.1:
                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values
                // An explicit EscapeSequence is needed to include a <CR> or <CR><LF> sequence.
                if (currChar === 13 /* carriageReturn */) {
                    contents += text.substring(start, pos);
                    if (pos + 1 < len && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
                        pos++;
                    }
                    pos++;
                    contents += "\n";
                    start = pos;
                    continue;
                }
                pos++;
            }
            ts.Debug.assert(resultingToken !== undefined);
            tokenValue = contents;
            return resultingToken;
        }
        function scanEscapeSequence() {
            pos++;
            if (pos >= len) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                return "";
            }
            var ch = text.charCodeAt(pos++);
            switch (ch) {
                case 48 /* _0 */:
                    return "\0";
                case 98 /* b */:
                    return "\b";
                case 116 /* t */:
                    return "\t";
                case 110 /* n */:
                    return "\n";
                case 118 /* v */:
                    return "\v";
                case 102 /* f */:
                    return "\f";
                case 114 /* r */:
                    return "\r";
                case 39 /* singleQuote */:
                    return "\'";
                case 34 /* doubleQuote */:
                    return "\"";
                case 120 /* x */:
                case 117 /* u */:
                    var ch = scanHexDigits(ch === 120 /* x */ ? 2 : 4, true);
                    if (ch >= 0) {
                        return String.fromCharCode(ch);
                    }
                    else {
                        error(ts.Diagnostics.Hexadecimal_digit_expected);
                        return "";
                    }
                case 13 /* carriageReturn */:
                    if (pos < len && text.charCodeAt(pos) === 10 /* lineFeed */) {
                        pos++;
                    }
                case 10 /* lineFeed */:
                case 8232 /* lineSeparator */:
                case 8233 /* paragraphSeparator */:
                    return "";
                default:
                    return String.fromCharCode(ch);
            }
        }
        // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
        // and return code point value if valid Unicode escape is found. Otherwise return -1.
        function peekUnicodeEscape() {
            if (pos + 5 < len && text.charCodeAt(pos + 1) === 117 /* u */) {
                var start = pos;
                pos += 2;
                var value = scanHexDigits(4, true);
                pos = start;
                return value;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < len) {
                var ch = text.charCodeAt(pos);
                if (isIdentifierPart(ch)) {
                    pos++;
                }
                else if (ch === 92 /* backslash */) {
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch))) {
                        break;
                    }
                    result += text.substring(start, pos);
                    result += String.fromCharCode(ch);
                    // Valid Unicode escape is always six characters
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            // Reserved words are between 2 and 11 characters long and start with a lowercase letter
            var len = tokenValue.length;
            if (len >= 2 && len <= 11) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 /* a */ && ch <= 122 /* z */ && hasOwnProperty.call(textToToken, tokenValue)) {
                    return token = textToToken[tokenValue];
                }
            }
            return token = 63 /* Identifier */;
        }
        function scan() {
            startPos = pos;
            precedingLineBreak = false;
            while (true) {
                tokenPos = pos;
                if (pos >= len) {
                    return token = 1 /* EndOfFileToken */;
                }
                var ch = text.charCodeAt(pos);
                switch (ch) {
                    case 10 /* lineFeed */:
                    case 13 /* carriageReturn */:
                        precedingLineBreak = true;
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            if (ch === 13 /* carriageReturn */ && pos + 1 < len && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
                                // consume both CR and LF
                                pos += 2;
                            }
                            else {
                                pos++;
                            }
                            return token = 4 /* NewLineTrivia */;
                        }
                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 32 /* space */:
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            while (pos < len && isWhiteSpace(text.charCodeAt(pos))) {
                                pos++;
                            }
                            return token = 5 /* WhitespaceTrivia */;
                        }
                    case 33 /* exclamation */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 30 /* ExclamationEqualsEqualsToken */;
                            }
                            return pos += 2, token = 28 /* ExclamationEqualsToken */;
                        }
                        return pos++, token = 45 /* ExclamationToken */;
                    case 34 /* doubleQuote */:
                    case 39 /* singleQuote */:
                        tokenValue = scanString();
                        return token = 7 /* StringLiteral */;
                    case 96 /* backtick */:
                        return token = scanTemplateAndSetTokenValue();
                    case 37 /* percent */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 56 /* PercentEqualsToken */;
                        }
                        return pos++, token = 36 /* PercentToken */;
                    case 38 /* ampersand */:
                        if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {
                            return pos += 2, token = 47 /* AmpersandAmpersandToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 60 /* AmpersandEqualsToken */;
                        }
                        return pos++, token = 42 /* AmpersandToken */;
                    case 40 /* openParen */:
                        return pos++, token = 15 /* OpenParenToken */;
                    case 41 /* closeParen */:
                        return pos++, token = 16 /* CloseParenToken */;
                    case 42 /* asterisk */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 54 /* AsteriskEqualsToken */;
                        }
                        return pos++, token = 34 /* AsteriskToken */;
                    case 43 /* plus */:
                        if (text.charCodeAt(pos + 1) === 43 /* plus */) {
                            return pos += 2, token = 37 /* PlusPlusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 52 /* PlusEqualsToken */;
                        }
                        return pos++, token = 32 /* PlusToken */;
                    case 44 /* comma */:
                        return pos++, token = 22 /* CommaToken */;
                    case 45 /* minus */:
                        if (text.charCodeAt(pos + 1) === 45 /* minus */) {
                            return pos += 2, token = 38 /* MinusMinusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 53 /* MinusEqualsToken */;
                        }
                        return pos++, token = 33 /* MinusToken */;
                    case 46 /* dot */:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanNumber();
                            return token = 6 /* NumericLiteral */;
                        }
                        if (text.charCodeAt(pos + 1) === 46 /* dot */ && text.charCodeAt(pos + 2) === 46 /* dot */) {
                            return pos += 3, token = 20 /* DotDotDotToken */;
                        }
                        return pos++, token = 19 /* DotToken */;
                    case 47 /* slash */:
                        // Single-line comment
                        if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            while (pos < len) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 2 /* SingleLineCommentTrivia */;
                            }
                        }
                        // Multi-line comment
                        if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                            pos += 2;
                            var commentClosed = false;
                            while (pos < len) {
                                var ch = text.charCodeAt(pos);
                                if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                if (isLineBreak(ch)) {
                                    precedingLineBreak = true;
                                }
                                pos++;
                            }
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 3 /* MultiLineCommentTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 55 /* SlashEqualsToken */;
                        }
                        return pos++, token = 35 /* SlashToken */;
                    case 48 /* _0 */:
                        if (pos + 2 < len && (text.charCodeAt(pos + 1) === 88 /* X */ || text.charCodeAt(pos + 1) === 120 /* x */)) {
                            pos += 2;
                            var value = scanHexDigits(1, false);
                            if (value < 0) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                value = 0;
                            }
                            tokenValue = "" + value;
                            return 6 /* NumericLiteral */;
                        }
                        // Try to parse as an octal
                        if (pos + 1 < len && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            return 6 /* NumericLiteral */;
                        }
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        tokenValue = "" + scanNumber();
                        return token = 6 /* NumericLiteral */;
                    case 58 /* colon */:
                        return pos++, token = 50 /* ColonToken */;
                    case 59 /* semicolon */:
                        return pos++, token = 21 /* SemicolonToken */;
                    case 60 /* lessThan */:
                        if (text.charCodeAt(pos + 1) === 60 /* lessThan */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 57 /* LessThanLessThanEqualsToken */;
                            }
                            return pos += 2, token = 39 /* LessThanLessThanToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 25 /* LessThanEqualsToken */;
                        }
                        return pos++, token = 23 /* LessThanToken */;
                    case 61 /* equals */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 29 /* EqualsEqualsEqualsToken */;
                            }
                            return pos += 2, token = 27 /* EqualsEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                            return pos += 2, token = 31 /* EqualsGreaterThanToken */;
                        }
                        return pos++, token = 51 /* EqualsToken */;
                    case 62 /* greaterThan */:
                        return pos++, token = 24 /* GreaterThanToken */;
                    case 63 /* question */:
                        return pos++, token = 49 /* QuestionToken */;
                    case 91 /* openBracket */:
                        return pos++, token = 17 /* OpenBracketToken */;
                    case 93 /* closeBracket */:
                        return pos++, token = 18 /* CloseBracketToken */;
                    case 94 /* caret */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 62 /* CaretEqualsToken */;
                        }
                        return pos++, token = 44 /* CaretToken */;
                    case 123 /* openBrace */:
                        return pos++, token = 13 /* OpenBraceToken */;
                    case 124 /* bar */:
                        if (text.charCodeAt(pos + 1) === 124 /* bar */) {
                            return pos += 2, token = 48 /* BarBarToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 61 /* BarEqualsToken */;
                        }
                        return pos++, token = 43 /* BarToken */;
                    case 125 /* closeBrace */:
                        return pos++, token = 14 /* CloseBraceToken */;
                    case 126 /* tilde */:
                        return pos++, token = 46 /* TildeToken */;
                    case 92 /* backslash */:
                        var ch = peekUnicodeEscape();
                        if (ch >= 0 && isIdentifierStart(ch)) {
                            pos += 6;
                            tokenValue = String.fromCharCode(ch) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                    default:
                        if (isIdentifierStart(ch)) {
                            pos++;
                            while (pos < len && isIdentifierPart(ch = text.charCodeAt(pos)))
                                pos++;
                            tokenValue = text.substring(tokenPos, pos);
                            if (ch === 92 /* backslash */) {
                                tokenValue += scanIdentifierParts();
                            }
                            return token = getIdentifierToken();
                        }
                        else if (isWhiteSpace(ch)) {
                            pos++;
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            precedingLineBreak = true;
                            pos++;
                            continue;
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                }
            }
        }
        function reScanGreaterToken() {
            if (token === 24 /* GreaterThanToken */) {
                if (text.charCodeAt(pos) === 62 /* greaterThan */) {
                    if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                        if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                            return pos += 3, token = 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                        }
                        return pos += 2, token = 41 /* GreaterThanGreaterThanGreaterThanToken */;
                    }
                    if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                        return pos += 2, token = 58 /* GreaterThanGreaterThanEqualsToken */;
                    }
                    return pos++, token = 40 /* GreaterThanGreaterThanToken */;
                }
                if (text.charCodeAt(pos) === 61 /* equals */) {
                    return pos++, token = 26 /* GreaterThanEqualsToken */;
                }
            }
            return token;
        }
        function reScanSlashToken() {
            if (token === 35 /* SlashToken */ || token === 55 /* SlashEqualsToken */) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    // If we've hit EOF without closing off the regex,
                    // simply return the token we originally parsed.
                    if (p >= len) {
                        return token;
                    }
                    var ch = text.charCodeAt(p);
                    // Line breaks are not permissible in the middle of a RegExp.
                    if (isLineBreak(ch)) {
                        return token;
                    }
                    if (inEscape) {
                        // Parsing an escape character;
                        // reset the flag and just advance to the next char.
                        inEscape = false;
                    }
                    else if (ch === 47 /* slash */ && !inCharacterClass) {
                        break;
                    }
                    else if (ch === 91 /* openBracket */) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92 /* backslash */) {
                        inEscape = true;
                    }
                    else if (ch === 93 /* closeBracket */) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                p++;
                while (isIdentifierPart(text.charCodeAt(p))) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 8 /* RegularExpressionLiteral */;
            }
            return token;
        }
        /**
         * Unconditionally back up and scan a template expression portion.
         */
        function reScanTemplateToken() {
            ts.Debug.assert(token === 14 /* CloseBraceToken */, "'reScanTemplateToken' should only be called on a '}'");
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue();
        }
        function tryScan(callback) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var savePrecedingLineBreak = precedingLineBreak;
            var result = callback();
            if (!result) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                precedingLineBreak = savePrecedingLineBreak;
            }
            return result;
        }
        function setText(newText) {
            text = newText || "";
            len = text.length;
            setTextPos(0);
        }
        function setTextPos(textPos) {
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0 /* Unknown */;
            precedingLineBreak = false;
        }
        setText(text);
        return {
            getStartPos: function () { return startPos; },
            getTextPos: function () { return pos; },
            getToken: function () { return token; },
            getTokenPos: function () { return tokenPos; },
            getTokenText: function () { return text.substring(tokenPos, pos); },
            getTokenValue: function () { return tokenValue; },
            hasPrecedingLineBreak: function () { return precedingLineBreak; },
            isIdentifier: function () { return token === 63 /* Identifier */ || token > 99 /* LastReservedWord */; },
            isReservedWord: function () { return token >= 64 /* FirstReservedWord */ && token <= 99 /* LastReservedWord */; },
            reScanGreaterToken: reScanGreaterToken,
            reScanSlashToken: reScanSlashToken,
            reScanTemplateToken: reScanTemplateToken,
            scan: scan,
            setText: setText,
            setTextPos: setTextPos,
            tryScan: tryScan
        };
    }
    ts.createScanner = createScanner;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
var ts;
(function (ts) {
    var nodeConstructors = new Array(196 /* Count */);
    function getNodeConstructor(kind) {
        return nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind));
    }
    ts.getNodeConstructor = getNodeConstructor;
    function createRootNode(kind, pos, end, flags) {
        var node = new (getNodeConstructor(kind))();
        node.pos = pos;
        node.end = end;
        node.flags = flags;
        return node;
    }
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 193 /* SourceFile */)
            node = node.parent;
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    // This is a useful function for debugging purposes.
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = file.getLineAndCharacterFromPosition(node.pos);
        return file.filename + "(" + loc.line + "," + loc.character + ")";
    }
    ts.nodePosToString = nodePosToString;
    function getStartPosOfNode(node) {
        return node.pos;
    }
    ts.getStartPosOfNode = getStartPosOfNode;
    function getTokenPosOfNode(node, sourceFile) {
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getTextOfNodeFromSourceText(sourceText, node) {
        return sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
    }
    ts.getTextOfNodeFromSourceText = getTextOfNodeFromSourceText;
    function getTextOfNode(node) {
        var text = getSourceFileOfNode(node).text;
        return text.substring(ts.skipTrivia(text, node.pos), node.end);
    }
    ts.getTextOfNode = getTextOfNode;
    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'
    function escapeIdentifier(identifier) {
        return identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ ? "_" + identifier : identifier;
    }
    ts.escapeIdentifier = escapeIdentifier;
    // Remove extra underscore from escaped identifier
    function unescapeIdentifier(identifier) {
        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;
    }
    ts.unescapeIdentifier = unescapeIdentifier;
    // TODO(jfreeman): Implement declarationNameToString for computed properties
    // Return display name of an identifier
    function declarationNameToString(name) {
        return name.kind === 120 /* Missing */ ? "(Missing)" : getTextOfNode(name);
    }
    ts.declarationNameToString = declarationNameToString;
    function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = node.kind === 120 /* Missing */ ? node.pos : ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2);
    }
    ts.createDiagnosticForNode = createDiagnosticForNode;
    function createDiagnosticForNodeFromMessageChain(node, messageChain, newLine) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.flattenDiagnosticChain(file, start, length, messageChain, newLine);
    }
    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;
    function getErrorSpanForNode(node) {
        var errorSpan;
        switch (node.kind) {
            case 181 /* VariableDeclaration */:
            case 184 /* ClassDeclaration */:
            case 185 /* InterfaceDeclaration */:
            case 188 /* ModuleDeclaration */:
            case 187 /* EnumDeclaration */:
            case 192 /* EnumMember */:
                errorSpan = node.name;
                break;
        }
        // We now have the ideal error span, but it may be a node that is optional and absent
        // (e.g. the name of a function expression), in which case errorSpan will be undefined.
        // Alternatively, it might be required and missing (e.g. the name of a module), in which
        // case its pos will equal its end (length 0). In either of these cases, we should fall
        // back to the original node that the error was issued on.
        return errorSpan && errorSpan.pos < errorSpan.end ? errorSpan : node;
    }
    ts.getErrorSpanForNode = getErrorSpanForNode;
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    function isDeclarationFile(file) {
        return (file.flags & 1024 /* DeclarationFile */) !== 0;
    }
    ts.isDeclarationFile = isDeclarationFile;
    function isConstEnumDeclaration(node) {
        return (node.flags & 4096 /* Const */) !== 0;
    }
    ts.isConstEnumDeclaration = isConstEnumDeclaration;
    function isPrologueDirective(node) {
        return node.kind === 161 /* ExpressionStatement */ && node.expression.kind === 7 /* StringLiteral */;
    }
    ts.isPrologueDirective = isPrologueDirective;
    function isEvalOrArgumentsIdentifier(node) {
        return node.kind === 63 /* Identifier */ && node.text && (node.text === "eval" || node.text === "arguments");
    }
    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)
    function isUseStrictPrologueDirective(node) {
        ts.Debug.assert(isPrologueDirective(node));
        return node.expression.text === "use strict";
    }
    function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {
        sourceFileOfNode = sourceFileOfNode || getSourceFileOfNode(node);
        // If parameter/type parameter, the prev token trailing comments are part of this node too
        if (node.kind === 123 /* Parameter */ || node.kind === 122 /* TypeParameter */) {
            // e.g.   (/** blah */ a, /** blah */ b);
            return ts.concatenate(ts.getTrailingCommentRanges(sourceFileOfNode.text, node.pos), ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos));
        }
        else {
            return ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos);
        }
    }
    ts.getLeadingCommentRangesOfNode = getLeadingCommentRangesOfNode;
    function getJsDocComments(node, sourceFileOfNode) {
        return ts.filter(getLeadingCommentRangesOfNode(node, sourceFileOfNode), function (comment) { return isJsDocComment(comment); });
        function isJsDocComment(comment) {
            // True if the comment starts with '/**' but not if it is '/**/'
            return sourceFileOfNode.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 2) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 3) !== 47 /* slash */;
        }
    }
    ts.getJsDocComments = getJsDocComments;
    ts.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)('|")(.+?)\2.*?\/>/;
    // Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
    // stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
    function forEachChild(node, cbNode, cbNodes) {
        function child(node) {
            if (node)
                return cbNode(node);
        }
        function children(nodes) {
            if (nodes) {
                if (cbNodes)
                    return cbNodes(nodes);
                var result;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    if (result = cbNode(nodes[i]))
                        break;
                }
                return result;
            }
        }
        if (!node)
            return;
        switch (node.kind) {
            case 121 /* QualifiedName */:
                return child(node.left) || child(node.right);
            case 122 /* TypeParameter */:
                return child(node.name) || child(node.constraint);
            case 123 /* Parameter */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 124 /* Property */:
            case 141 /* PropertyAssignment */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 129 /* CallSignature */:
            case 130 /* ConstructSignature */:
            case 131 /* IndexSignature */:
                return children(node.typeParameters) || children(node.parameters) || child(node.type);
            case 125 /* Method */:
            case 126 /* Constructor */:
            case 127 /* GetAccessor */:
            case 128 /* SetAccessor */:
            case 149 /* FunctionExpression */:
            case 182 /* FunctionDeclaration */:
            case 150 /* ArrowFunction */:
                return child(node.name) || children(node.typeParameters) || children(node.parameters) || child(node.type) || child(node.body);
            case 132 /* TypeReference */:
                return child(node.typeName) || children(node.typeArguments);
            case 133 /* TypeQuery */:
                return child(node.exprName);
            case 134 /* TypeLiteral */:
                return children(node.members);
            case 135 /* ArrayType */:
                return child(node.elementType);
            case 136 /* TupleType */:
                return children(node.elementTypes);
            case 137 /* UnionType */:
                return children(node.types);
            case 138 /* ParenType */:
                return child(node.type);
            case 139 /* ArrayLiteral */:
                return children(node.elements);
            case 140 /* ObjectLiteral */:
                return children(node.properties);
            case 142 /* PropertyAccess */:
                return child(node.left) || child(node.right);
            case 143 /* IndexedAccess */:
                return child(node.object) || child(node.index);
            case 144 /* CallExpression */:
            case 145 /* NewExpression */:
                return child(node.func) || children(node.typeArguments) || children(node.arguments);
            case 146 /* TaggedTemplateExpression */:
                return child(node.tag) || child(node.template);
            case 147 /* TypeAssertion */:
                return child(node.type) || child(node.operand);
            case 148 /* ParenExpression */:
                return child(node.expression);
            case 151 /* PrefixOperator */:
            case 152 /* PostfixOperator */:
                return child(node.operand);
            case 153 /* BinaryExpression */:
                return child(node.left) || child(node.right);
            case 154 /* ConditionalExpression */:
                return child(node.condition) || child(node.whenTrue) || child(node.whenFalse);
            case 158 /* Block */:
            case 177 /* TryBlock */:
            case 179 /* FinallyBlock */:
            case 183 /* FunctionBlock */:
            case 189 /* ModuleBlock */:
            case 193 /* SourceFile */:
                return children(node.statements);
            case 159 /* VariableStatement */:
                return children(node.declarations);
            case 161 /* ExpressionStatement */:
                return child(node.expression);
            case 162 /* IfStatement */:
                return child(node.expression) || child(node.thenStatement) || child(node.elseStatement);
            case 163 /* DoStatement */:
                return child(node.statement) || child(node.expression);
            case 164 /* WhileStatement */:
                return child(node.expression) || child(node.statement);
            case 165 /* ForStatement */:
                return children(node.declarations) || child(node.initializer) || child(node.condition) || child(node.iterator) || child(node.statement);
            case 166 /* ForInStatement */:
                return child(node.declaration) || child(node.variable) || child(node.expression) || child(node.statement);
            case 167 /* ContinueStatement */:
            case 168 /* BreakStatement */:
                return child(node.label);
            case 169 /* ReturnStatement */:
                return child(node.expression);
            case 170 /* WithStatement */:
                return child(node.expression) || child(node.statement);
            case 171 /* SwitchStatement */:
                return child(node.expression) || children(node.clauses);
            case 172 /* CaseClause */:
            case 173 /* DefaultClause */:
                return child(node.expression) || children(node.statements);
            case 174 /* LabeledStatement */:
                return child(node.label) || child(node.statement);
            case 175 /* ThrowStatement */:
                return child(node.expression);
            case 176 /* TryStatement */:
                return child(node.tryBlock) || child(node.catchBlock) || child(node.finallyBlock);
            case 178 /* CatchBlock */:
                return child(node.variable) || children(node.statements);
            case 181 /* VariableDeclaration */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 184 /* ClassDeclaration */:
                return child(node.name) || children(node.typeParameters) || child(node.baseType) || children(node.implementedTypes) || children(node.members);
            case 185 /* InterfaceDeclaration */:
                return child(node.name) || children(node.typeParameters) || children(node.baseTypes) || children(node.members);
            case 186 /* TypeAliasDeclaration */:
                return child(node.name) || child(node.type);
            case 187 /* EnumDeclaration */:
                return child(node.name) || children(node.members);
            case 192 /* EnumMember */:
                return child(node.name) || child(node.initializer);
            case 188 /* ModuleDeclaration */:
                return child(node.name) || child(node.body);
            case 190 /* ImportDeclaration */:
                return child(node.name) || child(node.entityName) || child(node.externalModuleName);
            case 191 /* ExportAssignment */:
                return child(node.exportName);
            case 155 /* TemplateExpression */:
                return child(node.head) || children(node.templateSpans);
            case 156 /* TemplateSpan */:
                return child(node.expression) || child(node.literal);
        }
    }
    ts.forEachChild = forEachChild;
    // Warning: This has the same semantics as the forEach family of functions,
    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.
    function forEachReturnStatement(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 169 /* ReturnStatement */:
                    return visitor(node);
                case 158 /* Block */:
                case 183 /* FunctionBlock */:
                case 162 /* IfStatement */:
                case 163 /* DoStatement */:
                case 164 /* WhileStatement */:
                case 165 /* ForStatement */:
                case 166 /* ForInStatement */:
                case 170 /* WithStatement */:
                case 171 /* SwitchStatement */:
                case 172 /* CaseClause */:
                case 173 /* DefaultClause */:
                case 174 /* LabeledStatement */:
                case 176 /* TryStatement */:
                case 177 /* TryBlock */:
                case 178 /* CatchBlock */:
                case 179 /* FinallyBlock */:
                    return forEachChild(node, traverse);
            }
        }
    }
    ts.forEachReturnStatement = forEachReturnStatement;
    function isAnyFunction(node) {
        if (node) {
            switch (node.kind) {
                case 149 /* FunctionExpression */:
                case 182 /* FunctionDeclaration */:
                case 150 /* ArrowFunction */:
                case 125 /* Method */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 126 /* Constructor */:
                    return true;
            }
        }
        return false;
    }
    ts.isAnyFunction = isAnyFunction;
    function getContainingFunction(node) {
        while (true) {
            node = node.parent;
            if (!node || isAnyFunction(node)) {
                return node;
            }
        }
    }
    ts.getContainingFunction = getContainingFunction;
    function getThisContainer(node, includeArrowFunctions) {
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 150 /* ArrowFunction */:
                    if (!includeArrowFunctions) {
                        continue;
                    }
                case 182 /* FunctionDeclaration */:
                case 149 /* FunctionExpression */:
                case 188 /* ModuleDeclaration */:
                case 124 /* Property */:
                case 125 /* Method */:
                case 126 /* Constructor */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 187 /* EnumDeclaration */:
                case 193 /* SourceFile */:
                    return node;
            }
        }
    }
    ts.getThisContainer = getThisContainer;
    function getSuperContainer(node) {
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 124 /* Property */:
                case 125 /* Method */:
                case 126 /* Constructor */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                    return node;
            }
        }
    }
    ts.getSuperContainer = getSuperContainer;
    function isExpression(node) {
        switch (node.kind) {
            case 91 /* ThisKeyword */:
            case 89 /* SuperKeyword */:
            case 87 /* NullKeyword */:
            case 93 /* TrueKeyword */:
            case 78 /* FalseKeyword */:
            case 8 /* RegularExpressionLiteral */:
            case 139 /* ArrayLiteral */:
            case 140 /* ObjectLiteral */:
            case 142 /* PropertyAccess */:
            case 143 /* IndexedAccess */:
            case 144 /* CallExpression */:
            case 145 /* NewExpression */:
            case 146 /* TaggedTemplateExpression */:
            case 147 /* TypeAssertion */:
            case 148 /* ParenExpression */:
            case 149 /* FunctionExpression */:
            case 150 /* ArrowFunction */:
            case 151 /* PrefixOperator */:
            case 152 /* PostfixOperator */:
            case 153 /* BinaryExpression */:
            case 154 /* ConditionalExpression */:
            case 155 /* TemplateExpression */:
            case 9 /* NoSubstitutionTemplateLiteral */:
            case 157 /* OmittedExpression */:
                return true;
            case 121 /* QualifiedName */:
                while (node.parent.kind === 121 /* QualifiedName */)
                    node = node.parent;
                return node.parent.kind === 133 /* TypeQuery */;
            case 63 /* Identifier */:
                if (node.parent.kind === 133 /* TypeQuery */) {
                    return true;
                }
            case 6 /* NumericLiteral */:
            case 7 /* StringLiteral */:
                var parent = node.parent;
                switch (parent.kind) {
                    case 181 /* VariableDeclaration */:
                    case 123 /* Parameter */:
                    case 124 /* Property */:
                    case 192 /* EnumMember */:
                    case 141 /* PropertyAssignment */:
                        return parent.initializer === node;
                    case 161 /* ExpressionStatement */:
                    case 162 /* IfStatement */:
                    case 163 /* DoStatement */:
                    case 164 /* WhileStatement */:
                    case 169 /* ReturnStatement */:
                    case 170 /* WithStatement */:
                    case 171 /* SwitchStatement */:
                    case 172 /* CaseClause */:
                    case 175 /* ThrowStatement */:
                    case 171 /* SwitchStatement */:
                        return parent.expression === node;
                    case 165 /* ForStatement */:
                        return parent.initializer === node || parent.condition === node || parent.iterator === node;
                    case 166 /* ForInStatement */:
                        return parent.variable === node || parent.expression === node;
                    case 147 /* TypeAssertion */:
                        return node === parent.operand;
                    case 156 /* TemplateSpan */:
                        return node === parent.expression;
                    default:
                        if (isExpression(parent)) {
                            return true;
                        }
                }
        }
        return false;
    }
    ts.isExpression = isExpression;
    function hasRestParameters(s) {
        return s.parameters.length > 0 && (s.parameters[s.parameters.length - 1].flags & 8 /* Rest */) !== 0;
    }
    ts.hasRestParameters = hasRestParameters;
    function isLiteralKind(kind) {
        return 6 /* FirstLiteralToken */ <= kind && kind <= 9 /* LastLiteralToken */;
    }
    ts.isLiteralKind = isLiteralKind;
    function isTextualLiteralKind(kind) {
        return kind === 7 /* StringLiteral */ || kind === 9 /* NoSubstitutionTemplateLiteral */;
    }
    ts.isTextualLiteralKind = isTextualLiteralKind;
    function isTemplateLiteralKind(kind) {
        return 9 /* FirstTemplateToken */ <= kind && kind <= 12 /* LastTemplateToken */;
    }
    ts.isTemplateLiteralKind = isTemplateLiteralKind;
    function isInAmbientContext(node) {
        while (node) {
            if (node.flags & (2 /* Ambient */ | 1024 /* DeclarationFile */))
                return true;
            node = node.parent;
        }
        return false;
    }
    ts.isInAmbientContext = isInAmbientContext;
    function isDeclaration(node) {
        switch (node.kind) {
            case 122 /* TypeParameter */:
            case 123 /* Parameter */:
            case 181 /* VariableDeclaration */:
            case 124 /* Property */:
            case 141 /* PropertyAssignment */:
            case 192 /* EnumMember */:
            case 125 /* Method */:
            case 182 /* FunctionDeclaration */:
            case 127 /* GetAccessor */:
            case 128 /* SetAccessor */:
            case 184 /* ClassDeclaration */:
            case 185 /* InterfaceDeclaration */:
            case 186 /* TypeAliasDeclaration */:
            case 187 /* EnumDeclaration */:
            case 188 /* ModuleDeclaration */:
            case 190 /* ImportDeclaration */:
                return true;
        }
        return false;
    }
    ts.isDeclaration = isDeclaration;
    function isStatement(n) {
        switch (n.kind) {
            case 168 /* BreakStatement */:
            case 167 /* ContinueStatement */:
            case 180 /* DebuggerStatement */:
            case 163 /* DoStatement */:
            case 161 /* ExpressionStatement */:
            case 160 /* EmptyStatement */:
            case 166 /* ForInStatement */:
            case 165 /* ForStatement */:
            case 162 /* IfStatement */:
            case 174 /* LabeledStatement */:
            case 169 /* ReturnStatement */:
            case 171 /* SwitchStatement */:
            case 92 /* ThrowKeyword */:
            case 176 /* TryStatement */:
            case 159 /* VariableStatement */:
            case 164 /* WhileStatement */:
            case 170 /* WithStatement */:
            case 191 /* ExportAssignment */:
                return true;
            default:
                return false;
        }
    }
    ts.isStatement = isStatement;
    // True if the given identifier, string literal, or number literal is the name of a declaration node
    function isDeclarationOrFunctionExpressionOrCatchVariableName(name) {
        if (name.kind !== 63 /* Identifier */ && name.kind !== 7 /* StringLiteral */ && name.kind !== 6 /* NumericLiteral */) {
            return false;
        }
        var parent = name.parent;
        if (isDeclaration(parent) || parent.kind === 149 /* FunctionExpression */) {
            return parent.name === name;
        }
        if (parent.kind === 178 /* CatchBlock */) {
            return parent.variable === name;
        }
        return false;
    }
    ts.isDeclarationOrFunctionExpressionOrCatchVariableName = isDeclarationOrFunctionExpressionOrCatchVariableName;
    function getAncestor(node, kind) {
        switch (kind) {
            case 184 /* ClassDeclaration */:
                while (node) {
                    switch (node.kind) {
                        case 184 /* ClassDeclaration */:
                            return node;
                        case 187 /* EnumDeclaration */:
                        case 185 /* InterfaceDeclaration */:
                        case 186 /* TypeAliasDeclaration */:
                        case 188 /* ModuleDeclaration */:
                        case 190 /* ImportDeclaration */:
                            // early exit cases - declarations cannot be nested in classes
                            return undefined;
                        default:
                            node = node.parent;
                            continue;
                    }
                }
                break;
            default:
                while (node) {
                    if (node.kind === kind) {
                        return node;
                    }
                    node = node.parent;
                }
                break;
        }
        return undefined;
    }
    ts.getAncestor = getAncestor;
    function parsingContextErrors(context) {
        switch (context) {
            case 0 /* SourceElements */: return ts.Diagnostics.Declaration_or_statement_expected;
            case 1 /* ModuleElements */: return ts.Diagnostics.Declaration_or_statement_expected;
            case 2 /* BlockStatements */: return ts.Diagnostics.Statement_expected;
            case 3 /* SwitchClauses */: return ts.Diagnostics.case_or_default_expected;
            case 4 /* SwitchClauseStatements */: return ts.Diagnostics.Statement_expected;
            case 5 /* TypeMembers */: return ts.Diagnostics.Property_or_signature_expected;
            case 6 /* ClassMembers */: return ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;
            case 7 /* EnumMembers */: return ts.Diagnostics.Enum_member_expected;
            case 8 /* BaseTypeReferences */: return ts.Diagnostics.Type_reference_expected;
            case 9 /* VariableDeclarations */: return ts.Diagnostics.Variable_declaration_expected;
            case 10 /* ArgumentExpressions */: return ts.Diagnostics.Argument_expression_expected;
            case 11 /* ObjectLiteralMembers */: return ts.Diagnostics.Property_assignment_expected;
            case 12 /* ArrayLiteralMembers */: return ts.Diagnostics.Expression_or_comma_expected;
            case 13 /* Parameters */: return ts.Diagnostics.Parameter_declaration_expected;
            case 14 /* TypeParameters */: return ts.Diagnostics.Type_parameter_declaration_expected;
            case 15 /* TypeArguments */: return ts.Diagnostics.Type_argument_expected;
            case 16 /* TupleElementTypes */: return ts.Diagnostics.Type_expected;
        }
    }
    ;
    function getFileReferenceFromReferencePath(comment, commentRange) {
        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        var isNoDefaultLibRegEx = /^(\/\/\/\s*<reference\s+no-default-lib\s*=\s*)('|")(.+?)\2\s*\/>/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            if (isNoDefaultLibRegEx.exec(comment)) {
                return {
                    isNoDefaultLib: true
                };
            }
            else {
                var matchResult = ts.fullTripleSlashReferencePathRegEx.exec(comment);
                if (matchResult) {
                    var start = commentRange.pos;
                    var end = commentRange.end;
                    var fileRef = {
                        pos: start,
                        end: end,
                        filename: matchResult[3]
                    };
                    return {
                        fileReference: fileRef,
                        isNoDefaultLib: false
                    };
                }
                else {
                    return {
                        diagnostic: ts.Diagnostics.Invalid_reference_directive_syntax,
                        isNoDefaultLib: false
                    };
                }
            }
        }
        return undefined;
    }
    ts.getFileReferenceFromReferencePath = getFileReferenceFromReferencePath;
    function isKeyword(token) {
        return 64 /* FirstKeyword */ <= token && token <= 119 /* LastKeyword */;
    }
    ts.isKeyword = isKeyword;
    function isTrivia(token) {
        return 2 /* FirstTriviaToken */ <= token && token <= 5 /* LastTriviaToken */;
    }
    ts.isTrivia = isTrivia;
    function isModifier(token) {
        switch (token) {
            case 106 /* PublicKeyword */:
            case 104 /* PrivateKeyword */:
            case 105 /* ProtectedKeyword */:
            case 107 /* StaticKeyword */:
            case 76 /* ExportKeyword */:
            case 112 /* DeclareKeyword */:
                return true;
        }
        return false;
    }
    ts.isModifier = isModifier;
    function createSourceFile(filename, sourceText, languageVersion, version, isOpen) {
        if (isOpen === void 0) { isOpen = false; }
        var file;
        var scanner;
        var token;
        var parsingContext;
        var commentRanges;
        var identifiers = {};
        var identifierCount = 0;
        var nodeCount = 0;
        var lineStarts;
        var isInStrictMode = false;
        var lookAheadMode = 0 /* NotLookingAhead */;
        var inAmbientContext = false;
        var inFunctionBody = false;
        var inSwitchStatement = 0 /* NotNested */;
        var inIterationStatement = 0 /* NotNested */;
        // The following is a state machine that tracks what labels are in our current parsing
        // context. So if we are parsing a node that is nested (arbitrarily deeply) in a label,
        // it will be tracked in this data structure. It is used for checking break/continue
        // statements, and checking for duplicate labels.
        var labelledStatementInfo = (function () {
            // These are initialized on demand because labels are rare, so it is usually
            // not even necessary to allocate these.
            var functionBoundarySentinel;
            var currentLabelSet;
            var labelSetStack;
            var isIterationStack;
            function addLabel(label) {
                if (!currentLabelSet) {
                    currentLabelSet = {};
                }
                currentLabelSet[label.text] = true;
            }
            function pushCurrentLabelSet(isIterationStatement) {
                if (!labelSetStack && !isIterationStack) {
                    labelSetStack = [];
                    isIterationStack = [];
                }
                ts.Debug.assert(currentLabelSet !== undefined);
                labelSetStack.push(currentLabelSet);
                isIterationStack.push(isIterationStatement);
                currentLabelSet = undefined;
            }
            function pushFunctionBoundary() {
                if (!functionBoundarySentinel) {
                    functionBoundarySentinel = {};
                    if (!labelSetStack && !isIterationStack) {
                        labelSetStack = [];
                        isIterationStack = [];
                    }
                }
                ts.Debug.assert(currentLabelSet === undefined);
                labelSetStack.push(functionBoundarySentinel);
                // It does not matter what we push here, since we will never ask if a function boundary
                // is an iteration statement
                isIterationStack.push(false);
            }
            function pop() {
                // Assert that we are in a "pushed" state
                ts.Debug.assert(labelSetStack.length && isIterationStack.length && currentLabelSet === undefined);
                labelSetStack.pop();
                isIterationStack.pop();
            }
            function nodeIsNestedInLabel(label, requireIterationStatement, stopAtFunctionBoundary) {
                if (!requireIterationStatement && currentLabelSet && ts.hasProperty(currentLabelSet, label.text)) {
                    return 1 /* Nested */;
                }
                if (!labelSetStack) {
                    return 0 /* NotNested */;
                }
                // We want to start searching for the label at the lowest point in the tree,
                // and climb up from there. So we start at the end of the labelSetStack array.
                var crossedFunctionBoundary = false;
                for (var i = labelSetStack.length - 1; i >= 0; i--) {
                    var labelSet = labelSetStack[i];
                    // Not allowed to cross function boundaries, so stop if we encounter one
                    if (labelSet === functionBoundarySentinel) {
                        if (stopAtFunctionBoundary) {
                            break;
                        }
                        else {
                            crossedFunctionBoundary = true;
                            continue;
                        }
                    }
                    // If we require an iteration statement, only search in the current
                    // statement if it is an iteration statement
                    if (requireIterationStatement && isIterationStack[i] === false) {
                        continue;
                    }
                    if (ts.hasProperty(labelSet, label.text)) {
                        return crossedFunctionBoundary ? 2 /* CrossingFunctionBoundary */ : 1 /* Nested */;
                    }
                }
                // This is a bit of a misnomer. If the caller passed true for stopAtFunctionBoundary,
                // there actually may be an enclosing label across a function boundary, but we will
                // just return NotNested
                return 0 /* NotNested */;
            }
            return {
                addLabel: addLabel,
                pushCurrentLabelSet: pushCurrentLabelSet,
                pushFunctionBoundary: pushFunctionBoundary,
                pop: pop,
                nodeIsNestedInLabel: nodeIsNestedInLabel
            };
        })();
        function getLineAndCharacterlFromSourcePosition(position) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getLineAndCharacterOfPosition(lineStarts, position);
        }
        function getPositionFromSourceLineAndCharacter(line, character) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getPositionFromLineAndCharacter(lineStarts, line, character);
        }
        function error(message, arg0, arg1, arg2) {
            var start = scanner.getTokenPos();
            var length = scanner.getTextPos() - start;
            errorAtPos(start, length, message, arg0, arg1, arg2);
        }
        // This is just like createDiagnosticForNode except that it uses the current file
        // being parsed instead of the file containing the node. This is because during
        // parse, the nodes do not have parent pointers to get to the file.
        //
        // It is very intentional that we are not checking or changing the lookAheadMode value
        // here. 'grammarErrorOnNode' is called when we are doing extra grammar checks and not
        // when we are doing the actual parsing to determine what the user wrote.  In other 
        // words, this function is called once we have already parsed the node, and are just
        // applying some stricter checks on that node.
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var span = getErrorSpanForNode(node);
            var start = span.end > span.pos ? ts.skipTrivia(file.text, span.pos) : span.pos;
            var length = span.end - start;
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function reportInvalidUseInStrictMode(node) {
            // declarationNameToString cannot be used here since it uses a backreference to 'parent' that is not yet set
            var name = sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
            grammarErrorOnNode(node, ts.Diagnostics.Invalid_use_of_0_in_strict_mode, name);
        }
        function grammarErrorAtPos(start, length, message, arg0, arg1, arg2) {
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function errorAtPos(start, length, message, arg0, arg1, arg2) {
            var lastErrorPos = file.syntacticErrors.length ? file.syntacticErrors[file.syntacticErrors.length - 1].start : -1;
            if (start !== lastErrorPos) {
                file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
            }
            if (lookAheadMode === 1 /* NoErrorYet */) {
                lookAheadMode = 2 /* Error */;
            }
        }
        function scanError(message) {
            var pos = scanner.getTextPos();
            errorAtPos(pos, 0, message);
        }
        function onComment(pos, end) {
            if (commentRanges)
                commentRanges.push({ pos: pos, end: end });
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function getNodeEnd() {
            return scanner.getStartPos();
        }
        function nextToken() {
            return token = scanner.scan();
        }
        function getTokenPos(pos) {
            return ts.skipTrivia(sourceText, pos);
        }
        function reScanGreaterToken() {
            return token = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return token = scanner.reScanSlashToken();
        }
        function reScanTemplateToken() {
            return token = scanner.reScanTemplateToken();
        }
        function lookAheadHelper(callback, alwaysResetState) {
            // Keep track of the state we'll need to rollback to if lookahead fails (or if the 
            // caller asked us to always reset our state).
            var saveToken = token;
            var saveSyntacticErrorsLength = file.syntacticErrors.length;
            // Keep track of the current look ahead mode (this matters if we have nested 
            // speculative parsing).
            var saveLookAheadMode = lookAheadMode;
            // Mark that we're in speculative parsing and then try to parse out whatever code
            // the callback wants.
            lookAheadMode = 1 /* NoErrorYet */;
            var result = callback();
            // If we switched from 1 to -1 then a parse error occurred during the callback.
            // If that's the case, then we want to act as if we never got any result at all.
            ts.Debug.assert(lookAheadMode === 2 /* Error */ || lookAheadMode === 1 /* NoErrorYet */);
            if (lookAheadMode === 2 /* Error */) {
                result = undefined;
            }
            // Now restore as appropriate.
            lookAheadMode = saveLookAheadMode;
            if (!result || alwaysResetState) {
                token = saveToken;
                file.syntacticErrors.length = saveSyntacticErrorsLength;
            }
            return result;
        }
        function lookAhead(callback) {
            var result;
            scanner.tryScan(function () {
                result = lookAheadHelper(callback, true);
                // Returning false here indicates to the scanner that it should always jump
                // back to where it started.  This makes sense as 'lookahead' acts as if 
                // neither the parser nor scanner was affected by the operation.
                //
                // Note: the rewinding of the parser state is already handled in lookAheadHelper
                // (because we passed 'true' for alwaysResetState).
                return false;
            });
            return result;
        }
        function tryParse(callback) {
            return scanner.tryScan(function () { return lookAheadHelper(callback, false); });
        }
        function isIdentifier() {
            return token === 63 /* Identifier */ || (isInStrictMode ? token > 108 /* LastFutureReservedWord */ : token > 99 /* LastReservedWord */);
        }
        function parseExpected(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            error(ts.Diagnostics._0_expected, ts.tokenToString(t));
            return false;
        }
        function parseOptional(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function canParseSemicolon() {
            // If there's a real semicolon, then we can always parse it out.
            if (token === 21 /* SemicolonToken */) {
                return true;
            }
            // We can parse out an optional semicolon in ASI cases in the following cases.
            return token === 14 /* CloseBraceToken */ || token === 1 /* EndOfFileToken */ || scanner.hasPrecedingLineBreak();
        }
        function parseSemicolon() {
            if (canParseSemicolon()) {
                if (token === 21 /* SemicolonToken */) {
                    // consume the semicolon if it was explicitly provided.
                    nextToken();
                }
            }
            else {
                error(ts.Diagnostics._0_expected, ";");
            }
        }
        function createNode(kind, pos) {
            nodeCount++;
            var node = new (nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind)))();
            if (!(pos >= 0))
                pos = scanner.getStartPos();
            node.pos = pos;
            node.end = pos;
            return node;
        }
        function finishNode(node) {
            node.end = scanner.getStartPos();
            return node;
        }
        function createMissingNode() {
            return createNode(120 /* Missing */);
        }
        function internIdentifier(text) {
            return ts.hasProperty(identifiers, text) ? identifiers[text] : (identifiers[text] = text);
        }
        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
        // each identifier in order to reduce memory consumption.
        function createIdentifier(isIdentifier) {
            identifierCount++;
            if (isIdentifier) {
                var node = createNode(63 /* Identifier */);
                var text = escapeIdentifier(scanner.getTokenValue());
                node.text = internIdentifier(text);
                nextToken();
                return finishNode(node);
            }
            error(ts.Diagnostics.Identifier_expected);
            var node = createMissingNode();
            node.text = "";
            return node;
        }
        function parseIdentifier() {
            return createIdentifier(isIdentifier());
        }
        function parseIdentifierName() {
            return createIdentifier(token >= 63 /* Identifier */);
        }
        function isPropertyName() {
            return token >= 63 /* Identifier */ || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */;
        }
        function parsePropertyName() {
            if (token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */) {
                return parseLiteralNode(true);
            }
            return parseIdentifierName();
        }
        function parseContextualModifier(t) {
            return token === t && tryParse(function () {
                nextToken();
                return token === 17 /* OpenBracketToken */ || isPropertyName();
            });
        }
        function parseAnyContextualModifier() {
            return isModifier(token) && tryParse(function () {
                nextToken();
                return token === 17 /* OpenBracketToken */ || isPropertyName();
            });
        }
        // True if positioned at the start of a list element
        function isListElement(kind, inErrorRecovery) {
            switch (kind) {
                case 0 /* SourceElements */:
                case 1 /* ModuleElements */:
                    return isSourceElement(inErrorRecovery);
                case 2 /* BlockStatements */:
                case 4 /* SwitchClauseStatements */:
                    return isStatement(inErrorRecovery);
                case 3 /* SwitchClauses */:
                    return token === 65 /* CaseKeyword */ || token === 71 /* DefaultKeyword */;
                case 5 /* TypeMembers */:
                    return isStartOfTypeMember();
                case 6 /* ClassMembers */:
                    return lookAhead(isClassMemberStart);
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return isPropertyName();
                case 8 /* BaseTypeReferences */:
                    return isIdentifier() && ((token !== 77 /* ExtendsKeyword */ && token !== 100 /* ImplementsKeyword */) || !lookAhead(function () { return (nextToken(), isIdentifier()); }));
                case 9 /* VariableDeclarations */:
                case 14 /* TypeParameters */:
                    return isIdentifier();
                case 10 /* ArgumentExpressions */:
                    return token === 22 /* CommaToken */ || isStartOfExpression();
                case 12 /* ArrayLiteralMembers */:
                    return token === 22 /* CommaToken */ || isStartOfExpression();
                case 13 /* Parameters */:
                    return isStartOfParameter();
                case 15 /* TypeArguments */:
                case 16 /* TupleElementTypes */:
                    return token === 22 /* CommaToken */ || isStartOfType();
            }
            ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        // True if positioned at a list terminator
        function isListTerminator(kind) {
            if (token === 1 /* EndOfFileToken */) {
                // Being at the end of the file ends all lists.
                return true;
            }
            switch (kind) {
                case 1 /* ModuleElements */:
                case 2 /* BlockStatements */:
                case 3 /* SwitchClauses */:
                case 5 /* TypeMembers */:
                case 6 /* ClassMembers */:
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return token === 14 /* CloseBraceToken */;
                case 4 /* SwitchClauseStatements */:
                    return token === 14 /* CloseBraceToken */ || token === 65 /* CaseKeyword */ || token === 71 /* DefaultKeyword */;
                case 8 /* BaseTypeReferences */:
                    return token === 13 /* OpenBraceToken */ || token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */;
                case 9 /* VariableDeclarations */:
                    return isVariableDeclaratorListTerminator();
                case 14 /* TypeParameters */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 24 /* GreaterThanToken */ || token === 15 /* OpenParenToken */ || token === 13 /* OpenBraceToken */ || token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */;
                case 10 /* ArgumentExpressions */:
                    // Tokens other than ')' are here for better error recovery
                    return token === 16 /* CloseParenToken */ || token === 21 /* SemicolonToken */;
                case 12 /* ArrayLiteralMembers */:
                case 16 /* TupleElementTypes */:
                    return token === 18 /* CloseBracketToken */;
                case 13 /* Parameters */:
                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
                    return token === 16 /* CloseParenToken */ || token === 18 /* CloseBracketToken */ || token === 13 /* OpenBraceToken */;
                case 15 /* TypeArguments */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 24 /* GreaterThanToken */ || token === 15 /* OpenParenToken */;
            }
        }
        function isVariableDeclaratorListTerminator() {
            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done 
            // with parsing the list of  variable declarators.
            if (canParseSemicolon()) {
                return true;
            }
            // in the case where we're parsing the variable declarator of a 'for-in' statement, we 
            // are done if we see an 'in' keyword in front of us.
            if (token === 84 /* InKeyword */) {
                return true;
            }
            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (token === 31 /* EqualsGreaterThanToken */) {
                return true;
            }
            // Keep trying to parse out variable declarators.
            return false;
        }
        // True if positioned at element or terminator of the current list or any enclosing list
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 17 /* Count */; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Parses a list of elements
        function parseList(kind, checkForStrictMode, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            var saveIsInStrictMode = isInStrictMode;
            while (!isListTerminator(kind)) {
                if (isListElement(kind, false)) {
                    var element = parseElement();
                    result.push(element);
                    // test elements only if we are not already in strict mode
                    if (!isInStrictMode && checkForStrictMode) {
                        if (isPrologueDirective(element)) {
                            if (isUseStrictPrologueDirective(element)) {
                                isInStrictMode = true;
                                checkForStrictMode = false;
                            }
                        }
                        else {
                            checkForStrictMode = false;
                        }
                    }
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            isInStrictMode = saveIsInStrictMode;
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        // Parses a comma-delimited list of elements
        function parseDelimitedList(kind, parseElement, allowTrailingComma) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            // Keep track of how many errors we had before the list started. If we don't see any new
            // errors resulting from the list being malformed, we are free to complain about a trailing comma.
            var errorCountBeforeParsingList = file.syntacticErrors.length;
            var commaStart = -1; // Meaning the previous token was not a comma
            while (true) {
                if (isListElement(kind, false)) {
                    result.push(parseElement());
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(22 /* CommaToken */)) {
                        continue;
                    }
                    commaStart = -1; // Back to the state where the last token was not a comma
                    if (isListTerminator(kind)) {
                        break;
                    }
                    error(ts.Diagnostics._0_expected, ",");
                }
                else if (isListTerminator(kind)) {
                    break;
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            // Recording the trailing comma is deliberately done after the previous
            // loop, and not just if we see a list terminator. This is because the list
            // may have ended incorrectly, but it is still important to know if there
            // was a trailing comma.
            // Check if the last token was a comma.
            if (commaStart >= 0) {
                if (!allowTrailingComma) {
                    if (file.syntacticErrors.length === errorCountBeforeParsingList) {
                        // Report a grammar error so we don't affect lookahead
                        grammarErrorAtPos(commaStart, scanner.getStartPos() - commaStart, ts.Diagnostics.Trailing_comma_not_allowed);
                    }
                }
                // Always preserve a trailing comma by marking it on the NodeArray
                result.hasTrailingComma = true;
            }
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        function createMissingList() {
            var pos = getNodePos();
            var result = [];
            result.pos = pos;
            result.end = pos;
            return result;
        }
        function createNodeArray(node) {
            var result = [node];
            result.pos = node.pos;
            result.end = node.end;
            return result;
        }
        function parseBracketedList(kind, parseElement, startToken, endToken) {
            if (parseExpected(startToken)) {
                var result = parseDelimitedList(kind, parseElement, false);
                parseExpected(endToken);
                return result;
            }
            return createMissingList();
        }
        // The allowReservedWords parameter controls whether reserved words are permitted after the first dot
        function parseEntityName(allowReservedWords) {
            var entity = parseIdentifier();
            while (parseOptional(19 /* DotToken */)) {
                var node = createNode(121 /* QualifiedName */, entity.pos);
                node.left = entity;
                node.right = allowReservedWords ? parseIdentifierName() : parseIdentifier();
                entity = finishNode(node);
            }
            return entity;
        }
        function parseTokenNode() {
            var node = createNode(token);
            nextToken();
            return finishNode(node);
        }
        function parseTemplateExpression() {
            var template = createNode(155 /* TemplateExpression */);
            template.head = parseLiteralNode();
            ts.Debug.assert(template.head.kind === 10 /* TemplateHead */, "Template head has wrong token kind");
            var templateSpans = [];
            templateSpans.pos = getNodePos();
            do {
                templateSpans.push(parseTemplateSpan());
            } while (templateSpans[templateSpans.length - 1].literal.kind === 11 /* TemplateMiddle */);
            templateSpans.end = getNodeEnd();
            template.templateSpans = templateSpans;
            return finishNode(template);
        }
        function parseTemplateSpan() {
            var span = createNode(156 /* TemplateSpan */);
            span.expression = parseExpression(false);
            var literal;
            if (token === 14 /* CloseBraceToken */) {
                reScanTemplateToken();
                literal = parseLiteralNode();
            }
            else {
                error(ts.Diagnostics.Invalid_template_literal_expected);
                literal = createMissingNode();
                literal.text = "";
            }
            span.literal = literal;
            return finishNode(span);
        }
        function parseLiteralNode(internName) {
            var node = createNode(token);
            var text = scanner.getTokenValue();
            node.text = internName ? internIdentifier(text) : text;
            var tokenPos = scanner.getTokenPos();
            nextToken();
            finishNode(node);
            // Octal literals are not allowed in strict mode or ES5
            // Note that theoretically the following condition would hold true literals like 009,
            // which is not octal.But because of how the scanner separates the tokens, we would
            // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.
            // We also do not need to check for negatives because any prefix operator would be part of a
            // parent unary expression.
            if (node.kind === 6 /* NumericLiteral */ && sourceText.charCodeAt(tokenPos) === 48 /* _0 */ && ts.isOctalDigit(sourceText.charCodeAt(tokenPos + 1))) {
                if (isInStrictMode) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode);
                }
                else if (languageVersion >= 1 /* ES5 */) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            return node;
        }
        function parseStringLiteral() {
            if (token === 7 /* StringLiteral */) {
                return parseLiteralNode(true);
            }
            error(ts.Diagnostics.String_literal_expected);
            return createMissingNode();
        }
        // TYPES
        function parseTypeReference() {
            var node = createNode(132 /* TypeReference */);
            node.typeName = parseEntityName(false);
            if (!scanner.hasPrecedingLineBreak() && token === 23 /* LessThanToken */) {
                node.typeArguments = parseTypeArguments();
            }
            return finishNode(node);
        }
        function parseTypeQuery() {
            var node = createNode(133 /* TypeQuery */);
            parseExpected(95 /* TypeOfKeyword */);
            node.exprName = parseEntityName(true);
            return finishNode(node);
        }
        function parseTypeParameter() {
            var node = createNode(122 /* TypeParameter */);
            node.name = parseIdentifier();
            if (parseOptional(77 /* ExtendsKeyword */)) {
                // It's not uncommon for people to write improper constraints to a generic.  If the 
                // user writes a constraint that is an expression and not an actual type, then parse
                // it out as an expression (so we can recover well), but report that a type is needed
                // instead.
                if (isStartOfType() || !isStartOfExpression()) {
                    node.constraint = parseType();
                }
                else {
                    // It was not a type, and it looked like an expression.  Parse out an expression
                    // here so we recover well.  Note: it is important that we call parseUnaryExpression
                    // and not parseExpression here.  If the user has:
                    //
                    //      <T extends "">
                    //
                    // We do *not* want to consume the  >  as we're consuming the expression for "".
                    var expr = parseUnaryExpression();
                    grammarErrorOnNode(expr, ts.Diagnostics.Type_expected);
                }
            }
            return finishNode(node);
        }
        function parseTypeParameters() {
            if (token === 23 /* LessThanToken */) {
                var pos = getNodePos();
                var result = parseBracketedList(14 /* TypeParameters */, parseTypeParameter, 23 /* LessThanToken */, 24 /* GreaterThanToken */);
                if (!result.length) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
                }
                return result;
            }
        }
        function parseParameterType() {
            return parseOptional(50 /* ColonToken */) ? token === 7 /* StringLiteral */ ? parseStringLiteral() : parseType() : undefined;
        }
        function isStartOfParameter() {
            return token === 20 /* DotDotDotToken */ || isIdentifier() || isModifier(token);
        }
        function parseParameter(flags) {
            if (flags === void 0) { flags = 0; }
            var node = createNode(123 /* Parameter */);
            node.flags |= parseAndCheckModifiers(3 /* Parameters */);
            if (parseOptional(20 /* DotDotDotToken */)) {
                node.flags |= 8 /* Rest */;
            }
            node.name = parseIdentifier();
            if (node.name.kind === 120 /* Missing */ && node.flags === 0 && isModifier(token)) {
                // in cases like
                // 'use strict' 
                // function foo(static)
                // isParameter('static') === true, because of isModifier('static')
                // however 'static' is not a legal identifier in a strict mode.
                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
                // to avoid this we'll advance cursor to the next token.
                nextToken();
            }
            if (parseOptional(49 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            node.type = parseParameterType();
            node.initializer = parseInitializer(true);
            // Do not check for initializers in an ambient context for parameters. This is not
            // a grammar error because the grammar allows arbitrary call signatures in
            // an ambient context.
            // It is actually not necessary for this to be an error at all. The reason is that
            // function/constructor implementations are syntactically disallowed in ambient
            // contexts. In addition, parameter initializers are semantically disallowed in
            // overload signatures. So parameter initializers are transitively disallowed in
            // ambient contexts.
            return finishNode(node);
        }
        function parseSignature(kind, returnToken, returnTokenRequired) {
            if (kind === 130 /* ConstructSignature */) {
                parseExpected(86 /* NewKeyword */);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameterList(15 /* OpenParenToken */, 16 /* CloseParenToken */);
            checkParameterList(parameters);
            var type;
            if (returnTokenRequired) {
                parseExpected(returnToken);
                type = parseType();
            }
            else if (parseOptional(returnToken)) {
                type = parseType();
            }
            return {
                typeParameters: typeParameters,
                parameters: parameters,
                type: type
            };
        }
        // Because we use this for index signatures as well, we sometimes use
        // parentheses, and sometimes use brackets.
        function parseParameterList(startDelimiter, endDelimiter) {
            return parseBracketedList(13 /* Parameters */, parseParameter, startDelimiter, endDelimiter);
        }
        function checkParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the 
                // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code 
                // or if its FunctionBody is strict code(11.1.5).
                // It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a 
                // strict mode FunctionLikeDeclaration or FunctionExpression(13.1) 
                if (isInStrictMode && isEvalOrArgumentsIdentifier(parameter.name)) {
                    reportInvalidUseInStrictMode(parameter.name);
                    return;
                }
                else if (parameter.flags & 8 /* Rest */) {
                    if (i !== (parameterCount - 1)) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return;
                    }
                    if (parameter.flags & 4 /* QuestionMark */) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                        return;
                    }
                    if (parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                        return;
                    }
                }
                else if (parameter.flags & 4 /* QuestionMark */ || parameter.initializer) {
                    seenOptionalParameter = true;
                    if (parameter.flags & 4 /* QuestionMark */ && parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                        return;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                        return;
                    }
                }
            }
        }
        function parseSignatureMember(kind, returnToken) {
            var node = createNode(kind);
            var sig = parseSignature(kind, returnToken, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            parseSemicolon();
            return finishNode(node);
        }
        function parseIndexSignatureMember() {
            var node = createNode(131 /* IndexSignature */);
            var errorCountBeforeIndexSignature = file.syntacticErrors.length;
            var indexerStart = scanner.getTokenPos();
            node.parameters = parseParameterList(17 /* OpenBracketToken */, 18 /* CloseBracketToken */);
            var indexerLength = scanner.getStartPos() - indexerStart;
            node.type = parseTypeAnnotation();
            parseSemicolon();
            if (file.syntacticErrors.length === errorCountBeforeIndexSignature) {
                checkIndexSignature(node, indexerStart, indexerLength);
            }
            return finishNode(node);
        }
        function checkIndexSignature(node, indexerStart, indexerLength) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                var arityDiagnostic = ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter;
                if (parameter) {
                    grammarErrorOnNode(parameter.name, arityDiagnostic);
                }
                else {
                    grammarErrorAtPos(indexerStart, indexerLength, arityDiagnostic);
                }
                return;
            }
            else if (parameter.flags & 8 /* Rest */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
                return;
            }
            else if (parameter.flags & 243 /* Modifier */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
                return;
            }
            else if (parameter.flags & 4 /* QuestionMark */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
                return;
            }
            else if (parameter.initializer) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
                return;
            }
            else if (!parameter.type) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
                return;
            }
            else if (parameter.type.kind !== 118 /* StringKeyword */ && parameter.type.kind !== 116 /* NumberKeyword */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);
                return;
            }
            else if (!node.type) {
                grammarErrorAtPos(indexerStart, indexerLength, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
                return;
            }
        }
        function parsePropertyOrMethod() {
            var node = createNode(0 /* Unknown */);
            node.name = parsePropertyName();
            if (parseOptional(49 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {
                node.kind = 125 /* Method */;
                var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
                node.typeParameters = sig.typeParameters;
                node.parameters = sig.parameters;
                node.type = sig.type;
            }
            else {
                node.kind = 124 /* Property */;
                node.type = parseTypeAnnotation();
            }
            parseSemicolon();
            return finishNode(node);
        }
        function isStartOfTypeMember() {
            switch (token) {
                case 15 /* OpenParenToken */:
                case 23 /* LessThanToken */:
                case 17 /* OpenBracketToken */:
                    return true;
                default:
                    return isPropertyName() && lookAhead(function () { return nextToken() === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */ || token === 49 /* QuestionToken */ || token === 50 /* ColonToken */ || canParseSemicolon(); });
            }
        }
        function parseTypeMember() {
            switch (token) {
                case 15 /* OpenParenToken */:
                case 23 /* LessThanToken */:
                    return parseSignatureMember(129 /* CallSignature */, 50 /* ColonToken */);
                case 17 /* OpenBracketToken */:
                    return parseIndexSignatureMember();
                case 86 /* NewKeyword */:
                    if (lookAhead(function () { return nextToken() === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */; })) {
                        return parseSignatureMember(130 /* ConstructSignature */, 50 /* ColonToken */);
                    }
                case 7 /* StringLiteral */:
                case 6 /* NumericLiteral */:
                    return parsePropertyOrMethod();
                default:
                    if (token >= 63 /* Identifier */) {
                        return parsePropertyOrMethod();
                    }
            }
        }
        function parseTypeLiteral() {
            var node = createNode(134 /* TypeLiteral */);
            if (parseExpected(13 /* OpenBraceToken */)) {
                node.members = parseList(5 /* TypeMembers */, false, parseTypeMember);
                parseExpected(14 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseTupleType() {
            var node = createNode(136 /* TupleType */);
            var startTokenPos = scanner.getTokenPos();
            var startErrorCount = file.syntacticErrors.length;
            node.elementTypes = parseBracketedList(16 /* TupleElementTypes */, parseType, 17 /* OpenBracketToken */, 18 /* CloseBracketToken */);
            if (!node.elementTypes.length && file.syntacticErrors.length === startErrorCount) {
                grammarErrorAtPos(startTokenPos, scanner.getStartPos() - startTokenPos, ts.Diagnostics.A_tuple_type_element_list_cannot_be_empty);
            }
            return finishNode(node);
        }
        function parseParenType() {
            var node = createNode(138 /* ParenType */);
            parseExpected(15 /* OpenParenToken */);
            node.type = parseType();
            parseExpected(16 /* CloseParenToken */);
            return finishNode(node);
        }
        function parseFunctionType(signatureKind) {
            var node = createNode(134 /* TypeLiteral */);
            var member = createNode(signatureKind);
            var sig = parseSignature(signatureKind, 31 /* EqualsGreaterThanToken */, true);
            member.typeParameters = sig.typeParameters;
            member.parameters = sig.parameters;
            member.type = sig.type;
            finishNode(member);
            node.members = createNodeArray(member);
            return finishNode(node);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token === 19 /* DotToken */ ? undefined : node;
        }
        function parseNonArrayType() {
            switch (token) {
                case 109 /* AnyKeyword */:
                case 118 /* StringKeyword */:
                case 116 /* NumberKeyword */:
                case 110 /* BooleanKeyword */:
                case 97 /* VoidKeyword */:
                    var node = tryParse(parseKeywordAndNoDot);
                    return node || parseTypeReference();
                case 95 /* TypeOfKeyword */:
                    return parseTypeQuery();
                case 13 /* OpenBraceToken */:
                    return parseTypeLiteral();
                case 17 /* OpenBracketToken */:
                    return parseTupleType();
                case 15 /* OpenParenToken */:
                    return parseParenType();
                default:
                    if (isIdentifier()) {
                        return parseTypeReference();
                    }
            }
            error(ts.Diagnostics.Type_expected);
            return createMissingNode();
        }
        function isStartOfType() {
            switch (token) {
                case 109 /* AnyKeyword */:
                case 118 /* StringKeyword */:
                case 116 /* NumberKeyword */:
                case 110 /* BooleanKeyword */:
                case 97 /* VoidKeyword */:
                case 95 /* TypeOfKeyword */:
                case 13 /* OpenBraceToken */:
                case 17 /* OpenBracketToken */:
                case 23 /* LessThanToken */:
                case 86 /* NewKeyword */:
                    return true;
                case 15 /* OpenParenToken */:
                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,
                    // or something that starts a type. We don't want to consider things like '(1)' a type.
                    return lookAhead(function () {
                        nextToken();
                        return token === 16 /* CloseParenToken */ || isStartOfParameter() || isStartOfType();
                    });
                default:
                    return isIdentifier();
            }
        }
        function parsePrimaryType() {
            var type = parseNonArrayType();
            while (!scanner.hasPrecedingLineBreak() && parseOptional(17 /* OpenBracketToken */)) {
                parseExpected(18 /* CloseBracketToken */);
                var node = createNode(135 /* ArrayType */, type.pos);
                node.elementType = type;
                type = finishNode(node);
            }
            return type;
        }
        function parseUnionType() {
            var type = parsePrimaryType();
            if (token === 43 /* BarToken */) {
                var types = [type];
                types.pos = type.pos;
                while (parseOptional(43 /* BarToken */)) {
                    types.push(parsePrimaryType());
                }
                types.end = getNodeEnd();
                var node = createNode(137 /* UnionType */, type.pos);
                node.types = types;
                type = finishNode(node);
            }
            return type;
        }
        function isStartOfFunctionType() {
            return token === 23 /* LessThanToken */ || token === 15 /* OpenParenToken */ && lookAhead(function () {
                nextToken();
                if (token === 16 /* CloseParenToken */ || token === 20 /* DotDotDotToken */) {
                    // ( )
                    // ( ...
                    return true;
                }
                if (isIdentifier() || isModifier(token)) {
                    nextToken();
                    if (token === 50 /* ColonToken */ || token === 22 /* CommaToken */ || token === 49 /* QuestionToken */ || token === 51 /* EqualsToken */ || isIdentifier() || isModifier(token)) {
                        // ( id :
                        // ( id ,
                        // ( id ?
                        // ( id =
                        // ( modifier id
                        return true;
                    }
                    if (token === 16 /* CloseParenToken */) {
                        nextToken();
                        if (token === 31 /* EqualsGreaterThanToken */) {
                            // ( id ) =>
                            return true;
                        }
                    }
                }
                return false;
            });
        }
        function parseType() {
            if (isStartOfFunctionType()) {
                return parseFunctionType(129 /* CallSignature */);
            }
            if (token === 86 /* NewKeyword */) {
                return parseFunctionType(130 /* ConstructSignature */);
            }
            return parseUnionType();
        }
        function parseTypeAnnotation() {
            return parseOptional(50 /* ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isStartOfExpression() {
            switch (token) {
                case 91 /* ThisKeyword */:
                case 89 /* SuperKeyword */:
                case 87 /* NullKeyword */:
                case 93 /* TrueKeyword */:
                case 78 /* FalseKeyword */:
                case 6 /* NumericLiteral */:
                case 7 /* StringLiteral */:
                case 9 /* NoSubstitutionTemplateLiteral */:
                case 10 /* TemplateHead */:
                case 15 /* OpenParenToken */:
                case 17 /* OpenBracketToken */:
                case 13 /* OpenBraceToken */:
                case 81 /* FunctionKeyword */:
                case 86 /* NewKeyword */:
                case 35 /* SlashToken */:
                case 55 /* SlashEqualsToken */:
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                case 46 /* TildeToken */:
                case 45 /* ExclamationToken */:
                case 72 /* DeleteKeyword */:
                case 95 /* TypeOfKeyword */:
                case 97 /* VoidKeyword */:
                case 37 /* PlusPlusToken */:
                case 38 /* MinusMinusToken */:
                case 23 /* LessThanToken */:
                case 63 /* Identifier */:
                    return true;
                default:
                    return isIdentifier();
            }
        }
        function isStartOfExpressionStatement() {
            // As per the grammar, neither '{' nor 'function' can start an expression statement.
            return token !== 13 /* OpenBraceToken */ && token !== 81 /* FunctionKeyword */ && isStartOfExpression();
        }
        function parseExpression(noIn) {
            var expr = parseAssignmentExpression(noIn);
            while (parseOptional(22 /* CommaToken */)) {
                expr = makeBinaryExpression(expr, 22 /* CommaToken */, parseAssignmentExpression(noIn));
            }
            return expr;
        }
        function parseInitializer(inParameter, noIn) {
            if (token !== 51 /* EqualsToken */) {
                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
                // there is no newline after the last token and if we're on an expression.  If so, parse
                // this as an equals-value clause with a missing equals.
                // NOTE: There are two places where we allow equals-value clauses.  The first is in a 
                // variable declarator.  The second is with a parameter.  For variable declarators
                // it's more likely that a { would be a allowed (as an object literal).  While this
                // is also allowed for parameters, the risk is that we consume the { as an object
                // literal when it really will be for the block following the parameter.
                if (scanner.hasPrecedingLineBreak() || (inParameter && token === 13 /* OpenBraceToken */) || !isStartOfExpression()) {
                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression - 
                    // do not try to parse initializer
                    return undefined;
                }
            }
            parseExpected(51 /* EqualsToken */);
            return parseAssignmentExpression(noIn);
        }
        function parseAssignmentExpression(noIn) {
            // Augmented by TypeScript:
            //
            //  AssignmentExpression[in]:
            //      1) ConditionalExpression[in]
            //      2) LeftHandSideExpression = AssignmentExpression[in]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
            //      4) ArrowFunctionExpression <-- added by TypeScript
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing. 
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, check if we have an arrow function (production '4') that starts with a parenthesized
            // parameter list. If we do, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is
            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done 
            // with AssignmentExpression if we see one.
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression();
            if (arrowExpression) {
                return arrowExpression;
            }
            // Now try to handle the rest of the cases.  First, see if we can parse out up to and
            // including a conditional expression.
            var expr = parseConditionalExpression(noIn);
            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
            // identifier and the current token is an arrow.
            if (expr.kind === 63 /* Identifier */ && token === 31 /* EqualsGreaterThanToken */) {
                return parseSimpleArrowFunctionExpression(expr);
            }
            // Now see if we might be in cases '2' or '3'.
            // If the expression was a LHS expression, and we have an assignment operator, then 
            // we're in '2' or '3'. Consume the assignment and return.
            if (isLeftHandSideExpression(expr) && isAssignmentOperator()) {
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    // ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                    // Assignment operator(11.13) or of a PostfixExpression(11.3)
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                return makeBinaryExpression(expr, operator, parseAssignmentExpression(noIn));
            }
            // otherwise this was production '1'.  Return whatever we parsed so far.
            return expr;
        }
        function isLeftHandSideExpression(expr) {
            if (expr) {
                switch (expr.kind) {
                    case 142 /* PropertyAccess */:
                    case 143 /* IndexedAccess */:
                    case 145 /* NewExpression */:
                    case 144 /* CallExpression */:
                    case 146 /* TaggedTemplateExpression */:
                    case 139 /* ArrayLiteral */:
                    case 148 /* ParenExpression */:
                    case 140 /* ObjectLiteral */:
                    case 149 /* FunctionExpression */:
                    case 63 /* Identifier */:
                    case 120 /* Missing */:
                    case 8 /* RegularExpressionLiteral */:
                    case 6 /* NumericLiteral */:
                    case 7 /* StringLiteral */:
                    case 9 /* NoSubstitutionTemplateLiteral */:
                    case 155 /* TemplateExpression */:
                    case 78 /* FalseKeyword */:
                    case 87 /* NullKeyword */:
                    case 91 /* ThisKeyword */:
                    case 93 /* TrueKeyword */:
                    case 89 /* SuperKeyword */:
                        return true;
                }
            }
            return false;
        }
        function parseSimpleArrowFunctionExpression(identifier) {
            ts.Debug.assert(token === 31 /* EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            parseExpected(31 /* EqualsGreaterThanToken */);
            var parameter = createNode(123 /* Parameter */, identifier.pos);
            parameter.name = identifier;
            finishNode(parameter);
            var parameters = [];
            parameters.push(parameter);
            parameters.pos = parameter.pos;
            parameters.end = parameter.end;
            var signature = { parameters: parameters };
            return parseArrowExpressionTail(identifier.pos, signature, false);
        }
        function tryParseParenthesizedArrowFunctionExpression() {
            // Indicates whether we are certain that we should parse an arrow expression.
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0 /* False */) {
                return undefined;
            }
            var pos = getNodePos();
            if (triState === 1 /* True */) {
                var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
                // If we have an arrow, then try to parse the body.
                // Even if not, try to parse if we have an opening brace, just in case we're in an error state.
                if (parseExpected(31 /* EqualsGreaterThanToken */) || token === 13 /* OpenBraceToken */) {
                    return parseArrowExpressionTail(pos, sig, false);
                }
                else {
                    // If not, we're probably better off bailing out and returning a bogus function expression.
                    return makeFunctionExpression(150 /* ArrowFunction */, pos, undefined, sig, createMissingNode());
                }
            }
            // *Maybe* we had an arrow function and we need to try to parse it out,
            // rolling back and trying other parses if we fail.
            var sig = tryParseSignatureIfArrowOrBraceFollows();
            if (sig) {
                parseExpected(31 /* EqualsGreaterThanToken */);
                return parseArrowExpressionTail(pos, sig, false);
            }
            else {
                return undefined;
            }
        }
        //  True        -> We definitely expect a parenthesized arrow function here.
        //  False       -> There *cannot* be a parenthesized arrow function here.
        //  Unknown     -> There *might* be a parenthesized arrow function here.
        //                 Speculatively look ahead to be sure, and rollback if not.
        function isParenthesizedArrowFunctionExpression() {
            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {
                return lookAhead(function () {
                    var first = token;
                    var second = nextToken();
                    if (first === 15 /* OpenParenToken */) {
                        if (second === 16 /* CloseParenToken */) {
                            // Simple cases: "() =>", "(): ", and  "() {".
                            // This is an arrow function with no parameters.
                            // The last one is not actually an arrow function,
                            // but this is probably what the user intended.
                            var third = nextToken();
                            switch (third) {
                                case 31 /* EqualsGreaterThanToken */:
                                case 50 /* ColonToken */:
                                case 13 /* OpenBraceToken */:
                                    return 1 /* True */;
                                default:
                                    return 0 /* False */;
                            }
                        }
                        // Simple case: "(..."
                        // This is an arrow function with a rest parameter.
                        if (second === 20 /* DotDotDotToken */) {
                            return 1 /* True */;
                        }
                        // If we had "(" followed by something that's not an identifier,
                        // then this definitely doesn't look like a lambda.
                        // Note: we could be a little more lenient and allow
                        // "(public" or "(private". These would not ever actually be allowed,
                        // but we could provide a good error message instead of bailing out.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // If we have something like "(a:", then we must have a
                        // type-annotated parameter in an arrow function expression.
                        if (nextToken() === 50 /* ColonToken */) {
                            return 1 /* True */;
                        }
                        // This *could* be a parenthesized arrow function.
                        // Return Unknown to let the caller know.
                        return 2 /* Unknown */;
                    }
                    else {
                        ts.Debug.assert(first === 23 /* LessThanToken */);
                        // If we have "<" not followed by an identifier,
                        // then this definitely is not an arrow function.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // This *could* be a parenthesized arrow function.
                        return 2 /* Unknown */;
                    }
                });
            }
            if (token === 31 /* EqualsGreaterThanToken */) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function expression as that's
                // likely what the user intended to write.
                return 1 /* True */;
            }
            // Definitely not a parenthesized arrow function.
            return 0 /* False */;
        }
        function tryParseSignatureIfArrowOrBraceFollows() {
            return tryParse(function () {
                var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
                // Parsing a signature isn't enough.
                // Parenthesized arrow signatures often look like other valid expressions.
                // For instance:
                //  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
                //  - "(x,y)" is a comma expression parsed as a signature with two parameters.
                //  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
                //
                // So we need just a bit of lookahead to ensure that it can only be a signature.
                if (token === 31 /* EqualsGreaterThanToken */ || token === 13 /* OpenBraceToken */) {
                    return sig;
                }
                return undefined;
            });
        }
        function parseArrowExpressionTail(pos, sig, noIn) {
            var body;
            if (token === 13 /* OpenBraceToken */) {
                body = parseBody(false);
            }
            else if (isStatement(true) && !isStartOfExpressionStatement() && token !== 81 /* FunctionKeyword */) {
                // Check if we got a plain statement (i.e. no expression-statements, no functions expressions/declarations)
                //
                // Here we try to recover from a potential error situation in the case where the 
                // user meant to supply a block. For example, if the user wrote:
                //
                //  a =>
                //      var v = 0;
                //  }
                //
                // they may be missing an open brace.  Check to see if that's the case so we can
                // try to recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                //
                // Note: even when 'ignoreMissingOpenBrace' is passed as true, parseBody will still error.
                body = parseBody(true);
            }
            else {
                body = parseAssignmentExpression(noIn);
            }
            return makeFunctionExpression(150 /* ArrowFunction */, pos, undefined, sig, body);
        }
        function isAssignmentOperator() {
            return token >= 51 /* FirstAssignment */ && token <= 62 /* LastAssignment */;
        }
        function parseConditionalExpression(noIn) {
            var expr = parseBinaryExpression(noIn);
            while (parseOptional(49 /* QuestionToken */)) {
                var node = createNode(154 /* ConditionalExpression */, expr.pos);
                node.condition = expr;
                node.whenTrue = parseAssignmentExpression(false);
                parseExpected(50 /* ColonToken */);
                node.whenFalse = parseAssignmentExpression(noIn);
                expr = finishNode(node);
            }
            return expr;
        }
        function parseBinaryExpression(noIn) {
            return parseBinaryOperators(parseUnaryExpression(), 0, noIn);
        }
        function parseBinaryOperators(expr, minPrecedence, noIn) {
            while (true) {
                reScanGreaterToken();
                var precedence = getOperatorPrecedence();
                if (precedence && precedence > minPrecedence && (!noIn || token !== 84 /* InKeyword */)) {
                    var operator = token;
                    nextToken();
                    expr = makeBinaryExpression(expr, operator, parseBinaryOperators(parseUnaryExpression(), precedence, noIn));
                    continue;
                }
                return expr;
            }
        }
        function getOperatorPrecedence() {
            switch (token) {
                case 48 /* BarBarToken */:
                    return 1;
                case 47 /* AmpersandAmpersandToken */:
                    return 2;
                case 43 /* BarToken */:
                    return 3;
                case 44 /* CaretToken */:
                    return 4;
                case 42 /* AmpersandToken */:
                    return 5;
                case 27 /* EqualsEqualsToken */:
                case 28 /* ExclamationEqualsToken */:
                case 29 /* EqualsEqualsEqualsToken */:
                case 30 /* ExclamationEqualsEqualsToken */:
                    return 6;
                case 23 /* LessThanToken */:
                case 24 /* GreaterThanToken */:
                case 25 /* LessThanEqualsToken */:
                case 26 /* GreaterThanEqualsToken */:
                case 85 /* InstanceOfKeyword */:
                case 84 /* InKeyword */:
                    return 7;
                case 39 /* LessThanLessThanToken */:
                case 40 /* GreaterThanGreaterThanToken */:
                case 41 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 8;
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                    return 9;
                case 34 /* AsteriskToken */:
                case 35 /* SlashToken */:
                case 36 /* PercentToken */:
                    return 10;
            }
            return undefined;
        }
        function makeBinaryExpression(left, operator, right) {
            var node = createNode(153 /* BinaryExpression */, left.pos);
            node.left = left;
            node.operator = operator;
            node.right = right;
            return finishNode(node);
        }
        function parseUnaryExpression() {
            var pos = getNodePos();
            switch (token) {
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                case 46 /* TildeToken */:
                case 45 /* ExclamationToken */:
                case 72 /* DeleteKeyword */:
                case 95 /* TypeOfKeyword */:
                case 97 /* VoidKeyword */:
                case 37 /* PlusPlusToken */:
                case 38 /* MinusMinusToken */:
                    var operator = token;
                    nextToken();
                    var operand = parseUnaryExpression();
                    if (isInStrictMode) {
                        // The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                        // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression 
                        // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator
                        if ((operator === 37 /* PlusPlusToken */ || operator === 38 /* MinusMinusToken */) && isEvalOrArgumentsIdentifier(operand)) {
                            reportInvalidUseInStrictMode(operand);
                        }
                        else if (operator === 72 /* DeleteKeyword */ && operand.kind === 63 /* Identifier */) {
                            // When a delete operator occurs within strict mode code, a SyntaxError is thrown if its 
                            // UnaryExpression is a direct reference to a variable, function argument, or function name
                            grammarErrorOnNode(operand, ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                        }
                    }
                    return makeUnaryExpression(151 /* PrefixOperator */, pos, operator, operand);
                case 23 /* LessThanToken */:
                    return parseTypeAssertion();
            }
            var primaryExpression = parsePrimaryExpression();
            // TS 1.0 spec (2014): 4.8
            // CallExpression:  ( Modified )
            //  super   (   ArgumentListopt   )
            //  super   .   IdentifierName
            var illegalUsageOfSuperKeyword = primaryExpression.kind === 89 /* SuperKeyword */ && token !== 15 /* OpenParenToken */ && token !== 19 /* DotToken */;
            if (illegalUsageOfSuperKeyword) {
                error(ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            }
            var expr = parseCallAndAccess(primaryExpression, false);
            ts.Debug.assert(isLeftHandSideExpression(expr));
            if ((token === 37 /* PlusPlusToken */ || token === 38 /* MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {
                // The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression 
                // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator. 
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                expr = makeUnaryExpression(152 /* PostfixOperator */, expr.pos, operator, expr);
            }
            return expr;
        }
        function parseTypeAssertion() {
            var node = createNode(147 /* TypeAssertion */);
            parseExpected(23 /* LessThanToken */);
            node.type = parseType();
            parseExpected(24 /* GreaterThanToken */);
            node.operand = parseUnaryExpression();
            return finishNode(node);
        }
        function makeUnaryExpression(kind, pos, operator, operand) {
            var node = createNode(kind, pos);
            node.operator = operator;
            node.operand = operand;
            return finishNode(node);
        }
        function parseCallAndAccess(expr, inNewExpression) {
            while (true) {
                var dotOrBracketStart = scanner.getTokenPos();
                if (parseOptional(19 /* DotToken */)) {
                    var propertyAccess = createNode(142 /* PropertyAccess */, expr.pos);
                    // Technically a keyword is valid here as all keywords are identifier names.
                    // However, often we'll encounter this in error situations when the keyword
                    // is actually starting another valid construct.
                    //
                    // So, we check for the following specific case:
                    //
                    //      name.
                    //      keyword identifierNameOrKeyword
                    //
                    // Note: the newlines are important here.  For example, if that above code 
                    // were rewritten into:
                    //
                    //      name.keyword
                    //      identifierNameOrKeyword
                    //
                    // Then we would consider it valid.  That's because ASI would take effect and
                    // the code would be implicitly: "name.keyword; identifierNameOrKeyword".  
                    // In the first case though, ASI will not take effect because there is not a
                    // line terminator after the keyword.
                    if (scanner.hasPrecedingLineBreak() && scanner.isReservedWord() && lookAhead(function () { return scanner.isReservedWord(); })) {
                        grammarErrorAtPos(dotOrBracketStart, scanner.getStartPos() - dotOrBracketStart, ts.Diagnostics.Identifier_expected);
                        var id = createMissingNode();
                    }
                    else {
                        var id = parseIdentifierName();
                    }
                    propertyAccess.left = expr;
                    propertyAccess.right = id;
                    expr = finishNode(propertyAccess);
                    continue;
                }
                if (parseOptional(17 /* OpenBracketToken */)) {
                    var indexedAccess = createNode(143 /* IndexedAccess */, expr.pos);
                    indexedAccess.object = expr;
                    // It's not uncommon for a user to write: "new Type[]".
                    // Check for that common pattern and report a better error message.
                    if (inNewExpression && parseOptional(18 /* CloseBracketToken */)) {
                        indexedAccess.index = createMissingNode();
                        grammarErrorAtPos(dotOrBracketStart, scanner.getStartPos() - dotOrBracketStart, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                    }
                    else {
                        indexedAccess.index = parseExpression();
                        if (indexedAccess.index.kind === 7 /* StringLiteral */ || indexedAccess.index.kind === 6 /* NumericLiteral */) {
                            var literal = indexedAccess.index;
                            literal.text = internIdentifier(literal.text);
                        }
                        parseExpected(18 /* CloseBracketToken */);
                    }
                    expr = finishNode(indexedAccess);
                    continue;
                }
                // Try to parse a Call Expression unless we are in a New Expression.
                // If we are parsing a New Expression, then parentheses are optional, 
                // and is taken care of by the 'parseNewExpression' caller.
                if ((token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) && !inNewExpression) {
                    var callExpr = createNode(144 /* CallExpression */, expr.pos);
                    callExpr.func = expr;
                    if (token === 23 /* LessThanToken */) {
                        if (!(callExpr.typeArguments = tryParse(parseTypeArgumentsAndOpenParen)))
                            return expr;
                    }
                    else {
                        parseExpected(15 /* OpenParenToken */);
                    }
                    callExpr.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseArgumentExpression, false);
                    parseExpected(16 /* CloseParenToken */);
                    expr = finishNode(callExpr);
                    continue;
                }
                if (token === 9 /* NoSubstitutionTemplateLiteral */ || token === 10 /* TemplateHead */) {
                    var tagExpression = createNode(146 /* TaggedTemplateExpression */, expr.pos);
                    tagExpression.tag = expr;
                    tagExpression.template = token === 9 /* NoSubstitutionTemplateLiteral */ ? parseLiteralNode() : parseTemplateExpression();
                    expr = finishNode(tagExpression);
                    if (languageVersion < 2 /* ES6 */) {
                        grammarErrorOnNode(expr, ts.Diagnostics.Tagged_templates_are_only_available_when_targeting_ECMAScript_6_and_higher);
                    }
                    continue;
                }
                return expr;
            }
        }
        function parseTypeArgumentsAndOpenParen() {
            var result = parseTypeArguments();
            parseExpected(15 /* OpenParenToken */);
            return result;
        }
        function parseTypeArguments() {
            var typeArgumentListStart = scanner.getTokenPos();
            var errorCountBeforeTypeParameterList = file.syntacticErrors.length;
            // We pass parseSingleTypeArgument instead of parseType as the element parser
            // because parseSingleTypeArgument knows how to parse a missing type argument.
            // This is useful for signature help. parseType has the disadvantage that when
            // it sees a missing type, it changes the LookAheadMode to Error, and the result
            // is a broken binary expression, which breaks signature help.
            var result = parseBracketedList(15 /* TypeArguments */, parseSingleTypeArgument, 23 /* LessThanToken */, 24 /* GreaterThanToken */);
            if (!result.length && file.syntacticErrors.length === errorCountBeforeTypeParameterList) {
                grammarErrorAtPos(typeArgumentListStart, scanner.getStartPos() - typeArgumentListStart, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
            return result;
        }
        function parseSingleTypeArgument() {
            if (token === 22 /* CommaToken */) {
                var errorStart = scanner.getTokenPos();
                var errorLength = scanner.getTextPos() - errorStart;
                grammarErrorAtPos(errorStart, errorLength, ts.Diagnostics.Type_expected);
                return createNode(120 /* Missing */);
            }
            return parseType();
        }
        function parsePrimaryExpression() {
            switch (token) {
                case 91 /* ThisKeyword */:
                case 89 /* SuperKeyword */:
                case 87 /* NullKeyword */:
                case 93 /* TrueKeyword */:
                case 78 /* FalseKeyword */:
                    return parseTokenNode();
                case 6 /* NumericLiteral */:
                case 7 /* StringLiteral */:
                case 9 /* NoSubstitutionTemplateLiteral */:
                    return parseLiteralNode();
                case 15 /* OpenParenToken */:
                    return parseParenExpression();
                case 17 /* OpenBracketToken */:
                    return parseArrayLiteral();
                case 13 /* OpenBraceToken */:
                    return parseObjectLiteral();
                case 81 /* FunctionKeyword */:
                    return parseFunctionExpression();
                case 86 /* NewKeyword */:
                    return parseNewExpression();
                case 35 /* SlashToken */:
                case 55 /* SlashEqualsToken */:
                    if (reScanSlashToken() === 8 /* RegularExpressionLiteral */) {
                        return parseLiteralNode();
                    }
                    break;
                case 10 /* TemplateHead */:
                    return parseTemplateExpression();
                default:
                    if (isIdentifier()) {
                        return parseIdentifier();
                    }
            }
            error(ts.Diagnostics.Expression_expected);
            return createMissingNode();
        }
        function parseParenExpression() {
            var node = createNode(148 /* ParenExpression */);
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            return finishNode(node);
        }
        function parseAssignmentExpressionOrOmittedExpression(omittedExpressionDiagnostic) {
            if (token === 22 /* CommaToken */) {
                if (omittedExpressionDiagnostic) {
                    var errorStart = scanner.getTokenPos();
                    var errorLength = scanner.getTextPos() - errorStart;
                    grammarErrorAtPos(errorStart, errorLength, omittedExpressionDiagnostic);
                }
                return createNode(157 /* OmittedExpression */);
            }
            return parseAssignmentExpression();
        }
        function parseArrayLiteralElement() {
            return parseAssignmentExpressionOrOmittedExpression(undefined);
        }
        function parseArgumentExpression() {
            return parseAssignmentExpressionOrOmittedExpression(ts.Diagnostics.Argument_expression_expected);
        }
        function parseArrayLiteral() {
            var node = createNode(139 /* ArrayLiteral */);
            parseExpected(17 /* OpenBracketToken */);
            if (scanner.hasPrecedingLineBreak())
                node.flags |= 256 /* MultiLine */;
            node.elements = parseDelimitedList(12 /* ArrayLiteralMembers */, parseArrayLiteralElement, true);
            parseExpected(18 /* CloseBracketToken */);
            return finishNode(node);
        }
        function parsePropertyAssignment() {
            var node = createNode(141 /* PropertyAssignment */);
            node.name = parsePropertyName();
            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {
                var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
                var body = parseBody(false);
                // do not propagate property name as name for function expression
                // for scenarios like 
                // var x = 1;
                // var y = { x() { } } 
                // otherwise this will bring y.x into the scope of x which is incorrect
                node.initializer = makeFunctionExpression(149 /* FunctionExpression */, node.pos, undefined, sig, body);
            }
            else {
                parseExpected(50 /* ColonToken */);
                node.initializer = parseAssignmentExpression(false);
            }
            return finishNode(node);
        }
        function parseObjectLiteralMember() {
            var initialPos = getNodePos();
            var initialToken = token;
            if (parseContextualModifier(113 /* GetKeyword */) || parseContextualModifier(117 /* SetKeyword */)) {
                var kind = initialToken === 113 /* GetKeyword */ ? 127 /* GetAccessor */ : 128 /* SetAccessor */;
                return parseAndCheckMemberAccessorDeclaration(kind, initialPos, 0);
            }
            return parsePropertyAssignment();
        }
        function parseObjectLiteral() {
            var node = createNode(140 /* ObjectLiteral */);
            parseExpected(13 /* OpenBraceToken */);
            if (scanner.hasPrecedingLineBreak()) {
                node.flags |= 256 /* MultiLine */;
            }
            node.properties = parseDelimitedList(11 /* ObjectLiteralMembers */, parseObjectLiteralMember, true);
            parseExpected(14 /* CloseBraceToken */);
            var seen = {};
            var Property = 1;
            var GetAccessor = 2;
            var SetAccesor = 4;
            var GetOrSetAccessor = GetAccessor | SetAccesor;
            ts.forEach(node.properties, function (p) {
                // TODO(jfreeman): continue if we have a computed property
                if (p.kind === 157 /* OmittedExpression */) {
                    return;
                }
                var name = p.name;
                // ECMA-262 11.1.5 Object Initialiser 
                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and 
                // IsDataDescriptor(propId.descriptor) is true.
                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true 
                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields 
                var currentKind;
                if (p.kind === 141 /* PropertyAssignment */) {
                    currentKind = Property;
                }
                else if (p.kind === 127 /* GetAccessor */) {
                    currentKind = GetAccessor;
                }
                else if (p.kind === 128 /* SetAccessor */) {
                    currentKind = SetAccesor;
                }
                else {
                    ts.Debug.fail("Unexpected syntax kind:" + p.kind);
                }
                if (!ts.hasProperty(seen, name.text)) {
                    seen[name.text] = currentKind;
                }
                else {
                    var existingKind = seen[name.text];
                    if (currentKind === Property && existingKind === Property) {
                        if (isInStrictMode) {
                            grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode);
                        }
                    }
                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {
                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {
                            seen[name.text] = currentKind | existingKind;
                        }
                        else {
                            grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else {
                        grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            });
            return finishNode(node);
        }
        function parseFunctionExpression() {
            var pos = getNodePos();
            parseExpected(81 /* FunctionKeyword */);
            var name = isIdentifier() ? parseIdentifier() : undefined;
            var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
            var body = parseBody(false);
            if (name && isInStrictMode && isEvalOrArgumentsIdentifier(name)) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the 
                // Identifier of a FunctionLikeDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(name);
            }
            return makeFunctionExpression(149 /* FunctionExpression */, pos, name, sig, body);
        }
        function makeFunctionExpression(kind, pos, name, sig, body) {
            var node = createNode(kind, pos);
            node.name = name;
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = body;
            return finishNode(node);
        }
        function parseNewExpression() {
            var node = createNode(145 /* NewExpression */);
            parseExpected(86 /* NewKeyword */);
            node.func = parseCallAndAccess(parsePrimaryExpression(), true);
            if (parseOptional(15 /* OpenParenToken */) || token === 23 /* LessThanToken */ && (node.typeArguments = tryParse(parseTypeArgumentsAndOpenParen))) {
                node.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseArgumentExpression, false);
                parseExpected(16 /* CloseParenToken */);
            }
            return finishNode(node);
        }
        // STATEMENTS
        function parseStatementAllowingLetDeclaration() {
            return parseStatement(true);
        }
        function parseBlock(ignoreMissingOpenBrace, checkForStrictMode) {
            var node = createNode(158 /* Block */);
            if (parseExpected(13 /* OpenBraceToken */) || ignoreMissingOpenBrace) {
                node.statements = parseList(2 /* BlockStatements */, checkForStrictMode, parseStatementAllowingLetDeclaration);
                parseExpected(14 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseBody(ignoreMissingOpenBrace) {
            var saveInFunctionBody = inFunctionBody;
            var saveInSwitchStatement = inSwitchStatement;
            var saveInIterationStatement = inIterationStatement;
            inFunctionBody = true;
            if (inSwitchStatement === 1 /* Nested */) {
                inSwitchStatement = 2 /* CrossingFunctionBoundary */;
            }
            if (inIterationStatement === 1 /* Nested */) {
                inIterationStatement = 2 /* CrossingFunctionBoundary */;
            }
            labelledStatementInfo.pushFunctionBoundary();
            var block = parseBlock(ignoreMissingOpenBrace, true);
            block.kind = 183 /* FunctionBlock */;
            labelledStatementInfo.pop();
            inFunctionBody = saveInFunctionBody;
            inSwitchStatement = saveInSwitchStatement;
            inIterationStatement = saveInIterationStatement;
            return block;
        }
        function parseEmptyStatement() {
            var node = createNode(160 /* EmptyStatement */);
            parseExpected(21 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseIfStatement() {
            var node = createNode(162 /* IfStatement */);
            parseExpected(82 /* IfKeyword */);
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            node.thenStatement = parseStatement(false);
            node.elseStatement = parseOptional(74 /* ElseKeyword */) ? parseStatement(false) : undefined;
            return finishNode(node);
        }
        function parseDoStatement() {
            var node = createNode(163 /* DoStatement */);
            parseExpected(73 /* DoKeyword */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement(false);
            inIterationStatement = saveInIterationStatement;
            parseExpected(98 /* WhileKeyword */);
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            parseOptional(21 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseWhileStatement() {
            var node = createNode(164 /* WhileStatement */);
            parseExpected(98 /* WhileKeyword */);
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement(false);
            inIterationStatement = saveInIterationStatement;
            return finishNode(node);
        }
        function parseForOrForInStatement() {
            var pos = getNodePos();
            parseExpected(80 /* ForKeyword */);
            parseExpected(15 /* OpenParenToken */);
            if (token !== 21 /* SemicolonToken */) {
                if (parseOptional(96 /* VarKeyword */)) {
                    var declarations = parseVariableDeclarationList(0, true);
                    if (!declarations.length) {
                        error(ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
                    }
                }
                else if (parseOptional(102 /* LetKeyword */)) {
                    var declarations = parseVariableDeclarationList(2048 /* Let */, true);
                    if (!declarations.length) {
                        error(ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
                    }
                    if (languageVersion < 2 /* ES6 */) {
                        grammarErrorAtPos(declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.let_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);
                    }
                }
                else if (parseOptional(68 /* ConstKeyword */)) {
                    var declarations = parseVariableDeclarationList(4096 /* Const */, true);
                    if (!declarations.length) {
                        error(ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
                    }
                    if (languageVersion < 2 /* ES6 */) {
                        grammarErrorAtPos(declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.const_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);
                    }
                }
                else {
                    var varOrInit = parseExpression(true);
                }
            }
            var forOrForInStatement;
            if (parseOptional(84 /* InKeyword */)) {
                var forInStatement = createNode(166 /* ForInStatement */, pos);
                if (declarations) {
                    if (declarations.length > 1) {
                        error(ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                    }
                    forInStatement.declaration = declarations[0];
                }
                else {
                    forInStatement.variable = varOrInit;
                }
                forInStatement.expression = parseExpression();
                parseExpected(16 /* CloseParenToken */);
                forOrForInStatement = forInStatement;
            }
            else {
                var forStatement = createNode(165 /* ForStatement */, pos);
                if (declarations)
                    forStatement.declarations = declarations;
                if (varOrInit)
                    forStatement.initializer = varOrInit;
                parseExpected(21 /* SemicolonToken */);
                if (token !== 21 /* SemicolonToken */ && token !== 16 /* CloseParenToken */) {
                    forStatement.condition = parseExpression();
                }
                parseExpected(21 /* SemicolonToken */);
                if (token !== 16 /* CloseParenToken */) {
                    forStatement.iterator = parseExpression();
                }
                parseExpected(16 /* CloseParenToken */);
                forOrForInStatement = forStatement;
            }
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            forOrForInStatement.statement = parseStatement(false);
            inIterationStatement = saveInIterationStatement;
            return finishNode(forOrForInStatement);
        }
        function parseBreakOrContinueStatement(kind) {
            var node = createNode(kind);
            var errorCountBeforeStatement = file.syntacticErrors.length;
            parseExpected(kind === 168 /* BreakStatement */ ? 64 /* BreakKeyword */ : 69 /* ContinueKeyword */);
            if (!canParseSemicolon())
                node.label = parseIdentifier();
            parseSemicolon();
            finishNode(node);
            // In an ambient context, we will already give an error for having a statement.
            if (!inAmbientContext && errorCountBeforeStatement === file.syntacticErrors.length) {
                if (node.label) {
                    checkBreakOrContinueStatementWithLabel(node);
                }
                else {
                    checkBareBreakOrContinueStatement(node);
                }
            }
            return node;
        }
        function checkBareBreakOrContinueStatement(node) {
            if (node.kind === 168 /* BreakStatement */) {
                if (inIterationStatement === 1 /* Nested */ || inSwitchStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */ && inSwitchStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                    return;
                }
            }
            else if (node.kind === 167 /* ContinueStatement */) {
                if (inIterationStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                    return;
                }
            }
            else {
                ts.Debug.fail("checkAnonymousBreakOrContinueStatement");
            }
            ts.Debug.assert(inIterationStatement === 2 /* CrossingFunctionBoundary */ || inSwitchStatement === 2 /* CrossingFunctionBoundary */);
            grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
        }
        function checkBreakOrContinueStatementWithLabel(node) {
            // For error specificity, if the label is not found, we want to distinguish whether it is because
            // it crossed a function boundary or it was simply not found. To do this, we pass false for
            // stopAtFunctionBoundary.
            var nodeIsNestedInLabel = labelledStatementInfo.nodeIsNestedInLabel(node.label, node.kind === 167 /* ContinueStatement */, false);
            if (nodeIsNestedInLabel === 1 /* Nested */) {
                return;
            }
            if (nodeIsNestedInLabel === 2 /* CrossingFunctionBoundary */) {
                grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                return;
            }
            // It is NotNested
            if (node.kind === 167 /* ContinueStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
            }
            else if (node.kind === 168 /* BreakStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement);
            }
            else {
                ts.Debug.fail("checkBreakOrContinueStatementWithLabel");
            }
        }
        function parseReturnStatement() {
            var node = createNode(169 /* ReturnStatement */);
            var errorCountBeforeReturnStatement = file.syntacticErrors.length;
            var returnTokenStart = scanner.getTokenPos();
            var returnTokenLength = scanner.getTextPos() - returnTokenStart;
            parseExpected(88 /* ReturnKeyword */);
            if (!canParseSemicolon())
                node.expression = parseExpression();
            parseSemicolon();
            // In an ambient context, we will already give an error for having a statement.
            if (!inFunctionBody && !inAmbientContext && errorCountBeforeReturnStatement === file.syntacticErrors.length) {
                grammarErrorAtPos(returnTokenStart, returnTokenLength, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            }
            return finishNode(node);
        }
        function parseWithStatement() {
            var node = createNode(170 /* WithStatement */);
            var startPos = scanner.getTokenPos();
            parseExpected(99 /* WithKeyword */);
            var endPos = scanner.getStartPos();
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            node.statement = parseStatement(false);
            node = finishNode(node);
            if (isInStrictMode) {
                // Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such 
                // a context is an 
                grammarErrorAtPos(startPos, endPos - startPos, ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode);
            }
            return node;
        }
        function parseCaseClause() {
            var node = createNode(172 /* CaseClause */);
            parseExpected(65 /* CaseKeyword */);
            node.expression = parseExpression();
            parseExpected(50 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatementAllowingLetDeclaration);
            return finishNode(node);
        }
        function parseDefaultClause() {
            var node = createNode(173 /* DefaultClause */);
            parseExpected(71 /* DefaultKeyword */);
            parseExpected(50 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatementAllowingLetDeclaration);
            return finishNode(node);
        }
        function parseCaseOrDefaultClause() {
            return token === 65 /* CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
        }
        function parseSwitchStatement() {
            var node = createNode(171 /* SwitchStatement */);
            parseExpected(90 /* SwitchKeyword */);
            parseExpected(15 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(16 /* CloseParenToken */);
            parseExpected(13 /* OpenBraceToken */);
            var saveInSwitchStatement = inSwitchStatement;
            inSwitchStatement = 1 /* Nested */;
            node.clauses = parseList(3 /* SwitchClauses */, false, parseCaseOrDefaultClause);
            inSwitchStatement = saveInSwitchStatement;
            parseExpected(14 /* CloseBraceToken */);
            // Error on duplicate 'default' clauses.
            var defaultClauses = ts.filter(node.clauses, function (clause) { return clause.kind === 173 /* DefaultClause */; });
            for (var i = 1, n = defaultClauses.length; i < n; i++) {
                var clause = defaultClauses[i];
                var start = ts.skipTrivia(file.text, clause.pos);
                var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;
                grammarErrorAtPos(start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
            }
            return finishNode(node);
        }
        function parseThrowStatement() {
            var node = createNode(175 /* ThrowStatement */);
            parseExpected(92 /* ThrowKeyword */);
            if (scanner.hasPrecedingLineBreak()) {
                error(ts.Diagnostics.Line_break_not_permitted_here);
            }
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        // TODO: Review for error recovery
        function parseTryStatement() {
            var node = createNode(176 /* TryStatement */);
            node.tryBlock = parseTokenAndBlock(94 /* TryKeyword */, 177 /* TryBlock */);
            if (token === 66 /* CatchKeyword */) {
                node.catchBlock = parseCatchBlock();
            }
            if (token === 79 /* FinallyKeyword */) {
                node.finallyBlock = parseTokenAndBlock(79 /* FinallyKeyword */, 179 /* FinallyBlock */);
            }
            if (!(node.catchBlock || node.finallyBlock)) {
                error(ts.Diagnostics.catch_or_finally_expected);
            }
            return finishNode(node);
        }
        function parseTokenAndBlock(token, kind) {
            var pos = getNodePos();
            parseExpected(token);
            var result = parseBlock(false, false);
            result.kind = kind;
            result.pos = pos;
            return result;
        }
        function parseCatchBlock() {
            var pos = getNodePos();
            parseExpected(66 /* CatchKeyword */);
            parseExpected(15 /* OpenParenToken */);
            var variable = parseIdentifier();
            var typeAnnotationColonStart = scanner.getTokenPos();
            var typeAnnotationColonLength = scanner.getTextPos() - typeAnnotationColonStart;
            var typeAnnotation = parseTypeAnnotation();
            parseExpected(16 /* CloseParenToken */);
            var result = parseBlock(false, false);
            result.kind = 178 /* CatchBlock */;
            result.pos = pos;
            result.variable = variable;
            if (typeAnnotation) {
                errorAtPos(typeAnnotationColonStart, typeAnnotationColonLength, ts.Diagnostics.Catch_clause_parameter_cannot_have_a_type_annotation);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(variable)) {
                // It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the 
                // Catch production is eval or arguments
                reportInvalidUseInStrictMode(variable);
            }
            return result;
        }
        function parseDebuggerStatement() {
            var node = createNode(180 /* DebuggerStatement */);
            parseExpected(70 /* DebuggerKeyword */);
            parseSemicolon();
            return finishNode(node);
        }
        function isIterationStatementStart() {
            return token === 98 /* WhileKeyword */ || token === 73 /* DoKeyword */ || token === 80 /* ForKeyword */;
        }
        function parseStatementWithLabelSet(allowLetAndConstDeclarations) {
            labelledStatementInfo.pushCurrentLabelSet(isIterationStatementStart());
            var statement = parseStatement(allowLetAndConstDeclarations);
            labelledStatementInfo.pop();
            return statement;
        }
        function isLabel() {
            return isIdentifier() && lookAhead(function () { return nextToken() === 50 /* ColonToken */; });
        }
        function parseLabeledStatement(allowLetAndConstDeclarations) {
            var node = createNode(174 /* LabeledStatement */);
            node.label = parseIdentifier();
            parseExpected(50 /* ColonToken */);
            if (labelledStatementInfo.nodeIsNestedInLabel(node.label, false, true)) {
                grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, getTextOfNodeFromSourceText(sourceText, node.label));
            }
            labelledStatementInfo.addLabel(node.label);
            // We only want to call parseStatementWithLabelSet when the label set is complete
            // Therefore, keep parsing labels until we know we're done.
            node.statement = isLabel() ? parseLabeledStatement(allowLetAndConstDeclarations) : parseStatementWithLabelSet(allowLetAndConstDeclarations);
            return finishNode(node);
        }
        function parseExpressionStatement() {
            var node = createNode(161 /* ExpressionStatement */);
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        function isStatement(inErrorRecovery) {
            switch (token) {
                case 21 /* SemicolonToken */:
                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                    // The problem is that ';' can show up in far too many contexts, and if we see one
                    // and assume it's a statement, then we may bail out inappropriately from whatever
                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                    // we really don't want to assume the class is over and we're on a statement in the
                    // outer module.  We just want to consume and move on.
                    return !inErrorRecovery;
                case 13 /* OpenBraceToken */:
                case 96 /* VarKeyword */:
                case 102 /* LetKeyword */:
                case 81 /* FunctionKeyword */:
                case 82 /* IfKeyword */:
                case 73 /* DoKeyword */:
                case 98 /* WhileKeyword */:
                case 80 /* ForKeyword */:
                case 69 /* ContinueKeyword */:
                case 64 /* BreakKeyword */:
                case 88 /* ReturnKeyword */:
                case 99 /* WithKeyword */:
                case 90 /* SwitchKeyword */:
                case 92 /* ThrowKeyword */:
                case 94 /* TryKeyword */:
                case 70 /* DebuggerKeyword */:
                case 66 /* CatchKeyword */:
                case 79 /* FinallyKeyword */:
                    return true;
                case 68 /* ConstKeyword */:
                    // const keyword can precede enum keyword when defining constant enums
                    // 'const enum' do not start statement.
                    // In ES 6 'enum' is a future reserved keyword, so it should not be used as identifier
                    var isConstEnum = lookAhead(function () { return nextToken() === 75 /* EnumKeyword */; });
                    return !isConstEnum;
                case 101 /* InterfaceKeyword */:
                case 67 /* ClassKeyword */:
                case 114 /* ModuleKeyword */:
                case 75 /* EnumKeyword */:
                case 119 /* TypeKeyword */:
                    // When followed by an identifier, these do not start a statement but might
                    // instead be following declarations
                    if (isDeclarationStart()) {
                        return false;
                    }
                case 106 /* PublicKeyword */:
                case 104 /* PrivateKeyword */:
                case 105 /* ProtectedKeyword */:
                case 107 /* StaticKeyword */:
                    // When followed by an identifier or keyword, these do not start a statement but
                    // might instead be following type members
                    if (lookAhead(function () { return nextToken() >= 63 /* Identifier */; })) {
                        return false;
                    }
                default:
                    return isStartOfExpression();
            }
        }
        function parseStatement(allowLetAndConstDeclarations) {
            switch (token) {
                case 13 /* OpenBraceToken */:
                    return parseBlock(false, false);
                case 96 /* VarKeyword */:
                case 102 /* LetKeyword */:
                case 68 /* ConstKeyword */:
                    // const here should always be parsed as const declaration because of check in 'isStatement' 
                    return parseVariableStatement(allowLetAndConstDeclarations);
                case 81 /* FunctionKeyword */:
                    return parseFunctionDeclaration();
                case 21 /* SemicolonToken */:
                    return parseEmptyStatement();
                case 82 /* IfKeyword */:
                    return parseIfStatement();
                case 73 /* DoKeyword */:
                    return parseDoStatement();
                case 98 /* WhileKeyword */:
                    return parseWhileStatement();
                case 80 /* ForKeyword */:
                    return parseForOrForInStatement();
                case 69 /* ContinueKeyword */:
                    return parseBreakOrContinueStatement(167 /* ContinueStatement */);
                case 64 /* BreakKeyword */:
                    return parseBreakOrContinueStatement(168 /* BreakStatement */);
                case 88 /* ReturnKeyword */:
                    return parseReturnStatement();
                case 99 /* WithKeyword */:
                    return parseWithStatement();
                case 90 /* SwitchKeyword */:
                    return parseSwitchStatement();
                case 92 /* ThrowKeyword */:
                    return parseThrowStatement();
                case 94 /* TryKeyword */:
                case 66 /* CatchKeyword */:
                case 79 /* FinallyKeyword */:
                    return parseTryStatement();
                case 70 /* DebuggerKeyword */:
                    return parseDebuggerStatement();
                default:
                    if (isLabel()) {
                        return parseLabeledStatement(allowLetAndConstDeclarations);
                    }
                    return parseExpressionStatement();
            }
        }
        function parseAndCheckFunctionBody(isConstructor) {
            var initialPosition = scanner.getTokenPos();
            var errorCountBeforeBody = file.syntacticErrors.length;
            if (token === 13 /* OpenBraceToken */) {
                var body = parseBody(false);
                if (body && inAmbientContext && file.syntacticErrors.length === errorCountBeforeBody) {
                    var diagnostic = isConstructor ? ts.Diagnostics.A_constructor_implementation_cannot_be_declared_in_an_ambient_context : ts.Diagnostics.A_function_implementation_cannot_be_declared_in_an_ambient_context;
                    grammarErrorAtPos(initialPosition, 1, diagnostic);
                }
                return body;
            }
            if (canParseSemicolon()) {
                parseSemicolon();
                return undefined;
            }
            error(ts.Diagnostics.Block_or_expected); // block or ';' expected
        }
        // DECLARATIONS
        function parseVariableDeclaration(flags, noIn) {
            var node = createNode(181 /* VariableDeclaration */);
            node.flags = flags;
            var errorCountBeforeVariableDeclaration = file.syntacticErrors.length;
            node.name = parseIdentifier();
            node.type = parseTypeAnnotation();
            // Issue any initializer-related errors on the equals token
            var initializerStart = scanner.getTokenPos();
            var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
            node.initializer = parseInitializer(false, noIn);
            if (inAmbientContext && node.initializer && errorCountBeforeVariableDeclaration === file.syntacticErrors.length) {
                grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
            if (!inAmbientContext && !node.initializer && flags & 4096 /* Const */) {
                grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {
                // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code 
                // and its Identifier is eval or arguments 
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseVariableDeclarationList(flags, noIn) {
            return parseDelimitedList(9 /* VariableDeclarations */, function () { return parseVariableDeclaration(flags, noIn); }, false);
        }
        function parseVariableStatement(allowLetAndConstDeclarations, pos, flags) {
            var node = createNode(159 /* VariableStatement */, pos);
            if (flags)
                node.flags = flags;
            var errorCountBeforeVarStatement = file.syntacticErrors.length;
            if (token === 102 /* LetKeyword */) {
                node.flags |= 2048 /* Let */;
            }
            else if (token === 68 /* ConstKeyword */) {
                node.flags |= 4096 /* Const */;
            }
            else if (token !== 96 /* VarKeyword */) {
                error(ts.Diagnostics.var_let_or_const_expected);
            }
            nextToken();
            node.declarations = parseVariableDeclarationList(node.flags, false);
            parseSemicolon();
            finishNode(node);
            if (!node.declarations.length && file.syntacticErrors.length === errorCountBeforeVarStatement) {
                grammarErrorOnNode(node, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
            if (languageVersion < 2 /* ES6 */) {
                if (node.flags & 2048 /* Let */) {
                    grammarErrorOnNode(node, ts.Diagnostics.let_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);
                }
                else if (node.flags & 4096 /* Const */) {
                    grammarErrorOnNode(node, ts.Diagnostics.const_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);
                }
            }
            else if (!allowLetAndConstDeclarations) {
                if (node.flags & 2048 /* Let */) {
                    grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);
                }
                else if (node.flags & 4096 /* Const */) {
                    grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);
                }
            }
            return node;
        }
        function parseFunctionDeclaration(pos, flags) {
            var node = createNode(182 /* FunctionDeclaration */, pos);
            if (flags)
                node.flags = flags;
            parseExpected(81 /* FunctionKeyword */);
            node.name = parseIdentifier();
            var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(false);
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name) && node.name.kind === 63 /* Identifier */) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the 
                // Identifier of a FunctionLikeDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseConstructorDeclaration(pos, flags) {
            var node = createNode(126 /* Constructor */, pos);
            node.flags = flags;
            parseExpected(111 /* ConstructorKeyword */);
            var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(true);
            if (node.typeParameters) {
                grammarErrorAtPos(node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
            if (node.type) {
                grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
            return finishNode(node);
        }
        function parsePropertyMemberDeclaration(pos, flags) {
            var errorCountBeforePropertyDeclaration = file.syntacticErrors.length;
            var name = parsePropertyName();
            var questionStart = scanner.getTokenPos();
            if (parseOptional(49 /* QuestionToken */)) {
                errorAtPos(questionStart, scanner.getStartPos() - questionStart, ts.Diagnostics.A_class_member_cannot_be_declared_optional);
            }
            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {
                var method = createNode(125 /* Method */, pos);
                method.flags = flags;
                method.name = name;
                var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
                method.typeParameters = sig.typeParameters;
                method.parameters = sig.parameters;
                method.type = sig.type;
                method.body = parseAndCheckFunctionBody(false);
                return finishNode(method);
            }
            else {
                var property = createNode(124 /* Property */, pos);
                property.flags = flags;
                property.name = name;
                property.type = parseTypeAnnotation();
                var initializerStart = scanner.getTokenPos();
                var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
                property.initializer = parseInitializer(false);
                parseSemicolon();
                if (inAmbientContext && property.initializer && errorCountBeforePropertyDeclaration === file.syntacticErrors.length) {
                    grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
                return finishNode(property);
            }
        }
        function parseAndCheckMemberAccessorDeclaration(kind, pos, flags) {
            var errorCountBeforeAccessor = file.syntacticErrors.length;
            var accessor = parseMemberAccessorDeclaration(kind, pos, flags);
            if (errorCountBeforeAccessor === file.syntacticErrors.length) {
                if (languageVersion < 1 /* ES5 */) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
                }
                else if (inAmbientContext) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);
                }
                else if (accessor.typeParameters) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
                }
                else if (kind === 127 /* GetAccessor */ && accessor.parameters.length) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.A_get_accessor_cannot_have_parameters);
                }
                else if (kind === 128 /* SetAccessor */) {
                    if (accessor.type) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                    }
                    else if (accessor.parameters.length !== 1) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
                    }
                    else {
                        var parameter = accessor.parameters[0];
                        if (parameter.flags & 8 /* Rest */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                        }
                        else if (parameter.flags & 243 /* Modifier */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                        }
                        else if (parameter.flags & 4 /* QuestionMark */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                        }
                        else if (parameter.initializer) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                        }
                    }
                }
            }
            return accessor;
        }
        function parseMemberAccessorDeclaration(kind, pos, flags) {
            var node = createNode(kind, pos);
            node.flags = flags;
            node.name = parsePropertyName();
            var sig = parseSignature(129 /* CallSignature */, 50 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            // A common error is to try to declare an accessor in an ambient class.
            if (inAmbientContext && canParseSemicolon()) {
                parseSemicolon();
                node.body = createMissingNode();
            }
            else {
                node.body = parseBody(false);
            }
            return finishNode(node);
        }
        function isClassMemberStart() {
            var idToken;
            while (isModifier(token)) {
                idToken = token;
                nextToken();
            }
            // Try to get the first property-like token following all modifiers.
            // This can either be an identifier or the 'get' or 'set' keywords.
            if (isPropertyName()) {
                idToken = token;
                nextToken();
            }
            // Index signatures are class members; we can parse.
            if (token === 17 /* OpenBracketToken */) {
                return true;
            }
            // If we were able to get any potential identifier...
            if (idToken !== undefined) {
                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
                if (!isKeyword(idToken) || idToken === 117 /* SetKeyword */ || idToken === 113 /* GetKeyword */) {
                    return true;
                }
                switch (token) {
                    case 15 /* OpenParenToken */:
                    case 23 /* LessThanToken */:
                    case 50 /* ColonToken */:
                    case 51 /* EqualsToken */:
                    case 49 /* QuestionToken */:
                        return true;
                    default:
                        // Covers
                        //  - Semicolons     (declaration termination)
                        //  - Closing braces (end-of-class, must be declaration)
                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)
                        //  - Line-breaks    (enabling *automatic semicolon insertion*)
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseAndCheckModifiers(context) {
            var flags = 0;
            var lastStaticModifierStart;
            var lastStaticModifierLength;
            var lastDeclareModifierStart;
            var lastDeclareModifierLength;
            var lastPrivateModifierStart;
            var lastPrivateModifierLength;
            var lastProtectedModifierStart;
            var lastProtectedModifierLength;
            while (true) {
                var modifierStart = scanner.getTokenPos();
                var modifierToken = token;
                // Try to parse the modifier
                if (!parseAnyContextualModifier())
                    break;
                var modifierLength = scanner.getStartPos() - modifierStart;
                switch (modifierToken) {
                    case 106 /* PublicKeyword */:
                        if (flags & 112 /* AccessibilityModifier */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "public", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "public");
                        }
                        flags |= 16 /* Public */;
                        break;
                    case 104 /* PrivateKeyword */:
                        if (flags & 112 /* AccessibilityModifier */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "private", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "private");
                        }
                        lastPrivateModifierStart = modifierStart;
                        lastPrivateModifierLength = modifierLength;
                        flags |= 32 /* Private */;
                        break;
                    case 105 /* ProtectedKeyword */:
                        if (flags & 16 /* Public */ || flags & 32 /* Private */ || flags & 64 /* Protected */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "protected", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "protected");
                        }
                        lastProtectedModifierStart = modifierStart;
                        lastProtectedModifierLength = modifierLength;
                        flags |= 64 /* Protected */;
                        break;
                    case 107 /* StaticKeyword */:
                        if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "static");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        lastStaticModifierStart = modifierStart;
                        lastStaticModifierLength = modifierLength;
                        flags |= 128 /* Static */;
                        break;
                    case 76 /* ExportKeyword */:
                        if (flags & 1 /* Export */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "export");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1 /* Export */;
                        break;
                    case 112 /* DeclareKeyword */:
                        if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "declare");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (inAmbientContext && context === 1 /* ModuleElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        lastDeclareModifierStart = modifierStart;
                        lastDeclareModifierLength = modifierLength;
                        flags |= 2 /* Ambient */;
                        break;
                }
            }
            if (token === 111 /* ConstructorKeyword */ && flags & 128 /* Static */) {
                grammarErrorAtPos(lastStaticModifierStart, lastStaticModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            else if (token === 111 /* ConstructorKeyword */ && flags & 32 /* Private */) {
                grammarErrorAtPos(lastPrivateModifierStart, lastPrivateModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "private");
            }
            else if (token === 111 /* ConstructorKeyword */ && flags & 64 /* Protected */) {
                grammarErrorAtPos(lastProtectedModifierStart, lastProtectedModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "protected");
            }
            else if (token === 83 /* ImportKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_import_declaration, "declare");
                }
            }
            else if (token === 101 /* InterfaceKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, "declare");
                }
            }
            else if (token !== 76 /* ExportKeyword */ && !(flags & 2 /* Ambient */) && inAmbientContext && context === 0 /* SourceElements */) {
                // A declare modifier is required for any top level .d.ts declaration except export=, interfaces and imports:
                // categories:
                //
                //  DeclarationElement:
                //     ExportAssignment
                //     export_opt   InterfaceDeclaration
                //     export_opt   ImportDeclaration
                //     export_opt   ExternalImportDeclaration
                //     export_opt   AmbientDeclaration
                //
                var declarationStart = scanner.getTokenPos();
                var declarationFirstTokenLength = scanner.getTextPos() - declarationStart;
                grammarErrorAtPos(declarationStart, declarationFirstTokenLength, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
            }
            return flags;
        }
        function parseClassMemberDeclaration() {
            var pos = getNodePos();
            var flags = parseAndCheckModifiers(2 /* ClassMembers */);
            if (parseContextualModifier(113 /* GetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(127 /* GetAccessor */, pos, flags);
            }
            if (parseContextualModifier(117 /* SetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(128 /* SetAccessor */, pos, flags);
            }
            if (token === 111 /* ConstructorKeyword */) {
                return parseConstructorDeclaration(pos, flags);
            }
            if (token >= 63 /* Identifier */ || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */) {
                return parsePropertyMemberDeclaration(pos, flags);
            }
            if (token === 17 /* OpenBracketToken */) {
                if (flags) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Modifiers_not_permitted_on_index_signature_members);
                }
                return parseIndexSignatureMember();
            }
            // 'isClassMemberStart' should have hinted not to attempt parsing.
            ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassDeclaration(pos, flags) {
            var node = createNode(184 /* ClassDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeClassDeclaration = file.syntacticErrors.length;
            parseExpected(67 /* ClassKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            node.baseType = parseOptional(77 /* ExtendsKeyword */) ? parseTypeReference() : undefined;
            var implementsKeywordStart = scanner.getTokenPos();
            var implementsKeywordLength;
            if (parseOptional(100 /* ImplementsKeyword */)) {
                implementsKeywordLength = scanner.getStartPos() - implementsKeywordStart;
                node.implementedTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, false);
            }
            var errorCountBeforeClassBody = file.syntacticErrors.length;
            if (parseExpected(13 /* OpenBraceToken */)) {
                node.members = parseList(6 /* ClassMembers */, false, parseClassMemberDeclaration);
                parseExpected(14 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            if (node.implementedTypes && !node.implementedTypes.length && errorCountBeforeClassBody === errorCountBeforeClassDeclaration) {
                grammarErrorAtPos(implementsKeywordStart, implementsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "implements");
            }
            return finishNode(node);
        }
        function parseInterfaceDeclaration(pos, flags) {
            var node = createNode(185 /* InterfaceDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeInterfaceDeclaration = file.syntacticErrors.length;
            parseExpected(101 /* InterfaceKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            var extendsKeywordStart = scanner.getTokenPos();
            var extendsKeywordLength;
            if (parseOptional(77 /* ExtendsKeyword */)) {
                extendsKeywordLength = scanner.getStartPos() - extendsKeywordStart;
                node.baseTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, false);
            }
            var errorCountBeforeInterfaceBody = file.syntacticErrors.length;
            node.members = parseTypeLiteral().members;
            if (node.baseTypes && !node.baseTypes.length && errorCountBeforeInterfaceBody === errorCountBeforeInterfaceDeclaration) {
                grammarErrorAtPos(extendsKeywordStart, extendsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "extends");
            }
            return finishNode(node);
        }
        function parseTypeAliasDeclaration(pos, flags) {
            var node = createNode(186 /* TypeAliasDeclaration */, pos);
            node.flags = flags;
            parseExpected(119 /* TypeKeyword */);
            node.name = parseIdentifier();
            parseExpected(51 /* EqualsToken */);
            node.type = parseType();
            parseSemicolon();
            return finishNode(node);
        }
        function parseAndCheckEnumDeclaration(pos, flags) {
            var enumIsConst = flags & 4096 /* Const */;
            function isIntegerLiteral(expression) {
                function isInteger(literalExpression) {
                    // Allows for scientific notation since literalExpression.text was formed by
                    // coercing a number to a string. Sometimes this coercion can yield a string
                    // in scientific notation.
                    // We also don't need special logic for hex because a hex integer is converted
                    // to decimal when it is coerced.
                    return /^[0-9]+([eE]\+?[0-9]+)?$/.test(literalExpression.text);
                }
                if (expression.kind === 151 /* PrefixOperator */) {
                    var unaryExpression = expression;
                    if (unaryExpression.operator === 32 /* PlusToken */ || unaryExpression.operator === 33 /* MinusToken */) {
                        expression = unaryExpression.operand;
                    }
                }
                if (expression.kind === 6 /* NumericLiteral */) {
                    return isInteger(expression);
                }
                return false;
            }
            var inConstantEnumMemberSection = true;
            // In an ambient declaration, the grammar only allows integer literals as initializers.
            // In a non-ambient declaration, the grammar allows uninitialized members only in a
            // ConstantEnumMemberSection, which starts at the beginning of an enum declaration
            // or any time an integer literal initializer is encountered.
            function parseAndCheckEnumMember() {
                var node = createNode(192 /* EnumMember */);
                var errorCountBeforeEnumMember = file.syntacticErrors.length;
                node.name = parsePropertyName();
                node.initializer = parseInitializer(false);
                // skip checks below for const enums  - they allow arbitrary initializers as long as they can be evaluated to constant expressions.
                // since all values are known in compile time - it is not necessary to check that constant enum section precedes computed enum members.
                if (!enumIsConst) {
                    if (inAmbientContext) {
                        if (node.initializer && !isIntegerLiteral(node.initializer) && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                            grammarErrorOnNode(node.name, ts.Diagnostics.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                        }
                    }
                    else if (node.initializer) {
                        inConstantEnumMemberSection = isIntegerLiteral(node.initializer);
                    }
                    else if (!inConstantEnumMemberSection && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                        grammarErrorOnNode(node.name, ts.Diagnostics.Enum_member_must_have_initializer);
                    }
                }
                return finishNode(node);
            }
            var node = createNode(187 /* EnumDeclaration */, pos);
            node.flags = flags;
            if (enumIsConst) {
                parseExpected(68 /* ConstKeyword */);
            }
            parseExpected(75 /* EnumKeyword */);
            node.name = parseIdentifier();
            if (parseExpected(13 /* OpenBraceToken */)) {
                node.members = parseDelimitedList(7 /* EnumMembers */, parseAndCheckEnumMember, true);
                parseExpected(14 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseModuleBody() {
            var node = createNode(189 /* ModuleBlock */);
            if (parseExpected(13 /* OpenBraceToken */)) {
                node.statements = parseList(1 /* ModuleElements */, false, parseModuleElement);
                parseExpected(14 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseInternalModuleTail(pos, flags) {
            var node = createNode(188 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseIdentifier();
            if (parseOptional(19 /* DotToken */)) {
                node.body = parseInternalModuleTail(getNodePos(), 1 /* Export */);
            }
            else {
                node.body = parseModuleBody();
                ts.forEach(node.body.statements, function (s) {
                    if (s.kind === 191 /* ExportAssignment */) {
                        // Export assignments are not allowed in an internal module
                        grammarErrorOnNode(s, ts.Diagnostics.An_export_assignment_cannot_be_used_in_an_internal_module);
                    }
                    else if (s.kind === 190 /* ImportDeclaration */ && s.externalModuleName) {
                        grammarErrorOnNode(s, ts.Diagnostics.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                    }
                });
            }
            return finishNode(node);
        }
        function parseAmbientExternalModuleDeclaration(pos, flags) {
            var node = createNode(188 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseStringLiteral();
            if (!inAmbientContext) {
                var errorCount = file.syntacticErrors.length;
                // Only report this error if we have not already errored about a missing declare modifier,
                // which would have been at or after pos
                if (!errorCount || file.syntacticErrors[errorCount - 1].start < getTokenPos(pos)) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }
            // For error recovery, just in case the user forgot the declare modifier on this ambient
            // external module, treat it as ambient anyway.
            var saveInAmbientContext = inAmbientContext;
            inAmbientContext = true;
            node.body = parseModuleBody();
            inAmbientContext = saveInAmbientContext;
            return finishNode(node);
        }
        function parseModuleDeclaration(pos, flags) {
            parseExpected(114 /* ModuleKeyword */);
            return token === 7 /* StringLiteral */ ? parseAmbientExternalModuleDeclaration(pos, flags) : parseInternalModuleTail(pos, flags);
        }
        function parseImportDeclaration(pos, flags) {
            var node = createNode(190 /* ImportDeclaration */, pos);
            node.flags = flags;
            parseExpected(83 /* ImportKeyword */);
            node.name = parseIdentifier();
            parseExpected(51 /* EqualsToken */);
            var entityName = parseEntityName(false);
            if (entityName.kind === 63 /* Identifier */ && entityName.text === "require" && parseOptional(15 /* OpenParenToken */)) {
                node.externalModuleName = parseStringLiteral();
                parseExpected(16 /* CloseParenToken */);
            }
            else {
                node.entityName = entityName;
            }
            parseSemicolon();
            return finishNode(node);
        }
        function parseExportAssignmentTail(pos) {
            var node = createNode(191 /* ExportAssignment */, pos);
            node.exportName = parseIdentifier();
            parseSemicolon();
            return finishNode(node);
        }
        function isDeclarationStart() {
            switch (token) {
                case 96 /* VarKeyword */:
                case 102 /* LetKeyword */:
                case 68 /* ConstKeyword */:
                case 81 /* FunctionKeyword */:
                    return true;
                case 67 /* ClassKeyword */:
                case 101 /* InterfaceKeyword */:
                case 75 /* EnumKeyword */:
                case 83 /* ImportKeyword */:
                case 119 /* TypeKeyword */:
                    // Not true keywords so ensure an identifier follows
                    return lookAhead(function () { return nextToken() >= 63 /* Identifier */; });
                case 114 /* ModuleKeyword */:
                    // Not a true keyword so ensure an identifier or string literal follows
                    return lookAhead(function () { return nextToken() >= 63 /* Identifier */ || token === 7 /* StringLiteral */; });
                case 76 /* ExportKeyword */:
                    // Check for export assignment or modifier on source element
                    return lookAhead(function () { return nextToken() === 51 /* EqualsToken */ || isDeclarationStart(); });
                case 112 /* DeclareKeyword */:
                case 106 /* PublicKeyword */:
                case 104 /* PrivateKeyword */:
                case 105 /* ProtectedKeyword */:
                case 107 /* StaticKeyword */:
                    // Check for modifier on source element
                    return lookAhead(function () {
                        nextToken();
                        return isDeclarationStart();
                    });
            }
        }
        function parseDeclaration(modifierContext) {
            var pos = getNodePos();
            var errorCountBeforeModifiers = file.syntacticErrors.length;
            var flags = parseAndCheckModifiers(modifierContext);
            if (token === 76 /* ExportKeyword */) {
                var modifiersEnd = scanner.getStartPos();
                nextToken();
                if (parseOptional(51 /* EqualsToken */)) {
                    var exportAssignmentTail = parseExportAssignmentTail(pos);
                    if (flags !== 0 && errorCountBeforeModifiers === file.syntacticErrors.length) {
                        var modifiersStart = ts.skipTrivia(sourceText, pos);
                        grammarErrorAtPos(modifiersStart, modifiersEnd - modifiersStart, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
                    }
                    return exportAssignmentTail;
                }
            }
            var saveInAmbientContext = inAmbientContext;
            if (flags & 2 /* Ambient */) {
                inAmbientContext = true;
            }
            var result;
            switch (token) {
                case 96 /* VarKeyword */:
                case 102 /* LetKeyword */:
                    result = parseVariableStatement(true, pos, flags);
                    break;
                case 68 /* ConstKeyword */:
                    var isConstEnum = lookAhead(function () { return nextToken() === 75 /* EnumKeyword */; });
                    if (isConstEnum) {
                        result = parseAndCheckEnumDeclaration(pos, flags | 4096 /* Const */);
                    }
                    else {
                        result = parseVariableStatement(true, pos, flags);
                    }
                    break;
                case 81 /* FunctionKeyword */:
                    result = parseFunctionDeclaration(pos, flags);
                    break;
                case 67 /* ClassKeyword */:
                    result = parseClassDeclaration(pos, flags);
                    break;
                case 101 /* InterfaceKeyword */:
                    result = parseInterfaceDeclaration(pos, flags);
                    break;
                case 119 /* TypeKeyword */:
                    result = parseTypeAliasDeclaration(pos, flags);
                    break;
                case 75 /* EnumKeyword */:
                    result = parseAndCheckEnumDeclaration(pos, flags);
                    break;
                case 114 /* ModuleKeyword */:
                    result = parseModuleDeclaration(pos, flags);
                    break;
                case 83 /* ImportKeyword */:
                    result = parseImportDeclaration(pos, flags);
                    break;
                default:
                    error(ts.Diagnostics.Declaration_expected);
            }
            inAmbientContext = saveInAmbientContext;
            return result;
        }
        function isSourceElement(inErrorRecovery) {
            return isDeclarationStart() || isStatement(inErrorRecovery);
        }
        function parseSourceElement() {
            return parseSourceElementOrModuleElement(0 /* SourceElements */);
        }
        function parseModuleElement() {
            return parseSourceElementOrModuleElement(1 /* ModuleElements */);
        }
        function parseSourceElementOrModuleElement(modifierContext) {
            if (isDeclarationStart()) {
                return parseDeclaration(modifierContext);
            }
            var statementStart = scanner.getTokenPos();
            var statementFirstTokenLength = scanner.getTextPos() - statementStart;
            var errorCountBeforeStatement = file.syntacticErrors.length;
            var statement = parseStatement(true);
            if (inAmbientContext && file.syntacticErrors.length === errorCountBeforeStatement) {
                grammarErrorAtPos(statementStart, statementFirstTokenLength, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
            }
            return statement;
        }
        function processReferenceComments() {
            var referencedFiles = [];
            var amdDependencies = [];
            commentRanges = [];
            token = scanner.scan();
            for (var i = 0; i < commentRanges.length; i++) {
                var range = commentRanges[i];
                var comment = sourceText.substring(range.pos, range.end);
                var referencePathMatchResult = getFileReferenceFromReferencePath(comment, range);
                if (referencePathMatchResult) {
                    var fileReference = referencePathMatchResult.fileReference;
                    file.hasNoDefaultLib = referencePathMatchResult.isNoDefaultLib;
                    var diagnostic = referencePathMatchResult.diagnostic;
                    if (fileReference) {
                        referencedFiles.push(fileReference);
                    }
                    if (diagnostic) {
                        errorAtPos(range.pos, range.end - range.pos, diagnostic);
                    }
                }
                else {
                    var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path\s*=\s*('|")(.+?)\1/gim;
                    var amdDependencyMatchResult = amdDependencyRegEx.exec(comment);
                    if (amdDependencyMatchResult) {
                        amdDependencies.push(amdDependencyMatchResult[2]);
                    }
                }
            }
            commentRanges = undefined;
            return {
                referencedFiles: referencedFiles,
                amdDependencies: amdDependencies
            };
        }
        function getExternalModuleIndicator() {
            return ts.forEach(file.statements, function (node) { return node.flags & 1 /* Export */ || node.kind === 190 /* ImportDeclaration */ && node.externalModuleName || node.kind === 191 /* ExportAssignment */ ? node : undefined; });
        }
        scanner = ts.createScanner(languageVersion, true, sourceText, scanError, onComment);
        var rootNodeFlags = 0;
        if (ts.fileExtensionIs(filename, ".d.ts")) {
            rootNodeFlags = 1024 /* DeclarationFile */;
            inAmbientContext = true;
        }
        file = createRootNode(193 /* SourceFile */, 0, sourceText.length, rootNodeFlags);
        file.filename = ts.normalizePath(filename);
        file.text = sourceText;
        file.getLineAndCharacterFromPosition = getLineAndCharacterlFromSourcePosition;
        file.getPositionFromLineAndCharacter = getPositionFromSourceLineAndCharacter;
        file.syntacticErrors = [];
        file.semanticErrors = [];
        var referenceComments = processReferenceComments();
        file.referencedFiles = referenceComments.referencedFiles;
        file.amdDependencies = referenceComments.amdDependencies;
        file.statements = parseList(0 /* SourceElements */, true, parseSourceElement);
        file.externalModuleIndicator = getExternalModuleIndicator();
        file.nodeCount = nodeCount;
        file.identifierCount = identifierCount;
        file.version = version;
        file.isOpen = isOpen;
        file.languageVersion = languageVersion;
        file.identifiers = identifiers;
        return file;
    }
    ts.createSourceFile = createSourceFile;
    function createProgram(rootNames, options, host) {
        var program;
        var files = [];
        var filesByName = {};
        var errors = [];
        var seenNoDefaultLib = options.noLib;
        var commonSourceDirectory;
        ts.forEach(rootNames, function (name) { return processRootFile(name, false); });
        if (!seenNoDefaultLib) {
            processRootFile(host.getDefaultLibFilename(), true);
        }
        verifyCompilerOptions();
        errors.sort(ts.compareDiagnostics);
        program = {
            getSourceFile: getSourceFile,
            getSourceFiles: function () { return files; },
            getCompilerOptions: function () { return options; },
            getCompilerHost: function () { return host; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getTypeChecker: function (fullTypeCheckMode) { return ts.createTypeChecker(program, fullTypeCheckMode); },
            getCommonSourceDirectory: function () { return commonSourceDirectory; }
        };
        return program;
        function getSourceFile(filename) {
            filename = host.getCanonicalFileName(filename);
            return ts.hasProperty(filesByName, filename) ? filesByName[filename] : undefined;
        }
        function getDiagnostics(sourceFile) {
            return sourceFile ? ts.filter(errors, function (e) { return e.file === sourceFile; }) : errors;
        }
        function getGlobalDiagnostics() {
            return ts.filter(errors, function (e) { return !e.file; });
        }
        function hasExtension(filename) {
            return ts.getBaseFilename(filename).indexOf(".") >= 0;
        }
        function processRootFile(filename, isDefaultLib) {
            processSourceFile(ts.normalizePath(filename), isDefaultLib);
        }
        function processSourceFile(filename, isDefaultLib, refFile, refPos, refEnd) {
            if (refEnd !== undefined && refPos !== undefined) {
                var start = refPos;
                var length = refEnd - refPos;
            }
            var diagnostic;
            if (hasExtension(filename)) {
                if (!ts.fileExtensionIs(filename, ".ts")) {
                    diagnostic = ts.Diagnostics.File_0_must_have_extension_ts_or_d_ts;
                }
                else if (!findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {
                    diagnostic = ts.Diagnostics.File_0_not_found;
                }
                else if (refFile && host.getCanonicalFileName(filename) === host.getCanonicalFileName(refFile.filename)) {
                    diagnostic = ts.Diagnostics.A_file_cannot_have_a_reference_to_itself;
                }
            }
            else {
                if (!(findSourceFile(filename + ".ts", isDefaultLib, refFile, refPos, refEnd) || findSourceFile(filename + ".d.ts", isDefaultLib, refFile, refPos, refEnd))) {
                    diagnostic = ts.Diagnostics.File_0_not_found;
                    filename += ".ts";
                }
            }
            if (diagnostic) {
                if (refFile) {
                    errors.push(ts.createFileDiagnostic(refFile, start, length, diagnostic, filename));
                }
                else {
                    errors.push(ts.createCompilerDiagnostic(diagnostic, filename));
                }
            }
        }
        // Get source file from normalized filename
        function findSourceFile(filename, isDefaultLib, refFile, refStart, refLength) {
            var canonicalName = host.getCanonicalFileName(filename);
            if (ts.hasProperty(filesByName, canonicalName)) {
                // We've already looked for this file, use cached result
                var file = filesByName[canonicalName];
                if (file && host.useCaseSensitiveFileNames() && canonicalName !== file.filename) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Filename_0_differs_from_already_included_filename_1_only_in_casing, filename, file.filename));
                }
            }
            else {
                // We haven't looked for this file, do so now and cache result
                var file = filesByName[canonicalName] = host.getSourceFile(filename, options.target, function (hostErrorMessage) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));
                });
                if (file) {
                    seenNoDefaultLib = seenNoDefaultLib || file.hasNoDefaultLib;
                    if (!options.noResolve) {
                        var basePath = ts.getDirectoryPath(filename);
                        processReferencedFiles(file, basePath);
                        processImportedModules(file, basePath);
                    }
                    if (isDefaultLib) {
                        files.unshift(file);
                    }
                    else {
                        files.push(file);
                    }
                    ts.forEach(file.syntacticErrors, function (e) {
                        errors.push(e);
                    });
                }
            }
            return file;
        }
        function processReferencedFiles(file, basePath) {
            ts.forEach(file.referencedFiles, function (ref) {
                var referencedFilename = ts.isRootedDiskPath(ref.filename) ? ref.filename : ts.combinePaths(basePath, ref.filename);
                processSourceFile(ts.normalizePath(referencedFilename), false, file, ref.pos, ref.end);
            });
        }
        function processImportedModules(file, basePath) {
            ts.forEach(file.statements, function (node) {
                if (node.kind === 190 /* ImportDeclaration */ && node.externalModuleName) {
                    var nameLiteral = node.externalModuleName;
                    var moduleName = nameLiteral.text;
                    if (moduleName) {
                        var searchPath = basePath;
                        while (true) {
                            var searchName = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                            if (findModuleSourceFile(searchName + ".ts", nameLiteral) || findModuleSourceFile(searchName + ".d.ts", nameLiteral)) {
                                break;
                            }
                            var parentPath = ts.getDirectoryPath(searchPath);
                            if (parentPath === searchPath) {
                                break;
                            }
                            searchPath = parentPath;
                        }
                    }
                }
                else if (node.kind === 188 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */ && (node.flags & 2 /* Ambient */ || isDeclarationFile(file))) {
                    // TypeScript 1.0 spec (April 2014): 12.1.6
                    // An AmbientExternalModuleDeclaration declares an external module. 
                    // This type of declaration is permitted only in the global module.
                    // The StringLiteral must specify a top - level external module name.
                    // Relative external module names are not permitted
                    forEachChild(node.body, function (node) {
                        if (node.kind === 190 /* ImportDeclaration */ && node.externalModuleName) {
                            var nameLiteral = node.externalModuleName;
                            var moduleName = nameLiteral.text;
                            if (moduleName) {
                                // TypeScript 1.0 spec (April 2014): 12.1.6
                                // An ExternalImportDeclaration in anAmbientExternalModuleDeclaration may reference other external modules 
                                // only through top - level external module names. Relative external module names are not permitted.
                                var searchName = ts.normalizePath(ts.combinePaths(basePath, moduleName));
                                var tsFile = findModuleSourceFile(searchName + ".ts", nameLiteral);
                                if (!tsFile) {
                                    findModuleSourceFile(searchName + ".d.ts", nameLiteral);
                                }
                            }
                        }
                    });
                }
            });
            function findModuleSourceFile(filename, nameLiteral) {
                return findSourceFile(filename, false, file, nameLiteral.pos, nameLiteral.end - nameLiteral.pos);
            }
        }
        function verifyCompilerOptions() {
            if (!options.sourceMap && (options.mapRoot || options.sourceRoot)) {
                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles
                if (options.mapRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                if (options.sourceRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                return;
            }
            var firstExternalModule = ts.forEach(files, function (f) { return isExternalModule(f) ? f : undefined; });
            if (firstExternalModule && options.module === 0 /* None */) {
                // We cannot use createDiagnosticFromNode because nodes do not have parents yet
                var externalModuleErrorSpan = getErrorSpanForNode(firstExternalModule.externalModuleIndicator);
                var errorStart = ts.skipTrivia(firstExternalModule.text, externalModuleErrorSpan.pos);
                var errorLength = externalModuleErrorSpan.end - errorStart;
                errors.push(ts.createFileDiagnostic(firstExternalModule, errorStart, errorLength, ts.Diagnostics.Cannot_compile_external_modules_unless_the_module_flag_is_provided));
            }
            // there has to be common source directory if user specified --outdir || --sourcRoot
            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
            if (options.outDir || options.sourceRoot || (options.mapRoot && (!options.out || firstExternalModule !== undefined))) {
                var commonPathComponents;
                ts.forEach(files, function (sourceFile) {
                    // Each file contributes into common source file path
                    if (!(sourceFile.flags & 1024 /* DeclarationFile */) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                        var sourcePathComponents = ts.getNormalizedPathComponents(sourceFile.filename, host.getCurrentDirectory());
                        sourcePathComponents.pop(); // FileName is not part of directory
                        if (commonPathComponents) {
                            for (var i = 0; i < Math.min(commonPathComponents.length, sourcePathComponents.length); i++) {
                                if (commonPathComponents[i] !== sourcePathComponents[i]) {
                                    if (i === 0) {
                                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files));
                                        return;
                                    }
                                    // New common path found that is 0 -> i-1
                                    commonPathComponents.length = i;
                                    break;
                                }
                            }
                            // If the fileComponent path completely matched and less than already found update the length
                            if (sourcePathComponents.length < commonPathComponents.length) {
                                commonPathComponents.length = sourcePathComponents.length;
                            }
                        }
                        else {
                            // first file
                            commonPathComponents = sourcePathComponents;
                        }
                    }
                });
                commonSourceDirectory = ts.getNormalizedPathFromPathComponents(commonPathComponents);
                if (commonSourceDirectory) {
                    // Make sure directory path ends with directory separator so this string can directly 
                    // used to replace with "" to get the relative path of the source file and the relative path doesn't
                    // start with / making it rooted path
                    commonSourceDirectory += ts.directorySeparator;
                }
            }
        }
    }
    ts.createProgram = createProgram;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    function getModuleInstanceState(node) {
        // A module is uninstantiated if it contains only 
        // 1. interface declarations
        if (node.kind === 185 /* InterfaceDeclaration */) {
            return 0 /* NonInstantiated */;
        }
        else if (node.kind === 187 /* EnumDeclaration */ && ts.isConstEnumDeclaration(node)) {
            return 2 /* ConstEnumOnly */;
        }
        else if (node.kind === 190 /* ImportDeclaration */ && !(node.flags & 1 /* Export */)) {
            return 0 /* NonInstantiated */;
        }
        else if (node.kind === 189 /* ModuleBlock */) {
            var state = 0 /* NonInstantiated */;
            ts.forEachChild(node, function (n) {
                switch (getModuleInstanceState(n)) {
                    case 0 /* NonInstantiated */:
                        // child is non-instantiated - continue searching
                        return false;
                    case 2 /* ConstEnumOnly */:
                        // child is const enum only - record state and continue searching
                        state = 2 /* ConstEnumOnly */;
                        return false;
                    case 1 /* Instantiated */:
                        // child is instantiated - record state and stop
                        state = 1 /* Instantiated */;
                        return true;
                }
            });
            return state;
        }
        else if (node.kind === 188 /* ModuleDeclaration */) {
            return getModuleInstanceState(node.body);
        }
        else {
            return 1 /* Instantiated */;
        }
    }
    ts.getModuleInstanceState = getModuleInstanceState;
    function bindSourceFile(file) {
        var parent;
        var container;
        var blockScopeContainer;
        var lastContainer;
        var symbolCount = 0;
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        if (!file.locals) {
            file.locals = {};
            container = blockScopeContainer = file;
            bind(file);
            file.symbolCount = symbolCount;
        }
        function createSymbol(flags, name) {
            symbolCount++;
            return new Symbol(flags, name);
        }
        function addDeclarationToSymbol(symbol, node, symbolKind) {
            symbol.flags |= symbolKind;
            if (!symbol.declarations)
                symbol.declarations = [];
            symbol.declarations.push(node);
            if (symbolKind & 1952 /* HasExports */ && !symbol.exports)
                symbol.exports = {};
            if (symbolKind & 6240 /* HasMembers */ && !symbol.members)
                symbol.members = {};
            node.symbol = symbol;
            if (symbolKind & 107455 /* Value */ && !symbol.valueDeclaration)
                symbol.valueDeclaration = node;
        }
        // TODO(jfreeman): Implement getDeclarationName for property name
        function getDeclarationName(node) {
            if (node.name) {
                if (node.kind === 188 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */) {
                    return '"' + node.name.text + '"';
                }
                return node.name.text;
            }
            switch (node.kind) {
                case 126 /* Constructor */: return "__constructor";
                case 129 /* CallSignature */: return "__call";
                case 130 /* ConstructSignature */: return "__new";
                case 131 /* IndexSignature */: return "__index";
            }
        }
        function getDisplayName(node) {
            return node.name ? ts.declarationNameToString(node.name) : getDeclarationName(node);
        }
        function declareSymbol(symbols, parent, node, includes, excludes) {
            var name = getDeclarationName(node);
            if (name !== undefined) {
                var symbol = ts.hasProperty(symbols, name) ? symbols[name] : (symbols[name] = createSymbol(0, name));
                if (symbol.flags & excludes) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    // Report errors every position with duplicate declaration
                    // Report errors on previous encountered declarations
                    var message = symbol.flags & 2 /* BlockScopedVariable */ ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;
                    ts.forEach(symbol.declarations, function (declaration) {
                        file.semanticErrors.push(ts.createDiagnosticForNode(declaration.name, message, getDisplayName(declaration)));
                    });
                    file.semanticErrors.push(ts.createDiagnosticForNode(node.name, message, getDisplayName(node)));
                    symbol = createSymbol(0, name);
                }
            }
            else {
                symbol = createSymbol(0, "__missing");
            }
            addDeclarationToSymbol(symbol, node, includes);
            symbol.parent = parent;
            if (node.kind === 184 /* ClassDeclaration */ && symbol.exports) {
                // TypeScript 1.0 spec (April 2014): 8.4
                // Every class automatically contains a static property member named 'prototype', 
                // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
                // It is an error to explicitly declare a static property member with the name 'prototype'.
                var prototypeSymbol = createSymbol(4 /* Property */ | 536870912 /* Prototype */, "prototype");
                if (ts.hasProperty(symbol.exports, prototypeSymbol.name)) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    file.semanticErrors.push(ts.createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0], ts.Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));
                }
                symbol.exports[prototypeSymbol.name] = prototypeSymbol;
                prototypeSymbol.parent = symbol;
            }
            return symbol;
        }
        function isAmbientContext(node) {
            while (node) {
                if (node.flags & 2 /* Ambient */)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function declareModuleMember(node, symbolKind, symbolExcludes) {
            // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue,
            // ExportType, or ExportContainer flag, and an associated export symbol with all the correct flags set
            // on it. There are 2 main reasons:
            //
            //   1. We treat locals and exports of the same name as mutually exclusive within a container. 
            //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
            //      with the same name in the same container.
            //      TODO: Make this a more specific error and decouple it from the exclusion logic.
            //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
            //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
            //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.
            var exportKind = 0;
            if (symbolKind & 107455 /* Value */) {
                exportKind |= 4194304 /* ExportValue */;
            }
            if (symbolKind & 3152352 /* Type */) {
                exportKind |= 8388608 /* ExportType */;
            }
            if (symbolKind & 1536 /* Namespace */) {
                exportKind |= 16777216 /* ExportNamespace */;
            }
            if (node.flags & 1 /* Export */ || (node.kind !== 190 /* ImportDeclaration */ && isAmbientContext(container))) {
                if (exportKind) {
                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);
                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    node.localSymbol = local;
                }
                else {
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                }
            }
            else {
                declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
            }
        }
        // All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function
        // in the type checker to validate that the local name used for a container is unique.
        function bindChildren(node, symbolKind, isBlockScopeContainer) {
            if (symbolKind & 1041936 /* HasLocals */) {
                node.locals = {};
            }
            var saveParent = parent;
            var saveContainer = container;
            var savedBlockScopeContainer = blockScopeContainer;
            parent = node;
            if (symbolKind & 1048560 /* IsContainer */) {
                container = node;
                // If container is not on container list, add it to the list
                if (lastContainer !== container && !container.nextContainer) {
                    if (lastContainer) {
                        lastContainer.nextContainer = container;
                    }
                    lastContainer = container;
                }
            }
            if (isBlockScopeContainer) {
                blockScopeContainer = node;
            }
            ts.forEachChild(node, bind);
            container = saveContainer;
            parent = saveParent;
            blockScopeContainer = savedBlockScopeContainer;
        }
        function bindDeclaration(node, symbolKind, symbolExcludes, isBlockScopeContainer) {
            switch (container.kind) {
                case 188 /* ModuleDeclaration */:
                    declareModuleMember(node, symbolKind, symbolExcludes);
                    break;
                case 193 /* SourceFile */:
                    if (ts.isExternalModule(container)) {
                        declareModuleMember(node, symbolKind, symbolExcludes);
                        break;
                    }
                case 129 /* CallSignature */:
                case 130 /* ConstructSignature */:
                case 131 /* IndexSignature */:
                case 125 /* Method */:
                case 126 /* Constructor */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 182 /* FunctionDeclaration */:
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                    declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
                    break;
                case 184 /* ClassDeclaration */:
                    if (node.flags & 128 /* Static */) {
                        declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                        break;
                    }
                case 134 /* TypeLiteral */:
                case 140 /* ObjectLiteral */:
                case 185 /* InterfaceDeclaration */:
                    declareSymbol(container.symbol.members, container.symbol, node, symbolKind, symbolExcludes);
                    break;
                case 187 /* EnumDeclaration */:
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    break;
            }
            bindChildren(node, symbolKind, isBlockScopeContainer);
        }
        function bindConstructorDeclaration(node) {
            bindDeclaration(node, 16384 /* Constructor */, 0, true);
            ts.forEach(node.parameters, function (p) {
                if (p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */)) {
                    bindDeclaration(p, 4 /* Property */, 107455 /* PropertyExcludes */, false);
                }
            });
        }
        function bindModuleDeclaration(node) {
            if (node.name.kind === 7 /* StringLiteral */) {
                bindDeclaration(node, 512 /* ValueModule */, 106639 /* ValueModuleExcludes */, true);
            }
            else {
                var state = getModuleInstanceState(node);
                if (state === 0 /* NonInstantiated */) {
                    bindDeclaration(node, 1024 /* NamespaceModule */, 0 /* NamespaceModuleExcludes */, true);
                }
                else {
                    bindDeclaration(node, 512 /* ValueModule */, 106639 /* ValueModuleExcludes */, true);
                    if (state === 2 /* ConstEnumOnly */) {
                        // mark value module as module that contains only enums
                        node.symbol.constEnumOnlyModule = true;
                    }
                    else if (node.symbol.constEnumOnlyModule) {
                        // const only value module was merged with instantiated module - reset flag
                        node.symbol.constEnumOnlyModule = false;
                    }
                }
            }
        }
        function bindAnonymousDeclaration(node, symbolKind, name, isBlockScopeContainer) {
            var symbol = createSymbol(symbolKind, name);
            addDeclarationToSymbol(symbol, node, symbolKind);
            bindChildren(node, symbolKind, isBlockScopeContainer);
        }
        function bindCatchVariableDeclaration(node) {
            var symbol = createSymbol(1 /* FunctionScopedVariable */, node.variable.text || "__missing");
            addDeclarationToSymbol(symbol, node, 1 /* FunctionScopedVariable */);
            var saveParent = parent;
            var savedBlockScopeContainer = blockScopeContainer;
            parent = blockScopeContainer = node;
            ts.forEachChild(node, bind);
            parent = saveParent;
            blockScopeContainer = savedBlockScopeContainer;
        }
        function bindBlockScopedVariableDeclaration(node) {
            switch (blockScopeContainer.kind) {
                case 188 /* ModuleDeclaration */:
                    declareModuleMember(node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);
                    break;
                case 193 /* SourceFile */:
                    if (ts.isExternalModule(container)) {
                        declareModuleMember(node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);
                        break;
                    }
                default:
                    if (!blockScopeContainer.locals) {
                        blockScopeContainer.locals = {};
                    }
                    declareSymbol(blockScopeContainer.locals, undefined, node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);
            }
            bindChildren(node, 2 /* BlockScopedVariable */, false);
        }
        function bind(node) {
            node.parent = parent;
            switch (node.kind) {
                case 122 /* TypeParameter */:
                    bindDeclaration(node, 1048576 /* TypeParameter */, 2103776 /* TypeParameterExcludes */, false);
                    break;
                case 123 /* Parameter */:
                    bindDeclaration(node, 1 /* FunctionScopedVariable */, 107455 /* ParameterExcludes */, false);
                    break;
                case 181 /* VariableDeclaration */:
                    if (node.flags & 6144 /* BlockScoped */) {
                        bindBlockScopedVariableDeclaration(node);
                    }
                    else {
                        bindDeclaration(node, 1 /* FunctionScopedVariable */, 107454 /* FunctionScopedVariableExcludes */, false);
                    }
                    break;
                case 124 /* Property */:
                case 141 /* PropertyAssignment */:
                    bindDeclaration(node, 4 /* Property */, 107455 /* PropertyExcludes */, false);
                    break;
                case 192 /* EnumMember */:
                    bindDeclaration(node, 8 /* EnumMember */, 107455 /* EnumMemberExcludes */, false);
                    break;
                case 129 /* CallSignature */:
                    bindDeclaration(node, 131072 /* CallSignature */, 0, false);
                    break;
                case 125 /* Method */:
                    bindDeclaration(node, 8192 /* Method */, 99263 /* MethodExcludes */, true);
                    break;
                case 130 /* ConstructSignature */:
                    bindDeclaration(node, 262144 /* ConstructSignature */, 0, true);
                    break;
                case 131 /* IndexSignature */:
                    bindDeclaration(node, 524288 /* IndexSignature */, 0, false);
                    break;
                case 182 /* FunctionDeclaration */:
                    bindDeclaration(node, 16 /* Function */, 106927 /* FunctionExcludes */, true);
                    break;
                case 126 /* Constructor */:
                    bindConstructorDeclaration(node);
                    break;
                case 127 /* GetAccessor */:
                    bindDeclaration(node, 32768 /* GetAccessor */, 41919 /* GetAccessorExcludes */, true);
                    break;
                case 128 /* SetAccessor */:
                    bindDeclaration(node, 65536 /* SetAccessor */, 74687 /* SetAccessorExcludes */, true);
                    break;
                case 134 /* TypeLiteral */:
                    bindAnonymousDeclaration(node, 2048 /* TypeLiteral */, "__type", false);
                    break;
                case 140 /* ObjectLiteral */:
                    bindAnonymousDeclaration(node, 4096 /* ObjectLiteral */, "__object", false);
                    break;
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                    bindAnonymousDeclaration(node, 16 /* Function */, "__function", true);
                    break;
                case 178 /* CatchBlock */:
                    bindCatchVariableDeclaration(node);
                    break;
                case 184 /* ClassDeclaration */:
                    bindDeclaration(node, 32 /* Class */, 3258879 /* ClassExcludes */, false);
                    break;
                case 185 /* InterfaceDeclaration */:
                    bindDeclaration(node, 64 /* Interface */, 3152288 /* InterfaceExcludes */, false);
                    break;
                case 186 /* TypeAliasDeclaration */:
                    bindDeclaration(node, 2097152 /* TypeAlias */, 3152352 /* TypeAliasExcludes */, false);
                    break;
                case 187 /* EnumDeclaration */:
                    if (ts.isConstEnumDeclaration(node)) {
                        bindDeclaration(node, 128 /* ConstEnum */, 3259263 /* ConstEnumExcludes */, false);
                    }
                    else {
                        bindDeclaration(node, 256 /* RegularEnum */, 3258623 /* RegularEnumExcludes */, false);
                    }
                    break;
                case 188 /* ModuleDeclaration */:
                    bindModuleDeclaration(node);
                    break;
                case 190 /* ImportDeclaration */:
                    bindDeclaration(node, 33554432 /* Import */, 33554432 /* ImportExcludes */, false);
                    break;
                case 193 /* SourceFile */:
                    if (ts.isExternalModule(node)) {
                        bindAnonymousDeclaration(node, 512 /* ValueModule */, '"' + ts.removeFileExtension(node.filename) + '"', true);
                        break;
                    }
                case 158 /* Block */:
                case 177 /* TryBlock */:
                case 178 /* CatchBlock */:
                case 179 /* FinallyBlock */:
                case 165 /* ForStatement */:
                case 166 /* ForInStatement */:
                case 171 /* SwitchStatement */:
                    bindChildren(node, 0, true);
                    break;
                default:
                    var saveParent = parent;
                    parent = node;
                    ts.forEachChild(node, bind);
                    parent = saveParent;
            }
        }
    }
    ts.bindSourceFile = bindSourceFile;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    var indentStrings = ["", "    "];
    function getIndentString(level) {
        if (indentStrings[level] === undefined) {
            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];
        }
        return indentStrings[level];
    }
    ts.getIndentString = getIndentString;
    function getIndentSize() {
        return indentStrings[1].length;
    }
    function shouldEmitToOwnFile(sourceFile, compilerOptions) {
        if (!ts.isDeclarationFile(sourceFile)) {
            if ((ts.isExternalModule(sourceFile) || !compilerOptions.out) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                return true;
            }
            return false;
        }
        return false;
    }
    ts.shouldEmitToOwnFile = shouldEmitToOwnFile;
    function isExternalModuleOrDeclarationFile(sourceFile) {
        return ts.isExternalModule(sourceFile) || ts.isDeclarationFile(sourceFile);
    }
    ts.isExternalModuleOrDeclarationFile = isExternalModuleOrDeclarationFile;
    // targetSourceFile is when users only want one file in entire project to be emitted. This is used in compilerOnSave feature
    function emitFiles(resolver, targetSourceFile) {
        var program = resolver.getProgram();
        var compilerHost = program.getCompilerHost();
        var compilerOptions = program.getCompilerOptions();
        var sourceMapDataList = compilerOptions.sourceMap ? [] : undefined;
        var diagnostics = [];
        var newLine = program.getCompilerHost().getNewLine();
        function getSourceFilePathInNewDir(newDirPath, sourceFile) {
            var sourceFilePath = ts.getNormalizedPathFromPathComponents(ts.getNormalizedPathComponents(sourceFile.filename, compilerHost.getCurrentDirectory()));
            sourceFilePath = sourceFilePath.replace(program.getCommonSourceDirectory(), "");
            return ts.combinePaths(newDirPath, sourceFilePath);
        }
        function getOwnEmitOutputFilePath(sourceFile, extension) {
            if (compilerOptions.outDir) {
                var emitOutputFilePathWithoutExtension = ts.removeFileExtension(getSourceFilePathInNewDir(compilerOptions.outDir, sourceFile));
            }
            else {
                var emitOutputFilePathWithoutExtension = ts.removeFileExtension(sourceFile.filename);
            }
            return emitOutputFilePathWithoutExtension + extension;
        }
        function getFirstConstructorWithBody(node) {
            return ts.forEach(node.members, function (member) {
                if (member.kind === 126 /* Constructor */ && member.body) {
                    return member;
                }
            });
        }
        function getAllAccessorDeclarations(node, accessor) {
            var firstAccessor;
            var getAccessor;
            var setAccessor;
            ts.forEach(node.members, function (member) {
                // TODO(jfreeman): Handle computed names for accessor matching
                if ((member.kind === 127 /* GetAccessor */ || member.kind === 128 /* SetAccessor */) && member.name.text === accessor.name.text && (member.flags & 128 /* Static */) === (accessor.flags & 128 /* Static */)) {
                    if (!firstAccessor) {
                        firstAccessor = member;
                    }
                    if (member.kind === 127 /* GetAccessor */ && !getAccessor) {
                        getAccessor = member;
                    }
                    if (member.kind === 128 /* SetAccessor */ && !setAccessor) {
                        setAccessor = member;
                    }
                }
            });
            return {
                firstAccessor: firstAccessor,
                getAccessor: getAccessor,
                setAccessor: setAccessor
            };
        }
        function createTextWriter() {
            var output = "";
            var indent = 0;
            var lineStart = true;
            var lineCount = 0;
            var linePos = 0;
            function write(s) {
                if (s && s.length) {
                    if (lineStart) {
                        output += getIndentString(indent);
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function rawWrite(s) {
                if (s !== undefined) {
                    if (lineStart) {
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function writeLiteral(s) {
                if (s && s.length) {
                    write(s);
                    var lineStartsOfS = ts.getLineStarts(s);
                    if (lineStartsOfS.length > 1) {
                        lineCount = lineCount + lineStartsOfS.length - 1;
                        linePos = output.length - s.length + lineStartsOfS[lineStartsOfS.length - 1];
                    }
                }
            }
            function writeLine() {
                if (!lineStart) {
                    output += newLine;
                    lineCount++;
                    linePos = output.length;
                    lineStart = true;
                }
            }
            return {
                write: write,
                rawWrite: rawWrite,
                writeLiteral: writeLiteral,
                writeLine: writeLine,
                increaseIndent: function () { return indent++; },
                decreaseIndent: function () { return indent--; },
                getIndent: function () { return indent; },
                getTextPos: function () { return output.length; },
                getLine: function () { return lineCount + 1; },
                getColumn: function () { return lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1; },
                getText: function () { return output; }
            };
        }
        // Get source text of node in the current source file. Unlike getSourceTextOfNode this function
        // doesn't walk the parent chain to find the containing source file, rather it assumes the node is
        // in the source file currently being processed.
        var currentSourceFile;
        function getSourceTextOfLocalNode(node) {
            var text = currentSourceFile.text;
            return text.substring(ts.skipTrivia(text, node.pos), node.end);
        }
        function getLineOfLocalPosition(pos) {
            return currentSourceFile.getLineAndCharacterFromPosition(pos).line;
        }
        function writeFile(filename, data, writeByteOrderMark) {
            compilerHost.writeFile(filename, data, writeByteOrderMark, function (hostErrorMessage) {
                diagnostics.push(ts.createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, filename, hostErrorMessage));
            });
        }
        function emitComments(comments, trailingSeparator, writer, writeComment) {
            var emitLeadingSpace = !trailingSeparator;
            ts.forEach(comments, function (comment) {
                if (emitLeadingSpace) {
                    writer.write(" ");
                    emitLeadingSpace = false;
                }
                writeComment(comment, writer);
                if (comment.hasTrailingNewLine) {
                    writer.writeLine();
                }
                else if (trailingSeparator) {
                    writer.write(" ");
                }
                else {
                    // Emit leading space to separate comment during next comment emit
                    emitLeadingSpace = true;
                }
            });
        }
        function emitNewLineBeforeLeadingComments(node, leadingComments, writer) {
            // If the leading comments start on different line than the start of node, write new line
            if (leadingComments && leadingComments.length && node.pos !== leadingComments[0].pos && getLineOfLocalPosition(node.pos) !== getLineOfLocalPosition(leadingComments[0].pos)) {
                writer.writeLine();
            }
        }
        function writeCommentRange(comment, writer) {
            if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                var firstCommentLineAndCharacter = currentSourceFile.getLineAndCharacterFromPosition(comment.pos);
                var firstCommentLineIndent;
                for (var pos = comment.pos, currentLine = firstCommentLineAndCharacter.line; pos < comment.end; currentLine++) {
                    var nextLineStart = currentSourceFile.getPositionFromLineAndCharacter(currentLine + 1, 1);
                    if (pos !== comment.pos) {
                        // If we are not emitting first line, we need to write the spaces to adjust the alignment
                        if (firstCommentLineIndent === undefined) {
                            firstCommentLineIndent = calculateIndent(currentSourceFile.getPositionFromLineAndCharacter(firstCommentLineAndCharacter.line, 1), comment.pos);
                        }
                        // These are number of spaces writer is going to write at current indent
                        var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                        // Number of spaces we want to be writing
                        // eg: Assume writer indent
                        // module m {
                        //         /* starts at character 9 this is line 1
                        //    * starts at character pos 4 line                        --1  = 8 - 8 + 3
                        //   More left indented comment */                            --2  = 8 - 8 + 2
                        //     class c { }
                        // }
                        // module m {
                        //     /* this is line 1 -- Assume current writer indent 8
                        //      * line                                                --3 = 8 - 4 + 5 
                        //            More right indented comment */                  --4 = 8 - 4 + 11
                        //     class c { }
                        // }
                        var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(pos, nextLineStart);
                        if (spacesToEmit > 0) {
                            var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                            var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                            // Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
                            writer.rawWrite(indentSizeSpaceString);
                            while (numberOfSingleSpacesToEmit) {
                                writer.rawWrite(" ");
                                numberOfSingleSpacesToEmit--;
                            }
                        }
                        else {
                            // No spaces to emit write empty string
                            writer.rawWrite("");
                        }
                    }
                    // Write the comment line text
                    writeTrimmedCurrentLine(pos, nextLineStart);
                    pos = nextLineStart;
                }
            }
            else {
                // Single line comment of style //....
                writer.write(currentSourceFile.text.substring(comment.pos, comment.end));
            }
            function writeTrimmedCurrentLine(pos, nextLineStart) {
                var end = Math.min(comment.end, nextLineStart - 1);
                var currentLineText = currentSourceFile.text.substring(pos, end).replace(/^\s+|\s+$/g, '');
                if (currentLineText) {
                    // trimmed forward and ending spaces text
                    writer.write(currentLineText);
                    if (end !== comment.end) {
                        writer.writeLine();
                    }
                }
                else {
                    // Empty string - make sure we write empty line
                    writer.writeLiteral(newLine);
                }
            }
            function calculateIndent(pos, end) {
                var currentLineIndent = 0;
                for (; pos < end && ts.isWhiteSpace(currentSourceFile.text.charCodeAt(pos)); pos++) {
                    if (currentSourceFile.text.charCodeAt(pos) === 9 /* tab */) {
                        // Tabs = TabSize = indent size and go to next tabStop
                        currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());
                    }
                    else {
                        // Single space
                        currentLineIndent++;
                    }
                }
                return currentLineIndent;
            }
        }
        function emitJavaScript(jsFilePath, root) {
            var writer = createTextWriter();
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var extendsEmitted = false;
            /** write emitted output to disk*/
            var writeEmittedFiles = writeJavaScriptFile;
            /** Emit leading comments of the node */
            var emitLeadingComments = compilerOptions.removeComments ? function (node) {
            } : emitLeadingDeclarationComments;
            /** Emit Trailing comments of the node */
            var emitTrailingComments = compilerOptions.removeComments ? function (node) {
            } : emitTrailingDeclarationComments;
            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) {
            } : emitLeadingCommentsOfLocalPosition;
            var detachedCommentsInfo;
            /** Emit detached comments of the node */
            var emitDetachedComments = compilerOptions.removeComments ? function (node) {
            } : emitDetachedCommentsAtPosition;
            /** Emits /// or pinned which is comment starting with /*! comments */
            var emitPinnedOrTripleSlashComments = compilerOptions.removeComments ? function (node) {
            } : emitPinnedOrTripleSlashCommentsOfNode;
            var writeComment = writeCommentRange;
            /** Emit a node */
            var emit = emitNode;
            /** Called just before starting emit of a node */
            var emitStart = function (node) {
            };
            /** Called once the emit of the node is done */
            var emitEnd = function (node) {
            };
            /** Emit the text for the given token that comes after startPos
              * This by default writes the text provided with the given tokenKind
              * but if optional emitFn callback is provided the text is emitted using the callback instead of default text
              * @param tokenKind the kind of the token to search and emit
              * @param startPos the position in the source to start searching for the token
              * @param emitFn if given will be invoked to emit the text instead of actual token emit */
            var emitToken = emitTokenText;
            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node
              * @param scopeDeclaration node that starts the lexical scope
              * @param scopeName Optional name of this scope instead of deducing one from the declaration node */
            var scopeEmitStart = function (scopeDeclaration, scopeName) {
            };
            /** Called after coming out of the scope */
            var scopeEmitEnd = function () {
            };
            /** Sourcemap data that will get encoded */
            var sourceMapData;
            function initializeEmitterWithSourceMaps() {
                var sourceMapDir; // The directory in which sourcemap will be
                // Current source map file and its index in the sources list
                var sourceMapSourceIndex = -1;
                // Names and its index map
                var sourceMapNameIndexMap = {};
                var sourceMapNameIndices = [];
                function getSourceMapNameIndex() {
                    return sourceMapNameIndices.length ? sourceMapNameIndices[sourceMapNameIndices.length - 1] : -1;
                }
                // Last recorded and encoded spans
                var lastRecordedSourceMapSpan;
                var lastEncodedSourceMapSpan = {
                    emittedLine: 1,
                    emittedColumn: 1,
                    sourceLine: 1,
                    sourceColumn: 1,
                    sourceIndex: 0
                };
                var lastEncodedNameIndex = 0;
                // Encoding for sourcemap span
                function encodeLastRecordedSourceMapSpan() {
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {
                        return;
                    }
                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;
                    // Line/Comma delimiters
                    if (lastEncodedSourceMapSpan.emittedLine == lastRecordedSourceMapSpan.emittedLine) {
                        // Emit comma to separate the entry
                        if (sourceMapData.sourceMapMappings) {
                            sourceMapData.sourceMapMappings += ",";
                        }
                    }
                    else {
                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {
                            sourceMapData.sourceMapMappings += ";";
                        }
                        prevEncodedEmittedColumn = 1;
                    }
                    // 1. Relative Column 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);
                    // 2. Relative sourceIndex 
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);
                    // 3. Relative sourceLine 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);
                    // 4. Relative sourceColumn 0 based 
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);
                    // 5. Relative namePosition 0 based
                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {
                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);
                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;
                    }
                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;
                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);
                    function base64VLQFormatEncode(inValue) {
                        function base64FormatEncode(inValue) {
                            if (inValue < 64) {
                                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(inValue);
                            }
                            throw TypeError(inValue + ": not a 64 based value");
                        }
                        // Add a new least significant bit that has the sign of the value.
                        // if negative number the least significant bit that gets added to the number has value 1
                        // else least significant bit value that gets added is 0
                        // eg. -1 changes to binary : 01 [1] => 3
                        //     +1 changes to binary : 01 [0] => 2
                        if (inValue < 0) {
                            inValue = ((-inValue) << 1) + 1;
                        }
                        else {
                            inValue = inValue << 1;
                        }
                        // Encode 5 bits at a time starting from least significant bits
                        var encodedStr = "";
                        do {
                            var currentDigit = inValue & 31; // 11111
                            inValue = inValue >> 5;
                            if (inValue > 0) {
                                // There are still more digits to decode, set the msb (6th bit)
                                currentDigit = currentDigit | 32;
                            }
                            encodedStr = encodedStr + base64FormatEncode(currentDigit);
                        } while (inValue > 0);
                        return encodedStr;
                    }
                }
                function recordSourceMapSpan(pos) {
                    var sourceLinePos = currentSourceFile.getLineAndCharacterFromPosition(pos);
                    var emittedLine = writer.getLine();
                    var emittedColumn = writer.getColumn();
                    // If this location wasn't recorded or the location in source is going backwards, record the span
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan.emittedLine != emittedLine || lastRecordedSourceMapSpan.emittedColumn != emittedColumn || (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex && (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line || (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {
                        // Encode the last recordedSpan before assigning new
                        encodeLastRecordedSourceMapSpan();
                        // New span
                        lastRecordedSourceMapSpan = {
                            emittedLine: emittedLine,
                            emittedColumn: emittedColumn,
                            sourceLine: sourceLinePos.line,
                            sourceColumn: sourceLinePos.character,
                            nameIndex: getSourceMapNameIndex(),
                            sourceIndex: sourceMapSourceIndex
                        };
                    }
                    else {
                        // Take the new pos instead since there is no change in emittedLine and column since last location
                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;
                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;
                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;
                    }
                }
                function recordEmitNodeStartSpan(node) {
                    // Get the token pos after skipping to the token (ignoring the leading trivia)
                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));
                }
                function recordEmitNodeEndSpan(node) {
                    recordSourceMapSpan(node.end);
                }
                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {
                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);
                    recordSourceMapSpan(tokenStartPos);
                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);
                    recordSourceMapSpan(tokenEndPos);
                    return tokenEndPos;
                }
                function recordNewSourceFileStart(node) {
                    // Add the file to tsFilePaths
                    // If sourceroot option: Use the relative path corresponding to the common directory path 
                    // otherwise source locations relative to map file location
                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? program.getCommonSourceDirectory() : sourceMapDir;
                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.filename, compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, true));
                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;
                    // The one that can be used from program to get the actual source file
                    sourceMapData.inputSourceFileNames.push(node.filename);
                }
                function recordScopeNameOfNode(node, scopeName) {
                    function recordScopeNameIndex(scopeNameIndex) {
                        sourceMapNameIndices.push(scopeNameIndex);
                    }
                    function recordScopeNameStart(scopeName) {
                        var scopeNameIndex = -1;
                        if (scopeName) {
                            var parentIndex = getSourceMapNameIndex();
                            if (parentIndex !== -1) {
                                scopeName = sourceMapData.sourceMapNames[parentIndex] + "." + scopeName;
                            }
                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);
                            if (scopeNameIndex === undefined) {
                                scopeNameIndex = sourceMapData.sourceMapNames.length;
                                sourceMapData.sourceMapNames.push(scopeName);
                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;
                            }
                        }
                        recordScopeNameIndex(scopeNameIndex);
                    }
                    if (scopeName) {
                        // The scope was already given a name  use it
                        recordScopeNameStart(scopeName);
                    }
                    else if (node.kind === 182 /* FunctionDeclaration */ || node.kind === 149 /* FunctionExpression */ || node.kind === 125 /* Method */ || node.kind === 127 /* GetAccessor */ || node.kind === 128 /* SetAccessor */ || node.kind === 188 /* ModuleDeclaration */ || node.kind === 184 /* ClassDeclaration */ || node.kind === 187 /* EnumDeclaration */) {
                        // Declaration and has associated name use it
                        if (node.name) {
                            // TODO(jfreeman): Ask shkamat about what this name should be for source maps
                            scopeName = node.name.text;
                        }
                        recordScopeNameStart(scopeName);
                    }
                    else {
                        // Block just use the name from upper level scope
                        recordScopeNameIndex(getSourceMapNameIndex());
                    }
                }
                function recordScopeNameEnd() {
                    sourceMapNameIndices.pop();
                }
                ;
                function writeCommentRangeWithMap(comment, writer) {
                    recordSourceMapSpan(comment.pos);
                    writeCommentRange(comment, writer);
                    recordSourceMapSpan(comment.end);
                }
                function serializeSourceMapContents(version, file, sourceRoot, sources, names, mappings) {
                    if (typeof JSON !== "undefined") {
                        return JSON.stringify({
                            version: version,
                            file: file,
                            sourceRoot: sourceRoot,
                            sources: sources,
                            names: names,
                            mappings: mappings
                        });
                    }
                    return "{\"version\":" + version + ",\"file\":\"" + ts.escapeString(file) + "\",\"sourceRoot\":\"" + ts.escapeString(sourceRoot) + "\",\"sources\":[" + serializeStringArray(sources) + "],\"names\":[" + serializeStringArray(names) + "],\"mappings\":\"" + ts.escapeString(mappings) + "\"}";
                    function serializeStringArray(list) {
                        var output = "";
                        for (var i = 0, n = list.length; i < n; i++) {
                            if (i) {
                                output += ",";
                            }
                            output += "\"" + ts.escapeString(list[i]) + "\"";
                        }
                        return output;
                    }
                }
                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {
                    // Write source map file
                    encodeLastRecordedSourceMapSpan();
                    writeFile(sourceMapData.sourceMapFilePath, serializeSourceMapContents(3, sourceMapData.sourceMapFile, sourceMapData.sourceMapSourceRoot, sourceMapData.sourceMapSources, sourceMapData.sourceMapNames, sourceMapData.sourceMapMappings), false);
                    sourceMapDataList.push(sourceMapData);
                    // Write sourcemap url to the js file and write the js file
                    writeJavaScriptFile(emitOutput + "//# sourceMappingURL=" + sourceMapData.jsSourceMappingURL, writeByteOrderMark);
                }
                // Initialize source map data
                var sourceMapJsFile = ts.getBaseFilename(ts.normalizeSlashes(jsFilePath));
                sourceMapData = {
                    sourceMapFilePath: jsFilePath + ".map",
                    jsSourceMappingURL: sourceMapJsFile + ".map",
                    sourceMapFile: sourceMapJsFile,
                    sourceMapSourceRoot: compilerOptions.sourceRoot || "",
                    sourceMapSources: [],
                    inputSourceFileNames: [],
                    sourceMapNames: [],
                    sourceMapMappings: "",
                    sourceMapDecodedMappings: []
                };
                // Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the 
                // relative paths of the sources list in the sourcemap
                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);
                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {
                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;
                }
                if (compilerOptions.mapRoot) {
                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);
                    if (root) {
                        // For modules or multiple emit files the mapRoot will have directory structure like the sources
                        // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                        sourceMapDir = ts.getDirectoryPath(getSourceFilePathInNewDir(sourceMapDir, root));
                    }
                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {
                        // The relative paths are relative to the common directory
                        sourceMapDir = ts.combinePaths(program.getCommonSourceDirectory(), sourceMapDir);
                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, true);
                    }
                    else {
                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);
                    }
                }
                else {
                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));
                }
                function emitNodeWithMap(node) {
                    if (node) {
                        if (node.kind != 193 /* SourceFile */) {
                            recordEmitNodeStartSpan(node);
                            emitNode(node);
                            recordEmitNodeEndSpan(node);
                        }
                        else {
                            recordNewSourceFileStart(node);
                            emitNode(node);
                        }
                    }
                }
                writeEmittedFiles = writeJavaScriptAndSourceMapFile;
                emit = emitNodeWithMap;
                emitStart = recordEmitNodeStartSpan;
                emitEnd = recordEmitNodeEndSpan;
                emitToken = writeTextWithSpanRecord;
                scopeEmitStart = recordScopeNameOfNode;
                scopeEmitEnd = recordScopeNameEnd;
                writeComment = writeCommentRangeWithMap;
            }
            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {
                writeFile(jsFilePath, emitOutput, writeByteOrderMark);
            }
            function emitTokenText(tokenKind, startPos, emitFn) {
                var tokenString = ts.tokenToString(tokenKind);
                if (emitFn) {
                    emitFn();
                }
                else {
                    write(tokenString);
                }
                return startPos + tokenString.length;
            }
            function emitOptional(prefix, node) {
                if (node) {
                    write(prefix);
                    emit(node);
                }
            }
            function emitTrailingCommaIfPresent(nodeList, isMultiline) {
                if (nodeList.hasTrailingComma) {
                    write(",");
                    if (isMultiline) {
                        writeLine();
                    }
                }
            }
            function emitCommaList(nodes, includeTrailingComma, count) {
                if (!(count >= 0)) {
                    count = nodes.length;
                }
                if (nodes) {
                    for (var i = 0; i < count; i++) {
                        if (i) {
                            write(", ");
                        }
                        emit(nodes[i]);
                    }
                    if (includeTrailingComma) {
                        emitTrailingCommaIfPresent(nodes, false);
                    }
                }
            }
            function emitMultiLineList(nodes, includeTrailingComma) {
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i) {
                            write(",");
                        }
                        writeLine();
                        emit(nodes[i]);
                    }
                    if (includeTrailingComma) {
                        emitTrailingCommaIfPresent(nodes, true);
                    }
                }
            }
            function emitLines(nodes) {
                emitLinesStartingAt(nodes, 0);
            }
            function emitLinesStartingAt(nodes, startIndex) {
                for (var i = startIndex; i < nodes.length; i++) {
                    writeLine();
                    emit(nodes[i]);
                }
            }
            function emitLiteral(node) {
                var text = getLiteralText();
                if (compilerOptions.sourceMap && (node.kind === 7 /* StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {
                    writer.writeLiteral(text);
                }
                else {
                    write(text);
                }
                function getLiteralText() {
                    if (compilerOptions.target < 2 /* ES6 */ && ts.isTemplateLiteralKind(node.kind)) {
                        return getTemplateLiteralAsStringLiteral(node);
                    }
                    return getSourceTextOfLocalNode(node);
                }
            }
            function getTemplateLiteralAsStringLiteral(node) {
                return '"' + ts.escapeString(node.text) + '"';
            }
            function emitTemplateExpression(node) {
                // In ES6 mode and above, we can simply emit each portion of a template in order, but in
                // ES3 & ES5 we must convert the template expression into a series of string concatenations.
                if (compilerOptions.target >= 2 /* ES6 */) {
                    ts.forEachChild(node, emit);
                    return;
                }
                ts.Debug.assert(node.parent.kind !== 146 /* TaggedTemplateExpression */);
                var templateNeedsParens = ts.isExpression(node.parent) && node.parent.kind !== 148 /* ParenExpression */ && comparePrecedenceToBinaryPlus(node.parent) !== -1 /* LessThan */;
                if (templateNeedsParens) {
                    write("(");
                }
                emitLiteral(node.head);
                ts.forEach(node.templateSpans, function (templateSpan) {
                    // Check if the expression has operands and binds its operands less closely than binary '+'.
                    // If it does, we need to wrap the expression in parentheses. Otherwise, something like
                    //    `abc${ 1 << 2}`
                    // becomes
                    //    "abc" + 1 << 2 + ""
                    // which is really
                    //    ("abc" + 1) << (2 + "")
                    // rather than
                    //    "abc" + (1 << 2) + ""
                    var needsParens = templateSpan.expression.kind !== 148 /* ParenExpression */ && comparePrecedenceToBinaryPlus(templateSpan.expression) !== 1 /* GreaterThan */;
                    write(" + ");
                    if (needsParens) {
                        write("(");
                    }
                    emit(templateSpan.expression);
                    if (needsParens) {
                        write(")");
                    }
                    // Only emit if the literal is non-empty.
                    // The binary '+' operator is left-associative, so the first string concatenation will force
                    // the result up to this point to be a string. Emitting a '+ ""' has no semantic effect.
                    if (templateSpan.literal.text.length !== 0) {
                        write(" + ");
                        emitLiteral(templateSpan.literal);
                    }
                });
                if (templateNeedsParens) {
                    write(")");
                }
                /**
                 * Returns whether the expression has lesser, greater,
                 * or equal precedence to the binary '+' operator
                 */
                function comparePrecedenceToBinaryPlus(expression) {
                    // All binary expressions have lower precedence than '+' apart from '*', '/', and '%'.
                    // All unary operators have a higher precedence apart from yield.
                    // Arrow functions and conditionals have a lower precedence, 
                    // although we convert the former into regular function expressions in ES5 mode,
                    // and in ES6 mode this function won't get called anyway.
                    // 
                    // TODO (drosen): Note that we need to account for the upcoming 'yield' and
                    //                spread ('...') unary operators that are anticipated for ES6.
                    ts.Debug.assert(compilerOptions.target <= 1 /* ES5 */);
                    switch (expression.kind) {
                        case 153 /* BinaryExpression */:
                            switch (expression.operator) {
                                case 34 /* AsteriskToken */:
                                case 35 /* SlashToken */:
                                case 36 /* PercentToken */:
                                    return 1 /* GreaterThan */;
                                case 32 /* PlusToken */:
                                    return 0 /* EqualTo */;
                                default:
                                    return -1 /* LessThan */;
                            }
                        case 154 /* ConditionalExpression */:
                            return -1 /* LessThan */;
                        default:
                            return 1 /* GreaterThan */;
                    }
                }
            }
            function emitTemplateSpan(span) {
                emit(span.expression);
                emit(span.literal);
            }
            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.
            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.
            function emitExpressionForPropertyName(node) {
                if (node.kind === 7 /* StringLiteral */) {
                    emitLiteral(node);
                }
                else {
                    write("\"");
                    if (node.kind === 6 /* NumericLiteral */) {
                        write(node.text);
                    }
                    else {
                        write(getSourceTextOfLocalNode(node));
                    }
                    write("\"");
                }
            }
            function isNonExpressionIdentifier(node) {
                var parent = node.parent;
                switch (parent.kind) {
                    case 123 /* Parameter */:
                    case 181 /* VariableDeclaration */:
                    case 124 /* Property */:
                    case 141 /* PropertyAssignment */:
                    case 192 /* EnumMember */:
                    case 125 /* Method */:
                    case 182 /* FunctionDeclaration */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 149 /* FunctionExpression */:
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                    case 188 /* ModuleDeclaration */:
                    case 190 /* ImportDeclaration */:
                        return parent.name === node;
                    case 168 /* BreakStatement */:
                    case 167 /* ContinueStatement */:
                    case 191 /* ExportAssignment */:
                        return false;
                    case 174 /* LabeledStatement */:
                        return node.parent.label === node;
                    case 178 /* CatchBlock */:
                        return node.parent.variable === node;
                }
            }
            function emitIdentifier(node) {
                if (!isNonExpressionIdentifier(node)) {
                    var prefix = resolver.getExpressionNamePrefix(node);
                    if (prefix) {
                        write(prefix);
                        write(".");
                    }
                }
                write(getSourceTextOfLocalNode(node));
            }
            function emitThis(node) {
                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {
                    write("_this");
                }
                else {
                    write("this");
                }
            }
            function emitSuper(node) {
                var flags = resolver.getNodeCheckFlags(node);
                if (flags & 16 /* SuperInstance */) {
                    write("_super.prototype");
                }
                else if (flags & 32 /* SuperStatic */) {
                    write("_super");
                }
                else {
                    write("super");
                }
            }
            function emitArrayLiteral(node) {
                if (node.flags & 256 /* MultiLine */) {
                    write("[");
                    increaseIndent();
                    emitMultiLineList(node.elements, true);
                    decreaseIndent();
                    writeLine();
                    write("]");
                }
                else {
                    write("[");
                    emitCommaList(node.elements, true);
                    write("]");
                }
            }
            function emitObjectLiteral(node) {
                if (!node.properties.length) {
                    write("{}");
                }
                else if (node.flags & 256 /* MultiLine */) {
                    write("{");
                    increaseIndent();
                    emitMultiLineList(node.properties, compilerOptions.target >= 1 /* ES5 */);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
                else {
                    write("{ ");
                    emitCommaList(node.properties, compilerOptions.target >= 1 /* ES5 */);
                    write(" }");
                }
            }
            function emitPropertyAssignment(node) {
                emitLeadingComments(node);
                emit(node.name);
                write(": ");
                emit(node.initializer);
                emitTrailingComments(node);
            }
            function tryEmitConstantValue(node) {
                var constantValue = resolver.getConstantValue(node);
                if (constantValue !== undefined) {
                    var propertyName = node.kind === 142 /* PropertyAccess */ ? ts.declarationNameToString(node.right) : ts.getTextOfNode(node.index);
                    write(constantValue.toString() + " /* " + propertyName + " */");
                    return true;
                }
                return false;
            }
            function emitPropertyAccess(node) {
                if (tryEmitConstantValue(node)) {
                    return;
                }
                emit(node.left);
                write(".");
                emit(node.right);
            }
            function emitIndexedAccess(node) {
                if (tryEmitConstantValue(node)) {
                    return;
                }
                emit(node.object);
                write("[");
                emit(node.index);
                write("]");
            }
            function emitCallExpression(node) {
                var superCall = false;
                if (node.func.kind === 89 /* SuperKeyword */) {
                    write("_super");
                    superCall = true;
                }
                else {
                    emit(node.func);
                    superCall = node.func.kind === 142 /* PropertyAccess */ && node.func.left.kind === 89 /* SuperKeyword */;
                }
                if (superCall) {
                    write(".call(");
                    emitThis(node.func);
                    if (node.arguments.length) {
                        write(", ");
                        emitCommaList(node.arguments, false);
                    }
                    write(")");
                }
                else {
                    write("(");
                    emitCommaList(node.arguments, false);
                    write(")");
                }
            }
            function emitNewExpression(node) {
                write("new ");
                emit(node.func);
                if (node.arguments) {
                    write("(");
                    emitCommaList(node.arguments, false);
                    write(")");
                }
            }
            function emitTaggedTemplateExpression(node) {
                ts.Debug.assert(compilerOptions.target >= 2 /* ES6 */, "Trying to emit a tagged template in pre-ES6 mode.");
                emit(node.tag);
                write(" ");
                emit(node.template);
            }
            function emitParenExpression(node) {
                if (node.expression.kind === 147 /* TypeAssertion */) {
                    var operand = node.expression.operand;
                    while (operand.kind == 147 /* TypeAssertion */) {
                        operand = operand.operand;
                    }
                    // We have an expression of the form: (<Type>SubExpr)
                    // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.
                    // Omitting the parentheses, however, could cause change in the semantics of the generated
                    // code if the casted expression has a lower precedence than the rest of the expression, e.g.: 
                    //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo
                    //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()
                    //      new (<any>A()) should be emitted as new (A()) and not new A()
                    //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()
                    if (operand.kind !== 151 /* PrefixOperator */ && operand.kind !== 152 /* PostfixOperator */ && operand.kind !== 145 /* NewExpression */ && !(operand.kind === 144 /* CallExpression */ && node.parent.kind === 145 /* NewExpression */) && !(operand.kind === 149 /* FunctionExpression */ && node.parent.kind === 144 /* CallExpression */)) {
                        emit(operand);
                        return;
                    }
                }
                write("(");
                emit(node.expression);
                write(")");
            }
            function emitUnaryExpression(node) {
                if (node.kind === 151 /* PrefixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
                // In some cases, we need to emit a space between the operator and the operand. One obvious case
                // is when the operator is an identifier, like delete or typeof. We also need to do this for plus
                // and minus expressions in certain cases. Specifically, consider the following two cases (parens
                // are just for clarity of exposition, and not part of the source code):
                //
                //  (+(+1))
                //  (+(++1))
                //
                // We need to emit a space in both cases. In the first case, the absence of a space will make
                // the resulting expression a prefix increment operation. And in the second, it will make the resulting
                // expression a prefix increment whose operand is a plus expression - (++(+x))
                // The same is true of minus of course.
                if (node.operator >= 63 /* Identifier */) {
                    write(" ");
                }
                else if (node.kind === 151 /* PrefixOperator */ && node.operand.kind === 151 /* PrefixOperator */) {
                    var operand = node.operand;
                    if (node.operator === 32 /* PlusToken */ && (operand.operator === 32 /* PlusToken */ || operand.operator === 37 /* PlusPlusToken */)) {
                        write(" ");
                    }
                    else if (node.operator === 33 /* MinusToken */ && (operand.operator === 33 /* MinusToken */ || operand.operator === 38 /* MinusMinusToken */)) {
                        write(" ");
                    }
                }
                emit(node.operand);
                if (node.kind === 152 /* PostfixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
            }
            function emitBinaryExpression(node) {
                emit(node.left);
                if (node.operator !== 22 /* CommaToken */)
                    write(" ");
                write(ts.tokenToString(node.operator));
                write(" ");
                emit(node.right);
            }
            function emitConditionalExpression(node) {
                emit(node.condition);
                write(" ? ");
                emit(node.whenTrue);
                write(" : ");
                emit(node.whenFalse);
            }
            function emitBlock(node) {
                emitToken(13 /* OpenBraceToken */, node.pos);
                increaseIndent();
                scopeEmitStart(node.parent);
                if (node.kind === 189 /* ModuleBlock */) {
                    ts.Debug.assert(node.parent.kind === 188 /* ModuleDeclaration */);
                    emitCaptureThisForNodeIfNecessary(node.parent);
                }
                emitLines(node.statements);
                decreaseIndent();
                writeLine();
                emitToken(14 /* CloseBraceToken */, node.statements.end);
                scopeEmitEnd();
            }
            function emitEmbeddedStatement(node) {
                if (node.kind === 158 /* Block */) {
                    write(" ");
                    emit(node);
                }
                else {
                    increaseIndent();
                    writeLine();
                    emit(node);
                    decreaseIndent();
                }
            }
            function emitExpressionStatement(node) {
                var isArrowExpression = node.expression.kind === 150 /* ArrowFunction */;
                emitLeadingComments(node);
                if (isArrowExpression)
                    write("(");
                emit(node.expression);
                if (isArrowExpression)
                    write(")");
                write(";");
                emitTrailingComments(node);
            }
            function emitIfStatement(node) {
                emitLeadingComments(node);
                var endPos = emitToken(82 /* IfKeyword */, node.pos);
                write(" ");
                endPos = emitToken(15 /* OpenParenToken */, endPos);
                emit(node.expression);
                emitToken(16 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.thenStatement);
                if (node.elseStatement) {
                    writeLine();
                    emitToken(74 /* ElseKeyword */, node.thenStatement.end);
                    if (node.elseStatement.kind === 162 /* IfStatement */) {
                        write(" ");
                        emit(node.elseStatement);
                    }
                    else {
                        emitEmbeddedStatement(node.elseStatement);
                    }
                }
                emitTrailingComments(node);
            }
            function emitDoStatement(node) {
                write("do");
                emitEmbeddedStatement(node.statement);
                if (node.statement.kind === 158 /* Block */) {
                    write(" ");
                }
                else {
                    writeLine();
                }
                write("while (");
                emit(node.expression);
                write(");");
            }
            function emitWhileStatement(node) {
                write("while (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForStatement(node) {
                var endPos = emitToken(80 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(15 /* OpenParenToken */, endPos);
                if (node.declarations) {
                    if (node.declarations[0] && node.declarations[0].flags & 2048 /* Let */) {
                        emitToken(102 /* LetKeyword */, endPos);
                    }
                    else if (node.declarations[0] && node.declarations[0].flags & 4096 /* Const */) {
                        emitToken(68 /* ConstKeyword */, endPos);
                    }
                    else {
                        emitToken(96 /* VarKeyword */, endPos);
                    }
                    write(" ");
                    emitCommaList(node.declarations, false);
                }
                if (node.initializer) {
                    emit(node.initializer);
                }
                write(";");
                emitOptional(" ", node.condition);
                write(";");
                emitOptional(" ", node.iterator);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForInStatement(node) {
                var endPos = emitToken(80 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(15 /* OpenParenToken */, endPos);
                if (node.declaration) {
                    if (node.declaration.flags & 2048 /* Let */) {
                        emitToken(102 /* LetKeyword */, endPos);
                    }
                    else {
                        emitToken(96 /* VarKeyword */, endPos);
                    }
                    write(" ");
                    emit(node.declaration);
                }
                else {
                    emit(node.variable);
                }
                write(" in ");
                emit(node.expression);
                emitToken(16 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.statement);
            }
            function emitBreakOrContinueStatement(node) {
                emitToken(node.kind === 168 /* BreakStatement */ ? 64 /* BreakKeyword */ : 69 /* ContinueKeyword */, node.pos);
                emitOptional(" ", node.label);
                write(";");
            }
            function emitReturnStatement(node) {
                emitLeadingComments(node);
                emitToken(88 /* ReturnKeyword */, node.pos);
                emitOptional(" ", node.expression);
                write(";");
                emitTrailingComments(node);
            }
            function emitWithStatement(node) {
                write("with (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitSwitchStatement(node) {
                var endPos = emitToken(90 /* SwitchKeyword */, node.pos);
                write(" ");
                emitToken(15 /* OpenParenToken */, endPos);
                emit(node.expression);
                endPos = emitToken(16 /* CloseParenToken */, node.expression.end);
                write(" ");
                emitToken(13 /* OpenBraceToken */, endPos);
                increaseIndent();
                emitLines(node.clauses);
                decreaseIndent();
                writeLine();
                emitToken(14 /* CloseBraceToken */, node.clauses.end);
            }
            function isOnSameLine(node1, node2) {
                return getLineOfLocalPosition(ts.skipTrivia(currentSourceFile.text, node1.pos)) === getLineOfLocalPosition(ts.skipTrivia(currentSourceFile.text, node2.pos));
            }
            function emitCaseOrDefaultClause(node) {
                if (node.kind === 172 /* CaseClause */) {
                    write("case ");
                    emit(node.expression);
                    write(":");
                }
                else {
                    write("default:");
                }
                if (node.statements.length === 1 && isOnSameLine(node, node.statements[0])) {
                    write(" ");
                    emit(node.statements[0]);
                }
                else {
                    increaseIndent();
                    emitLines(node.statements);
                    decreaseIndent();
                }
            }
            function emitThrowStatement(node) {
                write("throw ");
                emit(node.expression);
                write(";");
            }
            function emitTryStatement(node) {
                write("try ");
                emit(node.tryBlock);
                emit(node.catchBlock);
                if (node.finallyBlock) {
                    writeLine();
                    write("finally ");
                    emit(node.finallyBlock);
                }
            }
            function emitCatchBlock(node) {
                writeLine();
                var endPos = emitToken(66 /* CatchKeyword */, node.pos);
                write(" ");
                emitToken(15 /* OpenParenToken */, endPos);
                emit(node.variable);
                emitToken(16 /* CloseParenToken */, node.variable.end);
                write(" ");
                emitBlock(node);
            }
            function emitDebuggerStatement(node) {
                emitToken(70 /* DebuggerKeyword */, node.pos);
                write(";");
            }
            function emitLabelledStatement(node) {
                emit(node.label);
                write(": ");
                emit(node.statement);
            }
            function getContainingModule(node) {
                do {
                    node = node.parent;
                } while (node && node.kind !== 188 /* ModuleDeclaration */);
                return node;
            }
            function emitModuleMemberName(node) {
                emitStart(node.name);
                if (node.flags & 1 /* Export */) {
                    var container = getContainingModule(node);
                    write(container ? resolver.getLocalNameOfContainer(container) : "exports");
                    write(".");
                }
                emitNode(node.name);
                emitEnd(node.name);
            }
            function emitVariableDeclaration(node) {
                emitLeadingComments(node);
                emitModuleMemberName(node);
                emitOptional(" = ", node.initializer);
                emitTrailingComments(node);
            }
            function emitVariableStatement(node) {
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */)) {
                    if (node.flags & 2048 /* Let */) {
                        write("let ");
                    }
                    else if (node.flags & 4096 /* Const */) {
                        write("const ");
                    }
                    else {
                        write("var ");
                    }
                }
                emitCommaList(node.declarations, false);
                write(";");
                emitTrailingComments(node);
            }
            function emitParameter(node) {
                emitLeadingComments(node);
                emit(node.name);
                emitTrailingComments(node);
            }
            function emitDefaultValueAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.initializer) {
                        writeLine();
                        emitStart(param);
                        write("if (");
                        emitNode(param.name);
                        write(" === void 0)");
                        emitEnd(param);
                        write(" { ");
                        emitStart(param);
                        emitNode(param.name);
                        write(" = ");
                        emitNode(param.initializer);
                        emitEnd(param);
                        write("; }");
                    }
                });
            }
            function emitRestParameter(node) {
                if (ts.hasRestParameters(node)) {
                    var restIndex = node.parameters.length - 1;
                    var restParam = node.parameters[restIndex];
                    writeLine();
                    emitLeadingComments(restParam);
                    emitStart(restParam);
                    write("var ");
                    emitNode(restParam.name);
                    write(" = [];");
                    emitEnd(restParam);
                    emitTrailingComments(restParam);
                    writeLine();
                    write("for (");
                    emitStart(restParam);
                    write("var _i = " + restIndex + ";");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i < arguments.length;");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i++");
                    emitEnd(restParam);
                    write(") {");
                    increaseIndent();
                    writeLine();
                    emitStart(restParam);
                    emitNode(restParam.name);
                    write("[_i - " + restIndex + "] = arguments[_i];");
                    emitEnd(restParam);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
            }
            function emitAccessor(node) {
                emitLeadingComments(node);
                write(node.kind === 127 /* GetAccessor */ ? "get " : "set ");
                emit(node.name);
                emitSignatureAndBody(node);
                emitTrailingComments(node);
            }
            function emitFunctionDeclaration(node) {
                if (!node.body) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                if (node.kind !== 125 /* Method */) {
                    // Methods will emit the comments as part of emitting method declaration
                    emitLeadingComments(node);
                }
                write("function ");
                if (node.kind === 182 /* FunctionDeclaration */ || (node.kind === 149 /* FunctionExpression */ && node.name)) {
                    emit(node.name);
                }
                emitSignatureAndBody(node);
                if (node.kind !== 125 /* Method */) {
                    emitTrailingComments(node);
                }
            }
            function emitCaptureThisForNodeIfNecessary(node) {
                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {
                    writeLine();
                    emitStart(node);
                    write("var _this = this;");
                    emitEnd(node);
                }
            }
            function emitSignatureParameters(node) {
                increaseIndent();
                write("(");
                if (node) {
                    emitCommaList(node.parameters, false, node.parameters.length - (ts.hasRestParameters(node) ? 1 : 0));
                }
                write(")");
                decreaseIndent();
            }
            function emitSignatureAndBody(node) {
                emitSignatureParameters(node);
                write(" {");
                scopeEmitStart(node);
                increaseIndent();
                emitDetachedComments(node.body.kind === 183 /* FunctionBlock */ ? node.body.statements : node.body);
                var startIndex = 0;
                if (node.body.kind === 183 /* FunctionBlock */) {
                    startIndex = emitDirectivePrologues(node.body.statements, true);
                }
                var outPos = writer.getTextPos();
                emitCaptureThisForNodeIfNecessary(node);
                emitDefaultValueAssignments(node);
                emitRestParameter(node);
                if (node.body.kind !== 183 /* FunctionBlock */ && outPos === writer.getTextPos()) {
                    decreaseIndent();
                    write(" ");
                    emitStart(node.body);
                    write("return ");
                    emitNode(node.body);
                    emitEnd(node.body);
                    write("; ");
                    emitStart(node.body);
                    write("}");
                    emitEnd(node.body);
                }
                else {
                    if (node.body.kind === 183 /* FunctionBlock */) {
                        emitLinesStartingAt(node.body.statements, startIndex);
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node.body);
                        write("return ");
                        emit(node.body);
                        write(";");
                        emitTrailingComments(node.body);
                    }
                    writeLine();
                    if (node.body.kind === 183 /* FunctionBlock */) {
                        emitLeadingCommentsOfPosition(node.body.statements.end);
                        decreaseIndent();
                        emitToken(14 /* CloseBraceToken */, node.body.statements.end);
                    }
                    else {
                        decreaseIndent();
                        emitStart(node.body);
                        write("}");
                        emitEnd(node.body);
                    }
                }
                scopeEmitEnd();
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
            }
            function findInitialSuperCall(ctor) {
                if (ctor.body) {
                    var statement = ctor.body.statements[0];
                    if (statement && statement.kind === 161 /* ExpressionStatement */) {
                        var expr = statement.expression;
                        if (expr && expr.kind === 144 /* CallExpression */) {
                            var func = expr.func;
                            if (func && func.kind === 89 /* SuperKeyword */) {
                                return statement;
                            }
                        }
                    }
                }
            }
            function emitParameterPropertyAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.flags & 112 /* AccessibilityModifier */) {
                        writeLine();
                        emitStart(param);
                        emitStart(param.name);
                        write("this.");
                        emitNode(param.name);
                        emitEnd(param.name);
                        write(" = ");
                        emit(param.name);
                        write(";");
                        emitEnd(param);
                    }
                });
            }
            // TODO(jfreeman): Account for computed property name
            function emitMemberAccess(memberName) {
                if (memberName.kind === 7 /* StringLiteral */ || memberName.kind === 6 /* NumericLiteral */) {
                    write("[");
                    emitNode(memberName);
                    write("]");
                }
                else {
                    write(".");
                    emitNode(memberName);
                }
            }
            function emitMemberAssignments(node, staticFlag) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 124 /* Property */ && (member.flags & 128 /* Static */) === staticFlag && member.initializer) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        if (staticFlag) {
                            emitNode(node.name);
                        }
                        else {
                            write("this");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emit(member.initializer);
                        write(";");
                        emitEnd(member);
                        emitTrailingComments(member);
                    }
                });
            }
            function emitMemberFunctions(node) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 125 /* Method */) {
                        if (!member.body) {
                            return emitPinnedOrTripleSlashComments(member);
                        }
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        emitNode(node.name);
                        if (!(member.flags & 128 /* Static */)) {
                            write(".prototype");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emitStart(member);
                        emitFunctionDeclaration(member);
                        emitEnd(member);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    }
                    else if (member.kind === 127 /* GetAccessor */ || member.kind === 128 /* SetAccessor */) {
                        var accessors = getAllAccessorDeclarations(node, member);
                        if (member === accessors.firstAccessor) {
                            writeLine();
                            emitStart(member);
                            write("Object.defineProperty(");
                            emitStart(member.name);
                            emitNode(node.name);
                            if (!(member.flags & 128 /* Static */)) {
                                write(".prototype");
                            }
                            write(", ");
                            emitExpressionForPropertyName(member.name);
                            emitEnd(member.name);
                            write(", {");
                            increaseIndent();
                            if (accessors.getAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.getAccessor);
                                write("get: ");
                                emitStart(accessors.getAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.getAccessor);
                                emitEnd(accessors.getAccessor);
                                emitTrailingComments(accessors.getAccessor);
                                write(",");
                            }
                            if (accessors.setAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.setAccessor);
                                write("set: ");
                                emitStart(accessors.setAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.setAccessor);
                                emitEnd(accessors.setAccessor);
                                emitTrailingComments(accessors.setAccessor);
                                write(",");
                            }
                            writeLine();
                            write("enumerable: true,");
                            writeLine();
                            write("configurable: true");
                            decreaseIndent();
                            writeLine();
                            write("});");
                            emitEnd(member);
                        }
                    }
                });
            }
            function emitClassDeclaration(node) {
                emitLeadingComments(node);
                write("var ");
                emit(node.name);
                write(" = (function (");
                if (node.baseType) {
                    write("_super");
                }
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                if (node.baseType) {
                    writeLine();
                    emitStart(node.baseType);
                    write("__extends(");
                    emit(node.name);
                    write(", _super);");
                    emitEnd(node.baseType);
                }
                writeLine();
                emitConstructorOfClass();
                emitMemberFunctions(node);
                emitMemberAssignments(node, 128 /* Static */);
                writeLine();
                function emitClassReturnStatement() {
                    write("return ");
                    emitNode(node.name);
                }
                emitToken(14 /* CloseBraceToken */, node.members.end, emitClassReturnStatement);
                write(";");
                decreaseIndent();
                writeLine();
                emitToken(14 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                emitStart(node);
                write(")(");
                if (node.baseType) {
                    emit(node.baseType.typeName);
                }
                write(");");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitConstructorOfClass() {
                    // Emit the constructor overload pinned comments
                    ts.forEach(node.members, function (member) {
                        if (member.kind === 126 /* Constructor */ && !member.body) {
                            emitPinnedOrTripleSlashComments(member);
                        }
                    });
                    var ctor = getFirstConstructorWithBody(node);
                    if (ctor) {
                        emitLeadingComments(ctor);
                    }
                    emitStart(ctor || node);
                    write("function ");
                    emit(node.name);
                    emitSignatureParameters(ctor);
                    write(" {");
                    scopeEmitStart(node, "constructor");
                    increaseIndent();
                    if (ctor) {
                        emitDetachedComments(ctor.body.statements);
                    }
                    emitCaptureThisForNodeIfNecessary(node);
                    if (ctor) {
                        emitDefaultValueAssignments(ctor);
                        emitRestParameter(ctor);
                        if (node.baseType) {
                            var superCall = findInitialSuperCall(ctor);
                            if (superCall) {
                                writeLine();
                                emit(superCall);
                            }
                        }
                        emitParameterPropertyAssignments(ctor);
                    }
                    else {
                        if (node.baseType) {
                            writeLine();
                            emitStart(node.baseType);
                            write("_super.apply(this, arguments);");
                            emitEnd(node.baseType);
                        }
                    }
                    emitMemberAssignments(node, 0);
                    if (ctor) {
                        var statements = ctor.body.statements;
                        if (superCall)
                            statements = statements.slice(1);
                        emitLines(statements);
                    }
                    writeLine();
                    if (ctor) {
                        emitLeadingCommentsOfPosition(ctor.body.statements.end);
                    }
                    decreaseIndent();
                    emitToken(14 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);
                    scopeEmitEnd();
                    emitEnd(ctor || node);
                    if (ctor) {
                        emitTrailingComments(ctor);
                    }
                }
            }
            function emitInterfaceDeclaration(node) {
                emitPinnedOrTripleSlashComments(node);
            }
            function emitEnumDeclaration(node) {
                // const enums are completely erased during compilation.
                var isConstEnum = ts.isConstEnumDeclaration(node);
                if (isConstEnum && !compilerOptions.preserveConstEnums) {
                    return;
                }
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */)) {
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                writeLine();
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                emitEnumMemberDeclarations(isConstEnum);
                decreaseIndent();
                writeLine();
                emitToken(14 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                write(")(");
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    write(" = ");
                    emitModuleMemberName(node);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitEnumMemberDeclarations(isConstEnum) {
                    ts.forEach(node.members, function (member) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        emitExpressionForPropertyName(member.name);
                        write("] = ");
                        if (member.initializer && !isConstEnum) {
                            emit(member.initializer);
                        }
                        else {
                            write(resolver.getEnumMemberValue(member).toString());
                        }
                        write("] = ");
                        emitExpressionForPropertyName(member.name);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    });
                }
            }
            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
                if (moduleDeclaration.body.kind === 188 /* ModuleDeclaration */) {
                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                    return recursiveInnerModule || moduleDeclaration.body;
                }
            }
            function emitModuleDeclaration(node) {
                if (ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                emitLeadingComments(node);
                emitStart(node);
                write("var ");
                emit(node.name);
                write(";");
                emitEnd(node);
                writeLine();
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") ");
                if (node.body.kind === 189 /* ModuleBlock */) {
                    emit(node.body);
                }
                else {
                    write("{");
                    increaseIndent();
                    scopeEmitStart(node);
                    emitCaptureThisForNodeIfNecessary(node);
                    writeLine();
                    emit(node.body);
                    decreaseIndent();
                    writeLine();
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    emitToken(14 /* CloseBraceToken */, moduleBlock.statements.end);
                    scopeEmitEnd();
                }
                write(")(");
                if (node.flags & 1 /* Export */) {
                    emit(node.name);
                    write(" = ");
                }
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                emitTrailingComments(node);
            }
            function emitImportDeclaration(node) {
                var emitImportDeclaration = resolver.isReferencedImportDeclaration(node);
                if (!emitImportDeclaration) {
                    // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
                    // - current file is not external module
                    // - import declaration is top level and target is value imported by entity name
                    emitImportDeclaration = !ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportWithEntityName(node);
                }
                if (emitImportDeclaration) {
                    if (node.externalModuleName && node.parent.kind === 193 /* SourceFile */ && compilerOptions.module === 2 /* AMD */) {
                        if (node.flags & 1 /* Export */) {
                            writeLine();
                            emitLeadingComments(node);
                            emitStart(node);
                            emitModuleMemberName(node);
                            write(" = ");
                            emit(node.name);
                            write(";");
                            emitEnd(node);
                            emitTrailingComments(node);
                        }
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node);
                        emitStart(node);
                        if (!(node.flags & 1 /* Export */))
                            write("var ");
                        emitModuleMemberName(node);
                        write(" = ");
                        if (node.entityName) {
                            emit(node.entityName);
                        }
                        else {
                            write("require(");
                            emitStart(node.externalModuleName);
                            emitLiteral(node.externalModuleName);
                            emitEnd(node.externalModuleName);
                            emitToken(16 /* CloseParenToken */, node.externalModuleName.end);
                        }
                        write(";");
                        emitEnd(node);
                        emitTrailingComments(node);
                    }
                }
            }
            function getExternalImportDeclarations(node) {
                var result = [];
                ts.forEach(node.statements, function (stat) {
                    if (stat.kind === 190 /* ImportDeclaration */ && stat.externalModuleName && resolver.isReferencedImportDeclaration(stat)) {
                        result.push(stat);
                    }
                });
                return result;
            }
            function getFirstExportAssignment(sourceFile) {
                return ts.forEach(sourceFile.statements, function (node) {
                    if (node.kind === 191 /* ExportAssignment */) {
                        return node;
                    }
                });
            }
            function emitAMDModule(node, startIndex) {
                var imports = getExternalImportDeclarations(node);
                writeLine();
                write("define([\"require\", \"exports\"");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emitLiteral(imp.externalModuleName);
                });
                ts.forEach(node.amdDependencies, function (amdDependency) {
                    var text = "\"" + amdDependency + "\"";
                    write(", ");
                    write(text);
                });
                write("], function (require, exports");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emit(imp.name);
                });
                write(") {");
                increaseIndent();
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("return ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
                decreaseIndent();
                writeLine();
                write("});");
            }
            function emitCommonJSModule(node, startIndex) {
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("module.exports = ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
            }
            function emitDirectivePrologues(statements, startWithNewLine) {
                for (var i = 0; i < statements.length; ++i) {
                    if (ts.isPrologueDirective(statements[i])) {
                        if (startWithNewLine || i > 0) {
                            writeLine();
                        }
                        emit(statements[i]);
                    }
                    else {
                        // return index of the first non prologue directive
                        return i;
                    }
                }
                return statements.length;
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                // Start new file on new line
                writeLine();
                emitDetachedComments(node);
                // emit prologue directives prior to __extends
                var startIndex = emitDirectivePrologues(node.statements, false);
                if (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */) {
                    writeLine();
                    write("var __extends = this.__extends || function (d, b) {");
                    increaseIndent();
                    writeLine();
                    write("for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    writeLine();
                    write("function __() { this.constructor = d; }");
                    writeLine();
                    write("__.prototype = b.prototype;");
                    writeLine();
                    write("d.prototype = new __();");
                    decreaseIndent();
                    writeLine();
                    write("};");
                    extendsEmitted = true;
                }
                if (ts.isExternalModule(node)) {
                    if (compilerOptions.module === 2 /* AMD */) {
                        emitAMDModule(node, startIndex);
                    }
                    else {
                        emitCommonJSModule(node, startIndex);
                    }
                }
                else {
                    emitCaptureThisForNodeIfNecessary(node);
                    emitLinesStartingAt(node.statements, startIndex);
                }
            }
            function emitNode(node) {
                if (!node) {
                    return;
                }
                if (node.flags & 2 /* Ambient */) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                switch (node.kind) {
                    case 63 /* Identifier */:
                        return emitIdentifier(node);
                    case 123 /* Parameter */:
                        return emitParameter(node);
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                        return emitAccessor(node);
                    case 91 /* ThisKeyword */:
                        return emitThis(node);
                    case 89 /* SuperKeyword */:
                        return emitSuper(node);
                    case 87 /* NullKeyword */:
                        return write("null");
                    case 93 /* TrueKeyword */:
                        return write("true");
                    case 78 /* FalseKeyword */:
                        return write("false");
                    case 6 /* NumericLiteral */:
                    case 7 /* StringLiteral */:
                    case 8 /* RegularExpressionLiteral */:
                    case 9 /* NoSubstitutionTemplateLiteral */:
                    case 10 /* TemplateHead */:
                    case 11 /* TemplateMiddle */:
                    case 12 /* TemplateTail */:
                        return emitLiteral(node);
                    case 155 /* TemplateExpression */:
                        return emitTemplateExpression(node);
                    case 156 /* TemplateSpan */:
                        return emitTemplateSpan(node);
                    case 121 /* QualifiedName */:
                        return emitPropertyAccess(node);
                    case 139 /* ArrayLiteral */:
                        return emitArrayLiteral(node);
                    case 140 /* ObjectLiteral */:
                        return emitObjectLiteral(node);
                    case 141 /* PropertyAssignment */:
                        return emitPropertyAssignment(node);
                    case 142 /* PropertyAccess */:
                        return emitPropertyAccess(node);
                    case 143 /* IndexedAccess */:
                        return emitIndexedAccess(node);
                    case 144 /* CallExpression */:
                        return emitCallExpression(node);
                    case 145 /* NewExpression */:
                        return emitNewExpression(node);
                    case 146 /* TaggedTemplateExpression */:
                        return emitTaggedTemplateExpression(node);
                    case 147 /* TypeAssertion */:
                        return emit(node.operand);
                    case 148 /* ParenExpression */:
                        return emitParenExpression(node);
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                    case 150 /* ArrowFunction */:
                        return emitFunctionDeclaration(node);
                    case 151 /* PrefixOperator */:
                    case 152 /* PostfixOperator */:
                        return emitUnaryExpression(node);
                    case 153 /* BinaryExpression */:
                        return emitBinaryExpression(node);
                    case 154 /* ConditionalExpression */:
                        return emitConditionalExpression(node);
                    case 157 /* OmittedExpression */:
                        return;
                    case 158 /* Block */:
                    case 177 /* TryBlock */:
                    case 179 /* FinallyBlock */:
                    case 183 /* FunctionBlock */:
                    case 189 /* ModuleBlock */:
                        return emitBlock(node);
                    case 159 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 160 /* EmptyStatement */:
                        return write(";");
                    case 161 /* ExpressionStatement */:
                        return emitExpressionStatement(node);
                    case 162 /* IfStatement */:
                        return emitIfStatement(node);
                    case 163 /* DoStatement */:
                        return emitDoStatement(node);
                    case 164 /* WhileStatement */:
                        return emitWhileStatement(node);
                    case 165 /* ForStatement */:
                        return emitForStatement(node);
                    case 166 /* ForInStatement */:
                        return emitForInStatement(node);
                    case 167 /* ContinueStatement */:
                    case 168 /* BreakStatement */:
                        return emitBreakOrContinueStatement(node);
                    case 169 /* ReturnStatement */:
                        return emitReturnStatement(node);
                    case 170 /* WithStatement */:
                        return emitWithStatement(node);
                    case 171 /* SwitchStatement */:
                        return emitSwitchStatement(node);
                    case 172 /* CaseClause */:
                    case 173 /* DefaultClause */:
                        return emitCaseOrDefaultClause(node);
                    case 174 /* LabeledStatement */:
                        return emitLabelledStatement(node);
                    case 175 /* ThrowStatement */:
                        return emitThrowStatement(node);
                    case 176 /* TryStatement */:
                        return emitTryStatement(node);
                    case 178 /* CatchBlock */:
                        return emitCatchBlock(node);
                    case 180 /* DebuggerStatement */:
                        return emitDebuggerStatement(node);
                    case 181 /* VariableDeclaration */:
                        return emitVariableDeclaration(node);
                    case 184 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 185 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 187 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 188 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 190 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 193 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function hasDetachedComments(pos) {
                return detachedCommentsInfo !== undefined && detachedCommentsInfo[detachedCommentsInfo.length - 1].nodePos === pos;
            }
            function getLeadingCommentsWithoutDetachedComments() {
                // get the leading comments from detachedPos
                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, detachedCommentsInfo[detachedCommentsInfo.length - 1].detachedCommentEndPos);
                if (detachedCommentsInfo.length - 1) {
                    detachedCommentsInfo.pop();
                }
                else {
                    detachedCommentsInfo = undefined;
                }
                return leadingComments;
            }
            function getLeadingCommentsToEmit(node) {
                // Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments
                if (node.parent.kind === 193 /* SourceFile */ || node.pos !== node.parent.pos) {
                    var leadingComments;
                    if (hasDetachedComments(node.pos)) {
                        // get comments without detached comments
                        leadingComments = getLeadingCommentsWithoutDetachedComments();
                    }
                    else {
                        // get the leading comments from the node
                        leadingComments = ts.getLeadingCommentRangesOfNode(node, currentSourceFile);
                    }
                    return leadingComments;
                }
            }
            function emitLeadingDeclarationComments(node) {
                var leadingComments = getLeadingCommentsToEmit(node);
                emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitTrailingDeclarationComments(node) {
                // Emit the trailing comments only if the parent's end doesn't match
                if (node.parent.kind === 193 /* SourceFile */ || node.end !== node.parent.end) {
                    var trailingComments = ts.getTrailingCommentRanges(currentSourceFile.text, node.end);
                    // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/
                    emitComments(trailingComments, false, writer, writeComment);
                }
            }
            function emitLeadingCommentsOfLocalPosition(pos) {
                var leadingComments;
                if (hasDetachedComments(pos)) {
                    // get comments without detached comments
                    leadingComments = getLeadingCommentsWithoutDetachedComments();
                }
                else {
                    // get the leading comments from the node
                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, pos);
                }
                emitNewLineBeforeLeadingComments({ pos: pos, end: pos }, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitDetachedCommentsAtPosition(node) {
                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, node.pos);
                if (leadingComments) {
                    var detachedComments = [];
                    var lastComment;
                    ts.forEach(leadingComments, function (comment) {
                        if (lastComment) {
                            var lastCommentLine = getLineOfLocalPosition(lastComment.end);
                            var commentLine = getLineOfLocalPosition(comment.pos);
                            if (commentLine >= lastCommentLine + 2) {
                                // There was a blank line between the last comment and this comment.  This
                                // comment is not part of the copyright comments.  Return what we have so 
                                // far.
                                return detachedComments;
                            }
                        }
                        detachedComments.push(comment);
                        lastComment = comment;
                    });
                    if (detachedComments.length) {
                        // All comments look like they could have been part of the copyright header.  Make
                        // sure there is at least one blank line between it and the node.  If not, it's not
                        // a copyright header.
                        var lastCommentLine = getLineOfLocalPosition(detachedComments[detachedComments.length - 1].end);
                        var astLine = getLineOfLocalPosition(ts.skipTrivia(currentSourceFile.text, node.pos));
                        if (astLine >= lastCommentLine + 2) {
                            // Valid detachedComments
                            emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                            emitComments(detachedComments, true, writer, writeComment);
                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: detachedComments[detachedComments.length - 1].end };
                            if (detachedCommentsInfo) {
                                detachedCommentsInfo.push(currentDetachedCommentInfo);
                            }
                            else {
                                detachedCommentsInfo = [currentDetachedCommentInfo];
                            }
                        }
                    }
                }
            }
            function emitPinnedOrTripleSlashCommentsOfNode(node) {
                var pinnedComments = ts.filter(getLeadingCommentsToEmit(node), isPinnedOrTripleSlashComment);
                function isPinnedOrTripleSlashComment(comment) {
                    if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                        return currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;
                    }
                    else if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ && comment.pos + 2 < comment.end && currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */ && currentSourceFile.text.substring(comment.pos, comment.end).match(ts.fullTripleSlashReferencePathRegEx)) {
                        return true;
                    }
                }
                emitNewLineBeforeLeadingComments(node, pinnedComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(pinnedComments, true, writer, writeComment);
            }
            if (compilerOptions.sourceMap) {
                initializeEmitterWithSourceMaps();
            }
            if (root) {
                emit(root);
            }
            else {
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        emit(sourceFile);
                    }
                });
            }
            writeLine();
            writeEmittedFiles(writer.getText(), compilerOptions.emitBOM);
        }
        function emitDeclarations(jsFilePath, root) {
            var writer = createTextWriterWithSymbolWriter();
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var enclosingDeclaration;
            var reportedDeclarationError = false;
            var emitJsDocComments = compilerOptions.removeComments ? function (declaration) {
            } : writeJsDocComments;
            var aliasDeclarationEmitInfo = [];
            var getSymbolVisibilityDiagnosticMessage;
            function createTextWriterWithSymbolWriter() {
                var writer = createTextWriter();
                writer.trackSymbol = trackSymbol;
                writer.writeKeyword = writer.write;
                writer.writeOperator = writer.write;
                writer.writePunctuation = writer.write;
                writer.writeSpace = writer.write;
                writer.writeStringLiteral = writer.writeLiteral;
                writer.writeParameter = writer.write;
                writer.writeSymbol = writer.write;
                return writer;
            }
            function writeAsychronousImportDeclarations(importDeclarations) {
                var oldWriter = writer;
                ts.forEach(importDeclarations, function (aliasToWrite) {
                    var aliasEmitInfo = ts.forEach(aliasDeclarationEmitInfo, function (declEmitInfo) { return declEmitInfo.declaration === aliasToWrite ? declEmitInfo : undefined; });
                    writer = createTextWriterWithSymbolWriter();
                    for (var declarationIndent = aliasEmitInfo.indent; declarationIndent; declarationIndent--) {
                        writer.increaseIndent();
                    }
                    writeImportDeclaration(aliasToWrite);
                    aliasEmitInfo.asynchronousOutput = writer.getText();
                });
                writer = oldWriter;
            }
            function trackSymbol(symbol, enclosingDeclaration, meaning) {
                var symbolAccesibilityResult = resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning);
                if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                    // write the aliases
                    if (symbolAccesibilityResult && symbolAccesibilityResult.aliasesToMakeVisible) {
                        writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                    }
                }
                else {
                    // Report error
                    reportedDeclarationError = true;
                    var errorInfo = getSymbolVisibilityDiagnosticMessage(symbolAccesibilityResult);
                    if (errorInfo) {
                        if (errorInfo.typeName) {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, getSourceTextOfLocalNode(errorInfo.typeName), symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                        else {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                    }
                }
            }
            function emitLines(nodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    emitNode(nodes[i]);
                }
            }
            function emitCommaList(nodes, eachNodeEmitFn) {
                var currentWriterPos = writer.getTextPos();
                for (var i = 0, n = nodes.length; i < n; i++) {
                    if (currentWriterPos !== writer.getTextPos()) {
                        write(", ");
                    }
                    currentWriterPos = writer.getTextPos();
                    eachNodeEmitFn(nodes[i]);
                }
            }
            function writeJsDocComments(declaration) {
                if (declaration) {
                    var jsDocComments = ts.getJsDocComments(declaration, currentSourceFile);
                    emitNewLineBeforeLeadingComments(declaration, jsDocComments, writer);
                    // jsDoc comments are emitted at /*leading comment1 */space/*leading comment*/space
                    emitComments(jsDocComments, true, writer, writeCommentRange);
                }
            }
            function emitSourceTextOfNode(node) {
                write(getSourceTextOfLocalNode(node));
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                enclosingDeclaration = node;
                emitLines(node.statements);
            }
            function emitExportAssignment(node) {
                write("export = ");
                emitSourceTextOfNode(node.exportName);
                write(";");
                writeLine();
            }
            function emitDeclarationFlags(node) {
                if (node.flags & 128 /* Static */) {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    else if (node.flags & 64 /* Protected */) {
                        write("protected ");
                    }
                    write("static ");
                }
                else {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    else if (node.flags & 64 /* Protected */) {
                        write("protected ");
                    }
                    else if (node.parent === currentSourceFile) {
                        // If the node is exported 
                        if (node.flags & 1 /* Export */) {
                            write("export ");
                        }
                        if (node.kind !== 185 /* InterfaceDeclaration */) {
                            write("declare ");
                        }
                    }
                }
            }
            function emitImportDeclaration(node) {
                var nodeEmitInfo = {
                    declaration: node,
                    outputPos: writer.getTextPos(),
                    indent: writer.getIndent(),
                    hasWritten: resolver.isDeclarationVisible(node)
                };
                aliasDeclarationEmitInfo.push(nodeEmitInfo);
                if (nodeEmitInfo.hasWritten) {
                    writeImportDeclaration(node);
                }
            }
            function writeImportDeclaration(node) {
                // note usage of writer. methods instead of aliases created, just to make sure we are using 
                // correct writer especially to handle asynchronous alias writing
                emitJsDocComments(node);
                if (node.flags & 1 /* Export */) {
                    writer.write("export ");
                }
                writer.write("import ");
                writer.write(getSourceTextOfLocalNode(node.name));
                writer.write(" = ");
                if (node.entityName) {
                    checkEntityNameAccessible();
                    writer.write(getSourceTextOfLocalNode(node.entityName));
                    writer.write(";");
                }
                else {
                    writer.write("require(");
                    writer.write(getSourceTextOfLocalNode(node.externalModuleName));
                    writer.write(");");
                }
                writer.writeLine();
                function checkEntityNameAccessible() {
                    var symbolAccesibilityResult = resolver.isImportDeclarationEntityNameReferenceDeclarationVisibile(node.entityName);
                    if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                        // write the aliases
                        if (symbolAccesibilityResult.aliasesToMakeVisible) {
                            writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                        }
                    }
                    else {
                        // Report error
                        reportedDeclarationError = true;
                        diagnostics.push(ts.createDiagnosticForNode(node, ts.Diagnostics.Import_declaration_0_is_using_private_name_1, getSourceTextOfLocalNode(node.name), symbolAccesibilityResult.errorSymbolName));
                    }
                }
            }
            function emitModuleDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("module ");
                    emitSourceTextOfNode(node.name);
                    while (node.body.kind !== 189 /* ModuleBlock */) {
                        node = node.body;
                        write(".");
                        emitSourceTextOfNode(node.name);
                    }
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.body.statements);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitTypeAliasDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("type ");
                    emitSourceTextOfNode(node.name);
                    write(" = ");
                    getSymbolVisibilityDiagnosticMessage = getTypeAliasDeclarationVisibilityError;
                    resolver.writeTypeAtLocation(node.type, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    write(";");
                    writeLine();
                }
                function getTypeAliasDeclarationVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Exported_type_alias_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Exported_type_alias_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Exported_type_alias_0_has_or_is_using_private_name_1;
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    };
                }
            }
            function emitEnumDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    if (ts.isConstEnumDeclaration(node)) {
                        write("const ");
                    }
                    write("enum ");
                    emitSourceTextOfNode(node.name);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                }
            }
            function emitEnumMemberDeclaration(node) {
                emitJsDocComments(node);
                emitSourceTextOfNode(node.name);
                var enumMemberValue = resolver.getEnumMemberValue(node);
                if (enumMemberValue !== undefined) {
                    write(" = ");
                    write(enumMemberValue.toString());
                }
                write(",");
                writeLine();
            }
            function emitTypeParameters(typeParameters) {
                function emitTypeParameter(node) {
                    function getTypeParameterConstraintVisibilityError(symbolAccesibilityResult) {
                        // Type parameter constraints are named by user so we should always be able to name it
                        var diagnosticMessage;
                        switch (node.parent.kind) {
                            case 184 /* ClassDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;
                                break;
                            case 185 /* InterfaceDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 130 /* ConstructSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 129 /* CallSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 125 /* Method */:
                                if (node.parent.flags & 128 /* Static */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else if (node.parent.parent.kind === 184 /* ClassDeclaration */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                                }
                                break;
                            case 182 /* FunctionDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;
                                break;
                            default:
                                ts.Debug.fail("This is unknown parent for type parameter: " + node.parent.kind);
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.name
                        };
                    }
                    increaseIndent();
                    emitJsDocComments(node);
                    decreaseIndent();
                    emitSourceTextOfNode(node.name);
                    // If there is constraint present and this is not a type parameter of the private method emit the constraint
                    if (node.constraint && (node.parent.kind !== 125 /* Method */ || !(node.parent.flags & 32 /* Private */))) {
                        write(" extends ");
                        getSymbolVisibilityDiagnosticMessage = getTypeParameterConstraintVisibilityError;
                        resolver.writeTypeAtLocation(node.constraint, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                if (typeParameters) {
                    write("<");
                    emitCommaList(typeParameters, emitTypeParameter);
                    write(">");
                }
            }
            function emitHeritageClause(typeReferences, isImplementsList) {
                if (typeReferences) {
                    write(isImplementsList ? " implements " : " extends ");
                    emitCommaList(typeReferences, emitTypeOfTypeReference);
                }
                function emitTypeOfTypeReference(node) {
                    getSymbolVisibilityDiagnosticMessage = getHeritageClauseVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 1 /* WriteArrayAsGenericType */ | 2 /* UseTypeOfFunction */, writer);
                    function getHeritageClauseVisibilityError(symbolAccesibilityResult) {
                        var diagnosticMessage;
                        // Heritage clause is written by user so it can always be named
                        if (node.parent.kind === 184 /* ClassDeclaration */) {
                            // Class
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // Class or Interface implemented/extended is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_private_name_1;
                            }
                        }
                        else {
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // interface is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;
                            }
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.parent.name
                        };
                    }
                }
            }
            function emitClassDeclaration(node) {
                function emitParameterProperties(constructorDeclaration) {
                    if (constructorDeclaration) {
                        ts.forEach(constructorDeclaration.parameters, function (param) {
                            if (param.flags & 112 /* AccessibilityModifier */) {
                                emitPropertyDeclaration(param);
                            }
                        });
                    }
                }
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("class ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    if (node.baseType) {
                        emitHeritageClause([node.baseType], false);
                    }
                    emitHeritageClause(node.implementedTypes, true);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitParameterProperties(getFirstConstructorWithBody(node));
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitInterfaceDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("interface ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    emitHeritageClause(node.baseTypes, false);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitPropertyDeclaration(node) {
                emitJsDocComments(node);
                emitDeclarationFlags(node);
                emitVariableDeclaration(node);
                write(";");
                writeLine();
            }
            // TODO(jfreeman): Factor out common part of property definition, but treat name differently
            function emitVariableDeclaration(node) {
                // If we are emitting property it isn't moduleElement and hence we already know it needs to be emitted
                // so there is no check needed to see if declaration is visible
                if (node.kind !== 181 /* VariableDeclaration */ || resolver.isDeclarationVisible(node)) {
                    emitSourceTextOfNode(node.name);
                    // If optional property emit ?
                    if (node.kind === 124 /* Property */ && (node.flags & 4 /* QuestionMark */)) {
                        write("?");
                    }
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getVariableDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                function getVariableDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 181 /* VariableDeclaration */) {
                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;
                    }
                    else if (node.kind === 124 /* Property */) {
                        // TODO(jfreeman): Deal with computed properties in error reporting.
                        if (node.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else if (node.parent.kind === 184 /* ClassDeclaration */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            // Interfaces cannot have types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;
                        }
                    }
                    return diagnosticMessage !== undefined ? {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    } : undefined;
                }
            }
            function emitVariableStatement(node) {
                var hasDeclarationWithEmit = ts.forEach(node.declarations, function (varDeclaration) { return resolver.isDeclarationVisible(varDeclaration); });
                if (hasDeclarationWithEmit) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    if (node.flags & 2048 /* Let */) {
                        write("let ");
                    }
                    else if (node.flags & 4096 /* Const */) {
                        write("const ");
                    }
                    else {
                        write("var ");
                    }
                    emitCommaList(node.declarations, emitVariableDeclaration);
                    write(";");
                    writeLine();
                }
            }
            function emitAccessorDeclaration(node) {
                var accessors = getAllAccessorDeclarations(node.parent, node);
                if (node === accessors.firstAccessor) {
                    emitJsDocComments(accessors.getAccessor);
                    emitJsDocComments(accessors.setAccessor);
                    emitDeclarationFlags(node);
                    emitSourceTextOfNode(node.name);
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getAccessorDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                    write(";");
                    writeLine();
                }
                function getAccessorDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 128 /* SetAccessor */) {
                        // Setters have to have type named and cannot infer it so, the type should always be named
                        if (node.parent.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.parameters[0],
                            // TODO(jfreeman): Investigate why we are passing node.name instead of node.parameters[0].name
                            typeName: node.name
                        };
                    }
                    else {
                        if (node.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.name,
                            typeName: undefined
                        };
                    }
                }
            }
            function emitFunctionDeclaration(node) {
                // If we are emitting Method/Constructor it isn't moduleElement and hence already determined to be emitting
                // so no need to verify if the declaration is visible
                if ((node.kind !== 182 /* FunctionDeclaration */ || resolver.isDeclarationVisible(node)) && !resolver.isImplementationOfOverload(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    if (node.kind === 182 /* FunctionDeclaration */) {
                        write("function ");
                        emitSourceTextOfNode(node.name);
                    }
                    else if (node.kind === 126 /* Constructor */) {
                        write("constructor");
                    }
                    else {
                        emitSourceTextOfNode(node.name);
                        if (node.flags & 4 /* QuestionMark */) {
                            write("?");
                        }
                    }
                    emitSignatureDeclaration(node);
                }
            }
            function emitConstructSignatureDeclaration(node) {
                emitJsDocComments(node);
                write("new ");
                emitSignatureDeclaration(node);
            }
            function emitSignatureDeclaration(node) {
                if (node.kind === 129 /* CallSignature */ || node.kind === 131 /* IndexSignature */) {
                    // Only index and call signatures are emitted directly, so emit their js doc comments, rest will do that in their own functions
                    emitJsDocComments(node);
                }
                emitTypeParameters(node.typeParameters);
                if (node.kind === 131 /* IndexSignature */) {
                    write("[");
                }
                else {
                    write("(");
                }
                // Parameters
                emitCommaList(node.parameters, emitParameterDeclaration);
                if (node.kind === 131 /* IndexSignature */) {
                    write("]");
                }
                else {
                    write(")");
                }
                // If this is not a constructor and is not private, emit the return type
                if (node.kind !== 126 /* Constructor */ && !(node.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getReturnTypeVisibilityError;
                    resolver.writeReturnTypeOfSignatureDeclaration(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                write(";");
                writeLine();
                function getReturnTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.kind) {
                        case 130 /* ConstructSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 129 /* CallSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 131 /* IndexSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 125 /* Method */:
                            if (node.flags & 128 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else if (node.parent.kind === 184 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else {
                                // Interfaces cannot have return types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;
                            }
                            break;
                        case 182 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;
                            break;
                        default:
                            ts.Debug.fail("This is unknown kind for signature: " + node.kind);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node.name || node
                    };
                }
            }
            function emitParameterDeclaration(node) {
                increaseIndent();
                emitJsDocComments(node);
                if (node.flags & 8 /* Rest */) {
                    write("...");
                }
                emitSourceTextOfNode(node.name);
                if (node.initializer || (node.flags & 4 /* QuestionMark */)) {
                    write("?");
                }
                decreaseIndent();
                if (!(node.parent.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getParameterDeclarationTypeVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                function getParameterDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.parent.kind) {
                        case 126 /* Constructor */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;
                            break;
                        case 130 /* ConstructSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 129 /* CallSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 125 /* Method */:
                            if (node.parent.flags & 128 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else if (node.parent.parent.kind === 184 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else {
                                // Interfaces cannot have parameter types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                            }
                            break;
                        case 182 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;
                            break;
                        default:
                            ts.Debug.fail("This is unknown parent for parameter: " + node.parent.kind);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    };
                }
            }
            function emitNode(node) {
                switch (node.kind) {
                    case 126 /* Constructor */:
                    case 182 /* FunctionDeclaration */:
                    case 125 /* Method */:
                        return emitFunctionDeclaration(node);
                    case 130 /* ConstructSignature */:
                        return emitConstructSignatureDeclaration(node);
                    case 129 /* CallSignature */:
                    case 131 /* IndexSignature */:
                        return emitSignatureDeclaration(node);
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                        return emitAccessorDeclaration(node);
                    case 159 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 124 /* Property */:
                        return emitPropertyDeclaration(node);
                    case 185 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 184 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 186 /* TypeAliasDeclaration */:
                        return emitTypeAliasDeclaration(node);
                    case 192 /* EnumMember */:
                        return emitEnumMemberDeclaration(node);
                    case 187 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 188 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 190 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 191 /* ExportAssignment */:
                        return emitExportAssignment(node);
                    case 193 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function tryResolveScriptReference(sourceFile, reference) {
                var referenceFileName = ts.normalizePath(ts.combinePaths(ts.getDirectoryPath(sourceFile.filename), reference.filename));
                return program.getSourceFile(referenceFileName);
            }
            // Contains the reference paths that needs to go in the declaration file. 
            // Collecting this separately because reference paths need to be first thing in the declaration file 
            // and we could be collecting these paths from multiple files into single one with --out option
            var referencePathsOutput = "";
            function writeReferencePath(referencedFile) {
                var declFileName = referencedFile.flags & 1024 /* DeclarationFile */ ? referencedFile.filename : shouldEmitToOwnFile(referencedFile, compilerOptions) ? getOwnEmitOutputFilePath(referencedFile, ".d.ts") : ts.removeFileExtension(compilerOptions.out) + ".d.ts"; // Global out file
                declFileName = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizeSlashes(jsFilePath)), declFileName, compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, false);
                referencePathsOutput += "/// <reference path=\"" + declFileName + "\" />" + newLine;
            }
            if (root) {
                // Emitting just a single file, so emit references in this file only
                if (!compilerOptions.noResolve) {
                    var addedGlobalFileReference = false;
                    ts.forEach(root.referencedFiles, function (fileReference) {
                        var referencedFile = tryResolveScriptReference(root, fileReference);
                        // All the references that are not going to be part of same file
                        if (referencedFile && ((referencedFile.flags & 1024 /* DeclarationFile */) || shouldEmitToOwnFile(referencedFile, compilerOptions) || !addedGlobalFileReference)) {
                            writeReferencePath(referencedFile);
                            if (!isExternalModuleOrDeclarationFile(referencedFile)) {
                                addedGlobalFileReference = true;
                            }
                        }
                    });
                }
                emitNode(root);
            }
            else {
                // Emit references corresponding to this file
                var emittedReferencedFiles = [];
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        // Check what references need to be added
                        if (!compilerOptions.noResolve) {
                            ts.forEach(sourceFile.referencedFiles, function (fileReference) {
                                var referencedFile = tryResolveScriptReference(sourceFile, fileReference);
                                // If the reference file is a declaration file or an external module, emit that reference
                                if (referencedFile && (isExternalModuleOrDeclarationFile(referencedFile) && !ts.contains(emittedReferencedFiles, referencedFile))) {
                                    writeReferencePath(referencedFile);
                                    emittedReferencedFiles.push(referencedFile);
                                }
                            });
                        }
                        emitNode(sourceFile);
                    }
                });
            }
            // TODO(shkamat): Should we not write any declaration file if any of them can produce error, 
            // or should we just not write this file like we are doing now
            if (!reportedDeclarationError) {
                var declarationOutput = referencePathsOutput;
                var synchronousDeclarationOutput = writer.getText();
                // apply additions
                var appliedSyncOutputPos = 0;
                ts.forEach(aliasDeclarationEmitInfo, function (aliasEmitInfo) {
                    if (aliasEmitInfo.asynchronousOutput) {
                        declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);
                        declarationOutput += aliasEmitInfo.asynchronousOutput;
                        appliedSyncOutputPos = aliasEmitInfo.outputPos;
                    }
                });
                declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos);
                writeFile(ts.removeFileExtension(jsFilePath) + ".d.ts", declarationOutput, compilerOptions.emitBOM);
            }
        }
        var hasSemanticErrors = resolver.hasSemanticErrors();
        var hasEarlyErrors = resolver.hasEarlyErrors(targetSourceFile);
        function emitFile(jsFilePath, sourceFile) {
            if (!hasEarlyErrors) {
                emitJavaScript(jsFilePath, sourceFile);
                if (!hasSemanticErrors && compilerOptions.declaration) {
                    emitDeclarations(jsFilePath, sourceFile);
                }
            }
        }
        if (targetSourceFile === undefined) {
            // No targetSourceFile is specified (e.g. calling emitter from batch compiler)
            ts.forEach(program.getSourceFiles(), function (sourceFile) {
                if (shouldEmitToOwnFile(sourceFile, compilerOptions)) {
                    var jsFilePath = getOwnEmitOutputFilePath(sourceFile, ".js");
                    emitFile(jsFilePath, sourceFile);
                }
            });
            if (compilerOptions.out) {
                emitFile(compilerOptions.out);
            }
        }
        else {
            // targetSourceFile is specified (e.g calling emitter from language service or calling getSemanticDiagnostic from language service)
            if (shouldEmitToOwnFile(targetSourceFile, compilerOptions)) {
                // If shouldEmitToOwnFile returns true or targetSourceFile is an external module file, then emit targetSourceFile in its own output file
                var jsFilePath = getOwnEmitOutputFilePath(targetSourceFile, ".js");
                emitFile(jsFilePath, targetSourceFile);
            }
            else if (!ts.isDeclarationFile(targetSourceFile) && compilerOptions.out) {
                // Otherwise, if --out is specified and targetSourceFile is not a declaration file,
                // Emit all, non-external-module file, into one single output file
                emitFile(compilerOptions.out);
            }
        }
        // Sort and make the unique list of diagnostics
        diagnostics.sort(ts.compareDiagnostics);
        diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
        // Update returnCode if there is any EmitterError
        var hasEmitterError = ts.forEach(diagnostics, function (diagnostic) { return diagnostic.category === 1 /* Error */; });
        // Check and update returnCode for syntactic and semantic
        var returnCode;
        if (hasEarlyErrors) {
            returnCode = 1 /* AllOutputGenerationSkipped */;
        }
        else if (hasEmitterError) {
            returnCode = 4 /* EmitErrorsEncountered */;
        }
        else if (hasSemanticErrors && compilerOptions.declaration) {
            returnCode = 3 /* DeclarationGenerationSkipped */;
        }
        else if (hasSemanticErrors && !compilerOptions.declaration) {
            returnCode = 2 /* JSGeneratedWithSemanticErrors */;
        }
        else {
            returnCode = 0 /* Succeeded */;
        }
        return {
            emitResultStatus: returnCode,
            errors: diagnostics,
            sourceMaps: sourceMapDataList
        };
    }
    ts.emitFiles = emitFiles;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
/// <reference path="binder.ts"/>
/// <reference path="emitter.ts"/>
var ts;
(function (ts) {
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    function getDeclarationOfKind(symbol, kind) {
        var declarations = symbol.declarations;
        for (var i = 0; i < declarations.length; i++) {
            var declaration = declarations[i];
            if (declaration.kind === kind) {
                return declaration;
            }
        }
        return undefined;
    }
    ts.getDeclarationOfKind = getDeclarationOfKind;
    // Pool writers to avoid needing to allocate them for every symbol we write.
    var stringWriters = [];
    function getSingleLineStringWriter() {
        if (stringWriters.length == 0) {
            var str = "";
            var writeText = function (text) { return str += text; };
            return {
                string: function () { return str; },
                writeKeyword: writeText,
                writeOperator: writeText,
                writePunctuation: writeText,
                writeSpace: writeText,
                writeStringLiteral: writeText,
                writeParameter: writeText,
                writeSymbol: writeText,
                // Completely ignore indentation for string writers.  And map newlines to
                // a single space.
                writeLine: function () { return str += " "; },
                increaseIndent: function () {
                },
                decreaseIndent: function () {
                },
                clear: function () { return str = ""; },
                trackSymbol: function () {
                }
            };
        }
        return stringWriters.pop();
    }
    ts.getSingleLineStringWriter = getSingleLineStringWriter;
    /// fullTypeCheck denotes if this instance of the typechecker will be used to get semantic diagnostics.
    /// If fullTypeCheck === true,  then the typechecker should do every possible check to produce all errors
    /// If fullTypeCheck === false, the typechecker can take shortcuts and skip checks that only produce errors.
    /// NOTE: checks that somehow affect decisions being made during typechecking should be executed in both cases.
    function createTypeChecker(program, fullTypeCheck) {
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        var Type = ts.objectAllocator.getTypeConstructor();
        var Signature = ts.objectAllocator.getSignatureConstructor();
        var typeCount = 0;
        var emptyArray = [];
        var emptySymbols = {};
        var compilerOptions = program.getCompilerOptions();
        var checker = {
            getProgram: function () { return program; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getNodeCount: function () { return ts.sum(program.getSourceFiles(), "nodeCount"); },
            getIdentifierCount: function () { return ts.sum(program.getSourceFiles(), "identifierCount"); },
            getSymbolCount: function () { return ts.sum(program.getSourceFiles(), "symbolCount"); },
            getTypeCount: function () { return typeCount; },
            checkProgram: checkProgram,
            emitFiles: invokeEmitter,
            getParentOfSymbol: getParentOfSymbol,
            getNarrowedTypeOfSymbol: getNarrowedTypeOfSymbol,
            getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
            getPropertiesOfType: getPropertiesOfType,
            getPropertyOfType: getPropertyOfType,
            getSignaturesOfType: getSignaturesOfType,
            getIndexTypeOfType: getIndexTypeOfType,
            getReturnTypeOfSignature: getReturnTypeOfSignature,
            getSymbolsInScope: getSymbolsInScope,
            getSymbolInfo: getSymbolInfo,
            getTypeOfNode: getTypeOfNode,
            typeToString: typeToString,
            getSymbolDisplayBuilder: getSymbolDisplayBuilder,
            symbolToString: symbolToString,
            getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
            getRootSymbols: getRootSymbols,
            getContextualType: getContextualType,
            getFullyQualifiedName: getFullyQualifiedName,
            getResolvedSignature: getResolvedSignature,
            getEnumMemberValue: getEnumMemberValue,
            isValidPropertyAccess: isValidPropertyAccess,
            getSignatureFromDeclaration: getSignatureFromDeclaration,
            isImplementationOfOverload: isImplementationOfOverload,
            getAliasedSymbol: resolveImport,
            isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },
            isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },
            hasEarlyErrors: hasEarlyErrors
        };
        var undefinedSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, "undefined");
        var argumentsSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, "arguments");
        var unknownSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, "unknown");
        var resolvingSymbol = createSymbol(268435456 /* Transient */, "__resolving__");
        var anyType = createIntrinsicType(1 /* Any */, "any");
        var stringType = createIntrinsicType(2 /* String */, "string");
        var numberType = createIntrinsicType(4 /* Number */, "number");
        var booleanType = createIntrinsicType(8 /* Boolean */, "boolean");
        var voidType = createIntrinsicType(16 /* Void */, "void");
        var undefinedType = createIntrinsicType(32 /* Undefined */, "undefined");
        var nullType = createIntrinsicType(64 /* Null */, "null");
        var unknownType = createIntrinsicType(1 /* Any */, "unknown");
        var resolvingType = createIntrinsicType(1 /* Any */, "__resolving__");
        var emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var noConstraintType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var inferenceFailureType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anySignature = createSignature(undefined, undefined, emptyArray, anyType, 0, false, false);
        var unknownSignature = createSignature(undefined, undefined, emptyArray, unknownType, 0, false, false);
        var globals = {};
        var globalArraySymbol;
        var globalObjectType;
        var globalFunctionType;
        var globalArrayType;
        var globalStringType;
        var globalNumberType;
        var globalBooleanType;
        var globalRegExpType;
        var tupleTypes = {};
        var unionTypes = {};
        var stringLiteralTypes = {};
        var emitExtends = false;
        var mergedSymbols = [];
        var symbolLinks = [];
        var nodeLinks = [];
        var potentialThisCollisions = [];
        var diagnostics = [];
        var diagnosticsModified = false;
        function addDiagnostic(diagnostic) {
            diagnostics.push(diagnostic);
            diagnosticsModified = true;
        }
        function error(location, message, arg0, arg1, arg2) {
            var diagnostic = location ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2) : ts.createCompilerDiagnostic(message, arg0, arg1, arg2);
            addDiagnostic(diagnostic);
        }
        function createSymbol(flags, name) {
            return new Symbol(flags, name);
        }
        function getExcludedSymbolFlags(flags) {
            var result = 0;
            if (flags & 2 /* BlockScopedVariable */)
                result |= 107455 /* BlockScopedVariableExcludes */;
            if (flags & 1 /* FunctionScopedVariable */)
                result |= 107454 /* FunctionScopedVariableExcludes */;
            if (flags & 4 /* Property */)
                result |= 107455 /* PropertyExcludes */;
            if (flags & 8 /* EnumMember */)
                result |= 107455 /* EnumMemberExcludes */;
            if (flags & 16 /* Function */)
                result |= 106927 /* FunctionExcludes */;
            if (flags & 32 /* Class */)
                result |= 3258879 /* ClassExcludes */;
            if (flags & 64 /* Interface */)
                result |= 3152288 /* InterfaceExcludes */;
            if (flags & 256 /* RegularEnum */)
                result |= 3258623 /* RegularEnumExcludes */;
            if (flags & 128 /* ConstEnum */)
                result |= 3259263 /* ConstEnumExcludes */;
            if (flags & 512 /* ValueModule */)
                result |= 106639 /* ValueModuleExcludes */;
            if (flags & 8192 /* Method */)
                result |= 99263 /* MethodExcludes */;
            if (flags & 32768 /* GetAccessor */)
                result |= 41919 /* GetAccessorExcludes */;
            if (flags & 65536 /* SetAccessor */)
                result |= 74687 /* SetAccessorExcludes */;
            if (flags & 1048576 /* TypeParameter */)
                result |= 2103776 /* TypeParameterExcludes */;
            if (flags & 2097152 /* TypeAlias */)
                result |= 3152352 /* TypeAliasExcludes */;
            if (flags & 33554432 /* Import */)
                result |= 33554432 /* ImportExcludes */;
            return result;
        }
        function recordMergedSymbol(target, source) {
            if (!source.mergeId)
                source.mergeId = nextMergeId++;
            mergedSymbols[source.mergeId] = target;
        }
        function cloneSymbol(symbol) {
            var result = createSymbol(symbol.flags | 134217728 /* Merged */, symbol.name);
            result.declarations = symbol.declarations.slice(0);
            result.parent = symbol.parent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.constEnumOnlyModule)
                result.constEnumOnlyModule = true;
            if (symbol.members)
                result.members = cloneSymbolTable(symbol.members);
            if (symbol.exports)
                result.exports = cloneSymbolTable(symbol.exports);
            recordMergedSymbol(result, symbol);
            return result;
        }
        function extendSymbol(target, source) {
            if (!(target.flags & getExcludedSymbolFlags(source.flags))) {
                if (source.flags & 512 /* ValueModule */ && target.flags & 512 /* ValueModule */ && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                    // reset flag when merging instantiated module into value module that has only const enums
                    target.constEnumOnlyModule = false;
                }
                target.flags |= source.flags;
                if (!target.valueDeclaration && source.valueDeclaration)
                    target.valueDeclaration = source.valueDeclaration;
                ts.forEach(source.declarations, function (node) {
                    target.declarations.push(node);
                });
                if (source.members) {
                    if (!target.members)
                        target.members = {};
                    extendSymbolTable(target.members, source.members);
                }
                if (source.exports) {
                    if (!target.exports)
                        target.exports = {};
                    extendSymbolTable(target.exports, source.exports);
                }
                recordMergedSymbol(target, source);
            }
            else {
                var message = target.flags & 2 /* BlockScopedVariable */ || source.flags & 2 /* BlockScopedVariable */ ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;
                ts.forEach(source.declarations, function (node) {
                    error(node.name ? node.name : node, message, symbolToString(source));
                });
                ts.forEach(target.declarations, function (node) {
                    error(node.name ? node.name : node, message, symbolToString(source));
                });
            }
        }
        function cloneSymbolTable(symbolTable) {
            var result = {};
            for (var id in symbolTable) {
                if (ts.hasProperty(symbolTable, id)) {
                    result[id] = symbolTable[id];
                }
            }
            return result;
        }
        function extendSymbolTable(target, source) {
            for (var id in source) {
                if (ts.hasProperty(source, id)) {
                    if (!ts.hasProperty(target, id)) {
                        target[id] = source[id];
                    }
                    else {
                        var symbol = target[id];
                        if (!(symbol.flags & 134217728 /* Merged */)) {
                            target[id] = symbol = cloneSymbol(symbol);
                        }
                        extendSymbol(symbol, source[id]);
                    }
                }
            }
        }
        function getSymbolLinks(symbol) {
            if (symbol.flags & 268435456 /* Transient */)
                return symbol;
            if (!symbol.id)
                symbol.id = nextSymbolId++;
            return symbolLinks[symbol.id] || (symbolLinks[symbol.id] = {});
        }
        function getNodeLinks(node) {
            if (!node.id)
                node.id = nextNodeId++;
            return nodeLinks[node.id] || (nodeLinks[node.id] = {});
        }
        function getSourceFile(node) {
            return ts.getAncestor(node, 193 /* SourceFile */);
        }
        function isGlobalSourceFile(node) {
            return node.kind === 193 /* SourceFile */ && !ts.isExternalModule(node);
        }
        function getSymbol(symbols, name, meaning) {
            if (meaning && ts.hasProperty(symbols, name)) {
                var symbol = symbols[name];
                ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & 33554432 /* Import */) {
                    var target = resolveImport(symbol);
                    // unknown symbol will mean that there were reported error during import resolution
                    // treat it as positive answer to avoid cascading errors
                    if (target === unknownSymbol || target.flags & meaning) {
                        return symbol;
                    }
                }
            }
            // return undefined if we can't find a symbol.
        }
        /** Returns true if node1 is defined before node 2**/
        function isDefinedBefore(node1, node2) {
            var file1 = ts.getSourceFileOfNode(node1);
            var file2 = ts.getSourceFileOfNode(node2);
            if (file1 === file2) {
                return node1.pos <= node2.pos;
            }
            if (!compilerOptions.out) {
                return true;
            }
            var sourceFiles = program.getSourceFiles();
            return sourceFiles.indexOf(file1) <= sourceFiles.indexOf(file2);
        }
        // Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
        // the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with
        // the given name can be found.
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg) {
            var result;
            var lastLocation;
            var propertyWithInvalidInitializer;
            var errorLocation = location;
            loop: while (location) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = getSymbol(location.locals, name, meaning)) {
                        break loop;
                    }
                }
                switch (location.kind) {
                    case 193 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 188 /* ModuleDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 35653619 /* ModuleMember */)) {
                            break loop;
                        }
                        break;
                    case 187 /* EnumDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 8 /* EnumMember */)) {
                            break loop;
                        }
                        break;
                    case 124 /* Property */:
                        // TypeScript 1.0 spec (April 2014): 8.4.1
                        // Initializer expressions for instance member variables are evaluated in the scope 
                        // of the class constructor body but are not permitted to reference parameters or 
                        // local variables of the constructor. This effectively means that entities from outer scopes 
                        // by the same name as a constructor parameter or local variable are inaccessible 
                        // in initializer expressions for instance member variables.
                        if (location.parent.kind === 184 /* ClassDeclaration */ && !(location.flags & 128 /* Static */)) {
                            var ctor = findConstructorDeclaration(location.parent);
                            if (ctor && ctor.locals) {
                                if (getSymbol(ctor.locals, name, meaning & 107455 /* Value */)) {
                                    // Remember the property node, it will be used later to report appropriate error
                                    propertyWithInvalidInitializer = location;
                                }
                            }
                        }
                        break;
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).members, name, meaning & 3152352 /* Type */)) {
                            if (lastLocation && lastLocation.flags & 128 /* Static */) {
                                // TypeScript 1.0 spec (April 2014): 3.4.1
                                // The scope of a type parameter extends over the entire declaration with which the type
                                // parameter list is associated, with the exception of static member declarations in classes.
                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                                return undefined;
                            }
                            break loop;
                        }
                        break;
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 182 /* FunctionDeclaration */:
                    case 150 /* ArrowFunction */:
                        if (name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        break;
                    case 149 /* FunctionExpression */:
                        if (name === "arguments") {
                            result = argumentsSymbol;
                            break loop;
                        }
                        var id = location.name;
                        if (id && name === id.text) {
                            result = location.symbol;
                            break loop;
                        }
                        break;
                    case 178 /* CatchBlock */:
                        var id = location.variable;
                        if (name === id.text) {
                            result = location.symbol;
                            break loop;
                        }
                        break;
                }
                lastLocation = location;
                location = location.parent;
            }
            if (!result) {
                result = getSymbol(globals, name, meaning);
            }
            if (!result) {
                if (nameNotFoundMessage) {
                    error(errorLocation, nameNotFoundMessage, typeof nameArg === "string" ? nameArg : ts.declarationNameToString(nameArg));
                }
                return undefined;
            }
            // Perform extra checks only if error reporting was requested
            if (nameNotFoundMessage) {
                if (propertyWithInvalidInitializer) {
                    // We have a match, but the reference occurred within a property initializer and the identifier also binds
                    // to a local variable in the constructor where the code will be emitted.
                    var propertyName = propertyWithInvalidInitializer.name;
                    error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.declarationNameToString(propertyName), typeof nameArg === "string" ? nameArg : ts.declarationNameToString(nameArg));
                    return undefined;
                }
                if (result.flags & 2 /* BlockScopedVariable */) {
                    // Block-scoped variables cannot be used before their definition
                    var declaration = ts.forEach(result.declarations, function (d) { return d.flags & 6144 /* BlockScoped */ ? d : undefined; });
                    ts.Debug.assert(declaration !== undefined, "Block-scoped variable declaration is undefined");
                    if (!isDefinedBefore(declaration, errorLocation)) {
                        error(errorLocation, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, ts.declarationNameToString(declaration.name));
                    }
                }
            }
            return result;
        }
        function resolveImport(symbol) {
            ts.Debug.assert((symbol.flags & 33554432 /* Import */) !== 0, "Should only get Imports here.");
            var links = getSymbolLinks(symbol);
            if (!links.target) {
                links.target = resolvingSymbol;
                var node = getDeclarationOfKind(symbol, 190 /* ImportDeclaration */);
                var target = node.externalModuleName ? resolveExternalModuleName(node, node.externalModuleName) : getSymbolOfPartOfRightHandSideOfImport(node.entityName, node);
                if (links.target === resolvingSymbol) {
                    links.target = target || unknownSymbol;
                }
                else {
                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
            }
            else if (links.target === resolvingSymbol) {
                links.target = unknownSymbol;
            }
            return links.target;
        }
        // This function is only for imports with entity names
        function getSymbolOfPartOfRightHandSideOfImport(entityName, importDeclaration) {
            if (!importDeclaration) {
                importDeclaration = ts.getAncestor(entityName, 190 /* ImportDeclaration */);
                ts.Debug.assert(importDeclaration !== undefined);
            }
            // There are three things we might try to look for. In the following examples,
            // the search term is enclosed in |...|:
            //
            //     import a = |b|; // Namespace
            //     import a = |b.c|; // Value, type, namespace
            //     import a = |b.c|.d; // Namespace
            if (entityName.kind === 63 /* Identifier */ && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            // Check for case 1 and 3 in the above example
            if (entityName.kind === 63 /* Identifier */ || entityName.parent.kind === 121 /* QualifiedName */) {
                return resolveEntityName(importDeclaration, entityName, 1536 /* Namespace */);
            }
            else {
                // Case 2 in above example
                // entityName.kind could be a QualifiedName or a Missing identifier
                ts.Debug.assert(entityName.parent.kind === 190 /* ImportDeclaration */);
                return resolveEntityName(importDeclaration, entityName, 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */);
            }
        }
        function getFullyQualifiedName(symbol) {
            return symbol.parent ? getFullyQualifiedName(symbol.parent) + "." + symbolToString(symbol) : symbolToString(symbol);
        }
        // Resolves a qualified name and any involved import aliases
        function resolveEntityName(location, name, meaning) {
            if (name.kind === 63 /* Identifier */) {
                var symbol = resolveName(location, name.text, meaning, ts.Diagnostics.Cannot_find_name_0, name);
                if (!symbol) {
                    return;
                }
            }
            else if (name.kind === 121 /* QualifiedName */) {
                var namespace = resolveEntityName(location, name.left, 1536 /* Namespace */);
                if (!namespace || namespace === unknownSymbol || name.right.kind === 120 /* Missing */)
                    return;
                var symbol = getSymbol(namespace.exports, name.right.text, meaning);
                if (!symbol) {
                    error(location, ts.Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(namespace), ts.declarationNameToString(name.right));
                    return;
                }
            }
            else {
                // Missing identifier
                return;
            }
            ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
            return symbol.flags & meaning ? symbol : resolveImport(symbol);
        }
        function isExternalModuleNameRelative(moduleName) {
            // TypeScript 1.0 spec (April 2014): 11.2.1
            // An external module name is "relative" if the first term is "." or "..".
            return moduleName.substr(0, 2) === "./" || moduleName.substr(0, 3) === "../" || moduleName.substr(0, 2) === ".\\" || moduleName.substr(0, 3) === "..\\";
        }
        function resolveExternalModuleName(location, moduleLiteral) {
            var searchPath = ts.getDirectoryPath(getSourceFile(location).filename);
            var moduleName = moduleLiteral.text;
            if (!moduleName)
                return;
            var isRelative = isExternalModuleNameRelative(moduleName);
            if (!isRelative) {
                var symbol = getSymbol(globals, '"' + moduleName + '"', 512 /* ValueModule */);
                if (symbol) {
                    return getResolvedExportSymbol(symbol);
                }
            }
            while (true) {
                var filename = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                var sourceFile = program.getSourceFile(filename + ".ts") || program.getSourceFile(filename + ".d.ts");
                if (sourceFile || isRelative)
                    break;
                var parentPath = ts.getDirectoryPath(searchPath);
                if (parentPath === searchPath)
                    break;
                searchPath = parentPath;
            }
            if (sourceFile) {
                if (sourceFile.symbol) {
                    return getResolvedExportSymbol(sourceFile.symbol);
                }
                error(moduleLiteral, ts.Diagnostics.File_0_is_not_an_external_module, sourceFile.filename);
                return;
            }
            error(moduleLiteral, ts.Diagnostics.Cannot_find_external_module_0, moduleName);
        }
        function getResolvedExportSymbol(moduleSymbol) {
            var symbol = getExportAssignmentSymbol(moduleSymbol);
            if (symbol) {
                if (symbol.flags & (107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */)) {
                    return symbol;
                }
                if (symbol.flags & 33554432 /* Import */) {
                    return resolveImport(symbol);
                }
            }
            return moduleSymbol;
        }
        function getExportAssignmentSymbol(symbol) {
            checkTypeOfExportAssignmentSymbol(symbol);
            var symbolLinks = getSymbolLinks(symbol);
            return symbolLinks.exportAssignSymbol === unknownSymbol ? undefined : symbolLinks.exportAssignSymbol;
        }
        function checkTypeOfExportAssignmentSymbol(containerSymbol) {
            var symbolLinks = getSymbolLinks(containerSymbol);
            if (!symbolLinks.exportAssignSymbol) {
                var exportInformation = collectExportInformationForSourceFileOrModule(containerSymbol);
                if (exportInformation.exportAssignments.length) {
                    if (exportInformation.exportAssignments.length > 1) {
                        // TypeScript 1.0 spec (April 2014): 11.2.4
                        // It is an error for an external module to contain more than one export assignment.
                        ts.forEach(exportInformation.exportAssignments, function (node) { return error(node, ts.Diagnostics.A_module_cannot_have_more_than_one_export_assignment); });
                    }
                    var node = exportInformation.exportAssignments[0];
                    if (exportInformation.hasExportedMember) {
                        // TypeScript 1.0 spec (April 2014): 11.2.3
                        // If an external module contains an export assignment it is an error 
                        // for the external module to also contain export declarations.
                        // The two types of exports are mutually exclusive.
                        error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                    }
                    if (node.exportName.text) {
                        var meaning = 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */;
                        var exportSymbol = resolveName(node, node.exportName.text, meaning, ts.Diagnostics.Cannot_find_name_0, node.exportName);
                    }
                }
                symbolLinks.exportAssignSymbol = exportSymbol || unknownSymbol;
            }
        }
        function collectExportInformationForSourceFileOrModule(symbol) {
            var seenExportedMember = false;
            var result = [];
            ts.forEach(symbol.declarations, function (declaration) {
                var block = (declaration.kind === 193 /* SourceFile */ ? declaration : declaration.body);
                ts.forEach(block.statements, function (node) {
                    if (node.kind === 191 /* ExportAssignment */) {
                        result.push(node);
                    }
                    else {
                        seenExportedMember = seenExportedMember || (node.flags & 1 /* Export */) !== 0;
                    }
                });
            });
            return {
                hasExportedMember: seenExportedMember,
                exportAssignments: result
            };
        }
        function getMergedSymbol(symbol) {
            var merged;
            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
        }
        function getSymbolOfNode(node) {
            return getMergedSymbol(node.symbol);
        }
        function getParentOfSymbol(symbol) {
            return getMergedSymbol(symbol.parent);
        }
        function getExportSymbolOfValueSymbolIfExported(symbol) {
            return symbol && (symbol.flags & 4194304 /* ExportValue */) !== 0 ? getMergedSymbol(symbol.exportSymbol) : symbol;
        }
        function symbolIsValue(symbol) {
            // If it is an instantiated symbol, then it is a value if the symbol it is an
            // instantiation of is a value.
            if (symbol.flags & 67108864 /* Instantiated */) {
                return symbolIsValue(getSymbolLinks(symbol).target);
            }
            // If the symbol has the value flag, it is trivially a value.
            if (symbol.flags & 107455 /* Value */) {
                return true;
            }
            // If it is an import, then it is a value if the symbol it resolves to is a value.
            if (symbol.flags & 33554432 /* Import */) {
                return (resolveImport(symbol).flags & 107455 /* Value */) !== 0;
            }
            return false;
        }
        function findConstructorDeclaration(node) {
            var members = node.members;
            for (var i = 0; i < members.length; i++) {
                var member = members[i];
                if (member.kind === 126 /* Constructor */ && member.body) {
                    return member;
                }
            }
        }
        function createType(flags) {
            var result = new Type(checker, flags);
            result.id = typeCount++;
            return result;
        }
        function createIntrinsicType(kind, intrinsicName) {
            var type = createType(kind);
            type.intrinsicName = intrinsicName;
            return type;
        }
        function createObjectType(kind, symbol) {
            var type = createType(kind);
            type.symbol = symbol;
            return type;
        }
        // A reserved member name starts with two underscores followed by a non-underscore
        function isReservedMemberName(name) {
            return name.charCodeAt(0) === 95 /* _ */ && name.charCodeAt(1) === 95 /* _ */ && name.charCodeAt(2) !== 95 /* _ */;
        }
        function getNamedMembers(members) {
            var result;
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    if (!isReservedMemberName(id)) {
                        if (!result)
                            result = [];
                        var symbol = members[id];
                        if (symbolIsValue(symbol)) {
                            result.push(symbol);
                        }
                    }
                }
            }
            return result || emptyArray;
        }
        function setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            type.members = members;
            type.properties = getNamedMembers(members);
            type.callSignatures = callSignatures;
            type.constructSignatures = constructSignatures;
            if (stringIndexType)
                type.stringIndexType = stringIndexType;
            if (numberIndexType)
                type.numberIndexType = numberIndexType;
            return type;
        }
        function createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            return setObjectTypeMembers(createObjectType(32768 /* Anonymous */, symbol), members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function isOptionalProperty(propertySymbol) {
            //  class C {
            //      constructor(public x?) { }
            //  }
            //
            // x is an optional parameter, but it is a required property.
            return propertySymbol.valueDeclaration && propertySymbol.valueDeclaration.flags & 4 /* QuestionMark */ && propertySymbol.valueDeclaration.kind !== 123 /* Parameter */;
        }
        function forEachSymbolTableInScope(enclosingDeclaration, callback) {
            var result;
            for (var location = enclosingDeclaration; location; location = location.parent) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = callback(location.locals)) {
                        return result;
                    }
                }
                switch (location.kind) {
                    case 193 /* SourceFile */:
                        if (!ts.isExternalModule(location)) {
                            break;
                        }
                    case 188 /* ModuleDeclaration */:
                        if (result = callback(getSymbolOfNode(location).exports)) {
                            return result;
                        }
                        break;
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                        if (result = callback(getSymbolOfNode(location).members)) {
                            return result;
                        }
                        break;
                }
            }
            return callback(globals);
        }
        function getQualifiedLeftMeaning(rightMeaning) {
            // If we are looking in value space, the parent meaning is value, other wise it is namespace
            return rightMeaning === 107455 /* Value */ ? 107455 /* Value */ : 1536 /* Namespace */;
        }
        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing) {
            function getAccessibleSymbolChainFromSymbolTable(symbols) {
                function canQualifySymbol(symbolFromSymbolTable, meaning) {
                    // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
                    if (!needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning)) {
                        return true;
                    }
                    // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                    var accessibleParent = getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing);
                    return !!accessibleParent;
                }
                function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol) {
                    if (symbol === (resolvedAliasSymbol || symbolFromSymbolTable)) {
                        // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                        // and if symbolfrom symbolTable or alias resolution matches the symbol, 
                        // check the symbol can be qualified, it is only then this symbol is accessible
                        return !ts.forEach(symbolFromSymbolTable.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); }) && canQualifySymbol(symbolFromSymbolTable, meaning);
                    }
                }
                // If symbol is directly available by its name in the symbol table
                if (isAccessible(ts.lookUp(symbols, symbol.name))) {
                    return [symbol];
                }
                // Check if symbol is any of the alias
                return ts.forEachValue(symbols, function (symbolFromSymbolTable) {
                    if (symbolFromSymbolTable.flags & 33554432 /* Import */) {
                        if (!useOnlyExternalAliasing || ts.forEach(symbolFromSymbolTable.declarations, function (declaration) { return declaration.kind === 190 /* ImportDeclaration */ && declaration.externalModuleName; })) {
                            var resolvedImportedSymbol = resolveImport(symbolFromSymbolTable);
                            if (isAccessible(symbolFromSymbolTable, resolveImport(symbolFromSymbolTable))) {
                                return [symbolFromSymbolTable];
                            }
                            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
                            // but only if the symbolFromSymbolTable can be qualified
                            var accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;
                            if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                                return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                            }
                        }
                    }
                });
            }
            if (symbol) {
                return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
            }
        }
        function needsQualification(symbol, enclosingDeclaration, meaning) {
            var qualify = false;
            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
                // If symbol of this name is not available in the symbol table we are ok
                if (!ts.hasProperty(symbolTable, symbol.name)) {
                    // Continue to the next symbol table
                    return false;
                }
                // If the symbol with this name is present it should refer to the symbol
                var symbolFromSymbolTable = symbolTable[symbol.name];
                if (symbolFromSymbolTable === symbol) {
                    // No need to qualify
                    return true;
                }
                // Qualify if the symbol from symbol table has same meaning as expected
                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 33554432 /* Import */) ? resolveImport(symbolFromSymbolTable) : symbolFromSymbolTable;
                if (symbolFromSymbolTable.flags & meaning) {
                    qualify = true;
                    return true;
                }
                // Continue to the next symbol table
                return false;
            });
            return qualify;
        }
        function isSymbolAccessible(symbol, enclosingDeclaration, meaning) {
            if (symbol && enclosingDeclaration && !(symbol.flags & 1048576 /* TypeParameter */)) {
                var initialSymbol = symbol;
                var meaningToLook = meaning;
                while (symbol) {
                    // Symbol is accessible if it by itself is accessible
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook, false);
                    if (accessibleSymbolChain) {
                        var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0]);
                        if (!hasAccessibleDeclarations) {
                            return {
                                accessibility: 1 /* NotAccessible */,
                                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                                errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, 1536 /* Namespace */) : undefined
                            };
                        }
                        return { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasAccessibleDeclarations.aliasesToMakeVisible };
                    }
                    // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
                    // It could be a qualified symbol and hence verify the path
                    // e.g.:
                    // module m {
                    //     export class c {
                    //     }
                    // }
                    // var x: typeof m.c
                    // In the above example when we start with checking if typeof m.c symbol is accessible,
                    // we are going to see if c can be accessed in scope directly. 
                    // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification
                    meaningToLook = getQualifiedLeftMeaning(meaning);
                    symbol = getParentOfSymbol(symbol);
                }
                // This could be a symbol that is not exported in the external module 
                // or it could be a symbol from different external module that is not aliased and hence cannot be named
                var symbolExternalModule = ts.forEach(initialSymbol.declarations, function (declaration) { return getExternalModuleContainer(declaration); });
                if (symbolExternalModule) {
                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule !== enclosingExternalModule) {
                        // name from different external module that is not visible
                        return {
                            accessibility: 2 /* CannotBeNamed */,
                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                            errorModuleName: symbolToString(symbolExternalModule)
                        };
                    }
                }
                // Just a local name that is not accessible
                return {
                    accessibility: 1 /* NotAccessible */,
                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning)
                };
            }
            return { accessibility: 0 /* Accessible */ };
            function getExternalModuleContainer(declaration) {
                for (; declaration; declaration = declaration.parent) {
                    if (hasExternalModuleSymbol(declaration)) {
                        return getSymbolOfNode(declaration);
                    }
                }
            }
        }
        function hasExternalModuleSymbol(declaration) {
            return (declaration.kind === 188 /* ModuleDeclaration */ && declaration.name.kind === 7 /* StringLiteral */) || (declaration.kind === 193 /* SourceFile */ && ts.isExternalModule(declaration));
        }
        function hasVisibleDeclarations(symbol) {
            var aliasesToMakeVisible;
            if (ts.forEach(symbol.declarations, function (declaration) { return !getIsDeclarationVisible(declaration); })) {
                return undefined;
            }
            return { aliasesToMakeVisible: aliasesToMakeVisible };
            function getIsDeclarationVisible(declaration) {
                if (!isDeclarationVisible(declaration)) {
                    // Mark the unexported alias as visible if its parent is visible 
                    // because these kind of aliases can be used to name types in declaration file
                    if (declaration.kind === 190 /* ImportDeclaration */ && !(declaration.flags & 1 /* Export */) && isDeclarationVisible(declaration.parent)) {
                        getNodeLinks(declaration).isVisible = true;
                        if (aliasesToMakeVisible) {
                            if (!ts.contains(aliasesToMakeVisible, declaration)) {
                                aliasesToMakeVisible.push(declaration);
                            }
                        }
                        else {
                            aliasesToMakeVisible = [declaration];
                        }
                        return true;
                    }
                    // Declaration is not visible
                    return false;
                }
                return true;
            }
        }
        function isImportDeclarationEntityNameReferenceDeclarationVisibile(entityName) {
            var firstIdentifier = getFirstIdentifier(entityName);
            var symbolOfNameSpace = resolveName(entityName.parent, firstIdentifier.text, 1536 /* Namespace */, ts.Diagnostics.Cannot_find_name_0, firstIdentifier);
            // Verify if the symbol is accessible
            var hasNamespaceDeclarationsVisibile = hasVisibleDeclarations(symbolOfNameSpace);
            return hasNamespaceDeclarationsVisibile ? { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasNamespaceDeclarationsVisibile.aliasesToMakeVisible } : { accessibility: 1 /* NotAccessible */, errorSymbolName: ts.declarationNameToString(firstIdentifier) };
        }
        function releaseStringWriter(writer) {
            writer.clear();
            stringWriters.push(writer);
        }
        function writeKeyword(writer, kind) {
            writer.writeKeyword(ts.tokenToString(kind));
        }
        function writePunctuation(writer, kind) {
            writer.writePunctuation(ts.tokenToString(kind));
        }
        function writeOperator(writer, kind) {
            writer.writeOperator(ts.tokenToString(kind));
        }
        function writeSpace(writer) {
            writer.writeSpace(" ");
        }
        function symbolToString(symbol, enclosingDeclaration, meaning) {
            var writer = getSingleLineStringWriter();
            getSymbolDisplayBuilder().buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning);
            var result = writer.string();
            releaseStringWriter(writer);
            return result;
        }
        function typeToString(type, enclosingDeclaration, flags) {
            var writer = getSingleLineStringWriter();
            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
            var result = writer.string();
            releaseStringWriter(writer);
            var maxLength = compilerOptions.noErrorTruncation || flags & 4 /* NoTruncation */ ? undefined : 100;
            if (maxLength && result.length >= maxLength) {
                result = result.substr(0, maxLength - "...".length) + "...";
            }
            return result;
        }
        function getTypeAliasForTypeLiteral(type) {
            if (type.symbol && type.symbol.flags & 2048 /* TypeLiteral */) {
                var node = type.symbol.declarations[0].parent;
                while (node.kind === 138 /* ParenType */) {
                    node = node.parent;
                }
                if (node.kind === 186 /* TypeAliasDeclaration */) {
                    return getSymbolOfNode(node);
                }
            }
            return undefined;
        }
        // This is for caching the result of getSymbolDisplayBuilder. Do not access directly.
        var _displayBuilder;
        function getSymbolDisplayBuilder() {
            /**
             * Writes only the name of the symbol out to the writer. Uses the original source text
             * for the name of the symbol if it is available to match how the user inputted the name.
             */
            function appendSymbolNameOnly(symbol, writer) {
                if (symbol.declarations && symbol.declarations.length > 0) {
                    var declaration = symbol.declarations[0];
                    if (declaration.name) {
                        writer.writeSymbol(ts.declarationNameToString(declaration.name), symbol);
                        return;
                    }
                }
                writer.writeSymbol(symbol.name, symbol);
            }
            /**
             * Enclosing declaration is optional when we don't want to get qualified name in the enclosing declaration scope
             * Meaning needs to be specified if the enclosing declaration is given
             */
            function buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags) {
                var parentSymbol;
                function appendParentTypeArgumentsAndSymbolName(symbol) {
                    if (parentSymbol) {
                        // Write type arguments of instantiated class/interface here
                        if (flags & 1 /* WriteTypeParametersOrArguments */) {
                            if (symbol.flags & 67108864 /* Instantiated */) {
                                buildDisplayForTypeArgumentsAndDelimiters(getTypeParametersOfClassOrInterface(parentSymbol), symbol.mapper, writer, enclosingDeclaration);
                            }
                            else {
                                buildTypeParameterDisplayFromSymbol(parentSymbol, writer, enclosingDeclaration);
                            }
                        }
                        writePunctuation(writer, 19 /* DotToken */);
                    }
                    parentSymbol = symbol;
                    appendSymbolNameOnly(symbol, writer);
                }
                // Let the writer know we just wrote out a symbol.  The declaration emitter writer uses 
                // this to determine if an import it has previously seen (and not written out) needs 
                // to be written to the file once the walk of the tree is complete.
                //
                // NOTE(cyrusn): This approach feels somewhat unfortunate.  A simple pass over the tree
                // up front (for example, during checking) could determine if we need to emit the imports
                // and we could then access that data during declaration emit.
                writer.trackSymbol(symbol, enclosingDeclaration, meaning);
                function walkSymbol(symbol, meaning) {
                    if (symbol) {
                        var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, !!(flags & 2 /* UseOnlyExternalAliasing */));
                        if (!accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                            // Go up and add our parent.
                            walkSymbol(getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol), getQualifiedLeftMeaning(meaning));
                        }
                        if (accessibleSymbolChain) {
                            for (var i = 0, n = accessibleSymbolChain.length; i < n; i++) {
                                appendParentTypeArgumentsAndSymbolName(accessibleSymbolChain[i]);
                            }
                        }
                        else {
                            // If we didn't find accessible symbol chain for this symbol, break if this is external module
                            if (!parentSymbol && ts.forEach(symbol.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); })) {
                                return;
                            }
                            // if this is anonymous type break
                            if (symbol.flags & 2048 /* TypeLiteral */ || symbol.flags & 4096 /* ObjectLiteral */) {
                                return;
                            }
                            appendParentTypeArgumentsAndSymbolName(symbol);
                        }
                    }
                }
                // Get qualified name 
                if (enclosingDeclaration && !(symbol.flags & 1048576 /* TypeParameter */)) {
                    walkSymbol(symbol, meaning);
                    return;
                }
                return appendParentTypeArgumentsAndSymbolName(symbol);
            }
            function buildTypeDisplay(type, writer, enclosingDeclaration, globalFlags, typeStack) {
                var globalFlagsToPass = globalFlags & 16 /* WriteOwnNameForAnyLike */;
                return writeType(type, globalFlags);
                function writeType(type, flags) {
                    // Write undefined/null type as any
                    if (type.flags & 127 /* Intrinsic */) {
                        // Special handling for unknown / resolving types, they should show up as any and not unknown or __resolving
                        writer.writeKeyword(!(globalFlags & 16 /* WriteOwnNameForAnyLike */) && (type.flags & 1 /* Any */) ? "any" : type.intrinsicName);
                    }
                    else if (type.flags & 4096 /* Reference */) {
                        writeTypeReference(type, flags);
                    }
                    else if (type.flags & (1024 /* Class */ | 2048 /* Interface */ | 128 /* Enum */ | 512 /* TypeParameter */)) {
                        buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, 3152352 /* Type */);
                    }
                    else if (type.flags & 8192 /* Tuple */) {
                        writeTupleType(type);
                    }
                    else if (type.flags & 16384 /* Union */) {
                        writeUnionType(type, flags);
                    }
                    else if (type.flags & 32768 /* Anonymous */) {
                        writeAnonymousType(type, flags);
                    }
                    else if (type.flags & 256 /* StringLiteral */) {
                        writer.writeStringLiteral(type.text);
                    }
                    else {
                        // Should never get here
                        // { ... }
                        writePunctuation(writer, 13 /* OpenBraceToken */);
                        writeSpace(writer);
                        writePunctuation(writer, 20 /* DotDotDotToken */);
                        writeSpace(writer);
                        writePunctuation(writer, 14 /* CloseBraceToken */);
                    }
                }
                function writeTypeList(types, union) {
                    for (var i = 0; i < types.length; i++) {
                        if (i > 0) {
                            if (union) {
                                writeSpace(writer);
                            }
                            writePunctuation(writer, union ? 43 /* BarToken */ : 22 /* CommaToken */);
                            writeSpace(writer);
                        }
                        writeType(types[i], union ? 64 /* InElementType */ : 0 /* None */);
                    }
                }
                function writeTypeReference(type, flags) {
                    if (type.target === globalArrayType && !(flags & 1 /* WriteArrayAsGenericType */)) {
                        writeType(type.typeArguments[0], 64 /* InElementType */);
                        writePunctuation(writer, 17 /* OpenBracketToken */);
                        writePunctuation(writer, 18 /* CloseBracketToken */);
                    }
                    else {
                        buildSymbolDisplay(type.target.symbol, writer, enclosingDeclaration, 3152352 /* Type */);
                        writePunctuation(writer, 23 /* LessThanToken */);
                        writeTypeList(type.typeArguments, false);
                        writePunctuation(writer, 24 /* GreaterThanToken */);
                    }
                }
                function writeTupleType(type) {
                    writePunctuation(writer, 17 /* OpenBracketToken */);
                    writeTypeList(type.elementTypes, false);
                    writePunctuation(writer, 18 /* CloseBracketToken */);
                }
                function writeUnionType(type, flags) {
                    if (flags & 64 /* InElementType */) {
                        writePunctuation(writer, 15 /* OpenParenToken */);
                    }
                    writeTypeList(type.types, true);
                    if (flags & 64 /* InElementType */) {
                        writePunctuation(writer, 16 /* CloseParenToken */);
                    }
                }
                function writeAnonymousType(type, flags) {
                    // Always use 'typeof T' for type of class, enum, and module objects
                    if (type.symbol && type.symbol.flags & (32 /* Class */ | 384 /* Enum */ | 512 /* ValueModule */)) {
                        writeTypeofSymbol(type);
                    }
                    else if (shouldWriteTypeOfFunctionSymbol()) {
                        writeTypeofSymbol(type);
                    }
                    else if (typeStack && ts.contains(typeStack, type)) {
                        // If type is an anonymous type literal in a type alias declaration, use type alias name
                        var typeAlias = getTypeAliasForTypeLiteral(type);
                        if (typeAlias) {
                            buildSymbolDisplay(typeAlias, writer, enclosingDeclaration, 3152352 /* Type */);
                        }
                        else {
                            // Recursive usage, use any
                            writeKeyword(writer, 109 /* AnyKeyword */);
                        }
                    }
                    else {
                        if (!typeStack) {
                            typeStack = [];
                        }
                        typeStack.push(type);
                        writeLiteralType(type, flags);
                        typeStack.pop();
                    }
                    function shouldWriteTypeOfFunctionSymbol() {
                        if (type.symbol) {
                            var isStaticMethodSymbol = !!(type.symbol.flags & 8192 /* Method */ && ts.forEach(type.symbol.declarations, function (declaration) { return declaration.flags & 128 /* Static */; }));
                            var isNonLocalFunctionSymbol = !!(type.symbol.flags & 16 /* Function */) && (type.symbol.parent || ts.forEach(type.symbol.declarations, function (declaration) { return declaration.parent.kind === 193 /* SourceFile */ || declaration.parent.kind === 189 /* ModuleBlock */; }));
                            if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                                // typeof is allowed only for static/non local functions
                                return !!(flags & 2 /* UseTypeOfFunction */) || (typeStack && ts.contains(typeStack, type)); // it is type of the symbol uses itself recursively
                            }
                        }
                    }
                }
                function writeTypeofSymbol(type) {
                    writeKeyword(writer, 95 /* TypeOfKeyword */);
                    writeSpace(writer);
                    buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, 107455 /* Value */);
                }
                function writeLiteralType(type, flags) {
                    var resolved = resolveObjectOrUnionTypeMembers(type);
                    if (!resolved.properties.length && !resolved.stringIndexType && !resolved.numberIndexType) {
                        if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                            writePunctuation(writer, 13 /* OpenBraceToken */);
                            writePunctuation(writer, 14 /* CloseBraceToken */);
                            return;
                        }
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            if (flags & 64 /* InElementType */) {
                                writePunctuation(writer, 15 /* OpenParenToken */);
                            }
                            buildSignatureDisplay(resolved.callSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 8 /* WriteArrowStyleSignature */, typeStack);
                            if (flags & 64 /* InElementType */) {
                                writePunctuation(writer, 16 /* CloseParenToken */);
                            }
                            return;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            if (flags & 64 /* InElementType */) {
                                writePunctuation(writer, 15 /* OpenParenToken */);
                            }
                            writeKeyword(writer, 86 /* NewKeyword */);
                            writeSpace(writer);
                            buildSignatureDisplay(resolved.constructSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 8 /* WriteArrowStyleSignature */, typeStack);
                            if (flags & 64 /* InElementType */) {
                                writePunctuation(writer, 16 /* CloseParenToken */);
                            }
                            return;
                        }
                    }
                    writePunctuation(writer, 13 /* OpenBraceToken */);
                    writer.writeLine();
                    writer.increaseIndent();
                    for (var i = 0; i < resolved.callSignatures.length; i++) {
                        buildSignatureDisplay(resolved.callSignatures[i], writer, enclosingDeclaration, globalFlagsToPass, typeStack);
                        writePunctuation(writer, 21 /* SemicolonToken */);
                        writer.writeLine();
                    }
                    for (var i = 0; i < resolved.constructSignatures.length; i++) {
                        writeKeyword(writer, 86 /* NewKeyword */);
                        writeSpace(writer);
                        buildSignatureDisplay(resolved.constructSignatures[i], writer, enclosingDeclaration, globalFlagsToPass, typeStack);
                        writePunctuation(writer, 21 /* SemicolonToken */);
                        writer.writeLine();
                    }
                    if (resolved.stringIndexType) {
                        // [x: string]: 
                        writePunctuation(writer, 17 /* OpenBracketToken */);
                        writer.writeParameter("x");
                        writePunctuation(writer, 50 /* ColonToken */);
                        writeSpace(writer);
                        writeKeyword(writer, 118 /* StringKeyword */);
                        writePunctuation(writer, 18 /* CloseBracketToken */);
                        writePunctuation(writer, 50 /* ColonToken */);
                        writeSpace(writer);
                        writeType(resolved.stringIndexType, 0 /* None */);
                        writePunctuation(writer, 21 /* SemicolonToken */);
                        writer.writeLine();
                    }
                    if (resolved.numberIndexType) {
                        // [x: number]: 
                        writePunctuation(writer, 17 /* OpenBracketToken */);
                        writer.writeParameter("x");
                        writePunctuation(writer, 50 /* ColonToken */);
                        writeSpace(writer);
                        writeKeyword(writer, 116 /* NumberKeyword */);
                        writePunctuation(writer, 18 /* CloseBracketToken */);
                        writePunctuation(writer, 50 /* ColonToken */);
                        writeSpace(writer);
                        writeType(resolved.numberIndexType, 0 /* None */);
                        writePunctuation(writer, 21 /* SemicolonToken */);
                        writer.writeLine();
                    }
                    for (var i = 0; i < resolved.properties.length; i++) {
                        var p = resolved.properties[i];
                        var t = getTypeOfSymbol(p);
                        if (p.flags & (16 /* Function */ | 8192 /* Method */) && !getPropertiesOfObjectType(t).length) {
                            var signatures = getSignaturesOfType(t, 0 /* Call */);
                            for (var j = 0; j < signatures.length; j++) {
                                buildSymbolDisplay(p, writer);
                                if (isOptionalProperty(p)) {
                                    writePunctuation(writer, 49 /* QuestionToken */);
                                }
                                buildSignatureDisplay(signatures[j], writer, enclosingDeclaration, globalFlagsToPass, typeStack);
                                writePunctuation(writer, 21 /* SemicolonToken */);
                                writer.writeLine();
                            }
                        }
                        else {
                            buildSymbolDisplay(p, writer);
                            if (isOptionalProperty(p)) {
                                writePunctuation(writer, 49 /* QuestionToken */);
                            }
                            writePunctuation(writer, 50 /* ColonToken */);
                            writeSpace(writer);
                            writeType(t, 0 /* None */);
                            writePunctuation(writer, 21 /* SemicolonToken */);
                            writer.writeLine();
                        }
                    }
                    writer.decreaseIndent();
                    writePunctuation(writer, 14 /* CloseBraceToken */);
                }
            }
            function buildTypeParameterDisplayFromSymbol(symbol, writer, enclosingDeclaraiton, flags) {
                var targetSymbol = getTargetSymbol(symbol);
                if (targetSymbol.flags & 32 /* Class */ || targetSymbol.flags & 64 /* Interface */) {
                    buildDisplayForTypeParametersAndDelimiters(getTypeParametersOfClassOrInterface(symbol), writer, enclosingDeclaraiton, flags);
                }
            }
            function buildTypeParameterDisplay(tp, writer, enclosingDeclaration, flags, typeStack) {
                appendSymbolNameOnly(tp.symbol, writer);
                var constraint = getConstraintOfTypeParameter(tp);
                if (constraint) {
                    writeSpace(writer);
                    writeKeyword(writer, 77 /* ExtendsKeyword */);
                    writeSpace(writer);
                    buildTypeDisplay(constraint, writer, enclosingDeclaration, flags, typeStack);
                }
            }
            function buildParameterDisplay(p, writer, enclosingDeclaration, flags, typeStack) {
                if (getDeclarationFlagsFromSymbol(p) & 8 /* Rest */) {
                    writePunctuation(writer, 20 /* DotDotDotToken */);
                }
                appendSymbolNameOnly(p, writer);
                if (p.valueDeclaration.flags & 4 /* QuestionMark */ || p.valueDeclaration.initializer) {
                    writePunctuation(writer, 49 /* QuestionToken */);
                }
                writePunctuation(writer, 50 /* ColonToken */);
                writeSpace(writer);
                buildTypeDisplay(getTypeOfSymbol(p), writer, enclosingDeclaration, flags, typeStack);
            }
            function buildDisplayForTypeParametersAndDelimiters(typeParameters, writer, enclosingDeclaration, flags, typeStack) {
                if (typeParameters && typeParameters.length) {
                    writePunctuation(writer, 23 /* LessThanToken */);
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (i > 0) {
                            writePunctuation(writer, 22 /* CommaToken */);
                            writeSpace(writer);
                        }
                        buildTypeParameterDisplay(typeParameters[i], writer, enclosingDeclaration, flags, typeStack);
                    }
                    writePunctuation(writer, 24 /* GreaterThanToken */);
                }
            }
            function buildDisplayForTypeArgumentsAndDelimiters(typeParameters, mapper, writer, enclosingDeclaration, flags, typeStack) {
                if (typeParameters && typeParameters.length) {
                    writePunctuation(writer, 23 /* LessThanToken */);
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (i > 0) {
                            writePunctuation(writer, 22 /* CommaToken */);
                            writeSpace(writer);
                        }
                        buildTypeDisplay(mapper(typeParameters[i]), writer, enclosingDeclaration, 0 /* None */);
                    }
                    writePunctuation(writer, 24 /* GreaterThanToken */);
                }
            }
            function buildDisplayForParametersAndDelimiters(parameters, writer, enclosingDeclaration, flags, typeStack) {
                writePunctuation(writer, 15 /* OpenParenToken */);
                for (var i = 0; i < parameters.length; i++) {
                    if (i > 0) {
                        writePunctuation(writer, 22 /* CommaToken */);
                        writeSpace(writer);
                    }
                    buildParameterDisplay(parameters[i], writer, enclosingDeclaration, flags, typeStack);
                }
                writePunctuation(writer, 16 /* CloseParenToken */);
            }
            function buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, typeStack) {
                if (flags & 8 /* WriteArrowStyleSignature */) {
                    writeSpace(writer);
                    writePunctuation(writer, 31 /* EqualsGreaterThanToken */);
                }
                else {
                    writePunctuation(writer, 50 /* ColonToken */);
                }
                writeSpace(writer);
                buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags, typeStack);
            }
            function buildSignatureDisplay(signature, writer, enclosingDeclaration, flags, typeStack) {
                if (signature.target && (flags & 32 /* WriteTypeArgumentsOfSignature */)) {
                    // Instantiated signature, write type arguments instead
                    // This is achieved by passing in the mapper separately
                    buildDisplayForTypeArgumentsAndDelimiters(signature.target.typeParameters, signature.mapper, writer, enclosingDeclaration);
                }
                else {
                    buildDisplayForTypeParametersAndDelimiters(signature.typeParameters, writer, enclosingDeclaration, flags, typeStack);
                }
                buildDisplayForParametersAndDelimiters(signature.parameters, writer, enclosingDeclaration, flags, typeStack);
                buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, typeStack);
            }
            return _displayBuilder || (_displayBuilder = {
                symbolToString: symbolToString,
                typeToString: typeToString,
                buildSymbolDisplay: buildSymbolDisplay,
                buildTypeDisplay: buildTypeDisplay,
                buildTypeParameterDisplay: buildTypeParameterDisplay,
                buildParameterDisplay: buildParameterDisplay,
                buildDisplayForParametersAndDelimiters: buildDisplayForParametersAndDelimiters,
                buildDisplayForTypeParametersAndDelimiters: buildDisplayForTypeParametersAndDelimiters,
                buildDisplayForTypeArgumentsAndDelimiters: buildDisplayForTypeArgumentsAndDelimiters,
                buildTypeParameterDisplayFromSymbol: buildTypeParameterDisplayFromSymbol,
                buildSignatureDisplay: buildSignatureDisplay,
                buildReturnTypeDisplay: buildReturnTypeDisplay
            });
        }
        function isDeclarationVisible(node) {
            function getContainingExternalModule(node) {
                for (; node; node = node.parent) {
                    if (node.kind === 188 /* ModuleDeclaration */) {
                        if (node.name.kind === 7 /* StringLiteral */) {
                            return node;
                        }
                    }
                    else if (node.kind === 193 /* SourceFile */) {
                        return ts.isExternalModule(node) ? node : undefined;
                    }
                }
                ts.Debug.fail("getContainingModule cant reach here");
            }
            function isUsedInExportAssignment(node) {
                // Get source File and see if it is external module and has export assigned symbol
                var externalModule = getContainingExternalModule(node);
                if (externalModule) {
                    // This is export assigned symbol node
                    var externalModuleSymbol = getSymbolOfNode(externalModule);
                    var exportAssignmentSymbol = getExportAssignmentSymbol(externalModuleSymbol);
                    var resolvedExportSymbol;
                    var symbolOfNode = getSymbolOfNode(node);
                    if (isSymbolUsedInExportAssignment(symbolOfNode)) {
                        return true;
                    }
                    // if symbolOfNode is import declaration, resolve the symbol declaration and check
                    if (symbolOfNode.flags & 33554432 /* Import */) {
                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));
                    }
                }
                // Check if the symbol is used in export assignment
                function isSymbolUsedInExportAssignment(symbol) {
                    if (exportAssignmentSymbol === symbol) {
                        return true;
                    }
                    if (exportAssignmentSymbol && !!(exportAssignmentSymbol.flags & 33554432 /* Import */)) {
                        // if export assigned symbol is import declaration, resolve the import
                        resolvedExportSymbol = resolvedExportSymbol || resolveImport(exportAssignmentSymbol);
                        if (resolvedExportSymbol === symbol) {
                            return true;
                        }
                        // Container of resolvedExportSymbol is visible
                        return ts.forEach(resolvedExportSymbol.declarations, function (declaration) {
                            while (declaration) {
                                if (declaration === node) {
                                    return true;
                                }
                                declaration = declaration.parent;
                            }
                        });
                    }
                }
            }
            function determineIfDeclarationIsVisible() {
                switch (node.kind) {
                    case 181 /* VariableDeclaration */:
                    case 188 /* ModuleDeclaration */:
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 186 /* TypeAliasDeclaration */:
                    case 182 /* FunctionDeclaration */:
                    case 187 /* EnumDeclaration */:
                    case 190 /* ImportDeclaration */:
                        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
                        var parent = node.kind === 181 /* VariableDeclaration */ ? node.parent.parent : node.parent;
                        // If the node is not exported or it is not ambient module element (except import declaration)
                        if (!(node.flags & 1 /* Export */) && !(node.kind !== 190 /* ImportDeclaration */ && parent.kind !== 193 /* SourceFile */ && ts.isInAmbientContext(parent))) {
                            return isGlobalSourceFile(parent) || isUsedInExportAssignment(node);
                        }
                        // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                        return isDeclarationVisible(parent);
                    case 124 /* Property */:
                    case 125 /* Method */:
                        if (node.flags & (32 /* Private */ | 64 /* Protected */)) {
                            // Private/protected properties/methods are not visible
                            return false;
                        }
                    case 126 /* Constructor */:
                    case 130 /* ConstructSignature */:
                    case 129 /* CallSignature */:
                    case 131 /* IndexSignature */:
                    case 123 /* Parameter */:
                    case 189 /* ModuleBlock */:
                        return isDeclarationVisible(node.parent);
                    case 193 /* SourceFile */:
                        return true;
                    default:
                        ts.Debug.fail("isDeclarationVisible unknown: SyntaxKind: " + node.kind);
                }
            }
            if (node) {
                var links = getNodeLinks(node);
                if (links.isVisible === undefined) {
                    links.isVisible = !!determineIfDeclarationIsVisible();
                }
                return links.isVisible;
            }
        }
        function getTypeOfPrototypeProperty(prototype) {
            // TypeScript 1.0 spec (April 2014): 8.4
            // Every class automatically contains a static property member named 'prototype', 
            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
            // It is an error to explicitly declare a static property member with the name 'prototype'.
            var classType = getDeclaredTypeOfSymbol(prototype.parent);
            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
        }
        function getTypeOfVariableOrPropertyDeclaration(declaration) {
            // A variable declared in a for..in statement is always of type any
            if (declaration.parent.kind === 166 /* ForInStatement */) {
                return anyType;
            }
            // Use type from type annotation if one is present
            if (declaration.type) {
                return getTypeFromTypeNode(declaration.type);
            }
            if (declaration.kind === 123 /* Parameter */) {
                var func = declaration.parent;
                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.kind === 128 /* SetAccessor */) {
                    var getter = getDeclarationOfKind(declaration.parent.symbol, 127 /* GetAccessor */);
                    if (getter) {
                        return getReturnTypeOfSignature(getSignatureFromDeclaration(getter));
                    }
                }
                // Use contextual parameter type if one is available
                var type = getContextuallyTypedParameterType(declaration);
                if (type) {
                    return type;
                }
            }
            // Use the type of the initializer expression if one is present
            if (declaration.initializer) {
                var type = checkAndMarkExpression(declaration.initializer);
                // Widening of property assignments is handled by checkObjectLiteral, exclude them here
                if (declaration.kind !== 141 /* PropertyAssignment */) {
                    var unwidenedType = type;
                    type = getWidenedType(type);
                    if (type !== unwidenedType) {
                        checkImplicitAny(type);
                    }
                }
                return type;
            }
            // Rest parameters default to type any[], other parameters default to type any
            var type = declaration.flags & 8 /* Rest */ ? createArrayType(anyType) : anyType;
            checkImplicitAny(type);
            return type;
            function checkImplicitAny(type) {
                if (!fullTypeCheck || !compilerOptions.noImplicitAny) {
                    return;
                }
                // We need to have ended up with 'any', 'any[]', 'any[][]', etc.
                if (getInnermostTypeOfNestedArrayTypes(type) !== anyType) {
                    return;
                }
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (isPrivateWithinAmbient(declaration) || (declaration.kind === 123 /* Parameter */ && isPrivateWithinAmbient(declaration.parent))) {
                    return;
                }
                switch (declaration.kind) {
                    case 124 /* Property */:
                        var diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;
                        break;
                    case 123 /* Parameter */:
                        var diagnostic = declaration.flags & 8 /* Rest */ ? ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;
                        break;
                    default:
                        var diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;
                }
                error(declaration, diagnostic, ts.declarationNameToString(declaration.name), typeToString(type));
            }
        }
        function getTypeOfVariableOrParameterOrProperty(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                // Handle prototype property
                if (symbol.flags & 536870912 /* Prototype */) {
                    return links.type = getTypeOfPrototypeProperty(symbol);
                }
                // Handle catch clause variables
                var declaration = symbol.valueDeclaration;
                if (declaration.kind === 178 /* CatchBlock */) {
                    return links.type = anyType;
                }
                // Handle variable, parameter or property
                links.type = resolvingType;
                var type = getTypeOfVariableOrPropertyDeclaration(declaration);
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
                if (compilerOptions.noImplicitAny) {
                    var diagnostic = symbol.valueDeclaration.type ? ts.Diagnostics._0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation : ts.Diagnostics._0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer;
                    error(symbol.valueDeclaration, diagnostic, symbolToString(symbol));
                }
            }
            return links.type;
        }
        function getSetAccessorTypeAnnotationNode(accessor) {
            return accessor && accessor.parameters.length > 0 && accessor.parameters[0].type;
        }
        function getAnnotatedAccessorType(accessor) {
            if (accessor) {
                if (accessor.kind === 127 /* GetAccessor */) {
                    return accessor.type && getTypeFromTypeNode(accessor.type);
                }
                else {
                    var setterTypeAnnotation = getSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);
                }
            }
            return undefined;
        }
        function getTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            checkAndStoreTypeOfAccessors(symbol, links);
            return links.type;
        }
        function checkAndStoreTypeOfAccessors(symbol, links) {
            links = links || getSymbolLinks(symbol);
            if (!links.type) {
                links.type = resolvingType;
                var getter = getDeclarationOfKind(symbol, 127 /* GetAccessor */);
                var setter = getDeclarationOfKind(symbol, 128 /* SetAccessor */);
                var type;
                // First try to see if the user specified a return type on the get-accessor.
                var getterReturnType = getAnnotatedAccessorType(getter);
                if (getterReturnType) {
                    type = getterReturnType;
                }
                else {
                    // If the user didn't specify a return type, try to use the set-accessor's parameter type.
                    var setterParameterType = getAnnotatedAccessorType(setter);
                    if (setterParameterType) {
                        type = setterParameterType;
                    }
                    else {
                        // If there are no specified types, try to infer it from the body of the get accessor if it exists.
                        if (getter) {
                            type = getReturnTypeFromBody(getter);
                        }
                        else {
                            if (compilerOptions.noImplicitAny) {
                                error(setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation, symbolToString(symbol));
                            }
                            type = anyType;
                        }
                    }
                }
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
                if (compilerOptions.noImplicitAny) {
                    var getter = getDeclarationOfKind(symbol, 127 /* GetAccessor */);
                    error(getter, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                }
            }
        }
        function getTypeOfFuncClassEnumModule(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = createObjectType(32768 /* Anonymous */, symbol);
            }
            return links.type;
        }
        function getTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
            }
            return links.type;
        }
        function getTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getTypeOfSymbol(resolveImport(symbol));
            }
            return links.type;
        }
        function getTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper);
            }
            return links.type;
        }
        function getTypeOfSymbol(symbol) {
            if (symbol.flags & 67108864 /* Instantiated */) {
                return getTypeOfInstantiatedSymbol(symbol);
            }
            if (symbol.flags & (3 /* Variable */ | 4 /* Property */)) {
                return getTypeOfVariableOrParameterOrProperty(symbol);
            }
            if (symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 384 /* Enum */ | 512 /* ValueModule */)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            if (symbol.flags & 8 /* EnumMember */) {
                return getTypeOfEnumMember(symbol);
            }
            if (symbol.flags & 98304 /* Accessor */) {
                return getTypeOfAccessors(symbol);
            }
            if (symbol.flags & 33554432 /* Import */) {
                return getTypeOfImport(symbol);
            }
            return unknownType;
        }
        function getTargetType(type) {
            return type.flags & 4096 /* Reference */ ? type.target : type;
        }
        function hasBaseType(type, checkBase) {
            return check(type);
            function check(type) {
                var target = getTargetType(type);
                return target === checkBase || ts.forEach(target.baseTypes, check);
            }
        }
        // Return combined list of type parameters from all declarations of a class or interface. Elsewhere we check they're all
        // the same, but even if they're not we still need the complete list to ensure instantiations supply type arguments
        // for all type parameters.
        function getTypeParametersOfClassOrInterface(symbol) {
            var result;
            ts.forEach(symbol.declarations, function (node) {
                if (node.kind === 185 /* InterfaceDeclaration */ || node.kind === 184 /* ClassDeclaration */) {
                    var declaration = node;
                    if (declaration.typeParameters && declaration.typeParameters.length) {
                        ts.forEach(declaration.typeParameters, function (node) {
                            var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
                            if (!result) {
                                result = [tp];
                            }
                            else if (!ts.contains(result, tp)) {
                                result.push(tp);
                            }
                        });
                    }
                }
            });
            return result;
        }
        function getDeclaredTypeOfClass(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(1024 /* Class */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                var declaration = getDeclarationOfKind(symbol, 184 /* ClassDeclaration */);
                if (declaration.baseType) {
                    var baseType = getTypeFromTypeReferenceNode(declaration.baseType);
                    if (baseType !== unknownType) {
                        if (getTargetType(baseType).flags & 1024 /* Class */) {
                            if (type !== baseType && !hasBaseType(baseType, type)) {
                                type.baseTypes.push(baseType);
                            }
                            else {
                                error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                            }
                        }
                        else {
                            error(declaration.baseType, ts.Diagnostics.A_class_may_only_extend_another_class);
                        }
                    }
                }
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = emptyArray;
                type.declaredConstructSignatures = emptyArray;
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfInterface(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(2048 /* Interface */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                ts.forEach(symbol.declarations, function (declaration) {
                    if (declaration.kind === 185 /* InterfaceDeclaration */ && declaration.baseTypes) {
                        ts.forEach(declaration.baseTypes, function (node) {
                            var baseType = getTypeFromTypeReferenceNode(node);
                            if (baseType !== unknownType) {
                                if (getTargetType(baseType).flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                    if (type !== baseType && !hasBaseType(baseType, type)) {
                                        type.baseTypes.push(baseType);
                                    }
                                    else {
                                        error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                                    }
                                }
                                else {
                                    error(node, ts.Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);
                                }
                            }
                        });
                    }
                });
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members["__call"]);
                type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members["__new"]);
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeAlias(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                links.declaredType = resolvingType;
                var declaration = getDeclarationOfKind(symbol, 186 /* TypeAliasDeclaration */);
                var type = getTypeFromTypeNode(declaration.type);
                if (links.declaredType === resolvingType) {
                    links.declaredType = type;
                }
            }
            else if (links.declaredType === resolvingType) {
                links.declaredType = unknownType;
                var declaration = getDeclarationOfKind(symbol, 186 /* TypeAliasDeclaration */);
                error(declaration.name, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfEnum(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(128 /* Enum */);
                type.symbol = symbol;
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeParameter(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(512 /* TypeParameter */);
                type.symbol = symbol;
                if (!getDeclarationOfKind(symbol, 122 /* TypeParameter */).constraint) {
                    type.constraint = noConstraintType;
                }
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                links.declaredType = getDeclaredTypeOfSymbol(resolveImport(symbol));
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfSymbol(symbol) {
            ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0);
            if (symbol.flags & 32 /* Class */) {
                return getDeclaredTypeOfClass(symbol);
            }
            if (symbol.flags & 64 /* Interface */) {
                return getDeclaredTypeOfInterface(symbol);
            }
            if (symbol.flags & 2097152 /* TypeAlias */) {
                return getDeclaredTypeOfTypeAlias(symbol);
            }
            if (symbol.flags & 384 /* Enum */) {
                return getDeclaredTypeOfEnum(symbol);
            }
            if (symbol.flags & 1048576 /* TypeParameter */) {
                return getDeclaredTypeOfTypeParameter(symbol);
            }
            if (symbol.flags & 33554432 /* Import */) {
                return getDeclaredTypeOfImport(symbol);
            }
            return unknownType;
        }
        function createSymbolTable(symbols) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = symbol;
            }
            return result;
        }
        function createInstantiatedSymbolTable(symbols, mapper) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = instantiateSymbol(symbol, mapper);
            }
            return result;
        }
        function addInheritedMembers(symbols, baseSymbols) {
            for (var i = 0; i < baseSymbols.length; i++) {
                var s = baseSymbols[i];
                if (!ts.hasProperty(symbols, s.name)) {
                    symbols[s.name] = s;
                }
            }
        }
        function addInheritedSignatures(signatures, baseSignatures) {
            if (baseSignatures) {
                for (var i = 0; i < baseSignatures.length; i++) {
                    signatures.push(baseSignatures[i]);
                }
            }
        }
        function resolveClassOrInterfaceMembers(type) {
            var members = type.symbol.members;
            var callSignatures = type.declaredCallSignatures;
            var constructSignatures = type.declaredConstructSignatures;
            var stringIndexType = type.declaredStringIndexType;
            var numberIndexType = type.declaredNumberIndexType;
            if (type.baseTypes.length) {
                members = createSymbolTable(type.declaredProperties);
                ts.forEach(type.baseTypes, function (baseType) {
                    addInheritedMembers(members, getPropertiesOfObjectType(baseType));
                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(baseType, 0 /* Call */));
                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(baseType, 1 /* Construct */));
                    stringIndexType = stringIndexType || getIndexTypeOfType(baseType, 0 /* String */);
                    numberIndexType = numberIndexType || getIndexTypeOfType(baseType, 1 /* Number */);
                });
            }
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveTypeReferenceMembers(type) {
            var target = type.target;
            var mapper = createTypeMapper(target.typeParameters, type.typeArguments);
            var members = createInstantiatedSymbolTable(target.declaredProperties, mapper);
            var callSignatures = instantiateList(target.declaredCallSignatures, mapper, instantiateSignature);
            var constructSignatures = instantiateList(target.declaredConstructSignatures, mapper, instantiateSignature);
            var stringIndexType = target.declaredStringIndexType ? instantiateType(target.declaredStringIndexType, mapper) : undefined;
            var numberIndexType = target.declaredNumberIndexType ? instantiateType(target.declaredNumberIndexType, mapper) : undefined;
            ts.forEach(target.baseTypes, function (baseType) {
                var instantiatedBaseType = instantiateType(baseType, mapper);
                addInheritedMembers(members, getPropertiesOfObjectType(instantiatedBaseType));
                callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));
                constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));
                stringIndexType = stringIndexType || getIndexTypeOfType(instantiatedBaseType, 0 /* String */);
                numberIndexType = numberIndexType || getIndexTypeOfType(instantiatedBaseType, 1 /* Number */);
            });
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function createSignature(declaration, typeParameters, parameters, resolvedReturnType, minArgumentCount, hasRestParameter, hasStringLiterals) {
            var sig = new Signature(checker);
            sig.declaration = declaration;
            sig.typeParameters = typeParameters;
            sig.parameters = parameters;
            sig.resolvedReturnType = resolvedReturnType;
            sig.minArgumentCount = minArgumentCount;
            sig.hasRestParameter = hasRestParameter;
            sig.hasStringLiterals = hasStringLiterals;
            return sig;
        }
        function cloneSignature(sig) {
            return createSignature(sig.declaration, sig.typeParameters, sig.parameters, sig.resolvedReturnType, sig.minArgumentCount, sig.hasRestParameter, sig.hasStringLiterals);
        }
        function getDefaultConstructSignatures(classType) {
            if (classType.baseTypes.length) {
                var baseType = classType.baseTypes[0];
                var baseSignatures = getSignaturesOfType(getTypeOfSymbol(baseType.symbol), 1 /* Construct */);
                return ts.map(baseSignatures, function (baseSignature) {
                    var signature = baseType.flags & 4096 /* Reference */ ? getSignatureInstantiation(baseSignature, baseType.typeArguments) : cloneSignature(baseSignature);
                    signature.typeParameters = classType.typeParameters;
                    signature.resolvedReturnType = classType;
                    return signature;
                });
            }
            return [createSignature(undefined, classType.typeParameters, emptyArray, classType, 0, false, false)];
        }
        function createTupleTypeMemberSymbols(memberTypes) {
            var members = {};
            for (var i = 0; i < memberTypes.length; i++) {
                var symbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, "" + i);
                symbol.type = memberTypes[i];
                members[i] = symbol;
            }
            return members;
        }
        function resolveTupleTypeMembers(type) {
            var arrayType = resolveObjectOrUnionTypeMembers(createArrayType(getUnionType(type.elementTypes)));
            var members = createTupleTypeMemberSymbols(type.elementTypes);
            addInheritedMembers(members, arrayType.properties);
            setObjectTypeMembers(type, members, arrayType.callSignatures, arrayType.constructSignatures, arrayType.stringIndexType, arrayType.numberIndexType);
        }
        function signatureListsIdentical(s, t) {
            if (s.length !== t.length) {
                return false;
            }
            for (var i = 0; i < s.length; i++) {
                if (!compareSignatures(s[i], t[i], false, compareTypes)) {
                    return false;
                }
            }
            return true;
        }
        // If the lists of call or construct signatures in the given types are all identical except for return types,
        // and if none of the signatures are generic, return a list of signatures that has substitutes a union of the
        // return types of the corresponding signatures in each resulting signature.
        function getUnionSignatures(types, kind) {
            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });
            var signatures = signatureLists[0];
            for (var i = 0; i < signatures.length; i++) {
                if (signatures[i].typeParameters) {
                    return emptyArray;
                }
            }
            for (var i = 1; i < signatureLists.length; i++) {
                if (!signatureListsIdentical(signatures, signatureLists[i])) {
                    return emptyArray;
                }
            }
            var result = ts.map(signatures, cloneSignature);
            for (var i = 0; i < result.length; i++) {
                var s = result[i];
                // Clear resolved return type we possibly got from cloneSignature
                s.resolvedReturnType = undefined;
                s.unionSignatures = ts.map(signatureLists, function (signatures) { return signatures[i]; });
            }
            return result;
        }
        function getUnionIndexType(types, kind) {
            var indexTypes = [];
            for (var i = 0; i < types.length; i++) {
                var indexType = getIndexTypeOfType(types[i], kind);
                if (!indexType) {
                    return undefined;
                }
                indexTypes.push(indexType);
            }
            return getUnionType(indexTypes);
        }
        function resolveUnionTypeMembers(type) {
            // The members and properties collections are empty for union types. To get all properties of a union
            // type use getPropertiesOfType (only the language service uses this).
            var callSignatures = getUnionSignatures(type.types, 0 /* Call */);
            var constructSignatures = getUnionSignatures(type.types, 1 /* Construct */);
            var stringIndexType = getUnionIndexType(type.types, 0 /* String */);
            var numberIndexType = getUnionIndexType(type.types, 1 /* Number */);
            setObjectTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveAnonymousTypeMembers(type) {
            var symbol = type.symbol;
            if (symbol.flags & 2048 /* TypeLiteral */) {
                var members = symbol.members;
                var callSignatures = getSignaturesOfSymbol(members["__call"]);
                var constructSignatures = getSignaturesOfSymbol(members["__new"]);
                var stringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                var numberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            else {
                // Combinations of function, class, enum and module
                var members = emptySymbols;
                var callSignatures = emptyArray;
                var constructSignatures = emptyArray;
                if (symbol.flags & 1952 /* HasExports */) {
                    members = symbol.exports;
                }
                if (symbol.flags & (16 /* Function */ | 8192 /* Method */)) {
                    callSignatures = getSignaturesOfSymbol(symbol);
                }
                if (symbol.flags & 32 /* Class */) {
                    var classType = getDeclaredTypeOfClass(symbol);
                    constructSignatures = getSignaturesOfSymbol(symbol.members["__constructor"]);
                    if (!constructSignatures.length) {
                        constructSignatures = getDefaultConstructSignatures(classType);
                    }
                    if (classType.baseTypes.length) {
                        members = createSymbolTable(getNamedMembers(members));
                        addInheritedMembers(members, getPropertiesOfObjectType(getTypeOfSymbol(classType.baseTypes[0].symbol)));
                    }
                }
                var stringIndexType = undefined;
                var numberIndexType = (symbol.flags & 384 /* Enum */) ? stringType : undefined;
            }
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveObjectOrUnionTypeMembers(type) {
            if (!type.members) {
                if (type.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                    resolveClassOrInterfaceMembers(type);
                }
                else if (type.flags & 32768 /* Anonymous */) {
                    resolveAnonymousTypeMembers(type);
                }
                else if (type.flags & 8192 /* Tuple */) {
                    resolveTupleTypeMembers(type);
                }
                else if (type.flags & 16384 /* Union */) {
                    resolveUnionTypeMembers(type);
                }
                else {
                    resolveTypeReferenceMembers(type);
                }
            }
            return type;
        }
        // Return properties of an object type or an empty array for other types
        function getPropertiesOfObjectType(type) {
            if (type.flags & 48128 /* ObjectType */) {
                return resolveObjectOrUnionTypeMembers(type).properties;
            }
            return emptyArray;
        }
        // If the given type is an object type and that type has a property by the given name, return
        // the symbol for that property. Otherwise return undefined.
        function getPropertyOfObjectType(type, name) {
            if (type.flags & 48128 /* ObjectType */) {
                var resolved = resolveObjectOrUnionTypeMembers(type);
                if (ts.hasProperty(resolved.members, name)) {
                    var symbol = resolved.members[name];
                    if (symbolIsValue(symbol)) {
                        return symbol;
                    }
                }
            }
        }
        function getPropertiesOfUnionType(type) {
            var result = [];
            ts.forEach(getPropertiesOfType(type.types[0]), function (prop) {
                var unionProp = getPropertyOfUnionType(type, prop.name);
                if (unionProp) {
                    result.push(unionProp);
                }
            });
            return result;
        }
        function getPropertiesOfType(type) {
            if (type.flags & 16384 /* Union */) {
                return getPropertiesOfUnionType(type);
            }
            return getPropertiesOfObjectType(getApparentType(type));
        }
        // For a type parameter, return the base constraint of the type parameter. For the string, number, and
        // boolean primitive types, return the corresponding object types.Otherwise return the type itself.
        // Note that the apparent type of a union type is the union type itself.
        function getApparentType(type) {
            if (type.flags & 512 /* TypeParameter */) {
                do {
                    type = getConstraintOfTypeParameter(type);
                } while (type && type.flags & 512 /* TypeParameter */);
                if (!type) {
                    type = emptyObjectType;
                }
            }
            if (type.flags & 258 /* StringLike */) {
                type = globalStringType;
            }
            else if (type.flags & 132 /* NumberLike */) {
                type = globalNumberType;
            }
            else if (type.flags & 8 /* Boolean */) {
                type = globalBooleanType;
            }
            return type;
        }
        function createUnionProperty(unionType, name) {
            var types = unionType.types;
            var props;
            for (var i = 0; i < types.length; i++) {
                var type = getApparentType(types[i]);
                if (type !== unknownType) {
                    var prop = getPropertyOfType(type, name);
                    if (!prop) {
                        return undefined;
                    }
                    if (!props) {
                        props = [prop];
                    }
                    else {
                        props.push(prop);
                    }
                }
            }
            var propTypes = [];
            var declarations = [];
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                if (prop.declarations) {
                    declarations.push.apply(declarations, prop.declarations);
                }
                propTypes.push(getTypeOfSymbol(prop));
            }
            var result = createSymbol(4 /* Property */ | 268435456 /* Transient */ | 1073741824 /* UnionProperty */, name);
            result.unionType = unionType;
            result.declarations = declarations;
            result.type = getUnionType(propTypes);
            return result;
        }
        function getPropertyOfUnionType(type, name) {
            var properties = type.resolvedProperties || (type.resolvedProperties = {});
            if (ts.hasProperty(properties, name)) {
                return properties[name];
            }
            var property = createUnionProperty(type, name);
            if (property) {
                properties[name] = property;
            }
            return property;
        }
        // Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
        // necessary, maps primtive types and type parameters are to their apparent types, and augments with properties from
        // Object and Function as appropriate.
        function getPropertyOfType(type, name) {
            if (type.flags & 16384 /* Union */) {
                return getPropertyOfUnionType(type, name);
            }
            if (!(type.flags & 48128 /* ObjectType */)) {
                type = getApparentType(type);
                if (!(type.flags & 48128 /* ObjectType */)) {
                    return undefined;
                }
            }
            var resolved = resolveObjectOrUnionTypeMembers(type);
            if (ts.hasProperty(resolved.members, name)) {
                var symbol = resolved.members[name];
                if (symbolIsValue(symbol)) {
                    return symbol;
                }
            }
            if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                var symbol = getPropertyOfObjectType(globalFunctionType, name);
                if (symbol)
                    return symbol;
            }
            return getPropertyOfObjectType(globalObjectType, name);
        }
        function getSignaturesOfObjectOrUnionType(type, kind) {
            if (type.flags & (48128 /* ObjectType */ | 16384 /* Union */)) {
                var resolved = resolveObjectOrUnionTypeMembers(type);
                return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return emptyArray;
        }
        // Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
        // maps primtive types and type parameters are to their apparent types.
        function getSignaturesOfType(type, kind) {
            return getSignaturesOfObjectOrUnionType(getApparentType(type), kind);
        }
        function getIndexTypeOfObjectOrUnionType(type, kind) {
            if (type.flags & (48128 /* ObjectType */ | 16384 /* Union */)) {
                var resolved = resolveObjectOrUnionTypeMembers(type);
                return kind === 0 /* String */ ? resolved.stringIndexType : resolved.numberIndexType;
            }
        }
        // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primtive types and type parameters are to their apparent types.
        function getIndexTypeOfType(type, kind) {
            return getIndexTypeOfObjectOrUnionType(getApparentType(type), kind);
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(typeParameterDeclarations) {
            var result = [];
            ts.forEach(typeParameterDeclarations, function (node) {
                var tp = getDeclaredTypeOfTypeParameter(node.symbol);
                if (!ts.contains(result, tp)) {
                    result.push(tp);
                }
            });
            return result;
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var classType = declaration.kind === 126 /* Constructor */ ? getDeclaredTypeOfClass(declaration.parent.symbol) : undefined;
                var typeParameters = classType ? classType.typeParameters : declaration.typeParameters ? getTypeParametersFromDeclaration(declaration.typeParameters) : undefined;
                var parameters = [];
                var hasStringLiterals = false;
                var minArgumentCount = -1;
                for (var i = 0, n = declaration.parameters.length; i < n; i++) {
                    var param = declaration.parameters[i];
                    parameters.push(param.symbol);
                    if (param.type && param.type.kind === 7 /* StringLiteral */) {
                        hasStringLiterals = true;
                    }
                    if (minArgumentCount < 0) {
                        if (param.initializer || param.flags & (4 /* QuestionMark */ | 8 /* Rest */)) {
                            minArgumentCount = i;
                        }
                    }
                }
                if (minArgumentCount < 0) {
                    minArgumentCount = declaration.parameters.length;
                }
                var returnType;
                if (classType) {
                    returnType = classType;
                }
                else if (declaration.type) {
                    returnType = getTypeFromTypeNode(declaration.type);
                }
                else {
                    // TypeScript 1.0 spec (April 2014):
                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    if (declaration.kind === 127 /* GetAccessor */) {
                        var setter = getDeclarationOfKind(declaration.symbol, 128 /* SetAccessor */);
                        returnType = getAnnotatedAccessorType(setter);
                    }
                    if (!returnType && !declaration.body) {
                        returnType = anyType;
                    }
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, parameters, returnType, minArgumentCount, ts.hasRestParameters(declaration), hasStringLiterals);
            }
            return links.resolvedSignature;
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol)
                return emptyArray;
            var result = [];
            for (var i = 0, len = symbol.declarations.length; i < len; i++) {
                var node = symbol.declarations[i];
                switch (node.kind) {
                    case 182 /* FunctionDeclaration */:
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 129 /* CallSignature */:
                    case 130 /* ConstructSignature */:
                    case 131 /* IndexSignature */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 149 /* FunctionExpression */:
                    case 150 /* ArrowFunction */:
                        // Don't include signature if node is the implementation of an overloaded function. A node is considered
                        // an implementation node if it has a body and the previous node is of the same kind and immediately
                        // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                        if (i > 0 && node.body) {
                            var previous = symbol.declarations[i - 1];
                            if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {
                                break;
                            }
                        }
                        result.push(getSignatureFromDeclaration(node));
                }
            }
            return result;
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                signature.resolvedReturnType = resolvingType;
                if (signature.target) {
                    var type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);
                }
                else if (signature.unionSignatures) {
                    var type = getUnionType(ts.map(signature.unionSignatures, getReturnTypeOfSignature));
                }
                else {
                    var type = getReturnTypeFromBody(signature.declaration);
                }
                if (signature.resolvedReturnType === resolvingType) {
                    signature.resolvedReturnType = type;
                }
            }
            else if (signature.resolvedReturnType === resolvingType) {
                signature.resolvedReturnType = anyType;
                if (compilerOptions.noImplicitAny) {
                    var declaration = signature.declaration;
                    if (declaration.name) {
                        error(declaration.name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(declaration.name));
                    }
                    else {
                        error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                    }
                }
            }
            return signature.resolvedReturnType;
        }
        function getRestTypeOfSignature(signature) {
            if (signature.hasRestParameter) {
                var type = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (type.flags & 4096 /* Reference */ && type.target === globalArrayType) {
                    return type.typeArguments[0];
                }
            }
            return anyType;
        }
        function getSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), true);
        }
        function getErasedSignature(signature) {
            if (!signature.typeParameters)
                return signature;
            if (!signature.erasedSignatureCache) {
                if (signature.target) {
                    signature.erasedSignatureCache = instantiateSignature(getErasedSignature(signature.target), signature.mapper);
                }
                else {
                    signature.erasedSignatureCache = instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);
                }
            }
            return signature.erasedSignatureCache;
        }
        function getOrCreateTypeFromSignature(signature) {
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var isConstructor = signature.declaration.kind === 126 /* Constructor */ || signature.declaration.kind === 130 /* ConstructSignature */;
                var type = createObjectType(32768 /* Anonymous */ | 65536 /* FromSignature */);
                type.members = emptySymbols;
                type.properties = emptyArray;
                type.callSignatures = !isConstructor ? [signature] : emptyArray;
                type.constructSignatures = isConstructor ? [signature] : emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members["__index"];
        }
        function getIndexDeclarationOfSymbol(symbol, kind) {
            var syntaxKind = kind === 1 /* Number */ ? 116 /* NumberKeyword */ : 118 /* StringKeyword */;
            var indexSymbol = getIndexSymbol(symbol);
            if (indexSymbol) {
                var len = indexSymbol.declarations.length;
                for (var i = 0; i < len; i++) {
                    var node = indexSymbol.declarations[i];
                    if (node.parameters.length === 1) {
                        var parameter = node.parameters[0];
                        if (parameter && parameter.type && parameter.type.kind === syntaxKind) {
                            return node;
                        }
                    }
                }
            }
            return undefined;
        }
        function getIndexTypeOfSymbol(symbol, kind) {
            var declaration = getIndexDeclarationOfSymbol(symbol, kind);
            return declaration ? declaration.type ? getTypeFromTypeNode(declaration.type) : anyType : undefined;
        }
        function getConstraintOfTypeParameter(type) {
            if (!type.constraint) {
                if (type.target) {
                    var targetConstraint = getConstraintOfTypeParameter(type.target);
                    type.constraint = targetConstraint ? instantiateType(targetConstraint, type.mapper) : noConstraintType;
                }
                else {
                    type.constraint = getTypeFromTypeNode(getDeclarationOfKind(type.symbol, 122 /* TypeParameter */).constraint);
                }
            }
            return type.constraint === noConstraintType ? undefined : type.constraint;
        }
        function getTypeListId(types) {
            switch (types.length) {
                case 1:
                    return "" + types[0].id;
                case 2:
                    return types[0].id + "," + types[1].id;
                default:
                    var result = "";
                    for (var i = 0; i < types.length; i++) {
                        if (i > 0)
                            result += ",";
                        result += types[i].id;
                    }
                    return result;
            }
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations[id];
            if (!type) {
                type = target.instantiations[id] = createObjectType(4096 /* Reference */, target.symbol);
                type.target = target;
                type.typeArguments = typeArguments;
            }
            return type;
        }
        function isTypeParameterReferenceIllegalInConstraint(typeReferenceNode, typeParameterSymbol) {
            var links = getNodeLinks(typeReferenceNode);
            if (links.isIllegalTypeReferenceInConstraint !== undefined) {
                return links.isIllegalTypeReferenceInConstraint;
            }
            // bubble up to the declaration
            var currentNode = typeReferenceNode;
            while (!ts.forEach(typeParameterSymbol.declarations, function (d) { return d.parent === currentNode.parent; })) {
                currentNode = currentNode.parent;
            }
            // if last step was made from the type parameter this means that path has started somewhere in constraint which is illegal
            links.isIllegalTypeReferenceInConstraint = currentNode.kind === 122 /* TypeParameter */;
            return links.isIllegalTypeReferenceInConstraint;
        }
        function checkTypeParameterHasIllegalReferencesInConstraint(typeParameter) {
            var typeParameterSymbol;
            function check(n) {
                if (n.kind === 132 /* TypeReference */ && n.typeName.kind === 63 /* Identifier */) {
                    var links = getNodeLinks(n);
                    if (links.isIllegalTypeReferenceInConstraint === undefined) {
                        var symbol = resolveName(typeParameter, n.typeName.text, 3152352 /* Type */, undefined, undefined);
                        if (symbol && (symbol.flags & 1048576 /* TypeParameter */)) {
                            // TypeScript 1.0 spec (April 2014): 3.4.1
                            // Type parameters declared in a particular type parameter list 
                            // may not be referenced in constraints in that type parameter list
                            // symbol.declaration.parent === typeParameter.parent
                            // -> typeParameter and symbol.declaration originate from the same type parameter list 
                            // -> illegal for all declarations in symbol
                            // forEach === exists
                            links.isIllegalTypeReferenceInConstraint = ts.forEach(symbol.declarations, function (d) { return d.parent == typeParameter.parent; });
                        }
                    }
                    if (links.isIllegalTypeReferenceInConstraint) {
                        error(typeParameter, ts.Diagnostics.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);
                    }
                }
                ts.forEachChild(n, check);
            }
            if (typeParameter.constraint) {
                typeParameterSymbol = getSymbolOfNode(typeParameter);
                check(typeParameter.constraint);
            }
        }
        function getTypeFromTypeReferenceNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var symbol = resolveEntityName(node, node.typeName, 3152352 /* Type */);
                if (symbol) {
                    var type;
                    if ((symbol.flags & 1048576 /* TypeParameter */) && isTypeParameterReferenceIllegalInConstraint(node, symbol)) {
                        // TypeScript 1.0 spec (April 2014): 3.4.1
                        // Type parameters declared in a particular type parameter list 
                        // may not be referenced in constraints in that type parameter list
                        // Implementation: such type references are resolved to 'unknown' type that usually denotes error
                        type = unknownType;
                    }
                    else {
                        type = getDeclaredTypeOfSymbol(symbol);
                        if (type.flags & (1024 /* Class */ | 2048 /* Interface */) && type.flags & 4096 /* Reference */) {
                            var typeParameters = type.typeParameters;
                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {
                                type = createTypeReference(type, ts.map(node.typeArguments, getTypeFromTypeNode));
                            }
                            else {
                                error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);
                                type = undefined;
                            }
                        }
                        else {
                            if (node.typeArguments) {
                                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
                                type = undefined;
                            }
                        }
                    }
                }
                links.resolvedType = type || unknownType;
            }
            return links.resolvedType;
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result. 
                links.resolvedType = getWidenedType(checkExpression(node.exprName));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                for (var i = 0; i < declarations.length; i++) {
                    var declaration = declarations[i];
                    switch (declaration.kind) {
                        case 184 /* ClassDeclaration */:
                        case 185 /* InterfaceDeclaration */:
                        case 187 /* EnumDeclaration */:
                            return declaration;
                    }
                }
            }
            if (!symbol) {
                return emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & 48128 /* ObjectType */)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbol.name);
                return emptyObjectType;
            }
            if ((type.typeParameters ? type.typeParameters.length : 0) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbol.name, arity);
                return emptyObjectType;
            }
            return type;
        }
        function getGlobalSymbol(name) {
            return resolveName(undefined, name, 3152352 /* Type */, ts.Diagnostics.Cannot_find_global_type_0, name);
        }
        function getGlobalType(name) {
            return getTypeOfGlobalSymbol(getGlobalSymbol(name), 0);
        }
        function createArrayType(elementType) {
            // globalArrayType will be undefined if we get here during creation of the Array type. This for example happens if
            // user code augments the Array type with call or construct signatures that have an array type as the return type.
            // We instead use globalArraySymbol to obtain the (not yet fully constructed) Array type.
            var arrayType = globalArrayType || getDeclaredTypeOfSymbol(globalArraySymbol);
            return arrayType !== emptyObjectType ? createTypeReference(arrayType, [elementType]) : emptyObjectType;
        }
        function getTypeFromArrayTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));
            }
            return links.resolvedType;
        }
        function createTupleType(elementTypes) {
            var id = getTypeListId(elementTypes);
            var type = tupleTypes[id];
            if (!type) {
                type = tupleTypes[id] = createObjectType(8192 /* Tuple */);
                type.elementTypes = elementTypes;
            }
            return type;
        }
        function getTypeFromTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = createTupleType(ts.map(node.elementTypes, getTypeFromTypeNode));
            }
            return links.resolvedType;
        }
        function addTypeToSortedSet(sortedSet, type) {
            if (type.flags & 16384 /* Union */) {
                addTypesToSortedSet(sortedSet, type.types);
            }
            else {
                var i = 0;
                var id = type.id;
                while (i < sortedSet.length && sortedSet[i].id < id) {
                    i++;
                }
                if (i === sortedSet.length || sortedSet[i].id !== id) {
                    sortedSet.splice(i, 0, type);
                }
            }
        }
        function addTypesToSortedSet(sortedTypes, types) {
            for (var i = 0, len = types.length; i < len; i++) {
                addTypeToSortedSet(sortedTypes, types[i]);
            }
        }
        function isSubtypeOfAny(candidate, types) {
            for (var i = 0, len = types.length; i < len; i++) {
                if (candidate !== types[i] && isTypeSubtypeOf(candidate, types[i])) {
                    return true;
                }
            }
            return false;
        }
        function removeSubtypes(types) {
            var i = types.length;
            while (i > 0) {
                i--;
                if (isSubtypeOfAny(types[i], types)) {
                    types.splice(i, 1);
                }
            }
        }
        function containsAnyType(types) {
            for (var i = 0; i < types.length; i++) {
                if (types[i].flags & 1 /* Any */) {
                    return true;
                }
            }
            return false;
        }
        function removeAllButLast(types, typeToRemove) {
            var i = types.length;
            while (i > 0 && types.length > 1) {
                i--;
                if (types[i] === typeToRemove) {
                    types.splice(i, 1);
                }
            }
        }
        function getUnionType(types, noSubtypeReduction) {
            if (types.length === 0) {
                return emptyObjectType;
            }
            var sortedTypes = [];
            addTypesToSortedSet(sortedTypes, types);
            if (noSubtypeReduction) {
                if (containsAnyType(sortedTypes)) {
                    return anyType;
                }
                removeAllButLast(sortedTypes, undefinedType);
                removeAllButLast(sortedTypes, nullType);
            }
            else {
                removeSubtypes(sortedTypes);
            }
            if (sortedTypes.length === 1) {
                return sortedTypes[0];
            }
            var id = getTypeListId(sortedTypes);
            var type = unionTypes[id];
            if (!type) {
                type = unionTypes[id] = createObjectType(16384 /* Union */);
                type.types = sortedTypes;
            }
            return type;
        }
        function getTypeFromUnionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), true);
            }
            return links.resolvedType;
        }
        function getTypeFromTypeLiteralNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // Deferred resolution of members is handled by resolveObjectTypeMembers
                links.resolvedType = createObjectType(32768 /* Anonymous */, node.symbol);
            }
            return links.resolvedType;
        }
        function getStringLiteralType(node) {
            if (ts.hasProperty(stringLiteralTypes, node.text))
                return stringLiteralTypes[node.text];
            var type = stringLiteralTypes[node.text] = createType(256 /* StringLiteral */);
            type.text = ts.getTextOfNode(node);
            return type;
        }
        function getTypeFromStringLiteral(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getStringLiteralType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromTypeNode(node) {
            switch (node.kind) {
                case 109 /* AnyKeyword */:
                    return anyType;
                case 118 /* StringKeyword */:
                    return stringType;
                case 116 /* NumberKeyword */:
                    return numberType;
                case 110 /* BooleanKeyword */:
                    return booleanType;
                case 97 /* VoidKeyword */:
                    return voidType;
                case 7 /* StringLiteral */:
                    return getTypeFromStringLiteral(node);
                case 132 /* TypeReference */:
                    return getTypeFromTypeReferenceNode(node);
                case 133 /* TypeQuery */:
                    return getTypeFromTypeQueryNode(node);
                case 135 /* ArrayType */:
                    return getTypeFromArrayTypeNode(node);
                case 136 /* TupleType */:
                    return getTypeFromTupleTypeNode(node);
                case 137 /* UnionType */:
                    return getTypeFromUnionTypeNode(node);
                case 138 /* ParenType */:
                    return getTypeFromTypeNode(node.type);
                case 134 /* TypeLiteral */:
                    return getTypeFromTypeLiteralNode(node);
                case 63 /* Identifier */:
                case 121 /* QualifiedName */:
                    var symbol = getSymbolInfo(node);
                    return symbol && getDeclaredTypeOfSymbol(symbol);
                default:
                    return unknownType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                var result = [];
                for (var i = 0; i < items.length; i++) {
                    result.push(instantiator(items[i], mapper));
                }
                return result;
            }
            return items;
        }
        function createUnaryTypeMapper(source, target) {
            return function (t) { return t === source ? target : t; };
        }
        function createBinaryTypeMapper(source1, target1, source2, target2) {
            return function (t) { return t === source1 ? target1 : t === source2 ? target2 : t; };
        }
        function createTypeMapper(sources, targets) {
            switch (sources.length) {
                case 1: return createUnaryTypeMapper(sources[0], targets[0]);
                case 2: return createBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return targets[i];
                }
                return t;
            };
        }
        function createUnaryTypeEraser(source) {
            return function (t) { return t === source ? anyType : t; };
        }
        function createBinaryTypeEraser(source1, source2) {
            return function (t) { return t === source1 || t === source2 ? anyType : t; };
        }
        function createTypeEraser(sources) {
            switch (sources.length) {
                case 1: return createUnaryTypeEraser(sources[0]);
                case 2: return createBinaryTypeEraser(sources[0], sources[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return anyType;
                }
                return t;
            };
        }
        function createInferenceMapper(context) {
            return function (t) {
                for (var i = 0; i < context.typeParameters.length; i++) {
                    if (t === context.typeParameters[i]) {
                        return getInferredType(context, i);
                    }
                }
                return t;
            };
        }
        function identityMapper(type) {
            return type;
        }
        function combineTypeMappers(mapper1, mapper2) {
            return function (t) { return mapper2(mapper1(t)); };
        }
        function instantiateTypeParameter(typeParameter, mapper) {
            var result = createType(512 /* TypeParameter */);
            result.symbol = typeParameter.symbol;
            if (typeParameter.constraint) {
                result.constraint = instantiateType(typeParameter.constraint, mapper);
            }
            else {
                result.target = typeParameter;
                result.mapper = mapper;
            }
            return result;
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            if (signature.typeParameters && !eraseTypeParameters) {
                var freshTypeParameters = instantiateList(signature.typeParameters, mapper, instantiateTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            }
            var result = createSignature(signature.declaration, freshTypeParameters, instantiateList(signature.parameters, mapper, instantiateSymbol), signature.resolvedReturnType ? instantiateType(signature.resolvedReturnType, mapper) : undefined, signature.minArgumentCount, signature.hasRestParameter, signature.hasStringLiterals);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            if (symbol.flags & 67108864 /* Instantiated */) {
                var links = getSymbolLinks(symbol);
                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and 
            // also transient so that we can just store data on it directly.
            var result = createSymbol(67108864 /* Instantiated */ | 268435456 /* Transient */ | symbol.flags, symbol.name);
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            return result;
        }
        function instantiateAnonymousType(type, mapper) {
            var result = createObjectType(32768 /* Anonymous */, type.symbol);
            result.properties = instantiateList(getPropertiesOfObjectType(type), mapper, instantiateSymbol);
            result.members = createSymbolTable(result.properties);
            result.callSignatures = instantiateList(getSignaturesOfType(type, 0 /* Call */), mapper, instantiateSignature);
            result.constructSignatures = instantiateList(getSignaturesOfType(type, 1 /* Construct */), mapper, instantiateSignature);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType)
                result.stringIndexType = instantiateType(stringIndexType, mapper);
            if (numberIndexType)
                result.numberIndexType = instantiateType(numberIndexType, mapper);
            return result;
        }
        function instantiateType(type, mapper) {
            if (mapper !== identityMapper) {
                if (type.flags & 512 /* TypeParameter */) {
                    return mapper(type);
                }
                if (type.flags & 32768 /* Anonymous */) {
                    return type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */ | 2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */) ? instantiateAnonymousType(type, mapper) : type;
                }
                if (type.flags & 4096 /* Reference */) {
                    return createTypeReference(type.target, instantiateList(type.typeArguments, mapper, instantiateType));
                }
                if (type.flags & 8192 /* Tuple */) {
                    return createTupleType(instantiateList(type.elementTypes, mapper, instantiateType));
                }
                if (type.flags & 16384 /* Union */) {
                    return getUnionType(instantiateList(type.types, mapper, instantiateType), true);
                }
            }
            return type;
        }
        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        // that is subject to contextual typing.
        function isContextSensitiveExpression(node) {
            switch (node.kind) {
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                    return !node.typeParameters && !ts.forEach(node.parameters, function (p) { return p.type; });
                case 140 /* ObjectLiteral */:
                    return ts.forEach(node.properties, function (p) { return p.kind === 141 /* PropertyAssignment */ && isContextSensitiveExpression(p.initializer); });
                case 139 /* ArrayLiteral */:
                    return ts.forEach(node.elements, function (e) { return isContextSensitiveExpression(e); });
                case 154 /* ConditionalExpression */:
                    return isContextSensitiveExpression(node.whenTrue) || isContextSensitiveExpression(node.whenFalse);
                case 153 /* BinaryExpression */:
                    return node.operator === 48 /* BarBarToken */ && (isContextSensitiveExpression(node.left) || isContextSensitiveExpression(node.right));
            }
            return false;
        }
        function getTypeWithoutConstructors(type) {
            if (type.flags & 48128 /* ObjectType */) {
                var resolved = resolveObjectOrUnionTypeMembers(type);
                if (resolved.constructSignatures.length) {
                    var result = createObjectType(32768 /* Anonymous */, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = resolved.callSignatures;
                    result.constructSignatures = emptyArray;
                    type = result;
                }
            }
            return type;
        }
        // TYPE CHECKING
        var subtypeRelation = {};
        var assignableRelation = {};
        var identityRelation = {};
        function isTypeIdenticalTo(source, target) {
            return checkTypeRelatedTo(source, target, identityRelation, undefined);
        }
        function compareTypes(source, target) {
            return checkTypeRelatedTo(source, target, identityRelation, undefined) ? -1 /* True */ : 0 /* False */;
        }
        function isTypeSubtypeOf(source, target) {
            return checkTypeSubtypeOf(source, target, undefined);
        }
        function isTypeAssignableTo(source, target) {
            return checkTypeAssignableTo(source, target, undefined);
        }
        function checkTypeSubtypeOf(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, headMessage, containingMessageChain);
        }
        function checkTypeAssignableTo(source, target, errorNode, headMessage) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage);
        }
        function isSignatureAssignableTo(source, target) {
            var sourceType = getOrCreateTypeFromSignature(source);
            var targetType = getOrCreateTypeFromSignature(target);
            return checkTypeRelatedTo(sourceType, targetType, assignableRelation, undefined);
        }
        function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain) {
            var errorInfo;
            var sourceStack;
            var targetStack;
            var expandingFlags;
            var depth = 0;
            var overflow = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedTo(source, target, errorNode !== undefined, headMessage);
            if (overflow) {
                error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
            }
            else if (errorInfo) {
                if (containingMessageChain) {
                    errorInfo = ts.concatenateDiagnosticMessageChains(containingMessageChain, errorInfo);
                }
                addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, program.getCompilerHost().getNewLine()));
            }
            return result !== 0 /* False */;
            function reportError(message, arg0, arg1, arg2) {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);
            }
            // Compare two types and return
            // Ternary.True if they are related with no assumptions,
            // Ternary.Maybe if they are related with assumptions of other relationships, or
            // Ternary.False if they are not related.
            function isRelatedTo(source, target, reportErrors, headMessage) {
                var result;
                if (relation === identityRelation) {
                    // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases
                    if (source === target)
                        return -1 /* True */;
                }
                else {
                    if (source === target)
                        return -1 /* True */;
                    if (target.flags & 1 /* Any */)
                        return -1 /* True */;
                    if (source === undefinedType)
                        return -1 /* True */;
                    if (source === nullType && target !== undefinedType)
                        return -1 /* True */;
                    if (source.flags & 128 /* Enum */ && target === numberType)
                        return -1 /* True */;
                    if (source.flags & 256 /* StringLiteral */ && target === stringType)
                        return -1 /* True */;
                    if (relation === assignableRelation) {
                        if (source.flags & 1 /* Any */)
                            return -1 /* True */;
                        if (source === numberType && target.flags & 128 /* Enum */)
                            return -1 /* True */;
                    }
                }
                if (source.flags & 16384 /* Union */) {
                    if (result = unionTypeRelatedToType(source, target, reportErrors)) {
                        return result;
                    }
                }
                else if (target.flags & 16384 /* Union */) {
                    if (result = typeRelatedToUnionType(source, target, reportErrors)) {
                        return result;
                    }
                }
                else if (source.flags & 512 /* TypeParameter */ && target.flags & 512 /* TypeParameter */) {
                    if (result = typeParameterRelatedTo(source, target, reportErrors)) {
                        return result;
                    }
                }
                else {
                    var saveErrorInfo = errorInfo;
                    if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                        // We have type references to same target type, see if relationship holds for all type arguments
                        if (result = typesRelatedTo(source.typeArguments, target.typeArguments, reportErrors)) {
                            return result;
                        }
                    }
                    // Even if relationship doesn't hold for type arguments, it may hold in a structural comparison
                    // Report structural errors only if we haven't reported any errors yet
                    var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo;
                    // identity relation does not use apparent type
                    var sourceOrApparentType = relation === identityRelation ? source : getApparentType(source);
                    if (sourceOrApparentType.flags & 48128 /* ObjectType */ && target.flags & 48128 /* ObjectType */ && (result = objectTypeRelatedTo(sourceOrApparentType, target, reportStructuralErrors))) {
                        errorInfo = saveErrorInfo;
                        return result;
                    }
                }
                if (reportErrors) {
                    headMessage = headMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    reportError(headMessage, typeToString(source), typeToString(target));
                }
                return 0 /* False */;
            }
            function typeRelatedToUnionType(source, target, reportErrors) {
                var targetTypes = target.types;
                for (var i = 0, len = targetTypes.length; i < len; i++) {
                    var related = isRelatedTo(source, targetTypes[i], reportErrors && i === len - 1);
                    if (related) {
                        return related;
                    }
                }
                return 0 /* False */;
            }
            function unionTypeRelatedToType(source, target, reportErrors) {
                var result = -1 /* True */;
                var sourceTypes = source.types;
                for (var i = 0, len = sourceTypes.length; i < len; i++) {
                    var related = isRelatedTo(sourceTypes[i], target, reportErrors);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typesRelatedTo(sources, targets, reportErrors) {
                var result = -1 /* True */;
                for (var i = 0, len = sources.length; i < len; i++) {
                    var related = isRelatedTo(sources[i], targets[i], reportErrors);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeParameterRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    if (source.symbol.name !== target.symbol.name) {
                        return 0 /* False */;
                    }
                    // covers case when both type parameters does not have constraint (both equal to noConstraintType)
                    if (source.constraint === target.constraint) {
                        return -1 /* True */;
                    }
                    if (source.constraint === noConstraintType || target.constraint === noConstraintType) {
                        return 0 /* False */;
                    }
                    return isRelatedTo(source.constraint, target.constraint, reportErrors);
                }
                else {
                    while (true) {
                        var constraint = getConstraintOfTypeParameter(source);
                        if (constraint === target)
                            return -1 /* True */;
                        if (!(constraint && constraint.flags & 512 /* TypeParameter */))
                            break;
                        source = constraint;
                    }
                    return 0 /* False */;
                }
            }
            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            function objectTypeRelatedTo(source, target, reportErrors) {
                if (overflow) {
                    return 0 /* False */;
                }
                var id = source.id + "," + target.id;
                var related = relation[id];
                if (related !== undefined) {
                    return related;
                }
                if (depth > 0) {
                    for (var i = 0; i < depth; i++) {
                        // If source and target are already being compared, consider them related with assumptions
                        if (source === sourceStack[i] && target === targetStack[i]) {
                            return 1 /* Maybe */;
                        }
                    }
                    if (depth === 100) {
                        overflow = true;
                        return 0 /* False */;
                    }
                }
                else {
                    sourceStack = [];
                    targetStack = [];
                    expandingFlags = 0;
                }
                sourceStack[depth] = source;
                targetStack[depth] = target;
                depth++;
                var saveExpandingFlags = expandingFlags;
                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack))
                    expandingFlags |= 1;
                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack))
                    expandingFlags |= 2;
                if (expandingFlags === 3) {
                    var result = -1 /* True */;
                }
                else {
                    var result = propertiesRelatedTo(source, target, reportErrors);
                    if (result) {
                        result &= signaturesRelatedTo(source, target, 0 /* Call */, reportErrors);
                        if (result) {
                            result &= signaturesRelatedTo(source, target, 1 /* Construct */, reportErrors);
                            if (result) {
                                result &= stringIndexTypesRelatedTo(source, target, reportErrors);
                                if (result) {
                                    result &= numberIndexTypesRelatedTo(source, target, reportErrors);
                                }
                            }
                        }
                    }
                }
                expandingFlags = saveExpandingFlags;
                depth--;
                // Only cache results that are free of assumptions
                if (result !== 1 /* Maybe */) {
                    relation[id] = result;
                }
                return result;
            }
            // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case
            // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,
            // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.
            // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at
            // some level beyond that.
            function isDeeplyNestedGeneric(type, stack) {
                if (type.flags & 4096 /* Reference */ && depth >= 10) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target) {
                            count++;
                            if (count >= 10)
                                return true;
                        }
                    }
                }
                return false;
            }
            function propertiesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return propertiesIdenticalTo(source, target);
                }
                var result = -1 /* True */;
                var properties = getPropertiesOfObjectType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfType(source, targetProp.name);
                    if (sourceProp !== targetProp) {
                        if (!sourceProp) {
                            if (relation === subtypeRelation || !isOptionalProperty(targetProp)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));
                                }
                                return 0 /* False */;
                            }
                        }
                        else if (!(targetProp.flags & 536870912 /* Prototype */)) {
                            var sourceFlags = getDeclarationFlagsFromSymbol(sourceProp);
                            var targetFlags = getDeclarationFlagsFromSymbol(targetProp);
                            if (sourceFlags & 32 /* Private */ || targetFlags & 32 /* Private */) {
                                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                                    if (reportErrors) {
                                        if (sourceFlags & 32 /* Private */ && targetFlags & 32 /* Private */) {
                                            reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                                        }
                                        else {
                                            reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourceFlags & 32 /* Private */ ? source : target), typeToString(sourceFlags & 32 /* Private */ ? target : source));
                                        }
                                    }
                                    return 0 /* False */;
                                }
                            }
                            else if (targetFlags & 64 /* Protected */) {
                                var sourceDeclaredInClass = sourceProp.parent && sourceProp.parent.flags & 32 /* Class */;
                                var sourceClass = sourceDeclaredInClass ? getDeclaredTypeOfSymbol(sourceProp.parent) : undefined;
                                var targetClass = getDeclaredTypeOfSymbol(targetProp.parent);
                                if (!sourceClass || !hasBaseType(sourceClass, targetClass)) {
                                    if (reportErrors) {
                                        reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(sourceClass || source), typeToString(targetClass));
                                    }
                                    return 0 /* False */;
                                }
                            }
                            else if (sourceFlags & 64 /* Protected */) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return 0 /* False */;
                            }
                            var related = isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
                            if (!related) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                                }
                                return 0 /* False */;
                            }
                            result &= related;
                            if (isOptionalProperty(sourceProp) && !isOptionalProperty(targetProp)) {
                                // TypeScript 1.0 spec (April 2014): 3.8.3
                                // S is a subtype of a type T, and T is a supertype of S if ...
                                // S' and T are object types and, for each member M in T..
                                // M is a property and S' contains a property N where
                                // if M is a required property, N is also a required property 
                                // (M - property in T)
                                // (N - property in S)
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return 0 /* False */;
                            }
                        }
                    }
                }
                return result;
            }
            function propertiesIdenticalTo(source, target) {
                var sourceProperties = getPropertiesOfObjectType(source);
                var targetProperties = getPropertiesOfObjectType(target);
                if (sourceProperties.length !== targetProperties.length) {
                    return 0 /* False */;
                }
                var result = -1 /* True */;
                for (var i = 0, len = sourceProperties.length; i < len; ++i) {
                    var sourceProp = sourceProperties[i];
                    var targetProp = getPropertyOfObjectType(target, sourceProp.name);
                    if (!targetProp) {
                        return 0 /* False */;
                    }
                    var related = compareProperties(sourceProp, targetProp, isRelatedTo);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
                return result;
            }
            function signaturesRelatedTo(source, target, kind, reportErrors) {
                if (relation === identityRelation) {
                    return signaturesIdenticalTo(source, target, kind);
                }
                if (target === anyFunctionType || source === anyFunctionType) {
                    return -1 /* True */;
                }
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var result = -1 /* True */;
                var saveErrorInfo = errorInfo;
                outer: for (var i = 0; i < targetSignatures.length; i++) {
                    var t = targetSignatures[i];
                    if (!t.hasStringLiterals || target.flags & 65536 /* FromSignature */) {
                        var localErrors = reportErrors;
                        for (var j = 0; j < sourceSignatures.length; j++) {
                            var s = sourceSignatures[j];
                            if (!s.hasStringLiterals || source.flags & 65536 /* FromSignature */) {
                                var related = signatureRelatedTo(s, t, localErrors);
                                if (related) {
                                    result &= related;
                                    errorInfo = saveErrorInfo;
                                    continue outer;
                                }
                                // Only report errors from the first failure
                                localErrors = false;
                            }
                        }
                        return 0 /* False */;
                    }
                }
                return result;
            }
            function signatureRelatedTo(source, target, reportErrors) {
                if (source === target) {
                    return -1 /* True */;
                }
                if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {
                    return 0 /* False */;
                }
                var sourceMax = source.parameters.length;
                var targetMax = target.parameters.length;
                var checkCount;
                if (source.hasRestParameter && target.hasRestParameter) {
                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;
                    sourceMax--;
                    targetMax--;
                }
                else if (source.hasRestParameter) {
                    sourceMax--;
                    checkCount = targetMax;
                }
                else if (target.hasRestParameter) {
                    targetMax--;
                    checkCount = sourceMax;
                }
                else {
                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;
                }
                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = getErasedSignature(source);
                target = getErasedSignature(target);
                var result = -1 /* True */;
                for (var i = 0; i < checkCount; i++) {
                    var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                    var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                    var saveErrorInfo = errorInfo;
                    var related = isRelatedTo(s, t, reportErrors);
                    if (!related) {
                        related = isRelatedTo(t, s, false);
                        if (!related) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, source.parameters[i < sourceMax ? i : sourceMax].name, target.parameters[i < targetMax ? i : targetMax].name);
                            }
                            return 0 /* False */;
                        }
                        errorInfo = saveErrorInfo;
                    }
                    result &= related;
                }
                var t = getReturnTypeOfSignature(target);
                if (t === voidType)
                    return result;
                var s = getReturnTypeOfSignature(source);
                return result & isRelatedTo(s, t, reportErrors);
            }
            function signaturesIdenticalTo(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (sourceSignatures.length !== targetSignatures.length) {
                    return 0 /* False */;
                }
                var result = -1 /* True */;
                for (var i = 0, len = sourceSignatures.length; i < len; ++i) {
                    var related = compareSignatures(sourceSignatures[i], targetSignatures[i], true, isRelatedTo);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
                return result;
            }
            function stringIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return indexTypesIdenticalTo(0 /* String */, source, target);
                }
                var targetType = getIndexTypeOfType(target, 0 /* String */);
                if (targetType) {
                    var sourceType = getIndexTypeOfType(source, 0 /* String */);
                    if (!sourceType) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                        }
                        return 0 /* False */;
                    }
                    var related = isRelatedTo(sourceType, targetType, reportErrors);
                    if (!related) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Index_signatures_are_incompatible);
                        }
                        return 0 /* False */;
                    }
                    return related;
                }
                return -1 /* True */;
            }
            function numberIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return indexTypesIdenticalTo(1 /* Number */, source, target);
                }
                var targetType = getIndexTypeOfType(target, 1 /* Number */);
                if (targetType) {
                    var sourceStringType = getIndexTypeOfType(source, 0 /* String */);
                    var sourceNumberType = getIndexTypeOfType(source, 1 /* Number */);
                    if (!(sourceStringType || sourceNumberType)) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                        }
                        return 0 /* False */;
                    }
                    if (sourceStringType && sourceNumberType) {
                        // If we know for sure we're testing both string and numeric index types then only report errors from the second one
                        var related = isRelatedTo(sourceStringType, targetType, false) || isRelatedTo(sourceNumberType, targetType, reportErrors);
                    }
                    else {
                        var related = isRelatedTo(sourceStringType || sourceNumberType, targetType, reportErrors);
                    }
                    if (!related) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Index_signatures_are_incompatible);
                        }
                        return 0 /* False */;
                    }
                    return related;
                }
                return -1 /* True */;
            }
            function indexTypesIdenticalTo(indexKind, source, target) {
                var targetType = getIndexTypeOfType(target, indexKind);
                var sourceType = getIndexTypeOfType(source, indexKind);
                if (!sourceType && !targetType) {
                    return -1 /* True */;
                }
                if (sourceType && targetType) {
                    return isRelatedTo(sourceType, targetType);
                }
                return 0 /* False */;
            }
        }
        function isPropertyIdenticalTo(sourceProp, targetProp) {
            return compareProperties(sourceProp, targetProp, compareTypes) !== 0 /* False */;
        }
        function compareProperties(sourceProp, targetProp, compareTypes) {
            // Two members are considered identical when
            // - they are public properties with identical names, optionality, and types,
            // - they are private or protected properties originating in the same declaration and having identical types
            if (sourceProp === targetProp) {
                return -1 /* True */;
            }
            var sourcePropAccessibility = getDeclarationFlagsFromSymbol(sourceProp) & (32 /* Private */ | 64 /* Protected */);
            var targetPropAccessibility = getDeclarationFlagsFromSymbol(targetProp) & (32 /* Private */ | 64 /* Protected */);
            if (sourcePropAccessibility !== targetPropAccessibility) {
                return 0 /* False */;
            }
            if (sourcePropAccessibility) {
                if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                    return 0 /* False */;
                }
            }
            else {
                if (isOptionalProperty(sourceProp) !== isOptionalProperty(targetProp)) {
                    return 0 /* False */;
                }
            }
            return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
        }
        function compareSignatures(source, target, compareReturnTypes, compareTypes) {
            if (source === target) {
                return -1 /* True */;
            }
            if (source.parameters.length !== target.parameters.length || source.minArgumentCount !== target.minArgumentCount || source.hasRestParameter !== target.hasRestParameter) {
                return 0 /* False */;
            }
            var result = -1 /* True */;
            if (source.typeParameters && target.typeParameters) {
                if (source.typeParameters.length !== target.typeParameters.length) {
                    return 0 /* False */;
                }
                for (var i = 0, len = source.typeParameters.length; i < len; ++i) {
                    var related = compareTypes(source.typeParameters[i], target.typeParameters[i]);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
            }
            else if (source.typeParameters || source.typeParameters) {
                return 0 /* False */;
            }
            // Spec 1.0 Section 3.8.3 & 3.8.4:
            // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
            source = getErasedSignature(source);
            target = getErasedSignature(target);
            for (var i = 0, len = source.parameters.length; i < len; i++) {
                var s = source.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(source) : getTypeOfSymbol(source.parameters[i]);
                var t = target.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(target) : getTypeOfSymbol(target.parameters[i]);
                var related = compareTypes(s, t);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            if (compareReturnTypes) {
                result &= compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            return result;
        }
        function isSupertypeOfEach(candidate, types) {
            for (var i = 0, len = types.length; i < len; i++) {
                if (candidate !== types[i] && !isTypeSubtypeOf(types[i], candidate))
                    return false;
            }
            return true;
        }
        function getCommonSupertype(types) {
            return ts.forEach(types, function (t) { return isSupertypeOfEach(t, types) ? t : undefined; });
        }
        function reportNoCommonSupertypeError(types, errorLocation, errorMessageChainHead) {
            var bestSupertype;
            var bestSupertypeDownfallType; // The type that caused bestSupertype not to be the common supertype
            var bestSupertypeScore = 0;
            for (var i = 0; i < types.length; i++) {
                var score = 0;
                var downfallType = undefined;
                for (var j = 0; j < types.length; j++) {
                    if (isTypeSubtypeOf(types[j], types[i])) {
                        score++;
                    }
                    else if (!downfallType) {
                        downfallType = types[j];
                    }
                }
                if (score > bestSupertypeScore) {
                    bestSupertype = types[i];
                    bestSupertypeDownfallType = downfallType;
                    bestSupertypeScore = score;
                }
                // types.length - 1 is the maximum score, given that getCommonSupertype returned false
                if (bestSupertypeScore === types.length - 1) {
                    break;
                }
            }
            // In the following errors, the {1} slot is before the {0} slot because checkTypeSubtypeOf supplies the
            // subtype as the first argument to the error
            checkTypeSubtypeOf(bestSupertypeDownfallType, bestSupertype, errorLocation, ts.Diagnostics.Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0, errorMessageChainHead);
        }
        function isTypeOfObjectLiteral(type) {
            return (type.flags & 32768 /* Anonymous */) && type.symbol && (type.symbol.flags & 4096 /* ObjectLiteral */) ? true : false;
        }
        function isArrayType(type) {
            return type.flags & 4096 /* Reference */ && type.target === globalArrayType;
        }
        function getInnermostTypeOfNestedArrayTypes(type) {
            while (isArrayType(type)) {
                type = type.typeArguments[0];
            }
            return type;
        }
        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */
        function getWidenedType(type, suppressNoImplicitAnyErrors) {
            if (type.flags & (32 /* Undefined */ | 64 /* Null */)) {
                return anyType;
            }
            if (type.flags & 16384 /* Union */) {
                return getWidenedTypeOfUnion(type);
            }
            if (isTypeOfObjectLiteral(type)) {
                return getWidenedTypeOfObjectLiteral(type);
            }
            if (isArrayType(type)) {
                return getWidenedTypeOfArrayLiteral(type);
            }
            return type;
            function getWidenedTypeOfUnion(type) {
                return getUnionType(ts.map(type.types, function (t) { return getWidenedType(t, suppressNoImplicitAnyErrors); }));
            }
            function getWidenedTypeOfObjectLiteral(type) {
                var properties = getPropertiesOfObjectType(type);
                if (properties.length) {
                    var widenedTypes = [];
                    var propTypeWasWidened = false;
                    ts.forEach(properties, function (p) {
                        var propType = getTypeOfSymbol(p);
                        var widenedType = getWidenedType(propType);
                        if (propType !== widenedType) {
                            propTypeWasWidened = true;
                            if (!suppressNoImplicitAnyErrors && compilerOptions.noImplicitAny && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                                error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(widenedType));
                            }
                        }
                        widenedTypes.push(widenedType);
                    });
                    if (propTypeWasWidened) {
                        var members = {};
                        var index = 0;
                        ts.forEach(properties, function (p) {
                            var symbol = createSymbol(4 /* Property */ | 268435456 /* Transient */ | p.flags, p.name);
                            symbol.declarations = p.declarations;
                            symbol.parent = p.parent;
                            symbol.type = widenedTypes[index++];
                            symbol.target = p;
                            if (p.valueDeclaration)
                                symbol.valueDeclaration = p.valueDeclaration;
                            members[symbol.name] = symbol;
                        });
                        var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
                        var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
                        if (stringIndexType)
                            stringIndexType = getWidenedType(stringIndexType);
                        if (numberIndexType)
                            numberIndexType = getWidenedType(numberIndexType);
                        type = createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexType, numberIndexType);
                    }
                }
                return type;
            }
            function getWidenedTypeOfArrayLiteral(type) {
                var elementType = type.typeArguments[0];
                var widenedType = getWidenedType(elementType, suppressNoImplicitAnyErrors);
                type = elementType !== widenedType ? createArrayType(widenedType) : type;
                return type;
            }
        }
        function forEachMatchingParameterType(source, target, callback) {
            var sourceMax = source.parameters.length;
            var targetMax = target.parameters.length;
            var count;
            if (source.hasRestParameter && target.hasRestParameter) {
                count = sourceMax > targetMax ? sourceMax : targetMax;
                sourceMax--;
                targetMax--;
            }
            else if (source.hasRestParameter) {
                sourceMax--;
                count = targetMax;
            }
            else if (target.hasRestParameter) {
                targetMax--;
                count = sourceMax;
            }
            else {
                count = sourceMax < targetMax ? sourceMax : targetMax;
            }
            for (var i = 0; i < count; i++) {
                var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                callback(s, t);
            }
        }
        function createInferenceContext(typeParameters, inferUnionTypes) {
            var inferences = [];
            for (var i = 0; i < typeParameters.length; i++) {
                inferences.push({ primary: undefined, secondary: undefined });
            }
            return {
                typeParameters: typeParameters,
                inferUnionTypes: inferUnionTypes,
                inferenceCount: 0,
                inferences: inferences,
                inferredTypes: new Array(typeParameters.length)
            };
        }
        function inferTypes(context, source, target) {
            var sourceStack;
            var targetStack;
            var depth = 0;
            var inferiority = 0;
            inferFromTypes(source, target);
            function isInProcess(source, target) {
                for (var i = 0; i < depth; i++) {
                    if (source === sourceStack[i] && target === targetStack[i])
                        return true;
                }
                return false;
            }
            function isWithinDepthLimit(type, stack) {
                if (depth >= 5) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target)
                            count++;
                    }
                    return count < 5;
                }
                return true;
            }
            function inferFromTypes(source, target) {
                if (target.flags & 512 /* TypeParameter */) {
                    // If target is a type parameter, make an inference
                    var typeParameters = context.typeParameters;
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (target === typeParameters[i]) {
                            var inferences = context.inferences[i];
                            var candidates = inferiority ? inferences.secondary || (inferences.secondary = []) : inferences.primary || (inferences.primary = []);
                            if (!ts.contains(candidates, source))
                                candidates.push(source);
                            break;
                        }
                    }
                }
                else if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                    // If source and target are references to the same generic type, infer from type arguments
                    var sourceTypes = source.typeArguments;
                    var targetTypes = target.typeArguments;
                    for (var i = 0; i < sourceTypes.length; i++) {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if (target.flags & 16384 /* Union */) {
                    var targetTypes = target.types;
                    var typeParameterCount = 0;
                    var typeParameter;
                    for (var i = 0; i < targetTypes.length; i++) {
                        var t = targetTypes[i];
                        if (t.flags & 512 /* TypeParameter */ && ts.contains(context.typeParameters, t)) {
                            typeParameter = t;
                            typeParameterCount++;
                        }
                        else {
                            inferFromTypes(source, t);
                        }
                    }
                    // If union contains a single naked type parameter, make a secondary inference to that type parameter
                    if (typeParameterCount === 1) {
                        inferiority++;
                        inferFromTypes(source, typeParameter);
                        inferiority--;
                    }
                }
                else if (source.flags & 16384 /* Union */) {
                    // Source is a union type, infer from each consituent type
                    var sourceTypes = source.types;
                    for (var i = 0; i < sourceTypes.length; i++) {
                        inferFromTypes(sourceTypes[i], target);
                    }
                }
                else if (source.flags & 48128 /* ObjectType */ && (target.flags & (4096 /* Reference */ | 8192 /* Tuple */) || (target.flags & 32768 /* Anonymous */) && target.symbol && target.symbol.flags & (8192 /* Method */ | 2048 /* TypeLiteral */))) {
                    // If source is an object type, and target is a type reference, a tuple type, the type of a method, or a type literal, infer from members
                    if (!isInProcess(source, target) && isWithinDepthLimit(source, sourceStack) && isWithinDepthLimit(target, targetStack)) {
                        if (depth === 0) {
                            sourceStack = [];
                            targetStack = [];
                        }
                        sourceStack[depth] = source;
                        targetStack[depth] = target;
                        depth++;
                        inferFromProperties(source, target);
                        inferFromSignatures(source, target, 0 /* Call */);
                        inferFromSignatures(source, target, 1 /* Construct */);
                        inferFromIndexTypes(source, target, 0 /* String */, 0 /* String */);
                        inferFromIndexTypes(source, target, 1 /* Number */, 1 /* Number */);
                        inferFromIndexTypes(source, target, 0 /* String */, 1 /* Number */);
                        depth--;
                    }
                }
            }
            function inferFromProperties(source, target) {
                var properties = getPropertiesOfObjectType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfObjectType(source, targetProp.name);
                    if (sourceProp) {
                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                    }
                }
            }
            function inferFromSignatures(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var sourceLen = sourceSignatures.length;
                var targetLen = targetSignatures.length;
                var len = sourceLen < targetLen ? sourceLen : targetLen;
                for (var i = 0; i < len; i++) {
                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
                }
            }
            function inferFromSignature(source, target) {
                forEachMatchingParameterType(source, target, inferFromTypes);
                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            function inferFromIndexTypes(source, target, sourceKind, targetKind) {
                var targetIndexType = getIndexTypeOfType(target, targetKind);
                if (targetIndexType) {
                    var sourceIndexType = getIndexTypeOfType(source, sourceKind);
                    if (sourceIndexType) {
                        inferFromTypes(sourceIndexType, targetIndexType);
                    }
                }
            }
        }
        function getInferenceCandidates(context, index) {
            var inferences = context.inferences[index];
            return inferences.primary || inferences.secondary || emptyArray;
        }
        function getInferredType(context, index) {
            var inferredType = context.inferredTypes[index];
            if (!inferredType) {
                var inferences = getInferenceCandidates(context, index);
                if (inferences.length) {
                    // Infer widened union or supertype, or the undefined type for no common supertype
                    var unionOrSuperType = context.inferUnionTypes ? getUnionType(inferences) : getCommonSupertype(inferences);
                    inferredType = unionOrSuperType ? getWidenedType(unionOrSuperType) : inferenceFailureType;
                }
                else {
                    // Infer the empty object type when no inferences were made
                    inferredType = emptyObjectType;
                }
                if (inferredType !== inferenceFailureType) {
                    var constraint = getConstraintOfTypeParameter(context.typeParameters[index]);
                    inferredType = constraint && !isTypeAssignableTo(inferredType, constraint) ? constraint : inferredType;
                }
                context.inferredTypes[index] = inferredType;
            }
            return inferredType;
        }
        function getInferredTypes(context) {
            for (var i = 0; i < context.inferredTypes.length; i++) {
                getInferredType(context, i);
            }
            return context.inferredTypes;
        }
        function hasAncestor(node, kind) {
            return ts.getAncestor(node, kind) !== undefined;
        }
        // EXPRESSION TYPE CHECKING
        function getResolvedSymbol(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSymbol) {
                links.resolvedSymbol = resolveName(node, node.text, 107455 /* Value */ | 4194304 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, node) || unknownSymbol;
            }
            return links.resolvedSymbol;
        }
        function isInTypeQuery(node) {
            while (node) {
                switch (node.kind) {
                    case 133 /* TypeQuery */:
                        return true;
                    case 63 /* Identifier */:
                    case 121 /* QualifiedName */:
                        node = node.parent;
                        continue;
                    default:
                        return false;
                }
            }
            ts.Debug.fail("should not get here");
        }
        // Remove one or more primitive types from a union type
        function subtractPrimitiveTypes(type, subtractMask) {
            if (type.flags & 16384 /* Union */) {
                var types = type.types;
                if (ts.forEach(types, function (t) { return t.flags & subtractMask; })) {
                    return getUnionType(ts.filter(types, function (t) { return !(t.flags & subtractMask); }));
                }
            }
            return type;
        }
        // Check if a given variable is assigned within a given syntax node
        function isVariableAssignedWithin(symbol, node) {
            var links = getNodeLinks(node);
            if (links.assignmentChecks) {
                var cachedResult = links.assignmentChecks[symbol.id];
                if (cachedResult !== undefined) {
                    return cachedResult;
                }
            }
            else {
                links.assignmentChecks = {};
            }
            return links.assignmentChecks[symbol.id] = isAssignedIn(node);
            function isAssignedInBinaryExpression(node) {
                if (node.operator >= 51 /* FirstAssignment */ && node.operator <= 62 /* LastAssignment */) {
                    var n = node.left;
                    while (n.kind === 148 /* ParenExpression */) {
                        n = n.expression;
                    }
                    if (n.kind === 63 /* Identifier */ && getResolvedSymbol(n) === symbol) {
                        return true;
                    }
                }
                return ts.forEachChild(node, isAssignedIn);
            }
            function isAssignedInVariableDeclaration(node) {
                if (getSymbolOfNode(node) === symbol && node.initializer) {
                    return true;
                }
                return ts.forEachChild(node, isAssignedIn);
            }
            function isAssignedIn(node) {
                switch (node.kind) {
                    case 153 /* BinaryExpression */:
                        return isAssignedInBinaryExpression(node);
                    case 181 /* VariableDeclaration */:
                        return isAssignedInVariableDeclaration(node);
                    case 139 /* ArrayLiteral */:
                    case 140 /* ObjectLiteral */:
                    case 142 /* PropertyAccess */:
                    case 143 /* IndexedAccess */:
                    case 144 /* CallExpression */:
                    case 145 /* NewExpression */:
                    case 147 /* TypeAssertion */:
                    case 148 /* ParenExpression */:
                    case 151 /* PrefixOperator */:
                    case 152 /* PostfixOperator */:
                    case 154 /* ConditionalExpression */:
                    case 158 /* Block */:
                    case 159 /* VariableStatement */:
                    case 161 /* ExpressionStatement */:
                    case 162 /* IfStatement */:
                    case 163 /* DoStatement */:
                    case 164 /* WhileStatement */:
                    case 165 /* ForStatement */:
                    case 166 /* ForInStatement */:
                    case 169 /* ReturnStatement */:
                    case 170 /* WithStatement */:
                    case 171 /* SwitchStatement */:
                    case 172 /* CaseClause */:
                    case 173 /* DefaultClause */:
                    case 174 /* LabeledStatement */:
                    case 175 /* ThrowStatement */:
                    case 176 /* TryStatement */:
                    case 177 /* TryBlock */:
                    case 178 /* CatchBlock */:
                    case 179 /* FinallyBlock */:
                        return ts.forEachChild(node, isAssignedIn);
                }
                return false;
            }
        }
        // Get the narrowed type of a given symbol at a given location
        function getNarrowedTypeOfSymbol(symbol, node) {
            var type = getTypeOfSymbol(symbol);
            // Only narrow when symbol is variable of a structured type
            if (node && (symbol.flags & 3 /* Variable */ && type.flags & 65025 /* Structured */)) {
                while (true) {
                    var child = node;
                    node = node.parent;
                    // Stop at containing function or module block
                    if (!node || node.kind === 183 /* FunctionBlock */ || node.kind === 189 /* ModuleBlock */) {
                        break;
                    }
                    var narrowedType = type;
                    switch (node.kind) {
                        case 162 /* IfStatement */:
                            // In a branch of an if statement, narrow based on controlling expression
                            if (child !== node.expression) {
                                narrowedType = narrowType(type, node.expression, child === node.thenStatement);
                            }
                            break;
                        case 154 /* ConditionalExpression */:
                            // In a branch of a conditional expression, narrow based on controlling condition
                            if (child !== node.condition) {
                                narrowedType = narrowType(type, node.condition, child === node.whenTrue);
                            }
                            break;
                        case 153 /* BinaryExpression */:
                            // In the right operand of an && or ||, narrow based on left operand
                            if (child === node.right) {
                                if (node.operator === 47 /* AmpersandAmpersandToken */) {
                                    narrowedType = narrowType(type, node.left, true);
                                }
                                else if (node.operator === 48 /* BarBarToken */) {
                                    narrowedType = narrowType(type, node.left, false);
                                }
                            }
                            break;
                    }
                    // Only use narrowed type if construct contains no assignments to variable
                    if (narrowedType !== type) {
                        if (isVariableAssignedWithin(symbol, node)) {
                            break;
                        }
                        type = narrowedType;
                    }
                }
            }
            return type;
            function narrowTypeByEquality(type, expr, assumeTrue) {
                var left = expr.left;
                var right = expr.right;
                // Check that we have 'typeof <symbol>' on the left and string literal on the right
                if (left.kind !== 151 /* PrefixOperator */ || left.operator !== 95 /* TypeOfKeyword */ || left.operand.kind !== 63 /* Identifier */ || right.kind !== 7 /* StringLiteral */ || getResolvedSymbol(left.operand) !== symbol) {
                    return type;
                }
                var t = right.text;
                var checkType = t === "string" ? stringType : t === "number" ? numberType : t === "boolean" ? booleanType : emptyObjectType;
                if (expr.operator === 30 /* ExclamationEqualsEqualsToken */) {
                    assumeTrue = !assumeTrue;
                }
                if (assumeTrue) {
                    // The assumed result is true. If check was for a primitive type, that type is the narrowed type. Otherwise we can
                    // remove the primitive types from the narrowed type.
                    return checkType === emptyObjectType ? subtractPrimitiveTypes(type, 2 /* String */ | 4 /* Number */ | 8 /* Boolean */) : checkType;
                }
                else {
                    // The assumed result is false. If check was for a primitive type we can remove that type from the narrowed type.
                    // Otherwise we don't have enough information to do anything.
                    return checkType === emptyObjectType ? type : subtractPrimitiveTypes(type, checkType.flags);
                }
            }
            function narrowTypeByAnd(type, expr, assumeTrue) {
                if (assumeTrue) {
                    // The assumed result is true, therefore we narrow assuming each operand to be true.
                    return narrowType(narrowType(type, expr.left, true), expr.right, true);
                }
                else {
                    // The assumed result is false. This means either the first operand was false, or the first operand was true
                    // and the second operand was false. We narrow with those assumptions and union the two resulting types.
                    return getUnionType([
                        narrowType(type, expr.left, false),
                        narrowType(narrowType(type, expr.left, true), expr.right, false)
                    ]);
                }
            }
            function narrowTypeByOr(type, expr, assumeTrue) {
                if (assumeTrue) {
                    // The assumed result is true. This means either the first operand was true, or the first operand was false
                    // and the second operand was true. We narrow with those assumptions and union the two resulting types.
                    return getUnionType([
                        narrowType(type, expr.left, true),
                        narrowType(narrowType(type, expr.left, false), expr.right, true)
                    ]);
                }
                else {
                    // The assumed result is false, therefore we narrow assuming each operand to be false.
                    return narrowType(narrowType(type, expr.left, false), expr.right, false);
                }
            }
            function narrowTypeByInstanceof(type, expr, assumeTrue) {
                // Check that assumed result is true and we have variable symbol on the left
                if (!assumeTrue || expr.left.kind !== 63 /* Identifier */ || getResolvedSymbol(expr.left) !== symbol) {
                    return type;
                }
                // Check that right operand is a function type with a prototype property
                var rightType = checkExpression(expr.right);
                if (!isTypeSubtypeOf(rightType, globalFunctionType)) {
                    return type;
                }
                var prototypeProperty = getPropertyOfType(rightType, "prototype");
                if (!prototypeProperty) {
                    return type;
                }
                var prototypeType = getTypeOfSymbol(prototypeProperty);
                // Narrow to type of prototype property if it is a subtype of current type
                return isTypeSubtypeOf(prototypeType, type) ? prototypeType : type;
            }
            // Narrow the given type based on the given expression having the assumed boolean value
            function narrowType(type, expr, assumeTrue) {
                switch (expr.kind) {
                    case 148 /* ParenExpression */:
                        return narrowType(type, expr.expression, assumeTrue);
                    case 153 /* BinaryExpression */:
                        var operator = expr.operator;
                        if (operator === 29 /* EqualsEqualsEqualsToken */ || operator === 30 /* ExclamationEqualsEqualsToken */) {
                            return narrowTypeByEquality(type, expr, assumeTrue);
                        }
                        else if (operator === 47 /* AmpersandAmpersandToken */) {
                            return narrowTypeByAnd(type, expr, assumeTrue);
                        }
                        else if (operator === 48 /* BarBarToken */) {
                            return narrowTypeByOr(type, expr, assumeTrue);
                        }
                        else if (operator === 85 /* InstanceOfKeyword */) {
                            return narrowTypeByInstanceof(type, expr, assumeTrue);
                        }
                        break;
                    case 151 /* PrefixOperator */:
                        if (expr.operator === 45 /* ExclamationToken */) {
                            return narrowType(type, expr.operand, !assumeTrue);
                        }
                        break;
                }
                return type;
            }
        }
        function checkIdentifier(node) {
            var symbol = getResolvedSymbol(node);
            if (symbol.flags & 33554432 /* Import */) {
                // Mark the import as referenced so that we emit it in the final .js file.
                // exception: identifiers that appear in type queries, const enums, modules that contain only const enums
                getSymbolLinks(symbol).referenced = !isInTypeQuery(node) && !isConstEnumOrConstEnumOnlyModule(resolveImport(symbol));
            }
            checkCollisionWithCapturedSuperVariable(node, node);
            checkCollisionWithCapturedThisVariable(node, node);
            checkCollisionWithIndexVariableInGeneratedCode(node, node);
            return getNarrowedTypeOfSymbol(getExportSymbolOfValueSymbolIfExported(symbol), node);
        }
        function captureLexicalThis(node, container) {
            var classNode = container.parent && container.parent.kind === 184 /* ClassDeclaration */ ? container.parent : undefined;
            getNodeLinks(node).flags |= 2 /* LexicalThis */;
            if (container.kind === 124 /* Property */ || container.kind === 126 /* Constructor */) {
                getNodeLinks(classNode).flags |= 4 /* CaptureThis */;
            }
            else {
                getNodeLinks(container).flags |= 4 /* CaptureThis */;
            }
        }
        function checkThisExpression(node) {
            // Stop at the first arrow function so that we can
            // tell whether 'this' needs to be captured.
            var container = ts.getThisContainer(node, true);
            var needToCaptureLexicalThis = false;
            // Now skip arrow functions to get the "real" owner of 'this'.
            if (container.kind === 150 /* ArrowFunction */) {
                container = ts.getThisContainer(container, false);
                needToCaptureLexicalThis = true;
            }
            switch (container.kind) {
                case 188 /* ModuleDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_body);
                    break;
                case 187 /* EnumDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                    break;
                case 126 /* Constructor */:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    }
                    break;
                case 124 /* Property */:
                    if (container.flags & 128 /* Static */) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);
                    }
                    break;
            }
            if (needToCaptureLexicalThis) {
                captureLexicalThis(node, container);
            }
            var classNode = container.parent && container.parent.kind === 184 /* ClassDeclaration */ ? container.parent : undefined;
            if (classNode) {
                var symbol = getSymbolOfNode(classNode);
                return container.flags & 128 /* Static */ ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol);
            }
            return anyType;
        }
        function getSuperContainer(node) {
            while (true) {
                node = node.parent;
                if (!node)
                    return node;
                switch (node.kind) {
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                    case 150 /* ArrowFunction */:
                    case 124 /* Property */:
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                        return node;
                }
            }
        }
        function isInConstructorArgumentInitializer(node, constructorDecl) {
            for (var n = node; n && n !== constructorDecl; n = n.parent) {
                if (n.kind === 123 /* Parameter */) {
                    return true;
                }
            }
            return false;
        }
        function checkSuperExpression(node) {
            var isCallExpression = node.parent.kind === 144 /* CallExpression */ && node.parent.func === node;
            var enclosingClass = ts.getAncestor(node, 184 /* ClassDeclaration */);
            var baseClass;
            if (enclosingClass && enclosingClass.baseType) {
                var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClass));
                baseClass = classType.baseTypes.length && classType.baseTypes[0];
            }
            if (!baseClass) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
                return unknownType;
            }
            var container = getSuperContainer(node);
            if (container) {
                var canUseSuperExpression = false;
                if (isCallExpression) {
                    // TS 1.0 SPEC (April 2014): 4.8.1
                    // Super calls are only permitted in constructors of derived classes
                    canUseSuperExpression = container.kind === 126 /* Constructor */;
                }
                else {
                    // TS 1.0 SPEC (April 2014)
                    // 'super' property access is allowed
                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                    // - In a static member function or static member accessor
                    // super property access might appear in arrow functions with arbitrary deep nesting
                    var needToCaptureLexicalThis = false;
                    while (container && container.kind === 150 /* ArrowFunction */) {
                        container = getSuperContainer(container);
                        needToCaptureLexicalThis = true;
                    }
                    // topmost container must be something that is directly nested in the class declaration
                    if (container && container.parent && container.parent.kind === 184 /* ClassDeclaration */) {
                        if (container.flags & 128 /* Static */) {
                            canUseSuperExpression = container.kind === 125 /* Method */ || container.kind === 127 /* GetAccessor */ || container.kind === 128 /* SetAccessor */;
                        }
                        else {
                            canUseSuperExpression = container.kind === 125 /* Method */ || container.kind === 127 /* GetAccessor */ || container.kind === 128 /* SetAccessor */ || container.kind === 124 /* Property */ || container.kind === 126 /* Constructor */;
                        }
                    }
                }
                if (canUseSuperExpression) {
                    var returnType;
                    if ((container.flags & 128 /* Static */) || isCallExpression) {
                        getNodeLinks(node).flags |= 32 /* SuperStatic */;
                        returnType = getTypeOfSymbol(baseClass.symbol);
                    }
                    else {
                        getNodeLinks(node).flags |= 16 /* SuperInstance */;
                        returnType = baseClass;
                    }
                    if (container.kind === 126 /* Constructor */ && isInConstructorArgumentInitializer(node, container)) {
                        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
                        error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
                        returnType = unknownType;
                    }
                    if (!isCallExpression && needToCaptureLexicalThis) {
                        // call expressions are allowed only in constructors so they should always capture correct 'this'
                        // super property access expressions can also appear in arrow functions -
                        // in this case they should also use correct lexical this
                        captureLexicalThis(node.parent, container);
                    }
                    return returnType;
                }
            }
            if (isCallExpression) {
                error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            }
            else {
                error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return unknownType;
        }
        // Return contextual type of parameter or undefined if no contextual type is available
        function getContextuallyTypedParameterType(parameter) {
            var func = parameter.parent;
            if (func.kind === 149 /* FunctionExpression */ || func.kind === 150 /* ArrowFunction */) {
                if (isContextSensitiveExpression(func)) {
                    var contextualSignature = getContextualSignature(func);
                    if (contextualSignature) {
                        var funcHasRestParameters = ts.hasRestParameters(func);
                        var len = func.parameters.length - (funcHasRestParameters ? 1 : 0);
                        var indexOfParameter = ts.indexOf(func.parameters, parameter);
                        if (indexOfParameter < len) {
                            return getTypeAtPosition(contextualSignature, indexOfParameter);
                        }
                        // If last parameter is contextually rest parameter get its type
                        if (indexOfParameter === (func.parameters.length - 1) && funcHasRestParameters && contextualSignature.hasRestParameter && func.parameters.length >= contextualSignature.parameters.length) {
                            return getTypeOfSymbol(contextualSignature.parameters[contextualSignature.parameters.length - 1]);
                        }
                    }
                }
            }
            return undefined;
        }
        // In a variable, parameter or property declaration with a type annotation, the contextual type of an initializer
        // expression is the type of the variable, parameter or property. In a parameter declaration of a contextually
        // typed function expression, the contextual type of an initializer expression is the contextual type of the
        // parameter.
        function getContextualTypeForInitializerExpression(node) {
            var declaration = node.parent;
            if (node === declaration.initializer) {
                if (declaration.type) {
                    return getTypeFromTypeNode(declaration.type);
                }
                if (declaration.kind === 123 /* Parameter */) {
                    return getContextuallyTypedParameterType(declaration);
                }
            }
            return undefined;
        }
        function getContextualTypeForReturnExpression(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
                // corresponding set accessor has a type annotation, return statements in the function are contextually typed
                if (func.type || func.kind === 126 /* Constructor */ || func.kind === 127 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 128 /* SetAccessor */))) {
                    return getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                }
                // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
                // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
                var signature = getContextualSignature(func);
                if (signature) {
                    return getReturnTypeOfSignature(signature);
                }
            }
            return undefined;
        }
        // In a typed function call, an argument expression is contextually typed by the type of the corresponding parameter.
        function getContextualTypeForArgument(node) {
            var callExpression = node.parent;
            var argIndex = ts.indexOf(callExpression.arguments, node);
            if (argIndex >= 0) {
                var signature = getResolvedSignature(callExpression);
                return getTypeAtPosition(signature, argIndex);
            }
            return undefined;
        }
        function getContextualTypeForBinaryOperand(node) {
            var binaryExpression = node.parent;
            var operator = binaryExpression.operator;
            if (operator >= 51 /* FirstAssignment */ && operator <= 62 /* LastAssignment */) {
                // In an assignment expression, the right operand is contextually typed by the type of the left operand.
                if (node === binaryExpression.right) {
                    return checkExpression(binaryExpression.left);
                }
            }
            else if (operator === 48 /* BarBarToken */) {
                // When an || expression has a contextual type, the operands are contextually typed by that type. When an ||
                // expression has no contextual type, the right operand is contextually typed by the type of the left operand.
                var type = getContextualType(binaryExpression);
                if (!type && node === binaryExpression.right) {
                    type = checkExpression(binaryExpression.left);
                }
                return type;
            }
            return undefined;
        }
        // Apply a mapping function to a contextual type and return the resulting type. If the contextual type
        // is a union type, the mapping function is applied to each constituent type and a union of the resulting
        // types is returned.
        function applyToContextualType(type, mapper) {
            if (!(type.flags & 16384 /* Union */)) {
                return mapper(type);
            }
            var types = type.types;
            var mappedType;
            var mappedTypes;
            for (var i = 0; i < types.length; i++) {
                var t = mapper(types[i]);
                if (t) {
                    if (!mappedType) {
                        mappedType = t;
                    }
                    else if (!mappedTypes) {
                        mappedTypes = [mappedType, t];
                    }
                    else {
                        mappedTypes.push(t);
                    }
                }
            }
            return mappedTypes ? getUnionType(mappedTypes) : mappedType;
        }
        function getTypeOfPropertyOfContextualType(type, name) {
            return applyToContextualType(type, function (t) {
                var prop = getPropertyOfObjectType(t, name);
                return prop ? getTypeOfSymbol(prop) : undefined;
            });
        }
        function getIndexTypeOfContextualType(type, kind) {
            return applyToContextualType(type, function (t) { return getIndexTypeOfObjectOrUnionType(t, kind); });
        }
        // Return true if the given contextual type is a tuple-like type
        function contextualTypeIsTupleType(type) {
            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getPropertyOfObjectType(t, "0"); }) : getPropertyOfObjectType(type, "0"));
        }
        // Return true if the given contextual type provides an index signature of the given kind
        function contextualTypeHasIndexSignature(type, kind) {
            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getIndexTypeOfObjectOrUnionType(t, kind); }) : getIndexTypeOfObjectOrUnionType(type, kind));
        }
        // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
        // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
        // exists. Otherwise, it is the type of the string index signature in T, if one exists.
        function getContextualTypeForPropertyExpression(node) {
            var declaration = node.parent;
            var objectLiteral = declaration.parent;
            var type = getContextualType(objectLiteral);
            // TODO(jfreeman): Handle this case for computed names and symbols
            var name = declaration.name.text;
            if (type && name) {
                return getTypeOfPropertyOfContextualType(type, name) || isNumericName(name) && getIndexTypeOfContextualType(type, 1 /* Number */) || getIndexTypeOfContextualType(type, 0 /* String */);
            }
            return undefined;
        }
        // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
        // the type of the property with the numeric name N in T, if one exists. Otherwise, it is the type of the numeric
        // index signature in T, if one exists.
        function getContextualTypeForElementExpression(node) {
            var arrayLiteral = node.parent;
            var type = getContextualType(arrayLiteral);
            if (type) {
                var index = ts.indexOf(arrayLiteral.elements, node);
                return getTypeOfPropertyOfContextualType(type, "" + index) || getIndexTypeOfContextualType(type, 1 /* Number */);
            }
            return undefined;
        }
        // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
        function getContextualTypeForConditionalOperand(node) {
            var conditional = node.parent;
            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;
        }
        // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
        // be "pushed" onto a node using the contextualType property.
        function getContextualType(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (node.contextualType) {
                return node.contextualType;
            }
            var parent = node.parent;
            switch (parent.kind) {
                case 181 /* VariableDeclaration */:
                case 123 /* Parameter */:
                case 124 /* Property */:
                    return getContextualTypeForInitializerExpression(node);
                case 150 /* ArrowFunction */:
                case 169 /* ReturnStatement */:
                    return getContextualTypeForReturnExpression(node);
                case 144 /* CallExpression */:
                case 145 /* NewExpression */:
                    return getContextualTypeForArgument(node);
                case 147 /* TypeAssertion */:
                    return getTypeFromTypeNode(parent.type);
                case 153 /* BinaryExpression */:
                    return getContextualTypeForBinaryOperand(node);
                case 141 /* PropertyAssignment */:
                    return getContextualTypeForPropertyExpression(node);
                case 139 /* ArrayLiteral */:
                    return getContextualTypeForElementExpression(node);
                case 154 /* ConditionalExpression */:
                    return getContextualTypeForConditionalOperand(node);
            }
            return undefined;
        }
        // If the given type is an object or union type, if that type has a single signature, and if
        // that signature is non-generic, return the signature. Otherwise return undefined.
        function getNonGenericSignature(type) {
            var signatures = getSignaturesOfObjectOrUnionType(type, 0 /* Call */);
            if (signatures.length === 1) {
                var signature = signatures[0];
                if (!signature.typeParameters) {
                    return signature;
                }
            }
        }
        // Return the contextual signature for a given expression node. A contextual type provides a
        // contextual signature if it has a single call signature and if that call signature is non-generic.
        // If the contextual type is a union type, get the signature from each type possible and if they are 
        // all identical ignoring their return type, the result is same signature but with return type as 
        // union type of return types from these signatures
        function getContextualSignature(node) {
            var type = getContextualType(node);
            if (!type) {
                return undefined;
            }
            if (!(type.flags & 16384 /* Union */)) {
                return getNonGenericSignature(type);
            }
            var signatureList;
            var types = type.types;
            for (var i = 0; i < types.length; i++) {
                // The signature set of all constituent type with call signatures should match
                // So number of signatures allowed is either 0 or 1
                if (signatureList && getSignaturesOfObjectOrUnionType(types[i], 0 /* Call */).length > 1) {
                    return undefined;
                }
                var signature = getNonGenericSignature(types[i]);
                if (signature) {
                    if (!signatureList) {
                        // This signature will contribute to contextual union signature
                        signatureList = [signature];
                    }
                    else if (!compareSignatures(signatureList[0], signature, false, compareTypes)) {
                        // Signatures arent identical, do not use
                        return undefined;
                    }
                    else {
                        // Use this signature for contextual union signature
                        signatureList.push(signature);
                    }
                }
            }
            // Result is union of signatures collected (return type is union of return types of this signature set)
            var result;
            if (signatureList) {
                result = cloneSignature(signatureList[0]);
                // Clear resolved return type we possibly got from cloneSignature
                result.resolvedReturnType = undefined;
                result.unionSignatures = signatureList;
            }
            return result;
        }
        // Presence of a contextual type mapper indicates inferential typing, except the identityMapper object is
        // used as a special marker for other purposes.
        function isInferentialContext(mapper) {
            return mapper && mapper !== identityMapper;
        }
        function checkArrayLiteral(node, contextualMapper) {
            var elements = node.elements;
            if (!elements.length) {
                return createArrayType(undefinedType);
            }
            var elementTypes = ts.map(elements, function (e) { return checkExpression(e, contextualMapper); });
            var contextualType = getContextualType(node);
            if (contextualType && contextualTypeIsTupleType(contextualType)) {
                return createTupleType(elementTypes);
            }
            return createArrayType(getUnionType(elementTypes));
        }
        function isNumericName(name) {
            // The intent of numeric names is that
            //     - they are names with text in a numeric form, and that
            //     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',
            //         acquired by applying the abstract 'ToNumber' operation on the name's text.
            //
            // The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.
            // In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.
            //
            // Consider the property name '"0xF00D"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'
            // according to the ECMAScript specification, so it is actually as if the user indexed with the string '"61453"'.
            // Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names
            // because their 'ToString' representation is not equal to their original text.
            // This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.
            //
            // Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.
            // The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.
            // Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.
            //
            // Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.
            // This is desired behavior, because when indexing with them as numeric entities, you are indexing
            // with the strings '"Infinity"', '"-Infinity"', and '"NaN"' respectively.
            return (+name).toString() === name;
        }
        function checkObjectLiteral(node, contextualMapper) {
            var members = node.symbol.members;
            var properties = {};
            var contextualType = getContextualType(node);
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    var member = members[id];
                    if (member.flags & 4 /* Property */) {
                        var type = checkExpression(member.declarations[0].initializer, contextualMapper);
                        var prop = createSymbol(4 /* Property */ | 268435456 /* Transient */ | member.flags, member.name);
                        prop.declarations = member.declarations;
                        prop.parent = member.parent;
                        if (member.valueDeclaration)
                            prop.valueDeclaration = member.valueDeclaration;
                        prop.type = type;
                        prop.target = member;
                        member = prop;
                    }
                    else {
                        // TypeScript 1.0 spec (April 2014)
                        // A get accessor declaration is processed in the same manner as 
                        // an ordinary function declaration(section 6.1) with no parameters.
                        // A set accessor declaration is processed in the same manner 
                        // as an ordinary function declaration with a single parameter and a Void return type.
                        var getAccessor = getDeclarationOfKind(member, 127 /* GetAccessor */);
                        if (getAccessor) {
                            checkAccessorDeclaration(getAccessor);
                        }
                        var setAccessor = getDeclarationOfKind(member, 128 /* SetAccessor */);
                        if (setAccessor) {
                            checkAccessorDeclaration(setAccessor);
                        }
                    }
                    properties[member.name] = member;
                }
            }
            var stringIndexType = getIndexType(0 /* String */);
            var numberIndexType = getIndexType(1 /* Number */);
            return createAnonymousType(node.symbol, properties, emptyArray, emptyArray, stringIndexType, numberIndexType);
            function getIndexType(kind) {
                if (contextualType && contextualTypeHasIndexSignature(contextualType, kind)) {
                    var propTypes = [];
                    for (var id in properties) {
                        if (ts.hasProperty(properties, id)) {
                            if (kind === 0 /* String */ || isNumericName(id)) {
                                var type = getTypeOfSymbol(properties[id]);
                                if (!ts.contains(propTypes, type)) {
                                    propTypes.push(type);
                                }
                            }
                        }
                    }
                    return propTypes.length ? getUnionType(propTypes) : undefinedType;
                }
                return undefined;
            }
        }
        // If a symbol is a synthesized symbol with no value declaration, we assume it is a property. Example of this are the synthesized
        // '.prototype' property as well as synthesized tuple index properties.
        function getDeclarationKindFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.kind : 124 /* Property */;
        }
        function getDeclarationFlagsFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.flags : s.flags & 536870912 /* Prototype */ ? 16 /* Public */ | 128 /* Static */ : 0;
        }
        function checkClassPropertyAccess(node, type, prop) {
            var flags = getDeclarationFlagsFromSymbol(prop);
            // Public properties are always accessible
            if (!(flags & (32 /* Private */ | 64 /* Protected */))) {
                return;
            }
            // Property is known to be private or protected at this point
            // Get the declaring and enclosing class instance types
            var enclosingClassDeclaration = ts.getAncestor(node, 184 /* ClassDeclaration */);
            var enclosingClass = enclosingClassDeclaration ? getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClassDeclaration)) : undefined;
            var declaringClass = getDeclaredTypeOfSymbol(prop.parent);
            // Private property is accessible if declaring and enclosing class are the same
            if (flags & 32 /* Private */) {
                if (declaringClass !== enclosingClass) {
                    error(node, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(declaringClass));
                }
                return;
            }
            // Property is known to be protected at this point
            // All protected properties of a supertype are accessible in a super access
            if (node.left.kind === 89 /* SuperKeyword */) {
                return;
            }
            // A protected property is accessible in the declaring class and classes derived from it
            if (!enclosingClass || !hasBaseType(enclosingClass, declaringClass)) {
                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(declaringClass));
                return;
            }
            // No further restrictions for static properties
            if (flags & 128 /* Static */) {
                return;
            }
            // An instance property must be accessed through an instance of the enclosing class
            if (!(getTargetType(type).flags & (1024 /* Class */ | 2048 /* Interface */) && hasBaseType(type, enclosingClass))) {
                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
            }
        }
        function checkPropertyAccess(node) {
            var type = checkExpression(node.left);
            if (type === unknownType)
                return type;
            if (type !== anyType) {
                var apparentType = getApparentType(getWidenedType(type));
                if (apparentType === unknownType) {
                    // handle cases when type is Type parameter with invalid constraint
                    return unknownType;
                }
                var prop = getPropertyOfType(apparentType, node.right.text);
                if (!prop) {
                    if (node.right.text) {
                        error(node.right, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(node.right), typeToString(type));
                    }
                    return unknownType;
                }
                getNodeLinks(node).resolvedSymbol = prop;
                if (prop.parent && prop.parent.flags & 32 /* Class */) {
                    // TS 1.0 spec (April 2014): 4.8.2
                    // - In a constructor, instance member function, instance member accessor, or 
                    //   instance member variable initializer where this references a derived class instance, 
                    //   a super property access is permitted and must specify a public instance member function of the base class.
                    // - In a static member function or static member accessor 
                    //   where this references the constructor function object of a derived class, 
                    //   a super property access is permitted and must specify a public static member function of the base class.
                    if (node.left.kind === 89 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 125 /* Method */) {
                        error(node.right, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    }
                    else {
                        checkClassPropertyAccess(node, type, prop);
                    }
                }
                return getTypeOfSymbol(prop);
            }
            return anyType;
        }
        function isValidPropertyAccess(node, propertyName) {
            var type = checkExpression(node.left);
            if (type !== unknownType && type !== anyType) {
                var prop = getPropertyOfType(getWidenedType(type), propertyName);
                if (prop && prop.parent && prop.parent.flags & 32 /* Class */) {
                    if (node.left.kind === 89 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 125 /* Method */) {
                        return false;
                    }
                    else {
                        var diagnosticsCount = diagnostics.length;
                        checkClassPropertyAccess(node, type, prop);
                        return diagnostics.length === diagnosticsCount;
                    }
                }
            }
            return true;
        }
        function checkIndexedAccess(node) {
            // Obtain base constraint such that we can bail out if the constraint is an unknown type
            var objectType = getApparentType(checkExpression(node.object));
            var indexType = checkExpression(node.index);
            if (objectType === unknownType)
                return unknownType;
            if (isConstEnumObjectType(objectType) && node.index.kind !== 7 /* StringLiteral */) {
                error(node.index, ts.Diagnostics.Index_expression_arguments_in_const_enums_must_be_of_type_string);
            }
            // TypeScript 1.0 spec (April 2014): 4.10 Property Access
            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name 
            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.
            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type, 
            //    the property access is of the type of that index signature.
            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type, 
            //    the property access is of the type of that index signature.
            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.
            // See if we can index as a property.
            if (node.index.kind === 7 /* StringLiteral */ || node.index.kind === 6 /* NumericLiteral */) {
                var name = node.index.text;
                var prop = getPropertyOfType(objectType, name);
                if (prop) {
                    getNodeLinks(node).resolvedSymbol = prop;
                    return getTypeOfSymbol(prop);
                }
            }
            // Check for compatible indexer types.
            if (indexType.flags & (1 /* Any */ | 258 /* StringLike */ | 132 /* NumberLike */)) {
                // Try to use a number indexer.
                if (indexType.flags & (1 /* Any */ | 132 /* NumberLike */)) {
                    var numberIndexType = getIndexTypeOfType(objectType, 1 /* Number */);
                    if (numberIndexType) {
                        return numberIndexType;
                    }
                }
                // Try to use string indexing.
                var stringIndexType = getIndexTypeOfType(objectType, 0 /* String */);
                if (stringIndexType) {
                    return stringIndexType;
                }
                // Fall back to any.
                if (compilerOptions.noImplicitAny && objectType !== anyType) {
                    error(node, ts.Diagnostics.Index_signature_of_object_type_implicitly_has_an_any_type);
                }
                return anyType;
            }
            // REVIEW: Users should know the type that was actually used.
            error(node, ts.Diagnostics.An_index_expression_argument_must_be_of_type_string_number_or_any);
            return unknownType;
        }
        function resolveUntypedCall(node) {
            ts.forEach(node.arguments, function (argument) {
                checkExpression(argument);
            });
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function signatureHasCorrectArity(node, signature) {
            if (!node.arguments) {
                // This only happens when we have something of the form:
                //     new C
                //
                return signature.minArgumentCount === 0;
            }
            // For IDE scenarios, since we may have an incomplete call, we make two modifications
            // to arity checking.
            //    1. A trailing comma is tantamount to adding another argument
            //    2. If the call is incomplete (no closing paren) allow fewer arguments than expected
            var args = node.arguments;
            var numberOfArgs = args.hasTrailingComma ? args.length + 1 : args.length;
            var hasTooManyArguments = !signature.hasRestParameter && numberOfArgs > signature.parameters.length;
            var hasRightNumberOfTypeArguments = !node.typeArguments || (signature.typeParameters && node.typeArguments.length === signature.typeParameters.length);
            if (hasTooManyArguments || !hasRightNumberOfTypeArguments) {
                return false;
            }
            // If we are missing the close paren, the call is incomplete, and we should skip
            // the lower bound check.
            var callIsIncomplete = args.end === node.end;
            var hasEnoughArguments = numberOfArgs >= signature.minArgumentCount;
            return callIsIncomplete || hasEnoughArguments;
        }
        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
        function getSingleCallSignature(type) {
            if (type.flags & 48128 /* ObjectType */) {
                var resolved = resolveObjectOrUnionTypeMembers(type);
                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 && resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {
                    return resolved.callSignatures[0];
                }
            }
            return undefined;
        }
        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper) {
            var context = createInferenceContext(signature.typeParameters, true);
            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
                inferTypes(context, instantiateType(source, contextualMapper), target);
            });
            return getSignatureInstantiation(signature, getInferredTypes(context));
        }
        function inferTypeArguments(signature, args, excludeArgument) {
            var typeParameters = signature.typeParameters;
            var context = createInferenceContext(typeParameters, false);
            var mapper = createInferenceMapper(context);
            for (var i = 0; i < args.length; i++) {
                if (args[i].kind === 157 /* OmittedExpression */) {
                    continue;
                }
                if (!excludeArgument || excludeArgument[i] === undefined) {
                    var parameterType = getTypeAtPosition(signature, i);
                    inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);
                }
            }
            // Next, infer from those context sensitive arguments that are no longer excluded
            if (excludeArgument) {
                for (var i = 0; i < args.length; i++) {
                    if (args[i].kind === 157 /* OmittedExpression */) {
                        continue;
                    }
                    if (excludeArgument[i] === false) {
                        var parameterType = getTypeAtPosition(signature, i);
                        inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);
                    }
                }
            }
            var inferredTypes = getInferredTypes(context);
            // Inference has failed if the inferenceFailureType type is in list of inferences
            context.failedTypeParameterIndex = ts.indexOf(inferredTypes, inferenceFailureType);
            for (var i = 0; i < inferredTypes.length; i++) {
                if (inferredTypes[i] === inferenceFailureType) {
                    inferredTypes[i] = unknownType;
                }
            }
            return context;
        }
        function checkTypeArguments(signature, typeArguments, typeArgumentResultTypes, reportErrors) {
            var typeParameters = signature.typeParameters;
            var typeArgumentsAreAssignable = true;
            for (var i = 0; i < typeParameters.length; i++) {
                var typeArgNode = typeArguments[i];
                var typeArgument = getTypeFromTypeNode(typeArgNode);
                // Do not push on this array! It has a preallocated length
                typeArgumentResultTypes[i] = typeArgument;
                if (typeArgumentsAreAssignable) {
                    var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                    if (constraint) {
                        typeArgumentsAreAssignable = checkTypeAssignableTo(typeArgument, constraint, reportErrors ? typeArgNode : undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                    }
                }
            }
            return typeArgumentsAreAssignable;
        }
        function checkApplicableSignature(node, signature, relation, excludeArgument, reportErrors) {
            if (node.arguments) {
                for (var i = 0; i < node.arguments.length; i++) {
                    var arg = node.arguments[i];
                    if (arg.kind === 157 /* OmittedExpression */) {
                        continue;
                    }
                    var paramType = getTypeAtPosition(signature, i);
                    // String literals get string literal types unless we're reporting errors
                    var argType = arg.kind === 7 /* StringLiteral */ && !reportErrors ? getStringLiteralType(arg) : checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                    // Use argument expression as error location when reporting errors
                    var isValidArgument = checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1);
                    if (!isValidArgument) {
                        return false;
                    }
                }
            }
            return true;
        }
        function resolveCall(node, signatures, candidatesOutArray) {
            ts.forEach(node.typeArguments, checkSourceElement);
            var candidates = candidatesOutArray || [];
            // collectCandidates fills up the candidates array directly
            collectCandidates();
            if (!candidates.length) {
                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
                return resolveErrorCall(node);
            }
            var args = node.arguments || emptyArray;
            var excludeArgument;
            for (var i = 0; i < args.length; i++) {
                if (isContextSensitiveExpression(args[i])) {
                    if (!excludeArgument)
                        excludeArgument = new Array(args.length);
                    excludeArgument[i] = true;
                }
            }
            // The following variables are captured and modified by calls to chooseOverload.
            // If overload resolution or type argument inference fails, we want to report the
            // best error possible. The best error is one which says that an argument was not
            // assignable to a parameter. This implies that everything else about the overload
            // was fine. So if there is any overload that is only incorrect because of an
            // argument, we will report an error on that one.
            //
            //     function foo(s: string) {}
            //     function foo(n: number) {} // Report argument error on this overload
            //     function foo() {}
            //     foo(true);
            //
            // If none of the overloads even made it that far, there are two possibilities.
            // There was a problem with type arguments for some overload, in which case
            // report an error on that. Or none of the overloads even had correct arity,
            // in which case give an arity error.
            //
            //     function foo<T>(x: T, y: T) {} // Report type argument inference error
            //     function foo() {}
            //     foo(0, true);
            //
            var candidateForArgumentError;
            var candidateForTypeArgumentError;
            var resultOfFailedInference;
            var result;
            // Section 4.12.1:
            // if the candidate list contains one or more signatures for which the type of each argument
            // expression is a subtype of each corresponding parameter type, the return type of the first
            // of those signatures becomes the return type of the function call.
            // Otherwise, the return type of the first signature in the candidate list becomes the return
            // type of the function call.
            //
            // Whether the call is an error is determined by assignability of the arguments. The subtype pass
            // is just important for choosing the best signature. So in the case where there is only one
            // signature, the subtype pass is useless. So skipping it is an optimization.
            if (candidates.length > 1) {
                result = chooseOverload(candidates, subtypeRelation, excludeArgument);
            }
            if (!result) {
                // Reinitialize these pointers for round two
                candidateForArgumentError = undefined;
                candidateForTypeArgumentError = undefined;
                resultOfFailedInference = undefined;
                result = chooseOverload(candidates, assignableRelation, excludeArgument);
            }
            if (result) {
                return result;
            }
            // No signatures were applicable. Now report errors based on the last applicable signature with
            // no arguments excluded from assignability checks.
            // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
            // skip the checkApplicableSignature check.
            if (candidateForArgumentError) {
                // excludeArgument is undefined, in this case also equivalent to [undefined, undefined, ...]
                // The importance of excludeArgument is to prevent us from typing function expression parameters
                // in arguments too early. If possible, we'd like to only type them once we know the correct
                // overload. However, this matters for the case where the call is correct. When the call is
                // an error, we don't need to exclude any arguments, although it would cause no harm to do so.
                checkApplicableSignature(node, candidateForArgumentError, assignableRelation, undefined, true);
            }
            else if (candidateForTypeArgumentError) {
                if (node.typeArguments) {
                    checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, [], true);
                }
                else {
                    ts.Debug.assert(resultOfFailedInference.failedTypeParameterIndex >= 0);
                    var failedTypeParameter = candidateForTypeArgumentError.typeParameters[resultOfFailedInference.failedTypeParameterIndex];
                    var inferenceCandidates = getInferenceCandidates(resultOfFailedInference, resultOfFailedInference.failedTypeParameterIndex);
                    var diagnosticChainHead = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly, typeToString(failedTypeParameter));
                    reportNoCommonSupertypeError(inferenceCandidates, node.func, diagnosticChainHead);
                }
            }
            else {
                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
            }
            // No signature was applicable. We have already reported the errors for the invalid signature.
            // If this is a type resolution session, e.g. Language Service, try to get better information that anySignature.
            // Pick the first candidate that matches the arity. This way we can get a contextual type for cases like:
            //  declare function f(a: { xa: number; xb: number; });
            //  f({ |
            if (!fullTypeCheck) {
                for (var i = 0, n = candidates.length; i < n; i++) {
                    if (signatureHasCorrectArity(node, candidates[i])) {
                        return candidates[i];
                    }
                }
            }
            return resolveErrorCall(node);
            function chooseOverload(candidates, relation, excludeArgument) {
                for (var i = 0; i < candidates.length; i++) {
                    if (!signatureHasCorrectArity(node, candidates[i])) {
                        continue;
                    }
                    var originalCandidate = candidates[i];
                    var inferenceResult;
                    while (true) {
                        var candidate = originalCandidate;
                        if (candidate.typeParameters) {
                            var typeArgumentTypes;
                            var typeArgumentsAreValid;
                            if (node.typeArguments) {
                                typeArgumentTypes = new Array(candidate.typeParameters.length);
                                typeArgumentsAreValid = checkTypeArguments(candidate, node.typeArguments, typeArgumentTypes, false);
                            }
                            else {
                                inferenceResult = inferTypeArguments(candidate, args, excludeArgument);
                                typeArgumentsAreValid = inferenceResult.failedTypeParameterIndex < 0;
                                typeArgumentTypes = inferenceResult.inferredTypes;
                            }
                            if (!typeArgumentsAreValid) {
                                break;
                            }
                            candidate = getSignatureInstantiation(candidate, typeArgumentTypes);
                        }
                        if (!checkApplicableSignature(node, candidate, relation, excludeArgument, false)) {
                            break;
                        }
                        var index = excludeArgument ? ts.indexOf(excludeArgument, true) : -1;
                        if (index < 0) {
                            return candidate;
                        }
                        excludeArgument[index] = false;
                    }
                    // A post-mortem of this iteration of the loop. The signature was not applicable,
                    // so we want to track it as a candidate for reporting an error. If the candidate
                    // had no type parameters, or had no issues related to type arguments, we can
                    // report an error based on the arguments. If there was an issue with type
                    // arguments, then we can only report an error based on the type arguments.
                    if (originalCandidate.typeParameters) {
                        var instantiatedCandidate = candidate;
                        if (typeArgumentsAreValid) {
                            candidateForArgumentError = instantiatedCandidate;
                        }
                        else {
                            candidateForTypeArgumentError = originalCandidate;
                            if (!node.typeArguments) {
                                resultOfFailedInference = inferenceResult;
                            }
                        }
                    }
                    else {
                        ts.Debug.assert(originalCandidate === candidate);
                        candidateForArgumentError = originalCandidate;
                    }
                }
                return undefined;
            }
            // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
            // A nit here is that we reorder only signatures that belong to the same symbol,
            // so order how inherited signatures are processed is still preserved.
            // interface A { (x: string): void }
            // interface B extends A { (x: 'foo'): string }
            // var b: B;
            // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
            function collectCandidates() {
                var result = candidates;
                var lastParent;
                var lastSymbol;
                var cutoffPos = 0;
                var pos;
                ts.Debug.assert(!result.length);
                for (var i = 0; i < signatures.length; i++) {
                    var signature = signatures[i];
                    var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                    var parent = signature.declaration && signature.declaration.parent;
                    if (!lastSymbol || symbol === lastSymbol) {
                        if (lastParent && parent === lastParent) {
                            pos++;
                        }
                        else {
                            lastParent = parent;
                            pos = cutoffPos;
                        }
                    }
                    else {
                        // current declaration belongs to a different symbol
                        // set cutoffPos so re-orderings in the future won't change result set from 0 to cutoffPos
                        pos = cutoffPos = result.length;
                        lastParent = parent;
                    }
                    lastSymbol = symbol;
                    for (var j = result.length; j > pos; j--) {
                        result[j] = result[j - 1];
                    }
                    result[pos] = signature;
                }
            }
        }
        function resolveCallExpression(node, candidatesOutArray) {
            if (node.func.kind === 89 /* SuperKeyword */) {
                var superType = checkSuperExpression(node.func);
                if (superType !== unknownType) {
                    return resolveCall(node, getSignaturesOfType(superType, 1 /* Construct */), candidatesOutArray);
                }
                return resolveUntypedCall(node);
            }
            var funcType = checkExpression(node.func);
            var apparentType = getApparentType(funcType);
            if (apparentType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including call signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
            // TS 1.0 spec: 4.12
            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures
            // but is a subtype of the Function interface, the call is an untyped function call. In an
            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
            // types are provided for the argument expressions, and the result is always of type Any.
            // We exclude union types because we may have a union of function types that happen to have
            // no common signatures.
            if (funcType === anyType || (!callSignatures.length && !constructSignatures.length && !(funcType.flags & 16384 /* Union */) && isTypeAssignableTo(funcType, globalFunctionType))) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
            // TypeScript employs overload resolution in typed function calls in order to support functions
            // with multiple call signatures.
            if (!callSignatures.length) {
                if (constructSignatures.length) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);
                }
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray);
        }
        function resolveNewExpression(node, candidatesOutArray) {
            var expressionType = checkExpression(node.func);
            // TS 1.0 spec: 4.11
            // If ConstructExpr is of type Any, Args can be any argument
            // list and the result of the operation is of type Any.
            if (expressionType === anyType) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If ConstructExpr's apparent type(section 3.8.1) is an object type with one or
            // more construct signatures, the expression is processed in the same manner as a
            // function call, but using the construct signatures as the initial set of candidate
            // signatures for overload resolution.The result type of the function call becomes
            // the result type of the operation.
            expressionType = getApparentType(expressionType);
            if (expressionType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including construct signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);
            if (constructSignatures.length) {
                return resolveCall(node, constructSignatures, candidatesOutArray);
            }
            // If ConstructExpr's apparent type is an object type with no construct signatures but
            // one or more call signatures, the expression is processed as a function call. A compile-time
            // error occurs if the result of the function call is not Void. The type of the result of the
            // operation is Any.
            var callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures, candidatesOutArray);
                if (getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                return signature;
            }
            error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);
            return resolveErrorCall(node);
        }
        // candidatesOutArray is passed by signature help in the language service, and collectCandidates
        // must fill it up with the appropriate candidate signatures
        function getResolvedSignature(node, candidatesOutArray) {
            var links = getNodeLinks(node);
            // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
            // However, it is possible that either candidatesOutArray was not passed in the first time,
            // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
            // to correctly fill the candidatesOutArray.
            if (!links.resolvedSignature || candidatesOutArray) {
                links.resolvedSignature = anySignature;
                links.resolvedSignature = node.kind === 144 /* CallExpression */ ? resolveCallExpression(node, candidatesOutArray) : resolveNewExpression(node, candidatesOutArray);
            }
            return links.resolvedSignature;
        }
        function checkCallExpression(node) {
            var signature = getResolvedSignature(node);
            if (node.func.kind === 89 /* SuperKeyword */) {
                return voidType;
            }
            if (node.kind === 145 /* NewExpression */) {
                var declaration = signature.declaration;
                if (declaration && (declaration.kind !== 126 /* Constructor */ && declaration.kind !== 130 /* ConstructSignature */)) {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any
                    if (compilerOptions.noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            return getReturnTypeOfSignature(signature);
        }
        function checkTaggedTemplateExpression(node) {
            // TODO (drosen): Make sure substitutions are assignable to the tag's arguments.
            checkExpression(node.tag);
            checkExpression(node.template);
            return anyType;
        }
        function checkTypeAssertion(node) {
            var exprType = checkExpression(node.operand);
            var targetType = getTypeFromTypeNode(node.type);
            if (fullTypeCheck && targetType !== unknownType) {
                var widenedType = getWidenedType(exprType, true);
                if (!(isTypeAssignableTo(targetType, widenedType))) {
                    checkTypeAssignableTo(exprType, targetType, node, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other);
                }
            }
            return targetType;
        }
        function getTypeAtPosition(signature, pos) {
            return signature.hasRestParameter ? pos < signature.parameters.length - 1 ? getTypeOfSymbol(signature.parameters[pos]) : getRestTypeOfSignature(signature) : pos < signature.parameters.length ? getTypeOfSymbol(signature.parameters[pos]) : anyType;
        }
        function assignContextualParameterTypes(signature, context, mapper) {
            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeAtPosition(context, i), mapper);
            }
            if (signature.hasRestParameter && context.hasRestParameter && signature.parameters.length >= context.parameters.length) {
                var parameter = signature.parameters[signature.parameters.length - 1];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeOfSymbol(context.parameters[context.parameters.length - 1]), mapper);
            }
        }
        function getReturnTypeFromBody(func, contextualMapper) {
            var contextualSignature = getContextualSignature(func);
            if (func.body.kind !== 183 /* FunctionBlock */) {
                var unwidenedType = checkAndMarkExpression(func.body, contextualMapper);
                var widenedType = getWidenedType(unwidenedType);
                if (fullTypeCheck && compilerOptions.noImplicitAny && !contextualSignature && widenedType !== unwidenedType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeToString(widenedType));
                }
                return widenedType;
            }
            // Aggregate the types of expressions within all the return statements.
            var types = checkAndAggregateReturnExpressionTypes(func.body, contextualMapper);
            // Try to return the best common type if we have any return expressions.
            if (types.length > 0) {
                // When return statements are contextually typed we allow the return type to be a union type. Otherwise we require the
                // return expressions to have a best common supertype.
                var commonType = contextualSignature ? getUnionType(types) : getCommonSupertype(types);
                if (!commonType) {
                    error(func, ts.Diagnostics.No_best_common_type_exists_among_return_expressions);
                    return unknownType;
                }
                var widenedType = getWidenedType(commonType);
                // Check and report for noImplicitAny if the best common type implicitly gets widened to an 'any'/arrays-of-'any' type.
                if (fullTypeCheck && compilerOptions.noImplicitAny && !contextualSignature && widenedType !== commonType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    var typeName = typeToString(widenedType);
                    if (func.name) {
                        error(func, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.declarationNameToString(func.name), typeName);
                    }
                    else {
                        error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
                return widenedType;
            }
            return voidType;
        }
        /// Returns a set of types relating to every return expression relating to a function block.
        function checkAndAggregateReturnExpressionTypes(body, contextualMapper) {
            var aggregatedTypes = [];
            ts.forEachReturnStatement(body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkAndMarkExpression(expr, contextualMapper);
                    if (!ts.contains(aggregatedTypes, type)) {
                        aggregatedTypes.push(type);
                    }
                }
            });
            return aggregatedTypes;
        }
        function bodyContainsAReturnStatement(funcBody) {
            return ts.forEachReturnStatement(funcBody, function (returnStatement) {
                return true;
            });
        }
        function bodyContainsSingleThrowStatement(body) {
            return (body.statements.length === 1) && (body.statements[0].kind === 175 /* ThrowStatement */);
        }
        // TypeScript Specification 1.0 (6.3) - July 2014
        // An explicitly typed function whose return type isn't the Void or the Any type
        // must have at least one return statement somewhere in its body.
        // An exception to this rule is if the function implementation consists of a single 'throw' statement.
        function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(func, returnType) {
            if (!fullTypeCheck) {
                return;
            }
            // Functions that return 'void' or 'any' don't need any return expressions.
            if (returnType === voidType || returnType === anyType) {
                return;
            }
            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            if (!func.body || func.body.kind !== 183 /* FunctionBlock */) {
                return;
            }
            var bodyBlock = func.body;
            // Ensure the body has at least one return expression.
            if (bodyContainsAReturnStatement(bodyBlock)) {
                return;
            }
            // If there are no return expressions, then we need to check if
            // the function body consists solely of a throw statement;
            // this is to make an exception for unimplemented functions.
            if (bodyContainsSingleThrowStatement(bodyBlock)) {
                return;
            }
            // This function does not conform to the specification.
            error(func.type, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement);
        }
        function checkFunctionExpression(node, contextualMapper) {
            // The identityMapper object is used to indicate that function expressions are wildcards
            if (contextualMapper === identityMapper) {
                return anyFunctionType;
            }
            var links = getNodeLinks(node);
            var type = getTypeOfSymbol(node.symbol);
            // Check if function expression is contextually typed and assign parameter types if so
            if (!(links.flags & 64 /* ContextChecked */)) {
                var contextualSignature = getContextualSignature(node);
                // If a type check is started at a function expression that is an argument of a function call, obtaining the
                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
                // already assigned contextual types.
                if (!(links.flags & 64 /* ContextChecked */)) {
                    links.flags |= 64 /* ContextChecked */;
                    if (contextualSignature) {
                        var signature = getSignaturesOfType(type, 0 /* Call */)[0];
                        if (isContextSensitiveExpression(node)) {
                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);
                        }
                        if (!node.type) {
                            signature.resolvedReturnType = resolvingType;
                            var returnType = getReturnTypeFromBody(node, contextualMapper);
                            if (signature.resolvedReturnType === resolvingType) {
                                signature.resolvedReturnType = returnType;
                            }
                        }
                    }
                    checkSignatureDeclaration(node);
                }
            }
            return type;
        }
        function checkFunctionExpressionBody(node) {
            if (node.type) {
                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
            }
            if (node.body.kind === 183 /* FunctionBlock */) {
                checkSourceElement(node.body);
            }
            else {
                var exprType = checkExpression(node.body);
                if (node.type) {
                    checkTypeAssignableTo(exprType, getTypeFromTypeNode(node.type), node.body, undefined);
                }
                checkFunctionExpressionBodies(node.body);
            }
        }
        function checkArithmeticOperandType(operand, type, diagnostic) {
            if (!(type.flags & (1 /* Any */ | 132 /* NumberLike */))) {
                error(operand, diagnostic);
                return false;
            }
            return true;
        }
        function checkReferenceExpression(n, invalidReferenceMessage, constantVarianleMessage) {
            function findSymbol(n) {
                var symbol = getNodeLinks(n).resolvedSymbol;
                // Because we got the symbol from the resolvedSymbol property, it might be of kind
                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export
                // symbol, which will have the correct flags set on it.
                return symbol && getExportSymbolOfValueSymbolIfExported(symbol);
            }
            function isReferenceOrErrorExpression(n) {
                switch (n.kind) {
                    case 63 /* Identifier */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.3
                        // An identifier expression that references a variable or parameter is classified as a reference. 
                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).
                        return !symbol || symbol === unknownSymbol || symbol === argumentsSymbol || (symbol.flags & 3 /* Variable */) !== 0;
                    case 142 /* PropertyAccess */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.10
                        // A property access expression is always classified as a reference.
                        // NOTE (not in spec): assignment to enum members should not be allowed
                        return !symbol || symbol === unknownSymbol || (symbol.flags & ~8 /* EnumMember */) !== 0;
                    case 143 /* IndexedAccess */:
                        //  old compiler doesn't check indexed assess
                        return true;
                    case 148 /* ParenExpression */:
                        return isReferenceOrErrorExpression(n.expression);
                    default:
                        return false;
                }
            }
            function isConstVariableReference(n) {
                switch (n.kind) {
                    case 63 /* Identifier */:
                    case 142 /* PropertyAccess */:
                        var symbol = findSymbol(n);
                        return symbol && (symbol.flags & 3 /* Variable */) !== 0 && (getDeclarationFlagsFromSymbol(symbol) & 4096 /* Const */) !== 0;
                    case 143 /* IndexedAccess */:
                        var index = n.index;
                        var symbol = findSymbol(n.object);
                        if (symbol && index.kind === 7 /* StringLiteral */) {
                            var name = index.text;
                            var prop = getPropertyOfType(getTypeOfSymbol(symbol), name);
                            return prop && (prop.flags & 3 /* Variable */) !== 0 && (getDeclarationFlagsFromSymbol(prop) & 4096 /* Const */) !== 0;
                        }
                        return false;
                    case 148 /* ParenExpression */:
                        return isConstVariableReference(n.expression);
                    default:
                        return false;
                }
            }
            if (!isReferenceOrErrorExpression(n)) {
                error(n, invalidReferenceMessage);
                return false;
            }
            if (isConstVariableReference(n)) {
                error(n, constantVarianleMessage);
                return false;
            }
            return true;
        }
        function checkPrefixExpression(node) {
            var operandType = checkExpression(node.operand);
            switch (node.operator) {
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                case 46 /* TildeToken */:
                    return numberType;
                case 45 /* ExclamationToken */:
                case 72 /* DeleteKeyword */:
                    return booleanType;
                case 95 /* TypeOfKeyword */:
                    return stringType;
                case 97 /* VoidKeyword */:
                    return undefinedType;
                case 37 /* PlusPlusToken */:
                case 38 /* MinusMinusToken */:
                    var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                    if (ok) {
                        // run check only if former checks succeeded to avoid reporting cascading errors
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);
                    }
                    return numberType;
            }
            return unknownType;
        }
        function checkPostfixExpression(node) {
            var operandType = checkExpression(node.operand);
            var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
            if (ok) {
                // run check only if former checks succeeded to avoid reporting cascading errors
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);
            }
            return numberType;
        }
        // Return true if type is any, an object type, a type parameter, or a union type composed of only those kinds of types
        function isStructuredType(type) {
            if (type.flags & 16384 /* Union */) {
                return !ts.forEach(type.types, function (t) { return !isStructuredType(t); });
            }
            return (type.flags & 65025 /* Structured */) !== 0;
        }
        function isConstEnumObjectType(type) {
            return type.flags & (48128 /* ObjectType */ | 32768 /* Anonymous */) && type.symbol && isConstEnumSymbol(type.symbol);
        }
        function isConstEnumSymbol(symbol) {
            return (symbol.flags & 128 /* ConstEnum */) !== 0;
        }
        function checkInstanceOfExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.4
            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
            // and the right operand to be of type Any or a subtype of the 'Function' interface type. 
            // The result is always of the Boolean primitive type.
            // NOTE: do not raise error if leftType is unknown as related error was already reported
            if (leftType !== unknownType && !isStructuredType(leftType)) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            // NOTE: do not raise error if right is unknown as related error was already reported
            if (rightType !== unknownType && rightType !== anyType && !isTypeSubtypeOf(rightType, globalFunctionType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.5
            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
            // and the right operand to be of type Any, an object type, or a type parameter type.
            // The result is always of the Boolean primitive type.
            if (leftType !== anyType && leftType !== stringType && leftType !== numberType) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number);
            }
            if (!isStructuredType(rightType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            return booleanType;
        }
        function checkBinaryExpression(node, contextualMapper) {
            var operator = node.operator;
            var leftType = checkExpression(node.left, contextualMapper);
            var rightType = checkExpression(node.right, contextualMapper);
            switch (operator) {
                case 34 /* AsteriskToken */:
                case 54 /* AsteriskEqualsToken */:
                case 35 /* SlashToken */:
                case 55 /* SlashEqualsToken */:
                case 36 /* PercentToken */:
                case 56 /* PercentEqualsToken */:
                case 33 /* MinusToken */:
                case 53 /* MinusEqualsToken */:
                case 39 /* LessThanLessThanToken */:
                case 57 /* LessThanLessThanEqualsToken */:
                case 40 /* GreaterThanGreaterThanToken */:
                case 58 /* GreaterThanGreaterThanEqualsToken */:
                case 41 /* GreaterThanGreaterThanGreaterThanToken */:
                case 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 43 /* BarToken */:
                case 61 /* BarEqualsToken */:
                case 44 /* CaretToken */:
                case 62 /* CaretEqualsToken */:
                case 42 /* AmpersandToken */:
                case 60 /* AmpersandEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.1
                    // These operators require their operands to be of type Any, the Number primitive type,
                    // or an enum type. Operands of an enum type are treated 
                    // as having the primitive type Number. If one operand is the null or undefined value,
                    // it is treated as having the type of the other operand.
                    // The result is always of the Number primitive type.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var suggestedOperator;
                    // if a user tries to apply a bitwise operator to 2 boolean operands 
                    // try and return them a helpful suggestion
                    if ((leftType.flags & 8 /* Boolean */) && (rightType.flags & 8 /* Boolean */) && (suggestedOperator = getSuggestedBooleanOperator(node.operator)) !== undefined) {
                        error(node, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(node.operator), ts.tokenToString(suggestedOperator));
                    }
                    else {
                        // otherwise just check each operand separately and report errors as normal 
                        var leftOk = checkArithmeticOperandType(node.left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                        var rightOk = checkArithmeticOperandType(node.right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                        if (leftOk && rightOk) {
                            checkAssignmentOperator(numberType);
                        }
                    }
                    return numberType;
                case 32 /* PlusToken */:
                case 52 /* PlusEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.2
                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,
                    // or at least one of the operands to be of type Any or the String primitive type.
                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var resultType;
                    if (leftType.flags & 132 /* NumberLike */ && rightType.flags & 132 /* NumberLike */) {
                        // Operands of an enum type are treated as having the primitive type Number.
                        // If both operands are of the Number primitive type, the result is of the Number primitive type.
                        resultType = numberType;
                    }
                    else if (leftType.flags & 258 /* StringLike */ || rightType.flags & 258 /* StringLike */) {
                        // If one or both operands are of the String primitive type, the result is of the String primitive type.
                        resultType = stringType;
                    }
                    else if (leftType.flags & 1 /* Any */ || leftType === unknownType || rightType.flags & 1 /* Any */ || rightType === unknownType) {
                        // Otherwise, the result is of type Any.
                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                        resultType = anyType;
                    }
                    if (!resultType) {
                        reportOperatorError();
                        return anyType;
                    }
                    if (operator === 52 /* PlusEqualsToken */) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 27 /* EqualsEqualsToken */:
                case 28 /* ExclamationEqualsToken */:
                case 29 /* EqualsEqualsEqualsToken */:
                case 30 /* ExclamationEqualsEqualsToken */:
                case 23 /* LessThanToken */:
                case 24 /* GreaterThanToken */:
                case 25 /* LessThanEqualsToken */:
                case 26 /* GreaterThanEqualsToken */:
                    if (!isTypeAssignableTo(leftType, rightType) && !isTypeAssignableTo(rightType, leftType)) {
                        reportOperatorError();
                    }
                    return booleanType;
                case 85 /* InstanceOfKeyword */:
                    return checkInstanceOfExpression(node, leftType, rightType);
                case 84 /* InKeyword */:
                    return checkInExpression(node, leftType, rightType);
                case 47 /* AmpersandAmpersandToken */:
                    return rightType;
                case 48 /* BarBarToken */:
                    return getUnionType([leftType, rightType]);
                case 51 /* EqualsToken */:
                    checkAssignmentOperator(rightType);
                    return rightType;
                case 22 /* CommaToken */:
                    return rightType;
            }
            function getSuggestedBooleanOperator(operator) {
                switch (operator) {
                    case 43 /* BarToken */:
                    case 61 /* BarEqualsToken */:
                        return 48 /* BarBarToken */;
                    case 44 /* CaretToken */:
                    case 62 /* CaretEqualsToken */:
                        return 30 /* ExclamationEqualsEqualsToken */;
                    case 42 /* AmpersandToken */:
                    case 60 /* AmpersandEqualsToken */:
                        return 47 /* AmpersandAmpersandToken */;
                    default:
                        return undefined;
                }
            }
            function checkAssignmentOperator(valueType) {
                if (fullTypeCheck && operator >= 51 /* FirstAssignment */ && operator <= 62 /* LastAssignment */) {
                    // TypeScript 1.0 spec (April 2014): 4.17
                    // An assignment of the form
                    //    VarExpr = ValueExpr
                    // requires VarExpr to be classified as a reference
                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1) 
                    // and the type of the non - compound operation to be assignable to the type of VarExpr.
                    var ok = checkReferenceExpression(node.left, ts.Diagnostics.Invalid_left_hand_side_of_assignment_expression, ts.Diagnostics.Left_hand_side_of_assignment_expression_cannot_be_a_constant);
                    // Use default messages
                    if (ok) {
                        // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                        checkTypeAssignableTo(valueType, leftType, node.left, undefined);
                    }
                }
            }
            function reportOperatorError() {
                error(node, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(node.operator), typeToString(leftType), typeToString(rightType));
            }
        }
        function checkConditionalExpression(node, contextualMapper) {
            checkExpression(node.condition);
            var type1 = checkExpression(node.whenTrue, contextualMapper);
            var type2 = checkExpression(node.whenFalse, contextualMapper);
            return getUnionType([type1, type2]);
        }
        function checkTemplateExpression(node) {
            // We just want to check each expressions, but we are unconcerned with
            // the type of each expression, as any value may be coerced into a string.
            // It is worth asking whether this is what we really want though.
            // A place where we actually *are* concerned with the expressions' types are
            // in tagged templates.
            ts.forEach(node.templateSpans, function (templateSpan) {
                checkExpression(templateSpan.expression);
            });
            return stringType;
        }
        function checkExpressionWithContextualType(node, contextualType, contextualMapper) {
            var saveContextualType = node.contextualType;
            node.contextualType = contextualType;
            var result = checkExpression(node, contextualMapper);
            node.contextualType = saveContextualType;
            return result;
        }
        function checkAndMarkExpression(node, contextualMapper) {
            var result = checkExpression(node, contextualMapper);
            getNodeLinks(node).flags |= 1 /* TypeChecked */;
            return result;
        }
        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When
        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the
        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in
        // conjunction with the generic contextual type. When contextualMapper is equal to the identityMapper function
        // object, it serves as an indicator that all contained function and arrow expressions should be considered to
        // have the wildcard function type; this form of type check is used during overload resolution to exclude
        // contextually typed function and arrow expressions in the initial phase.
        function checkExpression(node, contextualMapper) {
            var type = checkExpressionNode(node, contextualMapper);
            if (contextualMapper && contextualMapper !== identityMapper) {
                var signature = getSingleCallSignature(type);
                if (signature && signature.typeParameters) {
                    var contextualType = getContextualType(node);
                    if (contextualType) {
                        var contextualSignature = getSingleCallSignature(contextualType);
                        if (contextualSignature && !contextualSignature.typeParameters) {
                            type = getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper));
                        }
                    }
                }
            }
            if (isConstEnumObjectType(type)) {
                // enum object type for const enums are only permitted in:
                // - 'left' in property access 
                // - 'object' in indexed access
                // - target in rhs of import statement
                var ok = (node.parent.kind === 142 /* PropertyAccess */ && node.parent.left === node) || (node.parent.kind === 143 /* IndexedAccess */ && node.parent.object === node) || ((node.kind === 63 /* Identifier */ || node.kind === 121 /* QualifiedName */) && isInRightSideOfImportOrExportAssignment(node));
                if (!ok) {
                    error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment);
                }
            }
            return type;
        }
        function checkExpressionNode(node, contextualMapper) {
            switch (node.kind) {
                case 63 /* Identifier */:
                    return checkIdentifier(node);
                case 91 /* ThisKeyword */:
                    return checkThisExpression(node);
                case 89 /* SuperKeyword */:
                    return checkSuperExpression(node);
                case 87 /* NullKeyword */:
                    return nullType;
                case 93 /* TrueKeyword */:
                case 78 /* FalseKeyword */:
                    return booleanType;
                case 6 /* NumericLiteral */:
                    return numberType;
                case 155 /* TemplateExpression */:
                    return checkTemplateExpression(node);
                case 7 /* StringLiteral */:
                case 9 /* NoSubstitutionTemplateLiteral */:
                    return stringType;
                case 8 /* RegularExpressionLiteral */:
                    return globalRegExpType;
                case 121 /* QualifiedName */:
                    return checkPropertyAccess(node);
                case 139 /* ArrayLiteral */:
                    return checkArrayLiteral(node, contextualMapper);
                case 140 /* ObjectLiteral */:
                    return checkObjectLiteral(node, contextualMapper);
                case 142 /* PropertyAccess */:
                    return checkPropertyAccess(node);
                case 143 /* IndexedAccess */:
                    return checkIndexedAccess(node);
                case 144 /* CallExpression */:
                case 145 /* NewExpression */:
                    return checkCallExpression(node);
                case 146 /* TaggedTemplateExpression */:
                    return checkTaggedTemplateExpression(node);
                case 147 /* TypeAssertion */:
                    return checkTypeAssertion(node);
                case 148 /* ParenExpression */:
                    return checkExpression(node.expression);
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                    return checkFunctionExpression(node, contextualMapper);
                case 151 /* PrefixOperator */:
                    return checkPrefixExpression(node);
                case 152 /* PostfixOperator */:
                    return checkPostfixExpression(node);
                case 153 /* BinaryExpression */:
                    return checkBinaryExpression(node, contextualMapper);
                case 154 /* ConditionalExpression */:
                    return checkConditionalExpression(node, contextualMapper);
                case 157 /* OmittedExpression */:
                    return undefinedType;
            }
            return unknownType;
        }
        // DECLARATION AND STATEMENT TYPE CHECKING
        function checkTypeParameter(node) {
            checkSourceElement(node.constraint);
            if (fullTypeCheck) {
                checkTypeParameterHasIllegalReferencesInConstraint(node);
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
            // TODO: Check multiple declarations are identical
        }
        function checkParameter(parameterDeclaration) {
            checkVariableDeclaration(parameterDeclaration);
            if (fullTypeCheck) {
                checkCollisionWithIndexVariableInGeneratedCode(parameterDeclaration, parameterDeclaration.name);
                if (parameterDeclaration.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */) && !(parameterDeclaration.parent.kind === 126 /* Constructor */ && parameterDeclaration.parent.body)) {
                    error(parameterDeclaration, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
                if (parameterDeclaration.flags & 8 /* Rest */) {
                    if (!isArrayType(getTypeOfSymbol(parameterDeclaration.symbol))) {
                        error(parameterDeclaration, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
                    }
                }
                else {
                    if (parameterDeclaration.initializer && !parameterDeclaration.parent.body) {
                        error(parameterDeclaration, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                    }
                }
            }
            function checkReferencesInInitializer(n) {
                if (n.kind === 63 /* Identifier */) {
                    var referencedSymbol = getNodeLinks(n).resolvedSymbol;
                    // check FunctionLikeDeclaration.locals (stores parameters\function local variable) 
                    // if it contains entry with a specified name and if this entry matches the resolved symbol
                    if (referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol(parameterDeclaration.parent.locals, referencedSymbol.name, 107455 /* Value */) === referencedSymbol) {
                        if (referencedSymbol.valueDeclaration.kind === 123 /* Parameter */) {
                            if (referencedSymbol.valueDeclaration === parameterDeclaration) {
                                error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.declarationNameToString(parameterDeclaration.name));
                                return;
                            }
                            var enclosingOrReferencedParameter = ts.forEach(parameterDeclaration.parent.parameters, function (p) { return p === parameterDeclaration || p === referencedSymbol.valueDeclaration ? p : undefined; });
                            if (enclosingOrReferencedParameter === referencedSymbol.valueDeclaration) {
                                // legal case - parameter initializer references some parameter strictly on left of current parameter declaration
                                return;
                            }
                        }
                        error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(parameterDeclaration.name), ts.declarationNameToString(n));
                    }
                }
                else {
                    ts.forEachChild(n, checkReferencesInInitializer);
                }
            }
            if (parameterDeclaration.initializer) {
                checkReferencesInInitializer(parameterDeclaration.initializer);
            }
        }
        function checkSignatureDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (fullTypeCheck) {
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithArgumentsInGeneratedCode(node);
                if (compilerOptions.noImplicitAny && !node.type) {
                    switch (node.kind) {
                        case 130 /* ConstructSignature */:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 129 /* CallSignature */:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
            }
            checkSpecializedSignatureDeclaration(node);
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 185 /* InterfaceDeclaration */) {
                var nodeSymbol = getSymbolOfNode(node);
                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
                // to prevent this run check only for the first declaration of a given kind
                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            // TypeScript 1.0 spec (April 2014)
            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol) {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;
                for (var i = 0, len = indexSymbol.declarations.length; i < len; ++i) {
                    var declaration = indexSymbol.declarations[i];
                    if (declaration.parameters.length == 1 && declaration.parameters[0].type) {
                        switch (declaration.parameters[0].type.kind) {
                            case 118 /* StringKeyword */:
                                if (!seenStringIndexer) {
                                    seenStringIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                                }
                                break;
                            case 116 /* NumberKeyword */:
                                if (!seenNumericIndexer) {
                                    seenNumericIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                                }
                                break;
                        }
                    }
                }
            }
        }
        function checkPropertyDeclaration(node) {
            // TODO
            checkVariableDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            // TODO
            checkFunctionDeclaration(node);
        }
        function checkConstructorDeclaration(node) {
            // TODO
            checkSignatureDeclaration(node);
            checkSourceElement(node.body);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = getDeclarationOfKind(symbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            // exit early in the case of signature - super checks are not relevant to them
            if (!node.body) {
                return;
            }
            if (!fullTypeCheck) {
                return;
            }
            function isSuperCallExpression(n) {
                return n.kind === 144 /* CallExpression */ && n.func.kind === 89 /* SuperKeyword */;
            }
            function containsSuperCall(n) {
                if (isSuperCallExpression(n)) {
                    return true;
                }
                switch (n.kind) {
                    case 149 /* FunctionExpression */:
                    case 182 /* FunctionDeclaration */:
                    case 150 /* ArrowFunction */:
                    case 140 /* ObjectLiteral */: return false;
                    default: return ts.forEachChild(n, containsSuperCall);
                }
            }
            function markThisReferencesAsErrors(n) {
                if (n.kind === 91 /* ThisKeyword */) {
                    error(n, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                }
                else if (n.kind !== 149 /* FunctionExpression */ && n.kind !== 182 /* FunctionDeclaration */) {
                    ts.forEachChild(n, markThisReferencesAsErrors);
                }
            }
            function isInstancePropertyWithInitializer(n) {
                return n.kind === 124 /* Property */ && !(n.flags & 128 /* Static */) && !!n.initializer;
            }
            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas 
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            if (node.parent.baseType) {
                if (containsSuperCall(node.body)) {
                    // The first statement in the body of a constructor must be a super call if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties 
                    //   or the containing class declares instance member variables with initializers.
                    var superCallShouldBeFirst = ts.forEach(node.parent.members, isInstancePropertyWithInitializer) || ts.forEach(node.parameters, function (p) { return p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */); });
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        if (!statements.length || statements[0].kind !== 161 /* ExpressionStatement */ || !isSuperCallExpression(statements[0].expression)) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                        }
                        else {
                            // In such a required super call, it is a compile-time error for argument expressions to reference this.
                            markThisReferencesAsErrors(statements[0].expression);
                        }
                    }
                }
                else {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (fullTypeCheck) {
                if (node.kind === 127 /* GetAccessor */) {
                    if (!ts.isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(node.body) || bodyContainsSingleThrowStatement(node.body))) {
                        error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);
                    }
                }
                // TypeScript 1.0 spec (April 2014): 8.4.3
                // Accessors for the same member name must specify the same accessibility.
                var otherKind = node.kind === 127 /* GetAccessor */ ? 128 /* SetAccessor */ : 127 /* GetAccessor */;
                var otherAccessor = getDeclarationOfKind(node.symbol, otherKind);
                if (otherAccessor) {
                    if (((node.flags & 112 /* AccessibilityModifier */) !== (otherAccessor.flags & 112 /* AccessibilityModifier */))) {
                        error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                    }
                    var thisType = getAnnotatedAccessorType(node);
                    var otherType = getAnnotatedAccessorType(otherAccessor);
                    // TypeScript 1.0 spec (April 2014): 4.5
                    // If both accessors include type annotations, the specified types must be identical.
                    if (thisType && otherType) {
                        if (!isTypeIdenticalTo(thisType, otherType)) {
                            error(node, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                        }
                    }
                }
            }
            checkFunctionDeclaration(node);
            checkAndStoreTypeOfAccessors(getSymbolOfNode(node));
        }
        function checkTypeReference(node) {
            var type = getTypeFromTypeReferenceNode(node);
            if (type !== unknownType && node.typeArguments) {
                // Do type argument local checks only if referenced type is successfully resolved
                var len = node.typeArguments.length;
                for (var i = 0; i < len; i++) {
                    checkSourceElement(node.typeArguments[i]);
                    var constraint = getConstraintOfTypeParameter(type.target.typeParameters[i]);
                    if (fullTypeCheck && constraint) {
                        var typeArgument = type.typeArguments[i];
                        checkTypeAssignableTo(typeArgument, constraint, node, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                    }
                }
            }
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                var type = getTypeFromTypeLiteralNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function checkArrayType(node) {
            checkSourceElement(node.elementType);
        }
        function checkTupleType(node) {
            ts.forEach(node.elementTypes, checkSourceElement);
        }
        function checkUnionType(node) {
            ts.forEach(node.types, checkSourceElement);
        }
        function isPrivateWithinAmbient(node) {
            return (node.flags & 32 /* Private */) && ts.isInAmbientContext(node);
        }
        function checkSpecializedSignatureDeclaration(signatureDeclarationNode) {
            if (!fullTypeCheck) {
                return;
            }
            var signature = getSignatureFromDeclaration(signatureDeclarationNode);
            if (!signature.hasStringLiterals) {
                return;
            }
            // TypeScript 1.0 spec (April 2014): 3.7.2.2
            // Specialized signatures are not permitted in conjunction with a function body
            if (signatureDeclarationNode.body) {
                error(signatureDeclarationNode, ts.Diagnostics.A_signature_with_an_implementation_cannot_use_a_string_literal_type);
                return;
            }
            var symbol = getSymbolOfNode(signatureDeclarationNode);
            // TypeScript 1.0 spec (April 2014): 3.7.2.4
            // Every specialized call or construct signature in an object type must be assignable
            // to at least one non-specialized call or construct signature in the same object type
            var signaturesToCheck;
            // Unnamed (call\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.
            // Use declaring type to obtain full list of signatures.
            if (!signatureDeclarationNode.name && signatureDeclarationNode.parent && signatureDeclarationNode.parent.kind === 185 /* InterfaceDeclaration */) {
                ts.Debug.assert(signatureDeclarationNode.kind === 129 /* CallSignature */ || signatureDeclarationNode.kind === 130 /* ConstructSignature */);
                var signatureKind = signatureDeclarationNode.kind === 129 /* CallSignature */ ? 0 /* Call */ : 1 /* Construct */;
                var containingSymbol = getSymbolOfNode(signatureDeclarationNode.parent);
                var containingType = getDeclaredTypeOfSymbol(containingSymbol);
                signaturesToCheck = getSignaturesOfType(containingType, signatureKind);
            }
            else {
                signaturesToCheck = getSignaturesOfSymbol(getSymbolOfNode(signatureDeclarationNode));
            }
            for (var i = 0; i < signaturesToCheck.length; i++) {
                var otherSignature = signaturesToCheck[i];
                if (!otherSignature.hasStringLiterals && isSignatureAssignableTo(signature, otherSignature)) {
                    return;
                }
            }
            error(signatureDeclarationNode, ts.Diagnostics.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = n.flags;
            if (n.parent.kind !== 185 /* InterfaceDeclaration */ && ts.isInAmbientContext(n)) {
                if (!(flags & 2 /* Ambient */)) {
                    // It is nested in an ambient context, which means it is automatically exported
                    flags |= 1 /* Export */;
                }
                flags |= 2 /* Ambient */;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!fullTypeCheck) {
                return;
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                // Error if some overloads have a flag that is not shared by all overloads. To find the
                // deviations, we XOR someOverloadFlags with allOverloadFlags
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
                    // Error on all deviations from this canonical set of flags
                    // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
                    // report the errors on those. To achieve this, we will say that the implementation is
                    // the canonical signature only if it is in the same container as the first overload
                    var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                    var canonicalFlags = implementationSharesContainerWithFirstOverload ? getEffectiveDeclarationFlags(implementation, flagsToCheck) : getEffectiveDeclarationFlags(overloads[0], flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                        if (deviation & 1 /* Export */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_exported_or_not_exported);
                        }
                        else if (deviation & 2 /* Ambient */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (32 /* Private */ | 64 /* Protected */)) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & 4 /* QuestionMark */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 32 /* Private */ | 64 /* Protected */ | 4 /* QuestionMark */;
            var someNodeFlags = 0;
            var allNodeFlags = flagsToCheck;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 16384 /* Constructor */) !== 0;
            function reportImplementationExpectedError(node) {
                if (node.name && node.name.kind === 120 /* Missing */) {
                    return;
                }
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                if (subsequentNode) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode = subsequentNode.name || subsequentNode;
                        // TODO(jfreeman): These are methods, so handle computed name case
                        if (node.name && subsequentNode.name && node.name.text === subsequentNode.name.text) {
                            // the only situation when this is possible (same kind\same name but different symbol) - mixed static and instance class members
                            ts.Debug.assert(node.kind === 125 /* Method */);
                            ts.Debug.assert((node.flags & 128 /* Static */) !== (subsequentNode.flags & 128 /* Static */));
                            var diagnostic = node.flags & 128 /* Static */ ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode, diagnostic);
                            return;
                        }
                        else if (subsequentNode.body) {
                            error(errorNode, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
            // when checking exported function declarations across modules check only duplicate implementations
            // names and consistency of modifiers are verified when we check local symbol
            var isExportSymbolInsideModule = symbol.parent && symbol.parent.flags & 1536 /* Module */;
            var duplicateFunctionDeclaration = false;
            var multipleConstructorImplementation = false;
            for (var i = 0; i < declarations.length; i++) {
                var node = declarations[i];
                var inAmbientContext = ts.isInAmbientContext(node);
                var inAmbientContextOrInterface = node.parent.kind === 185 /* InterfaceDeclaration */ || node.parent.kind === 134 /* TypeLiteral */ || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e. this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = undefined;
                }
                if (node.kind === 182 /* FunctionDeclaration */ || node.kind === 125 /* Method */ || node.kind === 126 /* Constructor */) {
                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    if (node.body && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        }
                        else {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    else if (!isExportSymbolInsideModule && previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (node.body) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
            }
            if (multipleConstructorImplementation) {
                ts.forEach(declarations, function (declaration) {
                    error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                });
            }
            if (duplicateFunctionDeclaration) {
                ts.forEach(declarations, function (declaration) {
                    error(declaration.name, ts.Diagnostics.Duplicate_function_implementation);
                });
            }
            if (!isExportSymbolInsideModule && lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    // If the implementation signature has string literals, we will have reported an error in
                    // checkSpecializedSignatureDeclaration
                    if (!bodySignature.hasStringLiterals) {
                        for (var i = 0, len = signatures.length; i < len; ++i) {
                            if (!signatures[i].hasStringLiterals && !isSignatureAssignableTo(bodySignature, signatures[i])) {
                                error(signatures[i].declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);
                                break;
                            }
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!fullTypeCheck) {
                return;
            }
            var symbol;
            // Exports should be checked only if enclosing module contains both exported and non exported declarations.
            // In case if all declarations are non-exported check is unnecessary.
            // if localSymbol is defined on node then node itself is exported - check is required
            var symbol = node.localSymbol;
            if (!symbol) {
                // local symbol is undefined => this declaration is non-exported.
                // however symbol might contain other declarations that are exported
                symbol = getSymbolOfNode(node);
                if (!(symbol.flags & 29360128 /* Export */)) {
                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                    return;
                }
            }
            // run the check only for the first declaration in the list
            if (getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace 
            // to denote disjoint declarationSpaces (without making new enum type).
            var exportedDeclarationSpaces = 0;
            var nonExportedDeclarationSpaces = 0;
            ts.forEach(symbol.declarations, function (d) {
                var declarationSpaces = getDeclarationSpaces(d);
                if (getEffectiveDeclarationFlags(d, 1 /* Export */)) {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            });
            var commonDeclarationSpace = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            if (commonDeclarationSpace) {
                // declaration spaces for exported and non-exported declarations intersect
                ts.forEach(symbol.declarations, function (d) {
                    if (getDeclarationSpaces(d) & commonDeclarationSpace) {
                        error(d.name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.declarationNameToString(d.name));
                    }
                });
            }
            function getDeclarationSpaces(d) {
                switch (d.kind) {
                    case 185 /* InterfaceDeclaration */:
                        return 8388608 /* ExportType */;
                    case 188 /* ModuleDeclaration */:
                        return d.name.kind === 7 /* StringLiteral */ || ts.getModuleInstanceState(d) !== 0 /* NonInstantiated */ ? 16777216 /* ExportNamespace */ | 4194304 /* ExportValue */ : 16777216 /* ExportNamespace */;
                    case 184 /* ClassDeclaration */:
                    case 187 /* EnumDeclaration */:
                        return 8388608 /* ExportType */ | 4194304 /* ExportValue */;
                    case 190 /* ImportDeclaration */:
                        var result = 0;
                        var target = resolveImport(getSymbolOfNode(d));
                        ts.forEach(target.declarations, function (d) {
                            result |= getDeclarationSpaces(d);
                        });
                        return result;
                    default:
                        return 4194304 /* ExportValue */;
                }
            }
        }
        function checkFunctionDeclaration(node) {
            checkSignatureDeclaration(node);
            var symbol = getSymbolOfNode(node);
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            var localSymbol = node.localSymbol || symbol;
            var firstDeclaration = getDeclarationOfKind(localSymbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }
            if (symbol.parent) {
                // run check once for the first declaration
                if (getDeclarationOfKind(symbol, node.kind) === node) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
            checkSourceElement(node.body);
            if (node.type && !isAccessor(node.kind)) {
                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
            }
            // If there is no body and no explicit return type, then report an error.
            if (fullTypeCheck && compilerOptions.noImplicitAny && !node.body && !node.type) {
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (!isPrivateWithinAmbient(node)) {
                    var typeName = typeToString(anyType);
                    if (node.name) {
                        error(node, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.declarationNameToString(node.name), typeName);
                    }
                    else {
                        error(node, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
            }
        }
        function checkBlock(node) {
            ts.forEach(node.statements, checkSourceElement);
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (!ts.hasRestParameters(node) || ts.isInAmbientContext(node) || !node.body) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && p.name.text === argumentsSymbol.name) {
                    error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        function checkCollisionWithIndexVariableInGeneratedCode(node, name) {
            if (!(name && name.text === "_i")) {
                return;
            }
            if (node.kind === 123 /* Parameter */) {
                // report error if parameter has name '_i' when:
                // - function has implementation (not a signature)
                // - function has rest parameters
                // - context is not ambient (otherwise no codegen impact)
                if (node.parent.body && ts.hasRestParameters(node.parent) && !ts.isInAmbientContext(node)) {
                    error(node, ts.Diagnostics.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter);
                }
                return;
            }
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol === unknownSymbol) {
                return;
            }
            // we would like to discover cases like one below:
            //
            // var _i = "!";
            // function foo(...a) {
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            // 
            // at runtime '_i' referenced in getter will be resolved to the generated index variable '_i' used to initialize rest parameters.
            // legitimate case: when '_i' is defined inside the function declaration with rest parameters.
            // 
            // function foo(...a) {
            //    var _i = "!";
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            ////  if resolved symbol for node has more than one declaration - this is definitely an error
            ////  (there is nothing value-like in the language that can be nested in function and consists of multiple declarations)
            //if (symbol.declarations.length > 1) {
            //    error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
            //    return;
            //}
            // short gist of the check:
            // - otherwise
            // - walk to the top of the tree starting from the 'node'
            // - at every step check if 'current' node contains any declaration of original node
            //   yes - return
            //   no - check if current declaration is function with rest parameters
            //        yes - report error since '_i' from this function will shadow '_i' defined in the outer scope
            //        no - go up to the next level
            var current = node;
            while (current) {
                var definedOnCurrentLevel = ts.forEach(symbol.declarations, function (d) { return d.parent === current ? d : undefined; });
                if (definedOnCurrentLevel) {
                    return;
                }
                switch (current.kind) {
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                    case 125 /* Method */:
                    case 150 /* ArrowFunction */:
                    case 126 /* Constructor */:
                        if (ts.hasRestParameters(current)) {
                            error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
                            return;
                        }
                        break;
                }
                current = current.parent;
            }
        }
        // TODO(jfreeman): Decide what to do for computed properties
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if (!(identifier && identifier.text === name)) {
                return false;
            }
            if (node.kind === 124 /* Property */ || node.kind === 125 /* Method */ || node.kind === 127 /* GetAccessor */ || node.kind === 128 /* SetAccessor */) {
                // it is ok to have member named '_super' or '_this' - member access is always qualified
                return false;
            }
            if (ts.isInAmbientContext(node)) {
                // ambient context - no codegen impact
                return false;
            }
            if (node.kind === 123 /* Parameter */ && !node.parent.body) {
                // just an overload - no codegen impact
                return false;
            }
            return true;
        }
        // TODO(jfreeman): Decide what to do for computed properties
        function checkCollisionWithCapturedThisVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_this")) {
                return;
            }
            potentialThisCollisions.push(node);
        }
        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        function checkIfThisIsCapturedInEnclosingScope(node) {
            var current = node;
            while (current) {
                if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
                    var isDeclaration = node.kind !== 63 /* Identifier */;
                    if (isDeclaration) {
                        error(node.name, ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return;
                }
                current = current.parent;
            }
        }
        function checkCollisionWithCapturedSuperVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_super")) {
                return;
            }
            // bubble up and find containing type
            var enclosingClass = ts.getAncestor(node, 184 /* ClassDeclaration */);
            // if containing type was not found or it is ambient - exit (no codegen)
            if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {
                return;
            }
            if (enclosingClass.baseType) {
                var isDeclaration = node.kind !== 63 /* Identifier */;
                if (isDeclaration) {
                    error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
                }
            }
        }
        // TODO(jfreeman): Decide what to do for computed properties
        function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (node.kind === 188 /* ModuleDeclaration */ && ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = node.kind === 181 /* VariableDeclaration */ ? node.parent.parent : node.parent;
            if (parent.kind === 193 /* SourceFile */ && ts.isExternalModule(parent)) {
                // If the declaration happens to be in external module, report error that require and exports are reserved keywords
                error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function checkCollisionWithConstDeclarations(node) {
            // Variable declarations are hoisted to the top of their function scope. They can shadow
            // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
            // by the binder as the declaration scope is different.
            // A non-initialized declaration is a no-op as the block declaration will resolve before the var
            // declaration. the problem is if the declaration has an initializer. this will act as a write to the
            // block declared value. this is fine for let, but not const.
            //
            // Only consider declarations with initializers, uninitialized var declarations will not 
            // step on a const variable.
            // Do not consider let and const declarations, as duplicate block-scoped declarations 
            // are handled by the binder.
            // We are only looking for var declarations that step on const declarations from a 
            // different scope. e.g.:
            //      var x = 0;
            //      {
            //          const x = 0;
            //          var x = 0;
            //      }
            if (node.initializer && (node.flags & 6144 /* BlockScoped */) === 0) {
                var symbol = getSymbolOfNode(node);
                if (symbol.flags & 1 /* FunctionScopedVariable */) {
                    var localDeclarationSymbol = resolveName(node, node.name.text, 3 /* Variable */, undefined, undefined);
                    if (localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & 2 /* BlockScopedVariable */) {
                        if (getDeclarationFlagsFromSymbol(localDeclarationSymbol) & 4096 /* Const */) {
                            error(node, ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0, symbolToString(localDeclarationSymbol));
                        }
                    }
                }
            }
        }
        function checkVariableDeclaration(node) {
            checkSourceElement(node.type);
            checkExportsOnMergedDeclarations(node);
            if (fullTypeCheck) {
                var symbol = getSymbolOfNode(node);
                var typeOfValueDeclaration = getTypeOfVariableOrParameterOrProperty(symbol);
                var type;
                var useTypeFromValueDeclaration = node === symbol.valueDeclaration;
                if (useTypeFromValueDeclaration) {
                    type = typeOfValueDeclaration;
                }
                else {
                    type = getTypeOfVariableOrPropertyDeclaration(node);
                }
                if (node.initializer) {
                    if (!(getNodeLinks(node.initializer).flags & 1 /* TypeChecked */)) {
                        // Use default messages
                        checkTypeAssignableTo(checkAndMarkExpression(node.initializer), type, node, undefined);
                    }
                    //TODO(jfreeman): Check that it is not a computed property
                    checkCollisionWithConstDeclarations(node);
                }
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                if (!useTypeFromValueDeclaration) {
                    // TypeScript 1.0 spec (April 2014): 5.1
                    // Multiple declarations for the same variable name in the same declaration space are permitted,
                    // provided that each declaration associates the same type with the variable.
                    if (typeOfValueDeclaration !== unknownType && type !== unknownType && !isTypeIdenticalTo(typeOfValueDeclaration, type)) {
                        error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(node.name), typeToString(typeOfValueDeclaration), typeToString(type));
                    }
                }
            }
        }
        function checkVariableStatement(node) {
            ts.forEach(node.declarations, checkVariableDeclaration);
        }
        function checkExpressionStatement(node) {
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.thenStatement);
            checkSourceElement(node.elseStatement);
        }
        function checkDoStatement(node) {
            checkSourceElement(node.statement);
            checkExpression(node.expression);
        }
        function checkWhileStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkForStatement(node) {
            if (node.declarations)
                ts.forEach(node.declarations, checkVariableDeclaration);
            if (node.initializer)
                checkExpression(node.initializer);
            if (node.condition)
                checkExpression(node.condition);
            if (node.iterator)
                checkExpression(node.iterator);
            checkSourceElement(node.statement);
        }
        function checkForInStatement(node) {
            // TypeScript 1.0 spec  (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (var VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.                        
            if (node.declaration) {
                checkVariableDeclaration(node.declaration);
                if (node.declaration.type) {
                    error(node.declaration, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation);
                }
            }
            // In a 'for-in' statement of the form
            // for (Var in Expr) Statement
            //   Var must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.variable) {
                var exprType = checkExpression(node.variable);
                if (exprType !== anyType && exprType !== stringType) {
                    error(node.variable, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    // run check only former check succeeded to avoid cascading errors
                    checkReferenceExpression(node.variable, ts.Diagnostics.Invalid_left_hand_side_in_for_in_statement, ts.Diagnostics.Left_hand_side_of_assignment_expression_cannot_be_a_constant);
                }
            }
            var exprType = checkExpression(node.expression);
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (!isStructuredType(exprType) && exprType !== unknownType) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            checkSourceElement(node.statement);
        }
        function checkBreakOrContinueStatement(node) {
            // TODO: Check that target label is valid
        }
        function checkReturnStatement(node) {
            if (node.expression && !(getNodeLinks(node.expression).flags & 1 /* TypeChecked */)) {
                var func = ts.getContainingFunction(node);
                if (func) {
                    if (func.kind === 128 /* SetAccessor */) {
                        if (node.expression) {
                            error(node.expression, ts.Diagnostics.Setters_cannot_return_a_value);
                        }
                    }
                    else {
                        var returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                        // do assignability check only if we short circuited in determining return type
                        // - function has explicit type annotation
                        // - function is getter with no type annotation and setter parameter type is used
                        // - function is a constructor (will be special cased below)
                        var checkAssignability = func.type || (func.kind === 127 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 128 /* SetAccessor */)));
                        if (checkAssignability) {
                            checkTypeAssignableTo(checkExpression(node.expression), returnType, node.expression, undefined);
                        }
                        else if (func.kind == 126 /* Constructor */) {
                            // constructor doesn't have explicit return type annotation and yet its return type is known - declaring type
                            // handle constructors and issue specialized error message for them.
                            if (!isTypeAssignableTo(checkExpression(node.expression), returnType)) {
                                error(node.expression, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                            }
                        }
                    }
                }
            }
        }
        function checkWithStatement(node) {
            checkExpression(node.expression);
            error(node.expression, ts.Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);
        }
        function checkSwitchStatement(node) {
            var expressionType = checkExpression(node.expression);
            ts.forEach(node.clauses, function (clause) {
                if (fullTypeCheck && clause.expression) {
                    // TypeScript 1.0 spec (April 2014):5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is assignable to or from the type of the 'switch' expression.
                    var caseType = checkExpression(clause.expression);
                    if (!isTypeAssignableTo(expressionType, caseType)) {
                        // check 'expressionType isAssignableTo caseType' failed, try the reversed check and report errors if it fails
                        checkTypeAssignableTo(caseType, expressionType, clause.expression, undefined);
                    }
                }
                checkBlock(clause);
            });
        }
        function checkLabeledStatement(node) {
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            checkExpression(node.expression);
        }
        function checkTryStatement(node) {
            checkBlock(node.tryBlock);
            if (node.catchBlock)
                checkBlock(node.catchBlock);
            if (node.finallyBlock)
                checkBlock(node.finallyBlock);
        }
        function checkIndexConstraints(type) {
            function checkIndexConstraintForProperty(prop, propertyType, indexDeclaration, indexType, indexKind) {
                if (!indexType) {
                    return;
                }
                // index is numeric and property name is not valid numeric literal
                if (indexKind === 1 /* Number */ && !isNumericName(prop.name)) {
                    return;
                }
                // perform property check if property or indexer is declared in 'type'
                // this allows to rule out cases when both property and indexer are inherited from the base class
                var errorNode;
                if (prop.parent === type.symbol) {
                    errorNode = prop.valueDeclaration;
                }
                else if (indexDeclaration) {
                    errorNode = indexDeclaration;
                }
                else if (type.flags & 2048 /* Interface */) {
                    // for interfaces property and indexer might be inherited from different bases
                    // check if any base class already has both property and indexer.
                    // check should be performed only if 'type' is the first type that brings property\indexer together
                    var someBaseClassHasBothPropertyAndIndexer = ts.forEach(type.baseTypes, function (base) { return getPropertyOfObjectType(base, prop.name) && getIndexTypeOfType(base, indexKind); });
                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : type.symbol.declarations[0];
                }
                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
                    var errorMessage = indexKind === 0 /* String */ ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2 : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));
                }
            }
            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1 /* Number */);
            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0 /* String */);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType || numberIndexType) {
                ts.forEach(getPropertiesOfObjectType(type), function (prop) {
                    var propType = getTypeOfSymbol(prop);
                    checkIndexConstraintForProperty(prop, propType, declaredStringIndexer, stringIndexType, 0 /* String */);
                    checkIndexConstraintForProperty(prop, propType, declaredNumberIndexer, numberIndexType, 1 /* Number */);
                });
            }
            var errorNode;
            if (stringIndexType && numberIndexType) {
                errorNode = declaredNumberIndexer || declaredStringIndexer;
                // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer
                if (!errorNode && (type.flags & 2048 /* Interface */)) {
                    var someBaseTypeHasBothIndexers = ts.forEach(type.baseTypes, function (base) { return getIndexTypeOfType(base, 0 /* String */) && getIndexTypeOfType(base, 1 /* Number */); });
                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
                }
            }
            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {
                error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));
            }
        }
        // TODO(jfreeman): Decide what to do for computed properties
        function checkTypeNameIsReserved(name, message) {
            switch (name.text) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "void":
                    error(name, message, name.text);
            }
        }
        // Check each type parameter and check that list has no duplicate type parameter declarations
        function checkTypeParameters(typeParameterDeclarations) {
            if (typeParameterDeclarations) {
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    if (fullTypeCheck) {
                        for (var j = 0; j < i; j++) {
                            if (typeParameterDeclarations[j].symbol === node.symbol) {
                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));
                            }
                        }
                    }
                }
            }
        }
        function checkClassDeclaration(node) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);
            checkTypeParameters(node.typeParameters);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var staticType = getTypeOfSymbol(symbol);
            if (node.baseType) {
                emitExtends = emitExtends || !ts.isInAmbientContext(node);
                checkTypeReference(node.baseType);
            }
            if (type.baseTypes.length) {
                if (fullTypeCheck) {
                    var baseType = type.baseTypes[0];
                    checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    var staticBaseType = getTypeOfSymbol(baseType.symbol);
                    checkTypeAssignableTo(staticType, getTypeWithoutConstructors(staticBaseType), node.name, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    if (baseType.symbol !== resolveEntityName(node, node.baseType.typeName, 107455 /* Value */)) {
                        error(node.baseType, ts.Diagnostics.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0, typeToString(baseType));
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType);
                }
                // Check that base type can be evaluated as expression
                checkExpression(node.baseType.typeName);
            }
            if (node.implementedTypes) {
                ts.forEach(node.implementedTypes, function (typeRefNode) {
                    checkTypeReference(typeRefNode);
                    if (fullTypeCheck) {
                        var t = getTypeFromTypeReferenceNode(typeRefNode);
                        if (t !== unknownType) {
                            var declaredType = (t.flags & 4096 /* Reference */) ? t.target : t;
                            if (declaredType.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                checkTypeAssignableTo(type, t, node.name, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);
                            }
                            else {
                                error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);
                            }
                        }
                    }
                });
            }
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function getTargetSymbol(s) {
            // if symbol is instantiated its flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return s.flags & 67108864 /* Instantiated */ ? getSymbolLinks(s).target : s;
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static) 
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by 
            // derived class instance member variables and accessors, but not by other kinds of members.
            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = getPropertiesOfObjectType(baseType);
            for (var i = 0, len = baseProperties.length; i < len; ++i) {
                var base = getTargetSymbol(baseProperties[i]);
                if (base.flags & 536870912 /* Prototype */) {
                    continue;
                }
                var derived = getTargetSymbol(getPropertyOfObjectType(type, base.name));
                if (derived) {
                    var baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);
                    var derivedDeclarationFlags = getDeclarationFlagsFromSymbol(derived);
                    if ((baseDeclarationFlags & 32 /* Private */) || (derivedDeclarationFlags & 32 /* Private */)) {
                        continue;
                    }
                    if ((baseDeclarationFlags & 128 /* Static */) !== (derivedDeclarationFlags & 128 /* Static */)) {
                        continue;
                    }
                    if ((base.flags & derived.flags & 8192 /* Method */) || ((base.flags & 98308 /* PropertyOrAccessor */) && (derived.flags & 98308 /* PropertyOrAccessor */))) {
                        continue;
                    }
                    var errorMessage;
                    if (base.flags & 8192 /* Method */) {
                        if (derived.flags & 98304 /* Accessor */) {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                        }
                        else {
                            ts.Debug.assert((derived.flags & 4 /* Property */) !== 0);
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                        }
                    }
                    else if (base.flags & 4 /* Property */) {
                        ts.Debug.assert((derived.flags & 8192 /* Method */) !== 0);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    else {
                        ts.Debug.assert((base.flags & 98304 /* Accessor */) !== 0);
                        ts.Debug.assert((derived.flags & 8192 /* Method */) !== 0);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    error(derived.valueDeclaration.name, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                }
            }
        }
        function isAccessor(kind) {
            return kind === 127 /* GetAccessor */ || kind === 128 /* SetAccessor */;
        }
        function areTypeParametersIdentical(list1, list2) {
            if (!list1 && !list2) {
                return true;
            }
            if (!list1 || !list2 || list1.length !== list2.length) {
                return false;
            }
            for (var i = 0, len = list1.length; i < len; i++) {
                var tp1 = list1[i];
                var tp2 = list2[i];
                if (tp1.name.text !== tp2.name.text) {
                    return false;
                }
                if (!tp1.constraint && !tp2.constraint) {
                    continue;
                }
                if (!tp1.constraint || !tp2.constraint) {
                    return false;
                }
                if (!isTypeIdenticalTo(getTypeFromTypeNode(tp1.constraint), getTypeFromTypeNode(tp2.constraint))) {
                    return false;
                }
            }
            return true;
        }
        function checkInheritedPropertiesAreIdentical(type, typeNode) {
            if (!type.baseTypes.length || type.baseTypes.length === 1) {
                return true;
            }
            var seen = {};
            ts.forEach(type.declaredProperties, function (p) {
                seen[p.name] = { prop: p, containingType: type };
            });
            var ok = true;
            for (var i = 0, len = type.baseTypes.length; i < len; ++i) {
                var base = type.baseTypes[i];
                var properties = getPropertiesOfObjectType(base);
                for (var j = 0, proplen = properties.length; j < proplen; ++j) {
                    var prop = properties[j];
                    if (!ts.hasProperty(seen, prop.name)) {
                        seen[prop.name] = { prop: prop, containingType: base };
                    }
                    else {
                        var existing = seen[prop.name];
                        var isInheritedProperty = existing.containingType !== type;
                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                            ok = false;
                            var typeName1 = typeToString(existing.containingType);
                            var typeName2 = typeToString(base);
                            var errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Named_properties_0_of_types_1_and_2_are_not_identical, prop.name, typeName1, typeName2);
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                            addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo, program.getCompilerHost().getNewLine()));
                        }
                    }
                }
            }
            return ok;
        }
        function checkInterfaceDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            if (fullTypeCheck) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                var firstInterfaceDecl = getDeclarationOfKind(symbol, 185 /* InterfaceDeclaration */);
                if (symbol.declarations.length > 1) {
                    if (node !== firstInterfaceDecl && !areTypeParametersIdentical(firstInterfaceDecl.typeParameters, node.typeParameters)) {
                        error(node.name, ts.Diagnostics.All_declarations_of_an_interface_must_have_identical_type_parameters);
                    }
                }
                // Only check this symbol once
                if (node === firstInterfaceDecl) {
                    var type = getDeclaredTypeOfSymbol(symbol);
                    // run subsequent checks only if first set succeeded
                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                        ts.forEach(type.baseTypes, function (baseType) {
                            checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                        });
                        checkIndexConstraints(type);
                    }
                }
            }
            ts.forEach(node.baseTypes, checkTypeReference);
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function checkTypeAliasDeclaration(node) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);
            checkSourceElement(node.type);
        }
        function computeEnumMemberValues(node) {
            var nodeLinks = getNodeLinks(node);
            if (!(nodeLinks.flags & 128 /* EnumValuesComputed */)) {
                var enumSymbol = getSymbolOfNode(node);
                var enumType = getDeclaredTypeOfSymbol(enumSymbol);
                var autoValue = 0;
                var ambient = ts.isInAmbientContext(node);
                var enumIsConst = ts.isConstEnumDeclaration(node);
                ts.forEach(node.members, function (member) {
                    // TODO(jfreeman): Check that it is not a computed name
                    if (isNumericName(member.name.text)) {
                        error(member.name, ts.Diagnostics.An_enum_member_cannot_have_a_numeric_name);
                    }
                    var initializer = member.initializer;
                    if (initializer) {
                        autoValue = getConstantValueForEnumMemberInitializer(initializer, enumIsConst);
                        if (autoValue === undefined) {
                            if (enumIsConst) {
                                error(initializer, ts.Diagnostics.In_const_enum_declarations_member_initializer_must_be_constant_expression);
                            }
                            else if (!ambient) {
                                // Only here do we need to check that the initializer is assignable to the enum type.
                                // If it is a constant value (not undefined), it is syntactically constrained to be a number. 
                                // Also, we do not need to check this for ambients because there is already
                                // a syntax error if it is not a constant.
                                checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, undefined);
                            }
                        }
                        else if (enumIsConst) {
                            if (isNaN(autoValue)) {
                                error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN);
                            }
                            else if (!isFinite(autoValue)) {
                                error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
                            }
                        }
                    }
                    else if (ambient && !enumIsConst) {
                        autoValue = undefined;
                    }
                    if (autoValue !== undefined) {
                        getNodeLinks(member).enumMemberValue = autoValue++;
                    }
                });
                nodeLinks.flags |= 128 /* EnumValuesComputed */;
            }
            function getConstantValueForEnumMemberInitializer(initializer, enumIsConst) {
                return evalConstant(initializer);
                function evalConstant(e) {
                    switch (e.kind) {
                        case 151 /* PrefixOperator */:
                            var value = evalConstant(e.operand);
                            if (value === undefined) {
                                return undefined;
                            }
                            switch (e.operator) {
                                case 32 /* PlusToken */: return value;
                                case 33 /* MinusToken */: return -value;
                                case 46 /* TildeToken */: return enumIsConst ? ~value : undefined;
                            }
                            return undefined;
                        case 153 /* BinaryExpression */:
                            if (!enumIsConst) {
                                return undefined;
                            }
                            var left = evalConstant(e.left);
                            if (left === undefined) {
                                return undefined;
                            }
                            var right = evalConstant(e.right);
                            if (right === undefined) {
                                return undefined;
                            }
                            switch (e.operator) {
                                case 43 /* BarToken */: return left | right;
                                case 42 /* AmpersandToken */: return left & right;
                                case 40 /* GreaterThanGreaterThanToken */: return left >> right;
                                case 41 /* GreaterThanGreaterThanGreaterThanToken */: return left >>> right;
                                case 39 /* LessThanLessThanToken */: return left << right;
                                case 44 /* CaretToken */: return left ^ right;
                                case 34 /* AsteriskToken */: return left * right;
                                case 35 /* SlashToken */: return left / right;
                                case 32 /* PlusToken */: return left + right;
                                case 33 /* MinusToken */: return left - right;
                                case 36 /* PercentToken */: return left % right;
                            }
                            return undefined;
                        case 6 /* NumericLiteral */:
                            return +e.text;
                        case 148 /* ParenExpression */:
                            return enumIsConst ? evalConstant(e.expression) : undefined;
                        case 63 /* Identifier */:
                        case 143 /* IndexedAccess */:
                        case 142 /* PropertyAccess */:
                            if (!enumIsConst) {
                                return undefined;
                            }
                            var member = initializer.parent;
                            var currentType = getTypeOfSymbol(getSymbolOfNode(member.parent));
                            var enumType;
                            var propertyName;
                            if (e.kind === 63 /* Identifier */) {
                                // unqualified names can refer to member that reside in different declaration of the enum so just doing name resolution won't work.
                                // instead pick current enum type and later try to fetch member from the type
                                enumType = currentType;
                                propertyName = e.text;
                            }
                            else {
                                if (e.kind === 143 /* IndexedAccess */) {
                                    if (e.index.kind !== 7 /* StringLiteral */) {
                                        return undefined;
                                    }
                                    var enumType = getTypeOfNode(e.object);
                                    propertyName = e.index.text;
                                }
                                else {
                                    var enumType = getTypeOfNode(e.left);
                                    propertyName = e.right.text;
                                }
                                if (enumType !== currentType) {
                                    return undefined;
                                }
                            }
                            if (propertyName === undefined) {
                                return undefined;
                            }
                            var property = getPropertyOfObjectType(enumType, propertyName);
                            if (!property || !(property.flags & 8 /* EnumMember */)) {
                                return undefined;
                            }
                            var propertyDecl = property.valueDeclaration;
                            // self references are illegal
                            if (member === propertyDecl) {
                                return undefined;
                            }
                            // illegal case: forward reference
                            if (!isDefinedBefore(propertyDecl, member)) {
                                return undefined;
                            }
                            return getNodeLinks(propertyDecl).enumMemberValue;
                    }
                }
            }
        }
        function checkEnumDeclaration(node) {
            if (!fullTypeCheck) {
                return;
            }
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkExportsOnMergedDeclarations(node);
            computeEnumMemberValues(node);
            // Spec 2014 - Section 9.3:
            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
            // for the first member.
            //
            // Only perform this check once per symbol
            var enumSymbol = getSymbolOfNode(node);
            var firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
            if (node === firstDeclaration) {
                if (enumSymbol.declarations.length > 1) {
                    var enumIsConst = ts.isConstEnumDeclaration(node);
                    // check that const is placed\omitted on all enum declarations
                    ts.forEach(enumSymbol.declarations, function (decl) {
                        if (ts.isConstEnumDeclaration(decl) !== enumIsConst) {
                            error(decl.name, ts.Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                        }
                    });
                }
                var seenEnumMissingInitialInitializer = false;
                ts.forEach(enumSymbol.declarations, function (declaration) {
                    // return true if we hit a violation of the rule, false otherwise
                    if (declaration.kind !== 187 /* EnumDeclaration */) {
                        return false;
                    }
                    var enumDeclaration = declaration;
                    if (!enumDeclaration.members.length) {
                        return false;
                    }
                    var firstEnumMember = enumDeclaration.members[0];
                    if (!firstEnumMember.initializer) {
                        if (seenEnumMissingInitialInitializer) {
                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else {
                            seenEnumMissingInitialInitializer = true;
                        }
                    }
                });
            }
        }
        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
            var declarations = symbol.declarations;
            for (var i = 0; i < declarations.length; i++) {
                var declaration = declarations[i];
                if ((declaration.kind === 184 /* ClassDeclaration */ || (declaration.kind === 182 /* FunctionDeclaration */ && declaration.body)) && !ts.isInAmbientContext(declaration)) {
                    return declaration;
                }
            }
            return undefined;
        }
        function checkModuleDeclaration(node) {
            if (fullTypeCheck) {
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                if (symbol.flags & 512 /* ValueModule */ && symbol.declarations.length > 1 && !ts.isInAmbientContext(node)) {
                    var classOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (classOrFunc) {
                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(classOrFunc)) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < classOrFunc.pos) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                }
                if (node.name.kind === 7 /* StringLiteral */) {
                    if (!isGlobalSourceFile(node.parent)) {
                        error(node.name, ts.Diagnostics.Ambient_external_modules_cannot_be_nested_in_other_modules);
                    }
                    if (isExternalModuleNameRelative(node.name.text)) {
                        error(node.name, ts.Diagnostics.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                    }
                }
            }
            checkSourceElement(node.body);
        }
        function getFirstIdentifier(node) {
            while (node.kind === 121 /* QualifiedName */) {
                node = node.left;
            }
            return node;
        }
        function checkImportDeclaration(node) {
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            var symbol = getSymbolOfNode(node);
            var target;
            if (node.entityName) {
                target = resolveImport(symbol);
                // Import declaration for an internal module
                if (target !== unknownSymbol) {
                    if (target.flags & 107455 /* Value */) {
                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name and
                        // ensure it can be evaluated as an expression
                        var moduleName = getFirstIdentifier(node.entityName);
                        if (resolveEntityName(node, moduleName, 107455 /* Value */ | 1536 /* Namespace */).flags & 1536 /* Namespace */) {
                            checkExpression(node.entityName);
                        }
                        else {
                            error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.declarationNameToString(moduleName));
                        }
                    }
                    if (target.flags & 3152352 /* Type */) {
                        checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                    }
                }
            }
            else {
                // Import declaration for an external module
                if (node.parent.kind === 193 /* SourceFile */) {
                    target = resolveImport(symbol);
                }
                else if (node.parent.kind === 189 /* ModuleBlock */ && node.parent.parent.name.kind === 7 /* StringLiteral */) {
                    // TypeScript 1.0 spec (April 2013): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference 
                    // other external modules only through top - level external module names.
                    // Relative external module names are not permitted.
                    if (isExternalModuleNameRelative(node.externalModuleName.text)) {
                        error(node, ts.Diagnostics.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name);
                        target = unknownSymbol;
                    }
                    else {
                        target = resolveImport(symbol);
                    }
                }
                else {
                    // Parent is an internal module (syntax error is already reported)
                    target = unknownSymbol;
                }
            }
            if (target !== unknownSymbol) {
                var excludedMeanings = (symbol.flags & 107455 /* Value */ ? 107455 /* Value */ : 0) | (symbol.flags & 3152352 /* Type */ ? 3152352 /* Type */ : 0) | (symbol.flags & 1536 /* Namespace */ ? 1536 /* Namespace */ : 0);
                if (target.flags & excludedMeanings) {
                    error(node, ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0, symbolToString(symbol));
                }
            }
        }
        function checkExportAssignment(node) {
            var container = node.parent;
            if (container.kind !== 193 /* SourceFile */) {
                // In a module, the immediate parent will be a block, so climb up one more parent
                container = container.parent;
            }
            checkTypeOfExportAssignmentSymbol(getSymbolOfNode(container));
        }
        function checkSourceElement(node) {
            if (!node)
                return;
            switch (node.kind) {
                case 122 /* TypeParameter */:
                    return checkTypeParameter(node);
                case 123 /* Parameter */:
                    return checkParameter(node);
                case 124 /* Property */:
                    return checkPropertyDeclaration(node);
                case 129 /* CallSignature */:
                case 130 /* ConstructSignature */:
                case 131 /* IndexSignature */:
                    return checkSignatureDeclaration(node);
                case 125 /* Method */:
                    return checkMethodDeclaration(node);
                case 126 /* Constructor */:
                    return checkConstructorDeclaration(node);
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                    return checkAccessorDeclaration(node);
                case 132 /* TypeReference */:
                    return checkTypeReference(node);
                case 133 /* TypeQuery */:
                    return checkTypeQuery(node);
                case 134 /* TypeLiteral */:
                    return checkTypeLiteral(node);
                case 135 /* ArrayType */:
                    return checkArrayType(node);
                case 136 /* TupleType */:
                    return checkTupleType(node);
                case 137 /* UnionType */:
                    return checkUnionType(node);
                case 138 /* ParenType */:
                    return checkSourceElement(node.type);
                case 182 /* FunctionDeclaration */:
                    return checkFunctionDeclaration(node);
                case 158 /* Block */:
                    return checkBlock(node);
                case 183 /* FunctionBlock */:
                case 189 /* ModuleBlock */:
                    return checkBody(node);
                case 159 /* VariableStatement */:
                    return checkVariableStatement(node);
                case 161 /* ExpressionStatement */:
                    return checkExpressionStatement(node);
                case 162 /* IfStatement */:
                    return checkIfStatement(node);
                case 163 /* DoStatement */:
                    return checkDoStatement(node);
                case 164 /* WhileStatement */:
                    return checkWhileStatement(node);
                case 165 /* ForStatement */:
                    return checkForStatement(node);
                case 166 /* ForInStatement */:
                    return checkForInStatement(node);
                case 167 /* ContinueStatement */:
                case 168 /* BreakStatement */:
                    return checkBreakOrContinueStatement(node);
                case 169 /* ReturnStatement */:
                    return checkReturnStatement(node);
                case 170 /* WithStatement */:
                    return checkWithStatement(node);
                case 171 /* SwitchStatement */:
                    return checkSwitchStatement(node);
                case 174 /* LabeledStatement */:
                    return checkLabeledStatement(node);
                case 175 /* ThrowStatement */:
                    return checkThrowStatement(node);
                case 176 /* TryStatement */:
                    return checkTryStatement(node);
                case 181 /* VariableDeclaration */:
                    return ts.Debug.fail("Checker encountered variable declaration");
                case 184 /* ClassDeclaration */:
                    return checkClassDeclaration(node);
                case 185 /* InterfaceDeclaration */:
                    return checkInterfaceDeclaration(node);
                case 186 /* TypeAliasDeclaration */:
                    return checkTypeAliasDeclaration(node);
                case 187 /* EnumDeclaration */:
                    return checkEnumDeclaration(node);
                case 188 /* ModuleDeclaration */:
                    return checkModuleDeclaration(node);
                case 190 /* ImportDeclaration */:
                    return checkImportDeclaration(node);
                case 191 /* ExportAssignment */:
                    return checkExportAssignment(node);
            }
        }
        // Function expression bodies are checked after all statements in the enclosing body. This is to ensure
        // constructs like the following are permitted:
        //     var foo = function () {
        //        var s = foo();
        //        return "hello";
        //     }
        // Here, performing a full type check of the body of the function expression whilst in the process of
        // determining the type of foo would cause foo to be given type any because of the recursive reference.
        // Delaying the type check of the body ensures foo has been assigned a type.
        function checkFunctionExpressionBodies(node) {
            switch (node.kind) {
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                    ts.forEach(node.parameters, checkFunctionExpressionBodies);
                    checkFunctionExpressionBody(node);
                    break;
                case 125 /* Method */:
                case 126 /* Constructor */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 182 /* FunctionDeclaration */:
                    ts.forEach(node.parameters, checkFunctionExpressionBodies);
                    break;
                case 170 /* WithStatement */:
                    checkFunctionExpressionBodies(node.expression);
                    break;
                case 123 /* Parameter */:
                case 124 /* Property */:
                case 139 /* ArrayLiteral */:
                case 140 /* ObjectLiteral */:
                case 141 /* PropertyAssignment */:
                case 142 /* PropertyAccess */:
                case 143 /* IndexedAccess */:
                case 144 /* CallExpression */:
                case 145 /* NewExpression */:
                case 146 /* TaggedTemplateExpression */:
                case 147 /* TypeAssertion */:
                case 148 /* ParenExpression */:
                case 151 /* PrefixOperator */:
                case 152 /* PostfixOperator */:
                case 153 /* BinaryExpression */:
                case 154 /* ConditionalExpression */:
                case 158 /* Block */:
                case 183 /* FunctionBlock */:
                case 189 /* ModuleBlock */:
                case 159 /* VariableStatement */:
                case 161 /* ExpressionStatement */:
                case 162 /* IfStatement */:
                case 163 /* DoStatement */:
                case 164 /* WhileStatement */:
                case 165 /* ForStatement */:
                case 166 /* ForInStatement */:
                case 167 /* ContinueStatement */:
                case 168 /* BreakStatement */:
                case 169 /* ReturnStatement */:
                case 171 /* SwitchStatement */:
                case 172 /* CaseClause */:
                case 173 /* DefaultClause */:
                case 174 /* LabeledStatement */:
                case 175 /* ThrowStatement */:
                case 176 /* TryStatement */:
                case 177 /* TryBlock */:
                case 178 /* CatchBlock */:
                case 179 /* FinallyBlock */:
                case 181 /* VariableDeclaration */:
                case 184 /* ClassDeclaration */:
                case 187 /* EnumDeclaration */:
                case 192 /* EnumMember */:
                case 193 /* SourceFile */:
                    ts.forEachChild(node, checkFunctionExpressionBodies);
                    break;
            }
        }
        function checkBody(node) {
            checkBlock(node);
            checkFunctionExpressionBodies(node);
        }
        // Fully type check a source file and collect the relevant diagnostics.
        function checkSourceFile(node) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1 /* TypeChecked */)) {
                emitExtends = false;
                potentialThisCollisions.length = 0;
                checkBody(node);
                if (ts.isExternalModule(node)) {
                    var symbol = getExportAssignmentSymbol(node.symbol);
                    if (symbol && symbol.flags & 33554432 /* Import */) {
                        // Mark the import as referenced so that we emit it in the final .js file.
                        getSymbolLinks(symbol).referenced = true;
                    }
                }
                if (potentialThisCollisions.length) {
                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                    potentialThisCollisions.length = 0;
                }
                if (emitExtends)
                    links.flags |= 8 /* EmitExtends */;
                links.flags |= 1 /* TypeChecked */;
            }
        }
        function checkProgram() {
            ts.forEach(program.getSourceFiles(), checkSourceFile);
        }
        function getSortedDiagnostics() {
            ts.Debug.assert(fullTypeCheck, "diagnostics are available only in the full typecheck mode");
            if (diagnosticsModified) {
                diagnostics.sort(ts.compareDiagnostics);
                diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
                diagnosticsModified = false;
            }
            return diagnostics;
        }
        function getDiagnostics(sourceFile) {
            if (sourceFile) {
                checkSourceFile(sourceFile);
                return ts.filter(getSortedDiagnostics(), function (d) { return d.file === sourceFile; });
            }
            checkProgram();
            return getSortedDiagnostics();
        }
        function getGlobalDiagnostics() {
            return ts.filter(getSortedDiagnostics(), function (d) { return !d.file; });
        }
        // Language service support
        function getNodeAtPosition(sourceFile, position) {
            function findChildAtPosition(parent) {
                var child = ts.forEachChild(parent, function (node) {
                    if (position >= node.pos && position <= node.end && position >= ts.getTokenPosOfNode(node)) {
                        return findChildAtPosition(node);
                    }
                });
                return child || parent;
            }
            if (position < sourceFile.pos)
                position = sourceFile.pos;
            if (position > sourceFile.end)
                position = sourceFile.end;
            return findChildAtPosition(sourceFile);
        }
        function isInsideWithStatementBody(node) {
            if (node) {
                while (node.parent) {
                    if (node.parent.kind === 170 /* WithStatement */ && node.parent.statement === node) {
                        return true;
                    }
                    node = node.parent;
                }
            }
            return false;
        }
        function getSymbolsInScope(location, meaning) {
            var symbols = {};
            var memberFlags = 0;
            function copySymbol(symbol, meaning) {
                if (symbol.flags & meaning) {
                    var id = symbol.name;
                    if (!isReservedMemberName(id) && !ts.hasProperty(symbols, id)) {
                        symbols[id] = symbol;
                    }
                }
            }
            function copySymbols(source, meaning) {
                if (meaning) {
                    for (var id in source) {
                        if (ts.hasProperty(source, id)) {
                            copySymbol(source[id], meaning);
                        }
                    }
                }
            }
            if (isInsideWithStatementBody(location)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return [];
            }
            while (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }
                switch (location.kind) {
                    case 193 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 188 /* ModuleDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 35653619 /* ModuleMember */);
                        break;
                    case 187 /* EnumDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 8 /* EnumMember */);
                        break;
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                        if (!(memberFlags & 128 /* Static */)) {
                            copySymbols(getSymbolOfNode(location).members, meaning & 3152352 /* Type */);
                        }
                        break;
                    case 149 /* FunctionExpression */:
                        if (location.name) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                    case 178 /* CatchBlock */:
                        if (location.variable.text) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                }
                memberFlags = location.flags;
                location = location.parent;
            }
            copySymbols(globals, meaning);
            return ts.mapToArray(symbols);
        }
        function isTypeDeclarationName(name) {
            return name.kind == 63 /* Identifier */ && isTypeDeclaration(name.parent) && name.parent.name === name;
        }
        function isTypeDeclaration(node) {
            switch (node.kind) {
                case 122 /* TypeParameter */:
                case 184 /* ClassDeclaration */:
                case 185 /* InterfaceDeclaration */:
                case 186 /* TypeAliasDeclaration */:
                case 187 /* EnumDeclaration */:
                    return true;
            }
        }
        // True if the given identifier is part of a type reference
        function isTypeReferenceIdentifier(entityName) {
            var node = entityName;
            while (node.parent && node.parent.kind === 121 /* QualifiedName */)
                node = node.parent;
            return node.parent && node.parent.kind === 132 /* TypeReference */;
        }
        function isTypeNode(node) {
            if (132 /* FirstTypeNode */ <= node.kind && node.kind <= 138 /* LastTypeNode */) {
                return true;
            }
            switch (node.kind) {
                case 109 /* AnyKeyword */:
                case 116 /* NumberKeyword */:
                case 118 /* StringKeyword */:
                case 110 /* BooleanKeyword */:
                    return true;
                case 97 /* VoidKeyword */:
                    return node.parent.kind !== 151 /* PrefixOperator */;
                case 7 /* StringLiteral */:
                    // Specialized signatures can have string literals as their parameters' type names
                    return node.parent.kind === 123 /* Parameter */;
                case 63 /* Identifier */:
                    // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.
                    if (node.parent.kind === 121 /* QualifiedName */) {
                        node = node.parent;
                    }
                case 121 /* QualifiedName */:
                    // At this point, node is either a qualified name or an identifier
                    ts.Debug.assert(node.kind === 63 /* Identifier */ || node.kind === 121 /* QualifiedName */, "'node' was expected to be a qualified name or identifier in 'isTypeNode'.");
                    var parent = node.parent;
                    if (parent.kind === 133 /* TypeQuery */) {
                        return false;
                    }
                    // Do not recursively call isTypeNode on the parent. In the example:
                    //
                    //     var a: A.B.C;
                    //
                    // Calling isTypeNode would consider the qualified name A.B a type node. Only C or
                    // A.B.C is a type node.
                    if (132 /* FirstTypeNode */ <= parent.kind && parent.kind <= 138 /* LastTypeNode */) {
                        return true;
                    }
                    switch (parent.kind) {
                        case 122 /* TypeParameter */:
                            return node === parent.constraint;
                        case 124 /* Property */:
                        case 123 /* Parameter */:
                        case 181 /* VariableDeclaration */:
                            return node === parent.type;
                        case 182 /* FunctionDeclaration */:
                        case 149 /* FunctionExpression */:
                        case 150 /* ArrowFunction */:
                        case 126 /* Constructor */:
                        case 125 /* Method */:
                        case 127 /* GetAccessor */:
                        case 128 /* SetAccessor */:
                            return node === parent.type;
                        case 129 /* CallSignature */:
                        case 130 /* ConstructSignature */:
                        case 131 /* IndexSignature */:
                            return node === parent.type;
                        case 147 /* TypeAssertion */:
                            return node === parent.type;
                        case 144 /* CallExpression */:
                        case 145 /* NewExpression */:
                            return parent.typeArguments && parent.typeArguments.indexOf(node) >= 0;
                        case 146 /* TaggedTemplateExpression */:
                            // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.
                            return false;
                    }
            }
            return false;
        }
        function isInRightSideOfImportOrExportAssignment(node) {
            while (node.parent.kind === 121 /* QualifiedName */) {
                node = node.parent;
            }
            if (node.parent.kind === 190 /* ImportDeclaration */) {
                return node.parent.entityName === node;
            }
            if (node.parent.kind === 191 /* ExportAssignment */) {
                return node.parent.exportName === node;
            }
            return false;
        }
        function isRightSideOfQualifiedNameOrPropertyAccess(node) {
            return (node.parent.kind === 121 /* QualifiedName */ || node.parent.kind === 142 /* PropertyAccess */) && node.parent.right === node;
        }
        function getSymbolOfEntityName(entityName) {
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(entityName)) {
                return getSymbolOfNode(entityName.parent);
            }
            if (entityName.parent.kind === 191 /* ExportAssignment */) {
                return resolveEntityName(entityName.parent.parent, entityName, 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */ | 33554432 /* Import */);
            }
            if (isInRightSideOfImportOrExportAssignment(entityName)) {
                // Since we already checked for ExportAssignment, this really could only be an Import
                return getSymbolOfPartOfRightHandSideOfImport(entityName);
            }
            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (ts.isExpression(entityName)) {
                if (entityName.kind === 63 /* Identifier */) {
                    // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                    // return the alias symbol.
                    var meaning = 107455 /* Value */ | 33554432 /* Import */;
                    return resolveEntityName(entityName, entityName, meaning);
                }
                else if (entityName.kind === 121 /* QualifiedName */ || entityName.kind === 142 /* PropertyAccess */) {
                    var symbol = getNodeLinks(entityName).resolvedSymbol;
                    if (!symbol) {
                        checkPropertyAccess(entityName);
                    }
                    return getNodeLinks(entityName).resolvedSymbol;
                }
                else {
                    // Missing identifier
                    return;
                }
            }
            else if (isTypeReferenceIdentifier(entityName)) {
                var meaning = entityName.parent.kind === 132 /* TypeReference */ ? 3152352 /* Type */ : 1536 /* Namespace */;
                // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                // return the alias symbol.
                meaning |= 33554432 /* Import */;
                return resolveEntityName(entityName, entityName, meaning);
            }
            // Do we want to return undefined here?
            return undefined;
        }
        function getSymbolInfo(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                // This is a declaration, call getSymbolOfNode
                return getSymbolOfNode(node.parent);
            }
            if (node.kind === 63 /* Identifier */ && isInRightSideOfImportOrExportAssignment(node)) {
                return node.parent.kind === 191 /* ExportAssignment */ ? getSymbolOfEntityName(node) : getSymbolOfPartOfRightHandSideOfImport(node);
            }
            switch (node.kind) {
                case 63 /* Identifier */:
                case 142 /* PropertyAccess */:
                case 121 /* QualifiedName */:
                    return getSymbolOfEntityName(node);
                case 91 /* ThisKeyword */:
                case 89 /* SuperKeyword */:
                    var type = checkExpression(node);
                    return type.symbol;
                case 111 /* ConstructorKeyword */:
                    // constructor keyword for an overload, should take us to the definition if it exist
                    var constructorDeclaration = node.parent;
                    if (constructorDeclaration && constructorDeclaration.kind === 126 /* Constructor */) {
                        return constructorDeclaration.parent.symbol;
                    }
                    return undefined;
                case 7 /* StringLiteral */:
                    // External module name in an import declaration
                    if (node.parent.kind === 190 /* ImportDeclaration */ && node.parent.externalModuleName === node) {
                        var importSymbol = getSymbolOfNode(node.parent);
                        var moduleType = getTypeOfSymbol(importSymbol);
                        return moduleType ? moduleType.symbol : undefined;
                    }
                case 6 /* NumericLiteral */:
                    // index access
                    if (node.parent.kind == 143 /* IndexedAccess */ && node.parent.index === node) {
                        var objectType = checkExpression(node.parent.object);
                        if (objectType === unknownType)
                            return undefined;
                        var apparentType = getApparentType(objectType);
                        if (apparentType === unknownType)
                            return undefined;
                        return getPropertyOfType(apparentType, node.text);
                    }
                    break;
            }
            return undefined;
        }
        function getTypeOfNode(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return unknownType;
            }
            if (ts.isExpression(node)) {
                return getTypeOfExpression(node);
            }
            if (isTypeNode(node)) {
                return getTypeFromTypeNode(node);
            }
            if (isTypeDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isTypeDeclarationName(node)) {
                var symbol = getSymbolInfo(node);
                return symbol && getDeclaredTypeOfSymbol(symbol);
            }
            if (ts.isDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getTypeOfSymbol(symbol);
            }
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                var symbol = getSymbolInfo(node);
                return symbol && getTypeOfSymbol(symbol);
            }
            if (isInRightSideOfImportOrExportAssignment(node)) {
                var symbol = getSymbolInfo(node);
                var declaredType = symbol && getDeclaredTypeOfSymbol(symbol);
                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);
            }
            return unknownType;
        }
        function getTypeOfExpression(expr) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
                expr = expr.parent;
            }
            return checkExpression(expr);
        }
        // Return the list of properties of the given type, augmented with properties from Function
        // if the type has call or construct signatures
        function getAugmentedPropertiesOfType(type) {
            var type = getApparentType(type);
            var propsByName = createSymbolTable(getPropertiesOfType(type));
            if (getSignaturesOfType(type, 0 /* Call */).length || getSignaturesOfType(type, 1 /* Construct */).length) {
                ts.forEach(getPropertiesOfType(globalFunctionType), function (p) {
                    if (!ts.hasProperty(propsByName, p.name)) {
                        propsByName[p.name] = p;
                    }
                });
            }
            return getNamedMembers(propsByName);
        }
        function getRootSymbols(symbol) {
            if (symbol.flags & 1073741824 /* UnionProperty */) {
                var symbols = [];
                var name = symbol.name;
                ts.forEach(getSymbolLinks(symbol).unionType.types, function (t) {
                    symbols.push(getPropertyOfType(t, name));
                });
                return symbols;
            }
            else if (symbol.flags & 268435456 /* Transient */) {
                var target = getSymbolLinks(symbol).target;
                if (target) {
                    return [target];
                }
            }
            return [symbol];
        }
        // Emitter support
        function isExternalModuleSymbol(symbol) {
            return symbol.flags & 512 /* ValueModule */ && symbol.declarations.length === 1 && symbol.declarations[0].kind === 193 /* SourceFile */;
        }
        function isNodeDescendentOf(node, ancestor) {
            while (node) {
                if (node === ancestor)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function isUniqueLocalName(name, container) {
            for (var node = container; isNodeDescendentOf(node, container); node = node.nextContainer) {
                if (node.locals && ts.hasProperty(node.locals, name) && node.locals[name].flags & (107455 /* Value */ | 4194304 /* ExportValue */)) {
                    return false;
                }
            }
            return true;
        }
        function getLocalNameOfContainer(container) {
            var links = getNodeLinks(container);
            if (!links.localModuleName) {
                var prefix = "";
                var name = ts.unescapeIdentifier(container.name.text);
                while (!isUniqueLocalName(ts.escapeIdentifier(prefix + name), container)) {
                    prefix += "_";
                }
                links.localModuleName = prefix + ts.getTextOfNode(container.name);
            }
            return links.localModuleName;
        }
        function getLocalNameForSymbol(symbol, location) {
            var node = location;
            while (node) {
                if ((node.kind === 188 /* ModuleDeclaration */ || node.kind === 187 /* EnumDeclaration */) && getSymbolOfNode(node) === symbol) {
                    return getLocalNameOfContainer(node);
                }
                node = node.parent;
            }
            ts.Debug.fail("getLocalNameForSymbol failed");
        }
        function getExpressionNamePrefix(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                // In general, we need to prefix an identifier with its parent name if it references
                // an exported entity from another module declaration. If we reference an exported
                // entity within the same module declaration, then whether we prefix depends on the
                // kind of entity. SymbolFlags.ExportHasLocal encompasses all the kinds that we
                // do NOT prefix.
                var exportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
                if (symbol !== exportSymbol && !(exportSymbol.flags & 944 /* ExportHasLocal */)) {
                    symbol = exportSymbol;
                }
                if (symbol.parent) {
                    return isExternalModuleSymbol(symbol.parent) ? "exports" : getLocalNameForSymbol(getParentOfSymbol(symbol), node.parent);
                }
            }
        }
        function getExportAssignmentName(node) {
            var symbol = getExportAssignmentSymbol(getSymbolOfNode(node));
            return symbol && symbolIsValue(symbol) && !isConstEnumSymbol(symbol) ? symbolToString(symbol) : undefined;
        }
        function isTopLevelValueImportWithEntityName(node) {
            if (node.parent.kind !== 193 /* SourceFile */ || !node.entityName) {
                // parent is not source file or it is not reference to internal module
                return false;
            }
            var symbol = getSymbolOfNode(node);
            return isImportResolvedToValue(getSymbolOfNode(node));
        }
        function hasSemanticErrors() {
            // Return true if there is any semantic error in a file or globally
            return getDiagnostics().length > 0 || getGlobalDiagnostics().length > 0;
        }
        function hasEarlyErrors(sourceFile) {
            return ts.forEach(getDiagnostics(sourceFile), function (d) { return d.isEarly; });
        }
        function isImportResolvedToValue(symbol) {
            var target = resolveImport(symbol);
            // const enums and modules that contain only const enums are not considered values from the emit perespective
            return target !== unknownSymbol && target.flags & 107455 /* Value */ && !isConstEnumOrConstEnumOnlyModule(target);
        }
        function isConstEnumOrConstEnumOnlyModule(s) {
            return isConstEnumSymbol(s) || s.constEnumOnlyModule;
        }
        function isReferencedImportDeclaration(node) {
            var symbol = getSymbolOfNode(node);
            if (getSymbolLinks(symbol).referenced) {
                return true;
            }
            // logic below will answer 'true' for exported import declaration in a nested module that itself is not exported.
            // As a consequence this might cause emitting extra.
            if (node.flags & 1 /* Export */) {
                return isImportResolvedToValue(symbol);
            }
            return false;
        }
        function isImplementationOfOverload(node) {
            if (node.body) {
                var symbol = getSymbolOfNode(node);
                var signaturesOfSymbol = getSignaturesOfSymbol(symbol);
                // If this function body corresponds to function with multiple signature, it is implementation of overload
                // e.g.: function foo(a: string): string;
                //       function foo(a: number): number;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
            }
            return false;
        }
        function getNodeCheckFlags(node) {
            return getNodeLinks(node).flags;
        }
        function getEnumMemberValue(node) {
            computeEnumMemberValues(node.parent);
            return getNodeLinks(node).enumMemberValue;
        }
        function getConstantValue(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol && (symbol.flags & 8 /* EnumMember */)) {
                var declaration = symbol.valueDeclaration;
                var constantValue;
                if (declaration.kind === 192 /* EnumMember */ && (constantValue = getNodeLinks(declaration).enumMemberValue) !== undefined) {
                    return constantValue;
                }
            }
            return undefined;
        }
        function writeTypeAtLocation(location, enclosingDeclaration, flags, writer) {
            // Get type of the symbol if this is the valid symbol otherwise get type at location
            var symbol = getSymbolOfNode(location);
            var type = symbol && !(symbol.flags & 2048 /* TypeLiteral */) ? getTypeOfSymbol(symbol) : getTypeFromTypeNode(location);
            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
        }
        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {
            var signature = getSignatureFromDeclaration(signatureDeclaration);
            getSymbolDisplayBuilder().buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags);
        }
        function invokeEmitter(targetSourceFile) {
            var resolver = {
                getProgram: function () { return program; },
                getLocalNameOfContainer: getLocalNameOfContainer,
                getExpressionNamePrefix: getExpressionNamePrefix,
                getExportAssignmentName: getExportAssignmentName,
                isReferencedImportDeclaration: isReferencedImportDeclaration,
                getNodeCheckFlags: getNodeCheckFlags,
                getEnumMemberValue: getEnumMemberValue,
                isTopLevelValueImportWithEntityName: isTopLevelValueImportWithEntityName,
                hasSemanticErrors: hasSemanticErrors,
                hasEarlyErrors: hasEarlyErrors,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                writeTypeAtLocation: writeTypeAtLocation,
                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,
                isSymbolAccessible: isSymbolAccessible,
                isImportDeclarationEntityNameReferenceDeclarationVisibile: isImportDeclarationEntityNameReferenceDeclarationVisibile,
                getConstantValue: getConstantValue
            };
            checkProgram();
            return ts.emitFiles(resolver, targetSourceFile);
        }
        function initializeTypeChecker() {
            // Bind all source files and propagate errors
            ts.forEach(program.getSourceFiles(), function (file) {
                ts.bindSourceFile(file);
                ts.forEach(file.semanticErrors, addDiagnostic);
            });
            // Initialize global symbol table
            ts.forEach(program.getSourceFiles(), function (file) {
                if (!ts.isExternalModule(file)) {
                    extendSymbolTable(globals, file.locals);
                }
            });
            // Initialize special symbols
            getSymbolLinks(undefinedSymbol).type = undefinedType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments");
            getSymbolLinks(unknownSymbol).type = unknownType;
            globals[undefinedSymbol.name] = undefinedSymbol;
            // Initialize special types
            globalArraySymbol = getGlobalSymbol("Array");
            globalArrayType = getTypeOfGlobalSymbol(globalArraySymbol, 1);
            globalObjectType = getGlobalType("Object");
            globalFunctionType = getGlobalType("Function");
            globalStringType = getGlobalType("String");
            globalNumberType = getGlobalType("Number");
            globalBooleanType = getGlobalType("Boolean");
            globalRegExpType = getGlobalType("RegExp");
        }
        initializeTypeChecker();
        return checker;
    }
    ts.createTypeChecker = createTypeChecker;
})(ts || (ts = {}));
// <auto-generated />
var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_comma_not_allowed: "Trailing comma not allowed.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        A_rest_parameter_must_be_last_in_a_parameter_list: "A rest parameter must be last in a parameter list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        A_required_parameter_cannot_follow_an_optional_parameter: "A required parameter cannot follow an optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        A_function_implementation_cannot_be_declared_in_an_ambient_context: "A function implementation cannot be declared in an ambient context.",
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: "A 'declare' modifier cannot be used in an already ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: "A 'declare' modifier cannot be used with an interface declaration.",
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: "A 'declare' modifier is required for a top level declaration in a .d.ts file.",
        A_rest_parameter_cannot_be_optional: "A rest parameter cannot be optional.",
        A_rest_parameter_cannot_have_an_initializer: "A rest parameter cannot have an initializer.",
        set_accessor_must_have_exactly_one_parameter: "'set' accessor must have exactly one parameter.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        A_declare_modifier_cannot_be_used_with_an_import_declaration: "A 'declare' modifier cannot be used with an import declaration.",
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: "Octal literals are not available when targeting ECMAScript 5 and higher.",
        Accessors_are_not_allowed_in_ambient_contexts: "Accessors are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_constructor_declaration: "'{0}' modifier cannot appear on a constructor declaration.",
        _0_modifier_cannot_appear_on_a_parameter: "'{0}' modifier cannot appear on a parameter.",
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: "Only a single variable declaration is allowed in a 'for...in' statement.",
        Type_parameters_cannot_appear_on_a_constructor_declaration: "Type parameters cannot appear on a constructor declaration.",
        Type_annotation_cannot_appear_on_a_constructor_declaration: "Type annotation cannot appear on a constructor declaration.",
        Type_parameters_cannot_appear_on_an_accessor: "Type parameters cannot appear on an accessor.",
        Type_annotation_cannot_appear_on_a_set_accessor: "Type annotation cannot appear on a 'set' accessor.",
        Index_signature_must_have_exactly_one_parameter: "Index signature must have exactly one parameter.",
        _0_list_cannot_be_empty: "'{0}' list cannot be empty.",
        variable_declaration: "variable declaration",
        type_argument: "type argument",
        Invalid_use_of_0_in_strict_mode: "Invalid use of '{0}' in strict mode.",
        with_statements_are_not_allowed_in_strict_mode: "'with' statements are not allowed in strict mode.",
        delete_cannot_be_called_on_an_identifier_in_strict_mode: "'delete' cannot be called on an identifier in strict mode.",
        Invalid_left_hand_side_in_for_in_statement: "Invalid left-hand side in 'for...in' statement.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: "Jump target not found.",
        Jump_target_cannot_cross_function_boundary: "Jump target cannot cross function boundary.",
        return_statement_must_be_contained_within_a_function_body: "'return' statement must be contained within a function body.",
        Expression_expected: "Expression expected.",
        Type_expected: "Type expected.",
        Template_literal_cannot_be_used_as_an_element_name: "Template literal cannot be used as an element name.",
        Computed_property_names_cannot_be_used_here: "Computed property names cannot be used here.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        An_index_expression_argument_must_be_string_number_or_any: "An index expression argument must be 'string', 'number', or 'any'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Type_0_is_not_assignable_to_type_1: "Type '{0}' is not assignable to type '{1}'.",
        Type_0_is_not_assignable_to_type_1_NL_2: "Type '{0}' is not assignable to type '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Cannot_find_external_module_0: "Cannot find external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_a_class_or_another_interface: "An interface may only extend a class or another interface.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Cannot_use_new_with_an_expression_whose_type_lacks_a_signature: "Cannot use 'new' with an expression whose type lacks a signature.",
        Only_a_void_function_can_be_called_with_the_new_keyword: "Only a void function can be called with the 'new' keyword.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1: "Type '{0}' does not satisfy the constraint '{1}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        Property_0_does_not_exist_on_value_of_type_1: "Property '{0}' does not exist on value of type '{1}'.",
        Cannot_find_name_0: "Cannot find name '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_members_cannot_reference_class_type_parameters: "Static members cannot reference class type parameters.",
        Type_0_recursively_references_itself_as_a_base_type: "Type '{0}' recursively references itself as a base type.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_can_only_be_referenced_in_a_derived_class: "'super' can only be referenced in a derived class.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: "Super calls are not permitted outside constructors or in nested functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_in_a_module_body: "'this' cannot be referenced in a module body.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: "An arithmetic operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Type_0_is_not_generic: "Type '{0}' is not generic.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_a_static_property_initializer: "'this' cannot be referenced in a static property initializer.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_not_exported: "Overload signatures must all be exported or not exported.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: "Specialized overload signature is not assignable to any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        A_rest_parameter_must_be_of_an_array_type: "A rest parameter must be of an array type.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0: "All numerically named properties must be assignable to numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1: "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_assignable_to_string_indexer_type_0: "All named properties must be assignable to string indexer type '{0}'.",
        All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1: "All named properties must be assignable to string indexer type '{0}':{NL}{1}",
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: "A parameter initializer is only allowed in a function or constructor implementation.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Module_0_has_no_exported_member_1: "Module '{0}' has no exported member '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1: "Type name '{0}' in extends clause does not reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: "Ambient external module declaration cannot be reopened.",
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: "Return type of constructor signature must be assignable to the instance type of the class.",
        Ambient_external_module_declaration_must_be_defined_in_global_context: "Ambient external module declaration must be defined in global context.",
        Ambient_external_module_declaration_cannot_specify_relative_module_name: "Ambient external module declaration cannot specify relative module name.",
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.",
        No_best_common_type_exists_among_return_expressions: "No best common type exists among return expressions.",
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: "Import declaration cannot refer to external module reference when --noResolve option is set.",
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.",
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.",
        No_best_common_type_exists_between_0_and_1: "No best common type exists between '{0}' and '{1}'.",
        No_best_common_type_exists_between_0_1_and_2: "No best common type exists between '{0}', '{1}', and '{2}'.",
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.",
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.",
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.",
        Parameter_0_cannot_be_referenced_in_its_initializer: "Parameter '{0}' cannot be referenced in its initializer.",
        Duplicate_string_index_signature: "Duplicate string index signature.",
        Duplicate_number_index_signature: "Duplicate number index signature.",
        All_declarations_of_an_interface_must_have_identical_type_parameters: "All declarations of an interface must have identical type parameters.",
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other: "Neither type '{0}' nor type '{1}' is assignable to the other.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other_NL_2: "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}",
        Duplicate_function_implementation: "Duplicate function implementation.",
        Function_implementation_expected: "Function implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        A_module_cannot_have_multiple_export_assignments: "A module cannot have multiple export assignments.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: "A parameter property is only allowed in a constructor implementation.",
        Function_overload_must_be_static: "Function overload must be static.",
        Function_overload_must_not_be_static: "Function overload must not be static.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element: "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: "Variable declaration cannot have the same name as an import declaration.",
        Signature_expected_0_type_arguments_got_1_instead: "Signature expected {0} type arguments, got {1} instead.",
        Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type: "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}",
        Named_properties_0_of_types_1_and_2_are_not_identical: "Named properties '{0}' of types '{1}' and '{2}' are not identical.",
        Types_of_string_indexer_of_types_0_and_1_are_not_identical: "Types of string indexer of types '{0}' and '{1}' are not identical.",
        Types_of_number_indexer_of_types_0_and_1_are_not_identical: "Types of number indexer of types '{0}' and '{1}' are not identical.",
        Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2: "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}",
        Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}",
        Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}",
        Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_static_property_2_as_private: "Types '{0}' and '{1}' define static property '{2}' as private.",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Argument_for_0_option_must_be_1_or_2: "Argument for '{0}' option must be '{1}' or '{2}'",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Unknown_compiler_option_0: "Unknown compiler option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead.",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file.",
        Generates_corresponding_0_file: "Generates corresponding {0} file.",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files.",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory.",
        Do_not_emit_comments_to_output: "Do not emit comments to output.",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing.",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: "Print this message.",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file1: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        file2: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        NUMBER: "NUMBER",
        Specify_the_codepage_to_use_when_opening_source_files: "Specify the codepage to use when opening source files.",
        Additional_locations: "Additional locations:",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Unknown_rule: "Unknown rule.",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening.",
        _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.",
        Index_signature_of_object_type_implicitly_has_an_any_type: "Index signature of object type implicitly has an 'any' type.",
        Object_literal_s_property_0_implicitly_has_an_any_type_from_widening: "Object literal's property '{0}' implicitly has an 'any' type from widening."
    };
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
// <auto-generated />
/// <reference path="..\core\diagnosticCategory.ts" />
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": { "code": 0, "category": 3 /* NoPrefix */ },
        "warning TS{0}: {1}": { "code": 1, "category": 3 /* NoPrefix */ },
        "Unrecognized escape sequence.": { "code": 1000, "category": 1 /* Error */ },
        "Unexpected character {0}.": { "code": 1001, "category": 1 /* Error */ },
        "Missing close quote character.": { "code": 1002, "category": 1 /* Error */ },
        "Identifier expected.": { "code": 1003, "category": 1 /* Error */ },
        "'{0}' keyword expected.": { "code": 1004, "category": 1 /* Error */ },
        "'{0}' expected.": { "code": 1005, "category": 1 /* Error */ },
        "Identifier expected; '{0}' is a keyword.": { "code": 1006, "category": 1 /* Error */ },
        "Automatic semicolon insertion not allowed.": { "code": 1007, "category": 1 /* Error */ },
        "Unexpected token; '{0}' expected.": { "code": 1008, "category": 1 /* Error */ },
        "Trailing comma not allowed.": { "code": 1009, "category": 1 /* Error */ },
        "'*/' expected.": { "code": 1010, "category": 1 /* Error */ },
        "'public' or 'private' modifier must precede 'static'.": { "code": 1011, "category": 1 /* Error */ },
        "Unexpected token.": { "code": 1012, "category": 1 /* Error */ },
        "Catch clause parameter cannot have a type annotation.": { "code": 1013, "category": 1 /* Error */ },
        "A rest parameter must be last in a parameter list.": { "code": 1014, "category": 1 /* Error */ },
        "Parameter cannot have question mark and initializer.": { "code": 1015, "category": 1 /* Error */ },
        "A required parameter cannot follow an optional parameter.": { "code": 1016, "category": 1 /* Error */ },
        "Index signatures cannot have rest parameters.": { "code": 1017, "category": 1 /* Error */ },
        "Index signature parameter cannot have accessibility modifiers.": { "code": 1018, "category": 1 /* Error */ },
        "Index signature parameter cannot have a question mark.": { "code": 1019, "category": 1 /* Error */ },
        "Index signature parameter cannot have an initializer.": { "code": 1020, "category": 1 /* Error */ },
        "Index signature must have a type annotation.": { "code": 1021, "category": 1 /* Error */ },
        "Index signature parameter must have a type annotation.": { "code": 1022, "category": 1 /* Error */ },
        "Index signature parameter type must be 'string' or 'number'.": { "code": 1023, "category": 1 /* Error */ },
        "'extends' clause already seen.": { "code": 1024, "category": 1 /* Error */ },
        "'extends' clause must precede 'implements' clause.": { "code": 1025, "category": 1 /* Error */ },
        "Classes can only extend a single class.": { "code": 1026, "category": 1 /* Error */ },
        "'implements' clause already seen.": { "code": 1027, "category": 1 /* Error */ },
        "Accessibility modifier already seen.": { "code": 1028, "category": 1 /* Error */ },
        "'{0}' modifier must precede '{1}' modifier.": { "code": 1029, "category": 1 /* Error */ },
        "'{0}' modifier already seen.": { "code": 1030, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a class element.": { "code": 1031, "category": 1 /* Error */ },
        "Interface declaration cannot have 'implements' clause.": { "code": 1032, "category": 1 /* Error */ },
        "'super' invocation cannot have type arguments.": { "code": 1034, "category": 1 /* Error */ },
        "Only ambient modules can use quoted names.": { "code": 1035, "category": 1 /* Error */ },
        "Statements are not allowed in ambient contexts.": { "code": 1036, "category": 1 /* Error */ },
        "A function implementation cannot be declared in an ambient context.": { "code": 1037, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used in an already ambient context.": { "code": 1038, "category": 1 /* Error */ },
        "Initializers are not allowed in ambient contexts.": { "code": 1039, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a module element.": { "code": 1044, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used with an interface declaration.": { "code": 1045, "category": 1 /* Error */ },
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": { "code": 1046, "category": 1 /* Error */ },
        "A rest parameter cannot be optional.": { "code": 1047, "category": 1 /* Error */ },
        "A rest parameter cannot have an initializer.": { "code": 1048, "category": 1 /* Error */ },
        "'set' accessor must have exactly one parameter.": { "code": 1049, "category": 1 /* Error */ },
        "'set' accessor parameter cannot be optional.": { "code": 1051, "category": 1 /* Error */ },
        "'set' accessor parameter cannot have an initializer.": { "code": 1052, "category": 1 /* Error */ },
        "'set' accessor cannot have rest parameter.": { "code": 1053, "category": 1 /* Error */ },
        "'get' accessor cannot have parameters.": { "code": 1054, "category": 1 /* Error */ },
        "Modifiers cannot appear here.": { "code": 1055, "category": 1 /* Error */ },
        "Accessors are only available when targeting ECMAScript 5 and higher.": { "code": 1056, "category": 1 /* Error */ },
        "Enum member must have initializer.": { "code": 1061, "category": 1 /* Error */ },
        "Export assignment cannot be used in internal modules.": { "code": 1063, "category": 1 /* Error */ },
        "Ambient enum elements can only have integer literal initializers.": { "code": 1066, "category": 1 /* Error */ },
        "module, class, interface, enum, import or statement": { "code": 1067, "category": 3 /* NoPrefix */ },
        "constructor, function, accessor or variable": { "code": 1068, "category": 3 /* NoPrefix */ },
        "statement": { "code": 1069, "category": 3 /* NoPrefix */ },
        "case or default clause": { "code": 1070, "category": 3 /* NoPrefix */ },
        "identifier": { "code": 1071, "category": 3 /* NoPrefix */ },
        "call, construct, index, property or function signature": { "code": 1072, "category": 3 /* NoPrefix */ },
        "expression": { "code": 1073, "category": 3 /* NoPrefix */ },
        "type name": { "code": 1074, "category": 3 /* NoPrefix */ },
        "property or accessor": { "code": 1075, "category": 3 /* NoPrefix */ },
        "parameter": { "code": 1076, "category": 3 /* NoPrefix */ },
        "type": { "code": 1077, "category": 3 /* NoPrefix */ },
        "type parameter": { "code": 1078, "category": 3 /* NoPrefix */ },
        "A 'declare' modifier cannot be used with an import declaration.": { "code": 1079, "category": 1 /* Error */ },
        "Invalid 'reference' directive syntax.": { "code": 1084, "category": 1 /* Error */ },
        "Octal literals are not available when targeting ECMAScript 5 and higher.": { "code": 1085, "category": 1 /* Error */ },
        "Accessors are not allowed in ambient contexts.": { "code": 1086, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a constructor declaration.": { "code": 1089, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a parameter.": { "code": 1090, "category": 1 /* Error */ },
        "Only a single variable declaration is allowed in a 'for...in' statement.": { "code": 1091, "category": 1 /* Error */ },
        "Type parameters cannot appear on a constructor declaration.": { "code": 1092, "category": 1 /* Error */ },
        "Type annotation cannot appear on a constructor declaration.": { "code": 1093, "category": 1 /* Error */ },
        "Type parameters cannot appear on an accessor.": { "code": 1094, "category": 1 /* Error */ },
        "Type annotation cannot appear on a 'set' accessor.": { "code": 1095, "category": 1 /* Error */ },
        "Index signature must have exactly one parameter.": { "code": 1096, "category": 1 /* Error */ },
        "'{0}' list cannot be empty.": { "code": 1097, "category": 1 /* Error */ },
        "variable declaration": { "code": 1098, "category": 3 /* NoPrefix */ },
        "type argument": { "code": 1099, "category": 3 /* NoPrefix */ },
        "Invalid use of '{0}' in strict mode.": { "code": 1100, "category": 1 /* Error */ },
        "'with' statements are not allowed in strict mode.": { "code": 1101, "category": 1 /* Error */ },
        "'delete' cannot be called on an identifier in strict mode.": { "code": 1102, "category": 1 /* Error */ },
        "Invalid left-hand side in 'for...in' statement.": { "code": 1103, "category": 1 /* Error */ },
        "'continue' statement can only be used within an enclosing iteration statement.": { "code": 1104, "category": 1 /* Error */ },
        "'break' statement can only be used within an enclosing iteration or switch statement.": { "code": 1105, "category": 1 /* Error */ },
        "Jump target not found.": { "code": 1106, "category": 1 /* Error */ },
        "Jump target cannot cross function boundary.": { "code": 1107, "category": 1 /* Error */ },
        "'return' statement must be contained within a function body.": { "code": 1108, "category": 1 /* Error */ },
        "Expression expected.": { "code": 1109, "category": 1 /* Error */ },
        "Type expected.": { "code": 1110, "category": 1 /* Error */ },
        "Template literal cannot be used as an element name.": { "code": 1111, "category": 1 /* Error */ },
        "Computed property names cannot be used here.": { "code": 1112, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'.": { "code": 2000, "category": 1 /* Error */ },
        "The name '{0}' does not exist in the current scope.": { "code": 2001, "category": 1 /* Error */ },
        "The name '{0}' does not refer to a value.": { "code": 2002, "category": 1 /* Error */ },
        "'super' can only be used inside a class instance method.": { "code": 2003, "category": 1 /* Error */ },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": { "code": 2004, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": { "code": 2161, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable.": { "code": 2006, "category": 1 /* Error */ },
        "Value of type '{0}' is not newable.": { "code": 2007, "category": 1 /* Error */ },
        "An index expression argument must be 'string', 'number', or 'any'.": { "code": 2008, "category": 1 /* Error */ },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": { "code": 2009, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}'.": { "code": 2011, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}':{NL}{2}": { "code": 2012, "category": 1 /* Error */ },
        "Expected var, class, interface, or module.": { "code": 2013, "category": 1 /* Error */ },
        "Getter '{0}' already declared.": { "code": 2015, "category": 1 /* Error */ },
        "Setter '{0}' already declared.": { "code": 2016, "category": 1 /* Error */ },
        "Exported class '{0}' extends private class '{1}'.": { "code": 2018, "category": 1 /* Error */ },
        "Exported class '{0}' implements private interface '{1}'.": { "code": 2019, "category": 1 /* Error */ },
        "Exported interface '{0}' extends private interface '{1}'.": { "code": 2020, "category": 1 /* Error */ },
        "Exported class '{0}' extends class from inaccessible module {1}.": { "code": 2021, "category": 1 /* Error */ },
        "Exported class '{0}' implements interface from inaccessible module {1}.": { "code": 2022, "category": 1 /* Error */ },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": { "code": 2023, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": { "code": 2024, "category": 1 /* Error */ },
        "Public property '{0}' of exported class has or is using private type '{1}'.": { "code": 2025, "category": 1 /* Error */ },
        "Property '{0}' of exported interface has or is using private type '{1}'.": { "code": 2026, "category": 1 /* Error */ },
        "Exported variable '{0}' has or is using private type '{1}'.": { "code": 2027, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": { "code": 2028, "category": 1 /* Error */ },
        "Public property '{0}' of exported class is using inaccessible module {1}.": { "code": 2029, "category": 1 /* Error */ },
        "Property '{0}' of exported interface is using inaccessible module {1}.": { "code": 2030, "category": 1 /* Error */ },
        "Exported variable '{0}' is using inaccessible module {1}.": { "code": 2031, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": { "code": 2032, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": { "code": 2033, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": { "code": 2034, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2035, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2036, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2037, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2038, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2039, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2040, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": { "code": 2041, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": { "code": 2042, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": { "code": 2043, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2044, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2045, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2046, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2047, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2048, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2049, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": { "code": 2050, "category": 1 /* Error */ },
        "Return type of public property getter from exported class has or is using private type '{0}'.": { "code": 2051, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": { "code": 2052, "category": 1 /* Error */ },
        "Return type of call signature from exported interface has or is using private type '{0}'.": { "code": 2053, "category": 1 /* Error */ },
        "Return type of index signature from exported interface has or is using private type '{0}'.": { "code": 2054, "category": 1 /* Error */ },
        "Return type of public static method from exported class has or is using private type '{0}'.": { "code": 2055, "category": 1 /* Error */ },
        "Return type of public method from exported class has or is using private type '{0}'.": { "code": 2056, "category": 1 /* Error */ },
        "Return type of method from exported interface has or is using private type '{0}'.": { "code": 2057, "category": 1 /* Error */ },
        "Return type of exported function has or is using private type '{0}'.": { "code": 2058, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": { "code": 2059, "category": 1 /* Error */ },
        "Return type of public property getter from exported class is using inaccessible module {0}.": { "code": 2060, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": { "code": 2061, "category": 1 /* Error */ },
        "Return type of call signature from exported interface is using inaccessible module {0}.": { "code": 2062, "category": 1 /* Error */ },
        "Return type of index signature from exported interface is using inaccessible module {0}.": { "code": 2063, "category": 1 /* Error */ },
        "Return type of public static method from exported class is using inaccessible module {0}.": { "code": 2064, "category": 1 /* Error */ },
        "Return type of public method from exported class is using inaccessible module {0}.": { "code": 2065, "category": 1 /* Error */ },
        "Return type of method from exported interface is using inaccessible module {0}.": { "code": 2066, "category": 1 /* Error */ },
        "Return type of exported function is using inaccessible module {0}.": { "code": 2067, "category": 1 /* Error */ },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": { "code": 2068, "category": 1 /* Error */ },
        "A parameter list must follow a generic type argument list. '(' expected.": { "code": 2069, "category": 1 /* Error */ },
        "Multiple constructor implementations are not allowed.": { "code": 2070, "category": 1 /* Error */ },
        "Cannot find external module '{0}'.": { "code": 2071, "category": 1 /* Error */ },
        "Module cannot be aliased to a non-module type.": { "code": 2072, "category": 1 /* Error */ },
        "A class may only extend another class.": { "code": 2073, "category": 1 /* Error */ },
        "A class may only implement another class or interface.": { "code": 2074, "category": 1 /* Error */ },
        "An interface may only extend a class or another interface.": { "code": 2075, "category": 1 /* Error */ },
        "Unable to resolve type.": { "code": 2077, "category": 1 /* Error */ },
        "Unable to resolve type of '{0}'.": { "code": 2078, "category": 1 /* Error */ },
        "Unable to resolve type parameter constraint.": { "code": 2079, "category": 1 /* Error */ },
        "Type parameter constraint cannot be a primitive type.": { "code": 2080, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target.": { "code": 2081, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target:{NL}{0}": { "code": 2082, "category": 1 /* Error */ },
        "Cannot use 'new' with an expression whose type lacks a signature.": { "code": 2083, "category": 1 /* Error */ },
        "Only a void function can be called with the 'new' keyword.": { "code": 2084, "category": 1 /* Error */ },
        "Could not select overload for 'new' expression.": { "code": 2085, "category": 1 /* Error */ },
        "Type '{0}' does not satisfy the constraint '{1}'.": { "code": 2086, "category": 1 /* Error */ },
        "Could not select overload for 'call' expression.": { "code": 2087, "category": 1 /* Error */ },
        "Cannot invoke an expression whose type lacks a call signature.": { "code": 2088, "category": 1 /* Error */ },
        "Calls to 'super' are only valid inside a class.": { "code": 2089, "category": 1 /* Error */ },
        "Generic type '{0}' requires {1} type argument(s).": { "code": 2090, "category": 1 /* Error */ },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": { "code": 2092, "category": 1 /* Error */ },
        "Could not find enclosing symbol for dotted name '{0}'.": { "code": 2093, "category": 1 /* Error */ },
        "Property '{0}' does not exist on value of type '{1}'.": { "code": 2094, "category": 1 /* Error */ },
        "Cannot find name '{0}'.": { "code": 2095, "category": 1 /* Error */ },
        "'get' and 'set' accessor must have the same type.": { "code": 2096, "category": 1 /* Error */ },
        "'this' cannot be referenced in current location.": { "code": 2097, "category": 1 /* Error */ },
        "Static members cannot reference class type parameters.": { "code": 2099, "category": 1 /* Error */ },
        "Type '{0}' recursively references itself as a base type.": { "code": 2100, "category": 1 /* Error */ },
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": { "code": 2102, "category": 1 /* Error */ },
        "'super' can only be referenced in a derived class.": { "code": 2103, "category": 1 /* Error */ },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": { "code": 2104, "category": 1 /* Error */ },
        "Constructors for derived classes must contain a 'super' call.": { "code": 2105, "category": 1 /* Error */ },
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": { "code": 2106, "category": 1 /* Error */ },
        "'{0}.{1}' is inaccessible.": { "code": 2107, "category": 1 /* Error */ },
        "'this' cannot be referenced in a module body.": { "code": 2108, "category": 1 /* Error */ },
        "Invalid '+' expression - types not known to support the addition operator.": { "code": 2111, "category": 1 /* Error */ },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2112, "category": 1 /* Error */ },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2113, "category": 1 /* Error */ },
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": { "code": 2114, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement cannot use a type annotation.": { "code": 2115, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": { "code": 2116, "category": 1 /* Error */ },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": { "code": 2117, "category": 1 /* Error */ },
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": { "code": 2118, "category": 1 /* Error */ },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": { "code": 2119, "category": 1 /* Error */ },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": { "code": 2120, "category": 1 /* Error */ },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": { "code": 2121, "category": 1 /* Error */ },
        "Setters cannot return a value.": { "code": 2122, "category": 1 /* Error */ },
        "Tried to query type of uninitialized module '{0}'.": { "code": 2123, "category": 1 /* Error */ },
        "Tried to set variable type to uninitialized module type '{0}'.": { "code": 2124, "category": 1 /* Error */ },
        "Type '{0}' is not generic.": { "code": 2125, "category": 1 /* Error */ },
        "Getters must return a value.": { "code": 2126, "category": 1 /* Error */ },
        "Getter and setter accessors do not agree in visibility.": { "code": 2127, "category": 1 /* Error */ },
        "Invalid left-hand side of assignment expression.": { "code": 2130, "category": 1 /* Error */ },
        "Function declared a non-void return type, but has no return expression.": { "code": 2131, "category": 1 /* Error */ },
        "Cannot resolve return type reference.": { "code": 2132, "category": 1 /* Error */ },
        "Constructors cannot have a return type of 'void'.": { "code": 2133, "category": 1 /* Error */ },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": { "code": 2134, "category": 1 /* Error */ },
        "All symbols within a with block will be resolved to 'any'.": { "code": 2135, "category": 1 /* Error */ },
        "Import declarations in an internal module cannot reference an external module.": { "code": 2136, "category": 1 /* Error */ },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": { "code": 2137, "category": 1 /* Error */ },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": { "code": 2138, "category": 1 /* Error */ },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": { "code": 2139, "category": 1 /* Error */ },
        "'this' cannot be referenced in a static property initializer.": { "code": 2140, "category": 1 /* Error */ },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2141, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2142, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": { "code": 2143, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition.": { "code": 2148, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition:{NL}{0}": { "code": 2149, "category": 1 /* Error */ },
        "Overload signatures must all be public or private.": { "code": 2150, "category": 1 /* Error */ },
        "Overload signatures must all be exported or not exported.": { "code": 2151, "category": 1 /* Error */ },
        "Overload signatures must all be ambient or non-ambient.": { "code": 2152, "category": 1 /* Error */ },
        "Overload signatures must all be optional or required.": { "code": 2153, "category": 1 /* Error */ },
        "Specialized overload signature is not assignable to any non-specialized signature.": { "code": 2154, "category": 1 /* Error */ },
        "'this' cannot be referenced in constructor arguments.": { "code": 2155, "category": 1 /* Error */ },
        "Instance member cannot be accessed off a class.": { "code": 2157, "category": 1 /* Error */ },
        "Untyped function calls may not accept type arguments.": { "code": 2158, "category": 1 /* Error */ },
        "Non-generic functions may not accept type arguments.": { "code": 2159, "category": 1 /* Error */ },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": { "code": 2160, "category": 1 /* Error */ },
        "A rest parameter must be of an array type.": { "code": 2162, "category": 1 /* Error */ },
        "Overload signature implementation cannot use specialized type.": { "code": 2163, "category": 1 /* Error */ },
        "Export assignments may only be used at the top-level of external modules.": { "code": 2164, "category": 1 /* Error */ },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2165, "category": 1 /* Error */ },
        "Only public methods of the base class are accessible via the 'super' keyword.": { "code": 2166, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": { "code": 2167, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": { "code": 2168, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": { "code": 2169, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": { "code": 2170, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}'.": { "code": 2171, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": { "code": 2172, "category": 1 /* Error */ },
        "A parameter initializer is only allowed in a function or constructor implementation.": { "code": 2174, "category": 1 /* Error */ },
        "Function expression declared a non-void return type, but has no return expression.": { "code": 2176, "category": 1 /* Error */ },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2177, "category": 1 /* Error */ },
        "Module '{0}' has no exported member '{1}'.": { "code": 2178, "category": 1 /* Error */ },
        "Unable to resolve module reference '{0}'.": { "code": 2179, "category": 1 /* Error */ },
        "Could not find module '{0}' in module '{1}'.": { "code": 2180, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": { "code": 2181, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": { "code": 2182, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": { "code": 2183, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": { "code": 2184, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": { "code": 2185, "category": 1 /* Error */ },
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": { "code": 2186, "category": 1 /* Error */ },
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": { "code": 2187, "category": 1 /* Error */ },
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": { "code": 2188, "category": 1 /* Error */ },
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": { "code": 2189, "category": 1 /* Error */ },
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": { "code": 2190, "category": 1 /* Error */ },
        "Ambient external module declaration cannot be reopened.": { "code": 2191, "category": 1 /* Error */ },
        "All declarations of merged declaration '{0}' must be exported or not exported.": { "code": 2192, "category": 1 /* Error */ },
        "'super' cannot be referenced in constructor arguments.": { "code": 2193, "category": 1 /* Error */ },
        "Return type of constructor signature must be assignable to the instance type of the class.": { "code": 2194, "category": 1 /* Error */ },
        "Ambient external module declaration must be defined in global context.": { "code": 2195, "category": 1 /* Error */ },
        "Ambient external module declaration cannot specify relative module name.": { "code": 2196, "category": 1 /* Error */ },
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": { "code": 2197, "category": 1 /* Error */ },
        "No best common type exists among return expressions.": { "code": 2198, "category": 1 /* Error */ },
        "Import declaration cannot refer to external module reference when --noResolve option is set.": { "code": 2199, "category": 1 /* Error */ },
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": { "code": 2200, "category": 1 /* Error */ },
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": { "code": 2205, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": { "code": 2206, "category": 1 /* Error */ },
        "Expression resolves to '_super' that compiler uses to capture base class reference.": { "code": 2207, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2208, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2209, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2210, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2211, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2212, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2213, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2214, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2215, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2216, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2217, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2218, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2219, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": { "code": 2220, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": { "code": 2221, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": { "code": 2222, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": { "code": 2223, "category": 1 /* Error */ },
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": { "code": 2224, "category": 1 /* Error */ },
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": { "code": 2225, "category": 1 /* Error */ },
        "No best common type exists between '{0}' and '{1}'.": { "code": 2226, "category": 1 /* Error */ },
        "No best common type exists between '{0}', '{1}', and '{2}'.": { "code": 2227, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": { "code": 2228, "category": 1 /* Error */ },
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": { "code": 2229, "category": 1 /* Error */ },
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": { "code": 2230, "category": 1 /* Error */ },
        "Parameter '{0}' cannot be referenced in its initializer.": { "code": 2231, "category": 1 /* Error */ },
        "Duplicate string index signature.": { "code": 2232, "category": 1 /* Error */ },
        "Duplicate number index signature.": { "code": 2233, "category": 1 /* Error */ },
        "All declarations of an interface must have identical type parameters.": { "code": 2234, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": { "code": 2235, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other.": { "code": 2236, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}": { "code": 2237, "category": 1 /* Error */ },
        "Duplicate function implementation.": { "code": 2237, "category": 1 /* Error */ },
        "Function implementation expected.": { "code": 2238, "category": 1 /* Error */ },
        "Function overload name must be '{0}'.": { "code": 2239, "category": 1 /* Error */ },
        "Constructor implementation expected.": { "code": 2240, "category": 1 /* Error */ },
        "Class name cannot be '{0}'.": { "code": 2241, "category": 1 /* Error */ },
        "Interface name cannot be '{0}'.": { "code": 2242, "category": 1 /* Error */ },
        "Enum name cannot be '{0}'.": { "code": 2243, "category": 1 /* Error */ },
        "A module cannot have multiple export assignments.": { "code": 2244, "category": 1 /* Error */ },
        "Export assignment not allowed in module with exported element.": { "code": 2245, "category": 1 /* Error */ },
        "A parameter property is only allowed in a constructor implementation.": { "code": 2246, "category": 1 /* Error */ },
        "Function overload must be static.": { "code": 2247, "category": 1 /* Error */ },
        "Function overload must not be static.": { "code": 2248, "category": 1 /* Error */ },
        "Type '{0}' is missing property '{1}' from type '{2}'.": { "code": 4000, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": { "code": 4001, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": { "code": 4002, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4003, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4004, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define property '{2}' as private.": { "code": 4005, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible.": { "code": 4006, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4007, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": { "code": 4008, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": { "code": 4009, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4010, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": { "code": 4011, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible.": { "code": 4012, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4013, "category": 3 /* NoPrefix */ },
        "Call signature expects {0} or fewer parameters.": { "code": 4014, "category": 3 /* NoPrefix */ },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": { "code": 4015, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4016, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4017, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": { "code": 4018, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": { "code": 4019, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": { "code": 4020, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": { "code": 4021, "category": 3 /* NoPrefix */ },
        "Type reference cannot refer to container '{0}'.": { "code": 4022, "category": 1 /* Error */ },
        "Type reference must refer to type.": { "code": 4023, "category": 1 /* Error */ },
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": { "code": 4024, "category": 1 /* Error */ },
        " (+ {0} overload(s))": { "code": 4025, "category": 2 /* Message */ },
        "Variable declaration cannot have the same name as an import declaration.": { "code": 4026, "category": 1 /* Error */ },
        "Signature expected {0} type arguments, got {1} instead.": { "code": 4027, "category": 1 /* Error */ },
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": { "code": 4028, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": { "code": 4029, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": { "code": 4030, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": { "code": 4031, "category": 3 /* NoPrefix */ },
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": { "code": 4032, "category": 3 /* NoPrefix */ },
        "Types of string indexer of types '{0}' and '{1}' are not identical.": { "code": 4033, "category": 3 /* NoPrefix */ },
        "Types of number indexer of types '{0}' and '{1}' are not identical.": { "code": 4034, "category": 3 /* NoPrefix */ },
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": { "code": 4035, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": { "code": 4036, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": { "code": 4037, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4038, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4039, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define static property '{2}' as private.": { "code": 4040, "category": 3 /* NoPrefix */ },
        "Current host does not support '{0}' option.": { "code": 5001, "category": 1 /* Error */ },
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": { "code": 5002, "category": 1 /* Error */ },
        "Argument for '{0}' option must be '{1}' or '{2}'": { "code": 5003, "category": 1 /* Error */ },
        "Could not find file: '{0}'.": { "code": 5004, "category": 1 /* Error */ },
        "A file cannot have a reference to itself.": { "code": 5006, "category": 1 /* Error */ },
        "Cannot resolve referenced file: '{0}'.": { "code": 5007, "category": 1 /* Error */ },
        "Cannot find the common subdirectory path for the input files.": { "code": 5009, "category": 1 /* Error */ },
        "Emit Error: {0}.": { "code": 5011, "category": 1 /* Error */ },
        "Cannot read file '{0}': {1}": { "code": 5012, "category": 1 /* Error */ },
        "Unsupported file encoding.": { "code": 5013, "category": 3 /* NoPrefix */ },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": { "code": 5014, "category": 1 /* Error */ },
        "Unsupported locale: '{0}'.": { "code": 5015, "category": 1 /* Error */ },
        "Execution Failed.{NL}": { "code": 5016, "category": 1 /* Error */ },
        "Invalid call to 'up'": { "code": 5019, "category": 1 /* Error */ },
        "Invalid call to 'down'": { "code": 5020, "category": 1 /* Error */ },
        "Base64 value '{0}' finished with a continuation bit.": { "code": 5021, "category": 1 /* Error */ },
        "Unknown compiler option '{0}'": { "code": 5023, "category": 1 /* Error */ },
        "Expected {0} arguments to message, got {1} instead.": { "code": 5024, "category": 1 /* Error */ },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": { "code": 5025, "category": 1 /* Error */ },
        "Could not delete file '{0}'": { "code": 5034, "category": 1 /* Error */ },
        "Could not create directory '{0}'": { "code": 5035, "category": 1 /* Error */ },
        "Error while executing file '{0}': ": { "code": 5036, "category": 1 /* Error */ },
        "Cannot compile external modules unless the '--module' flag is provided.": { "code": 5037, "category": 1 /* Error */ },
        "Option mapRoot cannot be specified without specifying sourcemap option.": { "code": 5038, "category": 1 /* Error */ },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5039, "category": 1 /* Error */ },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5040, "category": 1 /* Error */ },
        "Option '{0}' specified without '{1}'": { "code": 5041, "category": 1 /* Error */ },
        "'codepage' option not supported on current platform.": { "code": 5042, "category": 1 /* Error */ },
        "Concatenate and emit output to single file.": { "code": 6001, "category": 2 /* Message */ },
        "Generates corresponding {0} file.": { "code": 6002, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate map files instead of generated locations.": { "code": 6003, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": { "code": 6004, "category": 2 /* Message */ },
        "Watch input files.": { "code": 6005, "category": 2 /* Message */ },
        "Redirect output structure to the directory.": { "code": 6006, "category": 2 /* Message */ },
        "Do not emit comments to output.": { "code": 6009, "category": 2 /* Message */ },
        "Skip resolution and preprocessing.": { "code": 6010, "category": 2 /* Message */ },
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": { "code": 6015, "category": 2 /* Message */ },
        "Specify module code generation: '{0}' or '{1}'": { "code": 6016, "category": 2 /* Message */ },
        "Print this message.": { "code": 6017, "category": 2 /* Message */ },
        "Print the compiler's version: {0}": { "code": 6019, "category": 2 /* Message */ },
        "Allow use of deprecated '{0}' keyword when referencing an external module.": { "code": 6021, "category": 2 /* Message */ },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": { "code": 6022, "category": 2 /* Message */ },
        "Syntax:   {0}": { "code": 6023, "category": 2 /* Message */ },
        "options": { "code": 6024, "category": 2 /* Message */ },
        "file1": { "code": 6025, "category": 2 /* Message */ },
        "Examples:": { "code": 6026, "category": 2 /* Message */ },
        "Options:": { "code": 6027, "category": 2 /* Message */ },
        "Insert command line options and files from a file.": { "code": 6030, "category": 2 /* Message */ },
        "Version {0}": { "code": 6029, "category": 2 /* Message */ },
        "Use the '{0}' flag to see options.": { "code": 6031, "category": 2 /* Message */ },
        "{NL}Recompiling ({0}):": { "code": 6032, "category": 2 /* Message */ },
        "STRING": { "code": 6033, "category": 2 /* Message */ },
        "KIND": { "code": 6034, "category": 2 /* Message */ },
        "file2": { "code": 6035, "category": 2 /* Message */ },
        "VERSION": { "code": 6036, "category": 2 /* Message */ },
        "LOCATION": { "code": 6037, "category": 2 /* Message */ },
        "DIRECTORY": { "code": 6038, "category": 2 /* Message */ },
        "NUMBER": { "code": 6039, "category": 2 /* Message */ },
        "Specify the codepage to use when opening source files.": { "code": 6040, "category": 2 /* Message */ },
        "Additional locations:": { "code": 6041, "category": 2 /* Message */ },
        "This version of the Javascript runtime does not support the '{0}' function.": { "code": 7000, "category": 1 /* Error */ },
        "Unknown rule.": { "code": 7002, "category": 1 /* Error */ },
        "Invalid line number ({0})": { "code": 7003, "category": 1 /* Error */ },
        "Warn on expressions and declarations with an implied 'any' type.": { "code": 7004, "category": 2 /* Message */ },
        "Variable '{0}' implicitly has an 'any' type.": { "code": 7005, "category": 1 /* Error */ },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": { "code": 7006, "category": 1 /* Error */ },
        "Parameter '{0}' of function type implicitly has an 'any' type.": { "code": 7007, "category": 1 /* Error */ },
        "Member '{0}' of object type implicitly has an 'any' type.": { "code": 7008, "category": 1 /* Error */ },
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": { "code": 7009, "category": 1 /* Error */ },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7010, "category": 1 /* Error */ },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7011, "category": 1 /* Error */ },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": { "code": 7012, "category": 1 /* Error */ },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7013, "category": 1 /* Error */ },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7014, "category": 1 /* Error */ },
        "Array Literal implicitly has an 'any' type from widening.": { "code": 7015, "category": 1 /* Error */ },
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": { "code": 7016, "category": 1 /* Error */ },
        "Index signature of object type implicitly has an 'any' type.": { "code": 7017, "category": 1 /* Error */ },
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": { "code": 7018, "category": 1 /* Error */ }
    };
})(TypeScript || (TypeScript = {}));
// ///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error("Invalid argument: " + argument + ". " + message);
        };
        Errors.argumentOutOfRange = function (argument) {
            return new Error("Argument out of range: " + argument);
        };
        Errors.argumentNull = function (argument) {
            return new Error("Argument null: " + argument);
        };
        Errors.abstract = function () {
            return new Error("Operation not implemented properly by subclass.");
        };
        Errors.notYetImplemented = function () {
            return new Error("Not yet implemented.");
        };
        Errors.invalidOperation = function (message) {
            return new Error("Invalid operation: " + message);
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
///<reference path='errors.ts' />
var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }
            if (!array1 || !array2) {
                return false;
            }
            if (array1.length !== array2.length) {
                return false;
            }
            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
            return false;
        };
        // Gets unique element array
        ArrayUtilities.distinct = function (array, equalsFn) {
            var result = [];
            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }
                if (j === result.length) {
                    result.push(current);
                }
            }
            return result;
        };
        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }
            return array[array.length - 1];
        };
        ArrayUtilities.lastOrDefault = function (array, predicate) {
            for (var i = array.length - 1; i >= 0; i--) {
                var v = array[i];
                if (predicate(v, i)) {
                    return v;
                }
            }
            return undefined;
        };
        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value, i)) {
                    return value;
                }
            }
            return undefined;
        };
        ArrayUtilities.first = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (!func || func(value, i)) {
                    return value;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        ArrayUtilities.sum = function (array, func) {
            var result = 0;
            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }
            return result;
        };
        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);
            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }
            return result;
        };
        ArrayUtilities.where = function (values, func) {
            var result = new Array();
            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }
            return result;
        };
        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;
            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];
                if (midValue === value) {
                    return middle;
                }
                else if (midValue > value) {
                    high = middle - 1;
                }
                else {
                    low = middle + 1;
                }
            }
            return ~low;
        };
        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }
            return result;
        };
        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };
        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        ArrayUtilities.indexOf = function (array, predicate) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(TypeScript.AssertionLevel || (TypeScript.AssertionLevel = {}));
    var AssertionLevel = TypeScript.AssertionLevel;
    var Debug = (function () {
        function Debug() {
        }
        Debug.shouldAssert = function (level) {
            return this.currentAssertionLevel >= level;
        };
        Debug.assert = function (expression, message, verboseDebugInfo) {
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information:" + verboseDebugInfo();
                }
                message = message || "";
                throw new Error("Debug Failure. False expression: " + message + verboseDebugString);
            }
        };
        Debug.fail = function (message) {
            Debug.assert(false, message);
        };
        Debug.currentAssertionLevel = 0 /* None */;
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    var Location = (function () {
        function Location(fileName, lineMap, start, length) {
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._start = start;
            this._length = length;
        }
        Location.prototype.fileName = function () {
            return this._fileName;
        };
        Location.prototype.lineMap = function () {
            return this._lineMap;
        };
        Location.prototype.line = function () {
            return this._lineMap ? this._lineMap.getLineNumberFromPosition(this.start()) : 0;
        };
        Location.prototype.character = function () {
            return this._lineMap ? this._lineMap.getLineAndCharacterFromPosition(this.start()).character() : 0;
        };
        Location.prototype.start = function () {
            return this._start;
        };
        Location.prototype.length = function () {
            return this._length;
        };
        Location.equals = function (location1, location2) {
            return location1._fileName === location2._fileName && location1._start === location2._start && location1._length === location2._length;
        };
        return Location;
    })();
    TypeScript.Location = Location;
    var Diagnostic = (function (_super) {
        __extends(Diagnostic, _super);
        function Diagnostic(fileName, lineMap, start, length, diagnosticKey, _arguments, additionalLocations) {
            _super.call(this, fileName, lineMap, start, length);
            this._diagnosticKey = diagnosticKey;
            this._arguments = (_arguments && _arguments.length > 0) ? _arguments : undefined;
            this._additionalLocations = (additionalLocations && additionalLocations.length > 0) ? additionalLocations : undefined;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();
            result.diagnosticCode = this._diagnosticKey;
            var _arguments = this.arguments();
            if (_arguments && _arguments.length > 0) {
                result.arguments = _arguments;
            }
            return result;
        };
        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };
        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };
        /**
         * Get the text of the message in the given language.
         */
        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };
        /**
         * Get the text of the message including the error code in the given language.
         */
        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };
        /**
         * If a derived class has additional information about other referenced symbols, it can
         * expose the locations of those symbols in a general way, so they can be reported along
         * with the error.
         */
        Diagnostic.prototype.additionalLocations = function () {
            return this._additionalLocations || [];
        };
        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return Location.equals(diagnostic1, diagnostic2) && diagnostic1._diagnosticKey === diagnostic2._diagnosticKey && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) { return v1 === v2; });
        };
        Diagnostic.prototype.info = function () {
            return getDiagnosticInfoFromKey(this.diagnosticKey());
        };
        return Diagnostic;
    })(Location);
    TypeScript.Diagnostic = Diagnostic;
    function newLine() {
        // TODO: We need to expose an extensibility point on our hosts to have them tell us what 
        // they want the newline string to be.  That way we can get the correct result regardless
        // of which host we use
        return "\r\n";
    }
    TypeScript.newLine = newLine;
    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;
        var match;
        while (match = regex.exec(diagnostic)) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }
        return largest;
    }
    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];
        TypeScript.Debug.assert(result);
        return result;
    }
    function getLocalizedText(diagnosticKey, args) {
        var diagnosticMessageText = diagnosticKey;
        TypeScript.Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);
        var actualCount = args ? args.length : 0;
        // We have a string like "foo_0_bar_1".  We want to find the largest integer there.
        // (i.e.'1').  We then need one more arg than that to be correct.
        var expectedCount = 1 + getLargestIndex(diagnosticKey);
        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }
        // This should also be the same number of arguments as the message text
        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }
        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });
        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });
        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;
    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);
        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else if (diagnostic.category === 0 /* Warning */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else {
            message = diagnosticMessageText;
        }
        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities;
    (function (IntegerUtilities) {
        function integerDivide(numerator, denominator) {
            return (numerator / denominator) >> 0;
        }
        IntegerUtilities.integerDivide = integerDivide;
        function integerMultiplyLow32Bits(n1, n2) {
            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }
        IntegerUtilities.integerMultiplyLow32Bits = integerMultiplyLow32Bits;
        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }
        IntegerUtilities.isInteger = isInteger;
        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        IntegerUtilities.isHexInteger = isHexInteger;
    })(IntegerUtilities = TypeScript.IntegerUtilities || (TypeScript.IntegerUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_computeLineStarts, length) {
            this._computeLineStarts = _computeLineStarts;
            this.length = length;
            this._lineStarts = undefined;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this.lineStarts(), length: this.length };
        };
        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) { return v1 === v2; });
        };
        LineMap.prototype.lineStarts = function () {
            if (!this._lineStarts) {
                this._lineStarts = this._computeLineStarts();
            }
            return this._lineStarts;
        };
        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };
        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };
        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            if (position === this.length) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }
            // Binary search to find the right line
            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }
            return lineNumber;
        };
        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };
        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };
        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        LineMap.empty = new LineMap(function () { return [0]; }, 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        /**
         * Initializes a new instance of a LinePosition with the given line and character. ArgumentOutOfRangeException if "line" or "character" is less than zero.
         * @param line The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
         * @param character The character position in the line.
         */
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }
            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }
            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };
        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
// ///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };
        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };
        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };
        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='..\resources\references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems 
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["backtick"] = 96] = "backtick";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ScriptSnapshot;
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
                this._lineStartPositions = undefined;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                if (!this._lineStartPositions) {
                    this._lineStartPositions = TypeScript.TextUtilities.parseLineStarts(this.text);
                }
                return this._lineStartPositions;
            };
            StringScriptSnapshot.prototype.getChangeRange = function (oldSnapshot) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(ScriptSnapshot = TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineMap1;
    (function (LineMap1) {
        function fromSimpleText(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts({ charCodeAt: function (index) { return text.charCodeAt(index); }, length: text.length() }); }, text.length());
        }
        LineMap1.fromSimpleText = fromSimpleText;
        function fromScriptSnapshot(scriptSnapshot) {
            return new TypeScript.LineMap(function () { return scriptSnapshot.getLineStartPositions(); }, scriptSnapshot.getLength());
        }
        LineMap1.fromScriptSnapshot = fromScriptSnapshot;
        function fromString(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts(text); }, text.length);
        }
        LineMap1.fromString = fromString;
    })(LineMap1 = TypeScript.LineMap1 || (TypeScript.LineMap1 = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SimpleText;
    (function (SimpleText) {
        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
                this._lineMap = undefined;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };
            SimpleStringText.prototype.substr = function (start, length) {
                var val = this.value;
                return start === 0 && length == val.length ? val : val.substr(start, length);
            };
            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };
            SimpleStringText.prototype.lineMap = function () {
                if (!this._lineMap) {
                    this._lineMap = TypeScript.LineMap1.fromString(this.value);
                }
                return this._lineMap;
            };
            return SimpleStringText;
        })();
        // Class which wraps a host IScriptSnapshot and exposes an ISimpleText for newer compiler code. 
        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
                this._lineMap = undefined;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };
            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };
            SimpleScriptSnapshotText.prototype.substr = function (start, length) {
                return this.scriptSnapshot.getText(start, start + length);
            };
            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var _this = this;
                if (!this._lineMap) {
                    this._lineMap = new TypeScript.LineMap(function () { return _this.scriptSnapshot.getLineStartPositions(); }, this.length());
                }
                return this._lineMap;
            };
            return SimpleScriptSnapshotText;
        })();
        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;
        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(SimpleText = TypeScript.SimpleText || (TypeScript.SimpleText = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextUtilities;
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length;
            // Corner case check
            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }
            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;
            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;
                // common case - ASCII & not a line break
                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                }
                else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                }
                else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                }
                else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }
                if (0 === lineBreakLength) {
                    index++;
                }
                else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }
            // Create a start for the final line.  
            arrayBuilder.push(position);
            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;
        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            }
            else if (isAnyLineBreakCharacter(c)) {
                return 1;
            }
            else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;
        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);
            // common case - ASCII & not a line break
            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }
            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;
        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TextUtilities = TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        /**
         * Creates a TextSpan instance beginning with the position Start and having the Length
         * specified with length.
         */
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }
            if (length < 0) {
                TypeScript.Errors.argument("length");
            }
            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.toJSON = function (key) {
            return { start: this._start, length: this._length };
        };
        TextSpan.prototype.start = function () {
            return this._start;
        };
        TextSpan.prototype.length = function () {
            return this._length;
        };
        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };
        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };
        /**
         * Determines whether the position lies within the span. Returns true if the position is greater than or equal to Start and strictly less
         * than End, otherwise false.
         * @param position The position to check.
         */
        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };
        /**
         * Determines whether span falls completely within this span. Returns true if the specified span falls completely within this span, otherwise false.
         * @param span The span to check.
         */
        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };
        /**
         * Determines whether the given span overlaps this span. Two spans are considered to overlap
         * if they have positions in common and neither is empty. Empty spans do not overlap with any
         * other span. Returns true if the spans overlap, false otherwise.
         * @param span The span to check.
         */
        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());
            return overlapStart < overlapEnd;
        };
        /**
         * Returns the overlap with the given span, or undefined if there is no overlap.
         * @param span The span to check.
         */
        TextSpan.prototype.overlap = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());
            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }
            return undefined;
        };
        /**
         * Determines whether span intersects this span. Two spans are considered to
         * intersect if they have positions in common or the end of one span
         * coincides with the start of the other span. Returns true if the spans intersect, false otherwise.
         * @param The span to check.
         */
        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };
        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };
        /**
         * Determines whether the given position intersects this span.
         * A position is considered to intersect if it is between the start and
         * end positions (inclusive) of this span. Returns true if the position intersects, false otherwise.
         * @param position The position to check.
         */
        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };
        /**
         * Returns the intersection with the given span, or undefined if there is no intersection.
         * @param span The span to check.
         */
        TextSpan.prototype.intersection = function (span) {
            var intersectStart = Math.max(this._start, span._start);
            var intersectEnd = Math.min(this.end(), span.end());
            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }
            return undefined;
        };
        /**
         * Creates a new TextSpan from the given start and end positions
         * as opposed to a position and length.
         */
        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        /**
         * Initializes a new instance of TextChangeRange.
         */
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }
            this._span = span;
            this._newLength = newLength;
        }
        /**
         * The span of text before the edit which is being changed
         */
        TextChangeRange.prototype.span = function () {
            return this._span;
        };
        /**
         * Width of the span after the edit.  A 0 here would represent a delete
         */
        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };
        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };
        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };
        /**
         * Called to merge all the changes that occurred across several versions of a script snapshot
         * into a single change.  i.e. if a user keeps making successive edits to a script we will
         * have a text change from V1 to V2, V2 to V3, ..., Vn.
         *
         * This function will then merge those changes into a single change range valid between V1 and
         * Vn.
         */
        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }
            if (changes.length === 1) {
                return changes[0];
            }
            // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
            // as it makes things much easier to reason about.
            var change0 = changes[0];
            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();
            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];
                // Consider the following case:
                // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
                // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
                // i.e. the span starting at 30 with length 30 is increased to length 40.
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      -------------------------------------------------------------------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      -------------------------------------------------------------------------------------------------------
                //                                     |                            \                                          
                //                                     |                               \                                       
                //   T2                                |                                 \                                     
                //                                     |                                   \                                   
                //                                     |                                      \                                
                //      -------------------------------------------------------------------------------------------------------
                //
                // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
                // it's just the min of the old and new starts.  i.e.:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      ------------------------------------------------------------*------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      ----------------------------------------$-------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // (Note the dots represent the newly inferrred start.
                // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
                // absolute positions at the asterixes, and the relative change between the dollar signs. Basically, we see
                // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
                // means:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      --------------------------------------------------------------------------------*----------------------
                //                |                                                                     /                      
                //                |                                                                /----                       
                //  T1            |                                                           /----                            
                //                |                                                      /----                                 
                //                |                                                 /----                                      
                //      ------------------------------------------------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // In other words (in this case), we're recognizing that the second edit happened after where the first edit
                // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
                // that's the same as if we started at char 80 instead of 60.  
                //
                // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rahter
                // than pusing the first edit forward to match the second, we'll push the second edit forward to match the
                // first.
                //
                // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
                // semantics: { { start: 10, length: 70 }, newLength: 60 }
                //
                // The math then works out as follows.
                // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the 
                // final result like so:
                //
                // {
                //      oldStart3: Min(oldStart1, oldStart2),
                //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
                //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
                // }
                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;
                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();
                oldStartN = Math.min(oldStart1, oldStart2);
                oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }
            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
///<reference path='..\core\references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var CharacterInfo;
    (function (CharacterInfo) {
        function isDecimalDigit(c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        }
        CharacterInfo.isDecimalDigit = isDecimalDigit;
        function isOctalDigit(c) {
            return c >= 48 /* _0 */ && c <= 55 /* _7 */;
        }
        CharacterInfo.isOctalDigit = isOctalDigit;
        function isHexDigit(c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        }
        CharacterInfo.isHexDigit = isHexDigit;
        function hexValue(c) {
            // Debug.assert(isHexDigit(c));
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        }
        CharacterInfo.hexValue = hexValue;
        function isWhitespace(ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }
            return false;
        }
        CharacterInfo.isWhitespace = isWhitespace;
        function isLineTerminator(ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }
            return false;
        }
        CharacterInfo.isLineTerminator = isLineTerminator;
    })(CharacterInfo = TypeScript.CharacterInfo || (TypeScript.CharacterInfo = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["None"] = 0] = "None";
        // Masks that we use to place information about a node into a single int.  The first bit tells
        // us if we've computed the data for a node.
        //
        // The second bit tells us if the node is incrementally reusable if it does not
        // containe any skipped tokens, zero width tokens, regex tokens in it ("/", "/=" or "/.../"), 
        // and contains no tokens that were parser generated.
        //
        // The next bit lets us know if the nodes was parsed in a strict context or node.  A node can
        // only be used by the incremental parser if it is parsed in the same strict context as before.
        // last masks off the part of the int
        //
        // The width of the node is stored in the remainder of the int.  This allows us up to 512MB
        // for a node by using all 29 bits.  However, in the common case, we'll use less than 29 bits
        // for the width.  Thus, the info will be stored in a single int in chakra.
        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var FormattingOptions = (function () {
        function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
            this.useTabs = useTabs;
            this.spacesPerTab = spacesPerTab;
            this.indentSpaces = indentSpaces;
            this.newLineCharacter = newLineCharacter;
        }
        FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
        return FormattingOptions;
    })();
    TypeScript.FormattingOptions = FormattingOptions;
})(TypeScript || (TypeScript = {}));
// If you change anything in this enum, make sure you run SyntaxGenerator again!
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        // Variable width tokens, trivia and lists.
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        // Trivia
        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 2] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 3] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 4] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 5] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 6] = "SkippedTokenTrivia";
        // Note: all variable width tokens must come before all fixed width tokens.
        SyntaxKind[SyntaxKind["ErrorToken"] = 7] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 8] = "EndOfFileToken";
        // Tokens
        SyntaxKind[SyntaxKind["IdentifierName"] = 9] = "IdentifierName";
        // LiteralTokens
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 10] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 12] = "StringLiteral";
        // Template tokens
        SyntaxKind[SyntaxKind["NoSubstitutionTemplateToken"] = 13] = "NoSubstitutionTemplateToken";
        SyntaxKind[SyntaxKind["TemplateStartToken"] = 14] = "TemplateStartToken";
        SyntaxKind[SyntaxKind["TemplateMiddleToken"] = 15] = "TemplateMiddleToken";
        SyntaxKind[SyntaxKind["TemplateEndToken"] = 16] = "TemplateEndToken";
        // All fixed width tokens follow.
        // Keywords
        SyntaxKind[SyntaxKind["BreakKeyword"] = 17] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 18] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 19] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 20] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 21] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 22] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 23] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 24] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 25] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 26] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 27] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 28] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 29] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 30] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 31] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 32] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 33] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 34] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 35] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 36] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 37] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 38] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 39] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 40] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 41] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 42] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 43] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 44] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 45] = "WithKeyword";
        // FutureReservedWords.
        SyntaxKind[SyntaxKind["ClassKeyword"] = 46] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 47] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 48] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 49] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 50] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 51] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 52] = "SuperKeyword";
        // FutureReservedStrictWords.
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 53] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 54] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 55] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 56] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 57] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 58] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 59] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 60] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 61] = "YieldKeyword";
        // TypeScript keywords.
        SyntaxKind[SyntaxKind["AnyKeyword"] = 62] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 63] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 64] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 65] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 66] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 67] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 68] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 69] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 70] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 71] = "StringKeyword";
        // Punctuators
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 72] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 73] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 74] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 75] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 76] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 77] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 78] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 79] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 80] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 81] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 82] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 83] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 84] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 85] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 86] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 87] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 88] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 89] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 90] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 91] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 92] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 93] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 94] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 95] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 96] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 97] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 98] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 99] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 100] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 101] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 102] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 103] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 104] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 105] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 106] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 107] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 108] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 109] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 110] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 111] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 112] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 113] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 114] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 115] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 116] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 117] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 118] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 119] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 120] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 121] = "SlashEqualsToken";
        // SyntaxNodes
        SyntaxKind[SyntaxKind["SourceUnit"] = 122] = "SourceUnit";
        // Names
        SyntaxKind[SyntaxKind["QualifiedName"] = 123] = "QualifiedName";
        // Types
        SyntaxKind[SyntaxKind["ObjectType"] = 124] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 125] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 126] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 127] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 128] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 129] = "TypeQuery";
        SyntaxKind[SyntaxKind["TupleType"] = 130] = "TupleType";
        SyntaxKind[SyntaxKind["UnionType"] = 131] = "UnionType";
        SyntaxKind[SyntaxKind["ParenthesizedType"] = 132] = "ParenthesizedType";
        // Module elements.
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 133] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 134] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 135] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 136] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 137] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 138] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 139] = "ExportAssignment";
        // ClassElements
        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 140] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 141] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 142] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["IndexMemberDeclaration"] = 143] = "IndexMemberDeclaration";
        // ClassElement and PropertyAssignment
        SyntaxKind[SyntaxKind["GetAccessor"] = 144] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 145] = "SetAccessor";
        // Type members.
        SyntaxKind[SyntaxKind["PropertySignature"] = 146] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 147] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 148] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 149] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 150] = "MethodSignature";
        // Statements
        SyntaxKind[SyntaxKind["Block"] = 151] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 152] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 153] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 154] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 155] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 156] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 157] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 158] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 159] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 160] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 161] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 162] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 163] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 164] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 165] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 166] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 167] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 168] = "WithStatement";
        // Expressions
        SyntaxKind[SyntaxKind["PrefixUnaryExpression"] = 169] = "PrefixUnaryExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 170] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 171] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 172] = "VoidExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 173] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["BinaryExpression"] = 174] = "BinaryExpression";
        SyntaxKind[SyntaxKind["PostfixUnaryExpression"] = 175] = "PostfixUnaryExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 176] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 177] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 178] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 179] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 180] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 181] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 182] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 183] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 184] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 185] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 186] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 187] = "OmittedExpression";
        SyntaxKind[SyntaxKind["TemplateExpression"] = 188] = "TemplateExpression";
        SyntaxKind[SyntaxKind["TemplateAccessExpression"] = 189] = "TemplateAccessExpression";
        // Variable declarations
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 190] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 191] = "VariableDeclarator";
        // Lists
        SyntaxKind[SyntaxKind["ArgumentList"] = 192] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 193] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 194] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 195] = "TypeParameterList";
        // Clauses
        SyntaxKind[SyntaxKind["HeritageClause"] = 196] = "HeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 197] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 198] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 199] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 200] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 201] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 202] = "FinallyClause";
        SyntaxKind[SyntaxKind["TemplateClause"] = 203] = "TemplateClause";
        // Generics
        SyntaxKind[SyntaxKind["TypeParameter"] = 204] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 205] = "Constraint";
        // Property Assignment
        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 206] = "SimplePropertyAssignment";
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 207] = "FunctionPropertyAssignment";
        // Misc.
        SyntaxKind[SyntaxKind["Parameter"] = 208] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 209] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 210] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ComputedPropertyName"] = 211] = "ComputedPropertyName";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 212] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 213] = "ModuleNameModuleReference";
        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";
        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";
        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";
        SyntaxKind[SyntaxKind["FirstTrivia"] = SyntaxKind.WhitespaceTrivia] = "FirstTrivia";
        SyntaxKind[SyntaxKind["LastTrivia"] = SyntaxKind.SkippedTokenTrivia] = "LastTrivia";
        SyntaxKind[SyntaxKind["FirstNode"] = SyntaxKind.SourceUnit] = "FirstNode";
        SyntaxKind[SyntaxKind["LastNode"] = SyntaxKind.ModuleNameModuleReference] = "LastNode";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
///<reference path='syntaxKind.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 62 /* AnyKeyword */,
            "boolean": 63 /* BooleanKeyword */,
            "break": 17 /* BreakKeyword */,
            "case": 18 /* CaseKeyword */,
            "catch": 19 /* CatchKeyword */,
            "class": 46 /* ClassKeyword */,
            "continue": 20 /* ContinueKeyword */,
            "const": 47 /* ConstKeyword */,
            "constructor": 64 /* ConstructorKeyword */,
            "debugger": 21 /* DebuggerKeyword */,
            "declare": 65 /* DeclareKeyword */,
            "default": 22 /* DefaultKeyword */,
            "delete": 23 /* DeleteKeyword */,
            "do": 24 /* DoKeyword */,
            "else": 25 /* ElseKeyword */,
            "enum": 48 /* EnumKeyword */,
            "export": 49 /* ExportKeyword */,
            "extends": 50 /* ExtendsKeyword */,
            "false": 26 /* FalseKeyword */,
            "finally": 27 /* FinallyKeyword */,
            "for": 28 /* ForKeyword */,
            "function": 29 /* FunctionKeyword */,
            "get": 66 /* GetKeyword */,
            "if": 30 /* IfKeyword */,
            "implements": 53 /* ImplementsKeyword */,
            "import": 51 /* ImportKeyword */,
            "in": 31 /* InKeyword */,
            "instanceof": 32 /* InstanceOfKeyword */,
            "interface": 54 /* InterfaceKeyword */,
            "let": 55 /* LetKeyword */,
            "module": 67 /* ModuleKeyword */,
            "new": 33 /* NewKeyword */,
            "null": 34 /* NullKeyword */,
            "number": 69 /* NumberKeyword */,
            "package": 56 /* PackageKeyword */,
            "private": 57 /* PrivateKeyword */,
            "protected": 58 /* ProtectedKeyword */,
            "public": 59 /* PublicKeyword */,
            "require": 68 /* RequireKeyword */,
            "return": 35 /* ReturnKeyword */,
            "set": 70 /* SetKeyword */,
            "static": 60 /* StaticKeyword */,
            "string": 71 /* StringKeyword */,
            "super": 52 /* SuperKeyword */,
            "switch": 36 /* SwitchKeyword */,
            "this": 37 /* ThisKeyword */,
            "throw": 38 /* ThrowKeyword */,
            "true": 39 /* TrueKeyword */,
            "try": 40 /* TryKeyword */,
            "typeof": 41 /* TypeOfKeyword */,
            "var": 42 /* VarKeyword */,
            "void": 43 /* VoidKeyword */,
            "while": 44 /* WhileKeyword */,
            "with": 45 /* WithKeyword */,
            "yield": 61 /* YieldKeyword */,
            "{": 72 /* OpenBraceToken */,
            "}": 73 /* CloseBraceToken */,
            "(": 74 /* OpenParenToken */,
            ")": 75 /* CloseParenToken */,
            "[": 76 /* OpenBracketToken */,
            "]": 77 /* CloseBracketToken */,
            ".": 78 /* DotToken */,
            "...": 79 /* DotDotDotToken */,
            ";": 80 /* SemicolonToken */,
            ",": 81 /* CommaToken */,
            "<": 82 /* LessThanToken */,
            ">": 83 /* GreaterThanToken */,
            "<=": 84 /* LessThanEqualsToken */,
            ">=": 85 /* GreaterThanEqualsToken */,
            "==": 86 /* EqualsEqualsToken */,
            "=>": 87 /* EqualsGreaterThanToken */,
            "!=": 88 /* ExclamationEqualsToken */,
            "===": 89 /* EqualsEqualsEqualsToken */,
            "!==": 90 /* ExclamationEqualsEqualsToken */,
            "+": 91 /* PlusToken */,
            "-": 92 /* MinusToken */,
            "*": 93 /* AsteriskToken */,
            "%": 94 /* PercentToken */,
            "++": 95 /* PlusPlusToken */,
            "--": 96 /* MinusMinusToken */,
            "<<": 97 /* LessThanLessThanToken */,
            ">>": 98 /* GreaterThanGreaterThanToken */,
            ">>>": 99 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 100 /* AmpersandToken */,
            "|": 101 /* BarToken */,
            "^": 102 /* CaretToken */,
            "!": 103 /* ExclamationToken */,
            "~": 104 /* TildeToken */,
            "&&": 105 /* AmpersandAmpersandToken */,
            "||": 106 /* BarBarToken */,
            "?": 107 /* QuestionToken */,
            ":": 108 /* ColonToken */,
            "=": 109 /* EqualsToken */,
            "+=": 110 /* PlusEqualsToken */,
            "-=": 111 /* MinusEqualsToken */,
            "*=": 112 /* AsteriskEqualsToken */,
            "%=": 113 /* PercentEqualsToken */,
            "<<=": 114 /* LessThanLessThanEqualsToken */,
            ">>=": 115 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 116 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 117 /* AmpersandEqualsToken */,
            "|=": 118 /* BarEqualsToken */,
            "^=": 119 /* CaretEqualsToken */,
            "/": 120 /* SlashToken */,
            "/=": 121 /* SlashEqualsToken */
        };
        var kindToText = new Array();
        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                // Debug.assert(kindToText[textToKeywordKind[name]] === undefined);
                kindToText[textToKeywordKind[name]] = name;
            }
        }
        // Manually work around a bug in the CScript 5.8 runtime where 'constructor' is not
        // listed when SyntaxFacts.textToKeywordKind is enumerated because it is the name of
        // the constructor function.
        kindToText[64 /* ConstructorKeyword */] = "constructor";
        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }
            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;
        function getText(kind) {
            var result = kindToText[kind];
            return result; //  !== undefined ? result : undefined;
        }
        SyntaxFacts.getText = getText;
        function isAnyKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstKeyword && kind <= TypeScript.SyntaxKind.LastKeyword;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;
        function isAnyPunctuation(kind) {
            return kind >= TypeScript.SyntaxKind.FirstPunctuation && kind <= TypeScript.SyntaxKind.LastPunctuation;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;
        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 91 /* PlusToken */:
                case 92 /* MinusToken */:
                case 104 /* TildeToken */:
                case 103 /* ExclamationToken */:
                case 95 /* PlusPlusToken */:
                case 96 /* MinusMinusToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;
        function isBinaryExpressionOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 93 /* AsteriskToken */:
                case 120 /* SlashToken */:
                case 94 /* PercentToken */:
                case 91 /* PlusToken */:
                case 92 /* MinusToken */:
                case 97 /* LessThanLessThanToken */:
                case 98 /* GreaterThanGreaterThanToken */:
                case 99 /* GreaterThanGreaterThanGreaterThanToken */:
                case 82 /* LessThanToken */:
                case 83 /* GreaterThanToken */:
                case 84 /* LessThanEqualsToken */:
                case 85 /* GreaterThanEqualsToken */:
                case 32 /* InstanceOfKeyword */:
                case 31 /* InKeyword */:
                case 86 /* EqualsEqualsToken */:
                case 88 /* ExclamationEqualsToken */:
                case 89 /* EqualsEqualsEqualsToken */:
                case 90 /* ExclamationEqualsEqualsToken */:
                case 100 /* AmpersandToken */:
                case 102 /* CaretToken */:
                case 101 /* BarToken */:
                case 105 /* AmpersandAmpersandToken */:
                case 106 /* BarBarToken */:
                case 118 /* BarEqualsToken */:
                case 117 /* AmpersandEqualsToken */:
                case 119 /* CaretEqualsToken */:
                case 114 /* LessThanLessThanEqualsToken */:
                case 115 /* GreaterThanGreaterThanEqualsToken */:
                case 116 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 110 /* PlusEqualsToken */:
                case 111 /* MinusEqualsToken */:
                case 112 /* AsteriskEqualsToken */:
                case 121 /* SlashEqualsToken */:
                case 113 /* PercentEqualsToken */:
                case 109 /* EqualsToken */:
                case 81 /* CommaToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;
        function isAssignmentOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 118 /* BarEqualsToken */:
                case 117 /* AmpersandEqualsToken */:
                case 119 /* CaretEqualsToken */:
                case 114 /* LessThanLessThanEqualsToken */:
                case 115 /* GreaterThanGreaterThanEqualsToken */:
                case 116 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 110 /* PlusEqualsToken */:
                case 111 /* MinusEqualsToken */:
                case 112 /* AsteriskEqualsToken */:
                case 121 /* SlashEqualsToken */:
                case 113 /* PercentEqualsToken */:
                case 109 /* EqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAssignmentOperatorToken = isAssignmentOperatorToken;
        function isType(kind) {
            switch (kind) {
                case 126 /* ArrayType */:
                case 62 /* AnyKeyword */:
                case 69 /* NumberKeyword */:
                case 63 /* BooleanKeyword */:
                case 71 /* StringKeyword */:
                case 43 /* VoidKeyword */:
                case 125 /* FunctionType */:
                case 124 /* ObjectType */:
                case 127 /* ConstructorType */:
                case 129 /* TypeQuery */:
                case 128 /* GenericType */:
                case 123 /* QualifiedName */:
                case 9 /* IdentifierName */:
                    return true;
            }
            return false;
        }
        SyntaxFacts.isType = isType;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Scanner;
    (function (Scanner) {
        // Make sure we can encode a token's kind in 7 bits.
        TypeScript.Debug.assert(TypeScript.SyntaxKind.LastToken <= 127);
        // Fixed width tokens (keywords and punctuation) that have no trivia generally make up 30% of
        // all the tokens in a program.  We heavily optimize for that case with a token instance that
        // just needs a parent pointer and a single 30bit int like so:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx x000 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 23 bits for the start of the token.  We don't need to store the width as it
        // can be inferred from the 'kind' for a fixed width token.
        // 
        // For small tokens, we encode the data in one 30bit int like so:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 xxxx x000 0000    <-- full width
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx 0000 0000 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This allows for 5bits for teh width.  i.e. tokens up to 31 chars in width.  And 18 bits for
        // the full start.  This allows for tokens starting up to and including position 262,143.
        //
        // In practice, for codebases we have measured, these values are sufficient to cover ~85% of 
        // all tokens.  If a token won't fit within those limits, we make a large token for it.
        //
        //
        // For large tokens, we encode data with two 30 bit ints like so:
        //
        //   _packedFullStartAndInfo:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 000x    <-- has leading trivia
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 00x0    <-- has leading comment (implies has leading trivia)
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x00    <-- has trailing trivia
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 x000    <-- has trailing comment (implies has trailing trivia)
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx xxxx 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 26 bits for the start of the token.  At 64MB That's more than enough for
        // any codebase.
        //
        //   _packedFullWidthAndKind:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx x000 0000    <-- full width
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 23bit for width (or 8MB of width which should be enough for any codebase).
        var ScannerConstants;
        (function (ScannerConstants) {
            ScannerConstants[ScannerConstants["LargeTokenFullWidthShift"] = 3] = "LargeTokenFullWidthShift";
            ScannerConstants[ScannerConstants["WhitespaceTrivia"] = 0x01] = "WhitespaceTrivia";
            ScannerConstants[ScannerConstants["NewlineTrivia"] = 0x02] = "NewlineTrivia";
            ScannerConstants[ScannerConstants["CommentTrivia"] = 0x04] = "CommentTrivia";
            ScannerConstants[ScannerConstants["TriviaMask"] = 0x07] = "TriviaMask";
            ScannerConstants[ScannerConstants["KindMask"] = 0x7F] = "KindMask";
            ScannerConstants[ScannerConstants["IsVariableWidthMask"] = 0x80] = "IsVariableWidthMask";
        })(ScannerConstants || (ScannerConstants = {}));
        function largeTokenPackData(fullWidth, leadingTriviaInfo) {
            return (fullWidth << 3 /* LargeTokenFullWidthShift */) | leadingTriviaInfo;
        }
        function largeTokenUnpackFullWidth(packedFullWidthAndInfo) {
            return packedFullWidthAndInfo >> 3 /* LargeTokenFullWidthShift */;
        }
        function largeTokenUnpackLeadingTriviaInfo(packedFullWidthAndInfo) {
            return packedFullWidthAndInfo & 7 /* TriviaMask */;
        }
        function largeTokenUnpackHasLeadingTrivia(packed) {
            return largeTokenUnpackLeadingTriviaInfo(packed) !== 0;
        }
        function hasComment(info) {
            return (info & 4 /* CommentTrivia */) !== 0;
        }
        function hasNewLine(info) {
            return (info & 2 /* NewlineTrivia */) !== 0;
        }
        function largeTokenUnpackHasLeadingNewLine(packed) {
            return hasNewLine(largeTokenUnpackLeadingTriviaInfo(packed));
        }
        function largeTokenUnpackHasLeadingComment(packed) {
            return hasComment(largeTokenUnpackLeadingTriviaInfo(packed));
        }
        var isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, 0);
        var isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
        var isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
        for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
            if ((character >= 97 /* a */ && character <= 122 /* z */) || (character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
                isIdentifierStartCharacter[character] = true;
                isIdentifierPartCharacter[character] = true;
            }
            else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
                isIdentifierPartCharacter[character] = true;
            }
        }
        for (var keywordKind = TypeScript.SyntaxKind.FirstKeyword; keywordKind <= TypeScript.SyntaxKind.LastKeyword; keywordKind++) {
            var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
            isKeywordStartCharacter[keyword.charCodeAt(0)] = 1;
        }
        function isContextualToken(token) {
            switch (token.kind) {
                case 10 /* RegularExpressionLiteral */:
                case 98 /* GreaterThanGreaterThanToken */:
                case 99 /* GreaterThanGreaterThanGreaterThanToken */:
                case 85 /* GreaterThanEqualsToken */:
                case 115 /* GreaterThanGreaterThanEqualsToken */:
                case 116 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;
                case 15 /* TemplateMiddleToken */:
                case 16 /* TemplateEndToken */:
                    return true;
                default:
                    return token.isKeywordConvertedToIdentifier();
            }
        }
        Scanner.isContextualToken = isContextualToken;
        var lastTokenInfo = { leadingTriviaWidth: -1 };
        var lastTokenInfoTokenID = -1;
        var triviaScanner = createScannerInternal(2 /* Latest */, TypeScript.SimpleText.fromString(""), function () {
        });
        function fillSizeInfo(token, text) {
            if (lastTokenInfoTokenID !== TypeScript.syntaxID(token)) {
                triviaScanner.fillTokenInfo(token, text, lastTokenInfo);
                lastTokenInfoTokenID = TypeScript.syntaxID(token);
            }
        }
        function fullText(token, text) {
            return text.substr(token.fullStart(), token.fullWidth());
        }
        function leadingTrivia(token, text) {
            if (!token.hasLeadingTrivia()) {
                return TypeScript.Syntax.emptyTriviaList;
            }
            return triviaScanner.scanTrivia(token, text);
        }
        function leadingTriviaWidth(token, text) {
            if (!token.hasLeadingTrivia()) {
                return 0;
            }
            fillSizeInfo(token, text);
            return lastTokenInfo.leadingTriviaWidth;
        }
        function tokenIsIncrementallyUnusable(token) {
            // No scanner tokens make their *containing node* incrementally unusable.  
            // Note: several scanner tokens may themselves be unusable.  i.e. if the parser asks
            // for a full node, then that ndoe can be returned even if it contains parser generated
            // tokens (like regexs and merged operator tokens). However, if the parser asks for a
            // for a token, then those contextual tokens will not be reusable.
            return false;
        }
        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(_fullStart, kind) {
                this._fullStart = _fullStart;
                this.kind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.setFullStart = function (fullStart) {
                this._fullStart = fullStart;
            };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.invalidOperation();
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return TypeScript.SyntaxFacts.getText(this.kind);
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return this.fullText();
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return fixedWidthTokenLength(this.kind);
            };
            FixedWidthTokenWithNoTrivia.prototype.fullStart = function () {
                return this._fullStart;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this._fullStart, this.kind);
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        FixedWidthTokenWithNoTrivia.prototype.childCount = 0;
        var LargeScannerToken = (function () {
            function LargeScannerToken(_fullStart, kind, _packedFullWidthAndInfo, cachedText) {
                this._fullStart = _fullStart;
                this.kind = kind;
                this._packedFullWidthAndInfo = _packedFullWidthAndInfo;
                if (cachedText !== undefined) {
                    this.cachedText = cachedText;
                }
            }
            LargeScannerToken.prototype.setFullStart = function (fullStart) {
                this._fullStart = fullStart;
            };
            LargeScannerToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.invalidOperation();
            };
            LargeScannerToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };
            LargeScannerToken.prototype.isIncrementallyUnusable = function () {
                return tokenIsIncrementallyUnusable(this);
            };
            LargeScannerToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            LargeScannerToken.prototype.fullText = function (text) {
                return fullText(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.text = function () {
                var cachedText = this.cachedText;
                return cachedText !== undefined ? cachedText : TypeScript.SyntaxFacts.getText(this.kind);
            };
            LargeScannerToken.prototype.leadingTrivia = function (text) {
                return leadingTrivia(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.leadingTriviaWidth = function (text) {
                return leadingTriviaWidth(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.fullWidth = function () {
                return largeTokenUnpackFullWidth(this._packedFullWidthAndInfo);
            };
            LargeScannerToken.prototype.fullStart = function () {
                return this._fullStart;
            };
            LargeScannerToken.prototype.hasLeadingTrivia = function () {
                return largeTokenUnpackHasLeadingTrivia(this._packedFullWidthAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingNewLine = function () {
                return largeTokenUnpackHasLeadingNewLine(this._packedFullWidthAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingComment = function () {
                return largeTokenUnpackHasLeadingComment(this._packedFullWidthAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingSkippedToken = function () {
                return false;
            };
            LargeScannerToken.prototype.clone = function () {
                return new LargeScannerToken(this._fullStart, this.kind, this._packedFullWidthAndInfo, this.cachedText);
            };
            return LargeScannerToken;
        })();
        LargeScannerToken.prototype.childCount = 0;
        function createScanner(languageVersion, text, reportDiagnostic) {
            var scanner = createScannerInternal(languageVersion, text, reportDiagnostic);
            return {
                setIndex: scanner.setIndex,
                scan: scanner.scan
            };
        }
        Scanner.createScanner = createScanner;
        function createScannerInternal(languageVersion, text, reportDiagnostic) {
            var str;
            var index;
            var start;
            var end;
            function setIndex(_index) {
                index = _index;
            }
            function reset(_text, _start, _end) {
                var textLength = _text.length();
                TypeScript.Debug.assert(_start <= textLength, "Token's start was not within the bounds of text.");
                TypeScript.Debug.assert(_end <= textLength, "Token's end was not within the bounds of text:");
                if (!str || text !== _text) {
                    text = _text;
                    str = _text.substr(0, textLength);
                }
                start = _start;
                end = _end;
                index = _start;
            }
            function scan(allowContextualToken) {
                var fullStart = index;
                var leadingTriviaInfo = scanTriviaInfo();
                var start = index;
                var kindAndIsVariableWidth = scanSyntaxKind(allowContextualToken);
                var fullEnd = index;
                var fullWidth = fullEnd - fullStart;
                // If we have no trivia, and we are a fixed width token kind, and our size isn't too 
                // large, and we're a real fixed width token (and not something like "\u0076ar").
                var kind = kindAndIsVariableWidth & 127 /* KindMask */;
                var isFixedWidth = kind >= TypeScript.SyntaxKind.FirstFixedWidth && kind <= TypeScript.SyntaxKind.LastFixedWidth && ((kindAndIsVariableWidth & 128 /* IsVariableWidthMask */) === 0);
                if (isFixedWidth && leadingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(fullStart, kind);
                }
                else {
                    var packedFullWidthAndInfo = largeTokenPackData(fullWidth, leadingTriviaInfo);
                    var cachedText = isFixedWidth ? undefined : text.substr(start, fullEnd - start);
                    return new LargeScannerToken(fullStart, kind, packedFullWidthAndInfo, cachedText);
                }
            }
            function scanTrivia(parent, text) {
                var tokenFullStart = parent.fullStart();
                var tokenStart = tokenFullStart + leadingTriviaWidth(parent, text);
                reset(text, tokenFullStart, tokenStart);
                // Debug.assert(length > 0);
                // Keep this exactly in sync with scanTriviaInfo
                var trivia = [];
                while (true) {
                    if (index < end) {
                        var ch = str.charCodeAt(index);
                        switch (ch) {
                            case 32 /* space */:
                            case 160 /* nonBreakingSpace */:
                            case 8192 /* enQuad */:
                            case 8193 /* emQuad */:
                            case 8194 /* enSpace */:
                            case 8195 /* emSpace */:
                            case 8196 /* threePerEmSpace */:
                            case 8197 /* fourPerEmSpace */:
                            case 8198 /* sixPerEmSpace */:
                            case 8199 /* figureSpace */:
                            case 8200 /* punctuationSpace */:
                            case 8201 /* thinSpace */:
                            case 8202 /* hairSpace */:
                            case 8203 /* zeroWidthSpace */:
                            case 8239 /* narrowNoBreakSpace */:
                            case 12288 /* ideographicSpace */:
                            case 9 /* tab */:
                            case 11 /* verticalTab */:
                            case 12 /* formFeed */:
                            case 65279 /* byteOrderMark */:
                                // Normal whitespace.  Consume and continue.
                                trivia.push(scanWhitespaceTrivia());
                                continue;
                            case 47 /* slash */:
                                // Potential comment.  Consume if so.  Otherwise, break out and return.
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    trivia.push(scanSingleLineCommentTrivia());
                                    continue;
                                }
                                if (ch2 === 42 /* asterisk */) {
                                    trivia.push(scanMultiLineCommentTrivia());
                                    continue;
                                }
                                throw TypeScript.Errors.invalidOperation();
                            case 13 /* carriageReturn */:
                            case 10 /* lineFeed */:
                            case 8233 /* paragraphSeparator */:
                            case 8232 /* lineSeparator */:
                                trivia.push(scanLineTerminatorSequenceTrivia(ch));
                                continue;
                            default:
                                throw TypeScript.Errors.invalidOperation();
                        }
                    }
                    // Debug.assert(trivia.length > 0);
                    var triviaList = TypeScript.Syntax.triviaList(trivia);
                    triviaList.parent = parent;
                    return triviaList;
                }
            }
            // Returns 0 if there was no trivia, or 1 if there was trivia.  Returned as an int instead 
            // of a boolean because we'll need a numerical value later on to store in our tokens.
            function scanTriviaInfo() {
                // Keep this exactly in sync with scanTrivia
                var result = 0;
                var _end = end;
                while (index < _end) {
                    var ch = str.charCodeAt(index);
                    switch (ch) {
                        case 9 /* tab */:
                        case 32 /* space */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                            index++;
                            // we have trivia
                            result |= 1 /* WhitespaceTrivia */;
                            continue;
                        case 13 /* carriageReturn */:
                            if ((index + 1) < end && str.charCodeAt(index + 1) === 10 /* lineFeed */) {
                                index++;
                            }
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            index++;
                            // we have trivia
                            result |= 2 /* NewlineTrivia */;
                            continue;
                        case 47 /* slash */:
                            if ((index + 1) < _end) {
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    // we have a comment, and we have trivia
                                    result |= 4 /* CommentTrivia */;
                                    skipSingleLineCommentTrivia();
                                    continue;
                                }
                                if (ch2 === 42 /* asterisk */) {
                                    // we have a comment, and we have trivia
                                    result |= 4 /* CommentTrivia */;
                                    skipMultiLineCommentTrivia();
                                    continue;
                                }
                            }
                            // Not a comment.  Don't consume.
                            return result;
                        default:
                            if (ch > 127 /* maxAsciiCharacter */ && slowScanWhitespaceTriviaInfo(ch)) {
                                result |= 1 /* WhitespaceTrivia */;
                                continue;
                            }
                            return result;
                    }
                }
                return result;
            }
            function slowScanWhitespaceTriviaInfo(ch) {
                switch (ch) {
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:
                    case 65279 /* byteOrderMark */:
                        index++;
                        return true;
                    default:
                        return false;
                }
            }
            function isNewLineCharacter(ch) {
                switch (ch) {
                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        return true;
                    default:
                        return false;
                }
            }
            function scanWhitespaceTrivia() {
                // We're going to be extracting text out of sliding window.  Make sure it can't move past
                // this point.
                var absoluteStartIndex = index;
                while (true) {
                    var ch = str.charCodeAt(index);
                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:
                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            // Normal whitespace.  Consume and continue.
                            index++;
                            continue;
                    }
                    break;
                }
                return createTrivia(2 /* WhitespaceTrivia */, absoluteStartIndex);
            }
            function createTrivia(kind, absoluteStartIndex) {
                var fullWidth = index - absoluteStartIndex;
                return TypeScript.Syntax.deferredTrivia(kind, text, absoluteStartIndex, fullWidth);
            }
            function scanSingleLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipSingleLineCommentTrivia();
                return createTrivia(5 /* SingleLineCommentTrivia */, absoluteStartIndex);
            }
            function skipSingleLineCommentTrivia() {
                index += 2;
                while (index < end) {
                    if (isNewLineCharacter(str.charCodeAt(index))) {
                        return;
                    }
                    index++;
                }
            }
            function scanMultiLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipMultiLineCommentTrivia();
                return createTrivia(4 /* MultiLineCommentTrivia */, absoluteStartIndex);
            }
            function skipMultiLineCommentTrivia() {
                // The '2' is for the "/*" we consumed.
                var _index = index + 2;
                var _end = end;
                index += 2;
                while (true) {
                    if (_index === _end) {
                        reportDiagnostic(end, 0, TypeScript.DiagnosticCode._0_expected, ["*/"]);
                        break;
                    }
                    if ((_index + 1) < _end && str.charCodeAt(_index) === 42 /* asterisk */ && str.charCodeAt(_index + 1) === 47 /* slash */) {
                        _index += 2;
                        break;
                    }
                    _index++;
                }
                index = _index;
            }
            function scanLineTerminatorSequenceTrivia(ch) {
                var absoluteStartIndex = index;
                skipLineTerminatorSequence(ch);
                return createTrivia(3 /* NewLineTrivia */, absoluteStartIndex);
            }
            function skipLineTerminatorSequence(ch) {
                // Consume the first of the line terminator we saw.
                index++;
                // If it happened to be a \r and there's a following \n, then consume both.
                if (ch === 13 /* carriageReturn */ && str.charCodeAt(index) === 10 /* lineFeed */) {
                    index++;
                }
            }
            function scanSyntaxKind(allowContextualToken) {
                if (index >= end) {
                    return 8 /* EndOfFileToken */;
                }
                var character = str.charCodeAt(index);
                index++;
                switch (character) {
                    case 33 /* exclamation */: return scanExclamationToken();
                    case 34 /* doubleQuote */: return scanStringLiteral(character);
                    case 37 /* percent */: return scanPercentToken();
                    case 38 /* ampersand */: return scanAmpersandToken();
                    case 39 /* singleQuote */: return scanStringLiteral(character);
                    case 40 /* openParen */: return 74 /* OpenParenToken */;
                    case 41 /* closeParen */: return 75 /* CloseParenToken */;
                    case 42 /* asterisk */: return scanAsteriskToken();
                    case 43 /* plus */: return scanPlusToken();
                    case 44 /* comma */: return 81 /* CommaToken */;
                    case 45 /* minus */: return scanMinusToken();
                    case 46 /* dot */: return scanDotToken();
                    case 47 /* slash */: return scanSlashToken(allowContextualToken);
                    case 48 /* _0 */:
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        return scanNumericLiteral(character);
                    case 58 /* colon */: return 108 /* ColonToken */;
                    case 59 /* semicolon */: return 80 /* SemicolonToken */;
                    case 60 /* lessThan */: return scanLessThanToken();
                    case 61 /* equals */: return scanEqualsToken();
                    case 62 /* greaterThan */: return scanGreaterThanToken(allowContextualToken);
                    case 63 /* question */: return 107 /* QuestionToken */;
                    case 91 /* openBracket */: return 76 /* OpenBracketToken */;
                    case 93 /* closeBracket */: return 77 /* CloseBracketToken */;
                    case 94 /* caret */: return scanCaretToken();
                    case 96 /* backtick */: return scanTemplateToken(character);
                    case 123 /* openBrace */: return 72 /* OpenBraceToken */;
                    case 124 /* bar */: return scanBarToken();
                    case 125 /* closeBrace */: return scanCloseBraceToken(allowContextualToken, character);
                    case 126 /* tilde */: return 104 /* TildeToken */;
                }
                // We run into so many identifiers (and keywords) when scanning, that we want the code to
                // be as fast as possible.  To that end, we have an extremely fast path for scanning that
                // handles the 99.9% case of no-unicode characters and no unicode escapes.
                if (isIdentifierStartCharacter[character]) {
                    var result = tryFastScanIdentifierOrKeyword(character);
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }
                // Move the index back one and try the slow path.
                index--;
                if (isIdentifierStart(peekCharOrUnicodeEscape())) {
                    return slowScanIdentifierOrKeyword();
                }
                // Was nothing that we could understand.  Report the issue and keep moving on.
                var text = String.fromCharCode(character);
                var messageText = getErrorMessageText(text);
                reportDiagnostic(index, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [messageText]);
                index++;
                return 7 /* ErrorToken */;
            }
            function isIdentifierStart(interpretedChar) {
                if (isIdentifierStartCharacter[interpretedChar]) {
                    return true;
                }
                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, languageVersion);
            }
            function isIdentifierPart(interpretedChar) {
                if (isIdentifierPartCharacter[interpretedChar]) {
                    return true;
                }
                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, languageVersion);
            }
            function tryFastScanIdentifierOrKeyword(firstCharacter) {
                var startIndex = index;
                var character = firstCharacter;
                while (index < end) {
                    character = str.charCodeAt(index);
                    if (!isIdentifierPartCharacter[character]) {
                        break;
                    }
                    index++;
                }
                if (index < end && (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */)) {
                    // We saw a \ (which could start a unicode escape), or we saw a unicode character.
                    // This can't be scanned quickly.  Don't update the window position and just bail out
                    // to the slow path.
                    index = startIndex;
                    return 0 /* None */;
                }
                else {
                    // Saw an ascii character that wasn't a backslash and wasn't an identifier 
                    // character.  Or we hit the end of the file  This identifier is done.
                    // Also check if it a keyword if it started with a keyword start char.
                    if (isKeywordStartCharacter[firstCharacter]) {
                        return TypeScript.ScannerUtilities.identifierKind(str, startIndex - 1, index - startIndex + 1);
                    }
                    else {
                        return 9 /* IdentifierName */;
                    }
                }
            }
            // A slow path for scanning identifiers.  Called when we run into a unicode character or
            // escape sequence while processing the fast path.
            function slowScanIdentifierOrKeyword() {
                var startIndex = index;
                do {
                    scanCharOrUnicodeEscape();
                } while (isIdentifierPart(peekCharOrUnicodeEscape()));
                // From ES6 specification.
                // The ReservedWord definitions are specified as literal sequences of Unicode 
                // characters.However, any Unicode character in a ReservedWord can also be 
                // expressed by a \ UnicodeEscapeSequence that expresses that same Unicode 
                // character's code point.Use of such escape sequences does not change the meaning 
                // of the ReservedWord.
                //
                // i.e. "\u0076ar" is the keyword 'var'.  Check for that here.
                var length = index - startIndex;
                var text = str.substr(startIndex, length);
                var valueText = TypeScript.massageEscapes(text);
                var keywordKind = TypeScript.SyntaxFacts.getTokenKind(valueText);
                if (keywordKind >= TypeScript.SyntaxKind.FirstKeyword && keywordKind <= TypeScript.SyntaxKind.LastKeyword) {
                    // We have a keyword, but it is also variable width.  We can't put represent this
                    // width a fixed width token.
                    return keywordKind | 128 /* IsVariableWidthMask */;
                }
                return 9 /* IdentifierName */;
            }
            function scanNumericLiteral(ch) {
                if (isHexNumericLiteral(ch)) {
                    scanHexNumericLiteral();
                }
                else if (isOctalNumericLiteral(ch)) {
                    scanOctalNumericLiteral();
                }
                else {
                    scanDecimalNumericLiteral();
                }
                return 11 /* NumericLiteral */;
            }
            function isOctalNumericLiteral(ch) {
                return ch === 48 /* _0 */ && TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index));
            }
            function scanOctalNumericLiteral() {
                var start = index - 1;
                while (TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index))) {
                    index++;
                }
                if (languageVersion >= 1 /* ES5 */) {
                    reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher, undefined);
                }
            }
            function scanDecimalDigits() {
                while (TypeScript.CharacterInfo.isDecimalDigit(str.charCodeAt(index))) {
                    index++;
                }
            }
            function scanDecimalNumericLiteral() {
                scanDecimalDigits();
                if (str.charCodeAt(index) === 46 /* dot */) {
                    index++;
                }
                scanDecimalNumericLiteralAfterDot();
            }
            function scanDecimalNumericLiteralAfterDot() {
                scanDecimalDigits();
                // If we see an 'e' or 'E' we should only consume it if its of the form:
                // e<number> or E<number> 
                // e+<number>   E+<number>
                // e-<number>   E-<number>
                var ch = str.charCodeAt(index);
                if (ch === 101 /* e */ || ch === 69 /* E */) {
                    // Ok, we've got 'e' or 'E'.  Make sure it's followed correctly.
                    var nextChar1 = str.charCodeAt(index + 1);
                    if (TypeScript.CharacterInfo.isDecimalDigit(nextChar1)) {
                        // e<number> or E<number>
                        // Consume 'e' or 'E' and the number portion.
                        index++;
                        scanDecimalDigits();
                    }
                    else if (nextChar1 === 45 /* minus */ || nextChar1 === 43 /* plus */) {
                        // e+ or E+ or e- or E-
                        var nextChar2 = str.charCodeAt(index + 2);
                        if (TypeScript.CharacterInfo.isDecimalDigit(nextChar2)) {
                            // e+<number> or E+<number> or e-<number> or E-<number>
                            // Consume first two characters and the number portion.
                            index += 2;
                            scanDecimalDigits();
                        }
                    }
                }
            }
            function scanHexNumericLiteral() {
                // Move past the x.
                index++;
                while (TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index))) {
                    index++;
                }
            }
            function isHexNumericLiteral(ch) {
                if (ch === 48 /* _0 */) {
                    var ch = str.charCodeAt(index);
                    if (ch === 120 /* x */ || ch === 88 /* X */) {
                        return TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index + 1));
                    }
                }
                return false;
            }
            function scanLessThanToken() {
                var ch0 = str.charCodeAt(index);
                if (ch0 === 61 /* equals */) {
                    index++;
                    return 84 /* LessThanEqualsToken */;
                }
                else if (ch0 === 60 /* lessThan */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 114 /* LessThanLessThanEqualsToken */;
                    }
                    else {
                        return 97 /* LessThanLessThanToken */;
                    }
                }
                else {
                    return 82 /* LessThanToken */;
                }
            }
            function scanGreaterThanToken(allowContextualToken) {
                if (allowContextualToken) {
                    var ch0 = str.charCodeAt(index);
                    if (ch0 === 62 /* greaterThan */) {
                        // >>
                        index++;
                        var ch1 = str.charCodeAt(index);
                        if (ch1 === 62 /* greaterThan */) {
                            // >>>
                            index++;
                            var ch2 = str.charCodeAt(index);
                            if (ch2 === 61 /* equals */) {
                                // >>>=
                                index++;
                                return 116 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                            }
                            else {
                                return 99 /* GreaterThanGreaterThanGreaterThanToken */;
                            }
                        }
                        else if (ch1 === 61 /* equals */) {
                            // >>=
                            index++;
                            return 115 /* GreaterThanGreaterThanEqualsToken */;
                        }
                        else {
                            return 98 /* GreaterThanGreaterThanToken */;
                        }
                    }
                    else if (ch0 === 61 /* equals */) {
                        // >=
                        index++;
                        return 85 /* GreaterThanEqualsToken */;
                    }
                }
                return 83 /* GreaterThanToken */;
            }
            function scanBarToken() {
                var ch = str.charCodeAt(index);
                if (ch === 61 /* equals */) {
                    index++;
                    return 118 /* BarEqualsToken */;
                }
                else if (ch === 124 /* bar */) {
                    index++;
                    return 106 /* BarBarToken */;
                }
                else {
                    return 101 /* BarToken */;
                }
            }
            function scanCaretToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 119 /* CaretEqualsToken */;
                }
                else {
                    return 102 /* CaretToken */;
                }
            }
            function scanCloseBraceToken(allowContextualToken, startChar) {
                return allowContextualToken ? scanTemplateToken(startChar) : 73 /* CloseBraceToken */;
            }
            function scanTemplateToken(startChar) {
                var startedWithBacktick = startChar === 96 /* backtick */;
                while (true) {
                    if (index === end) {
                        // Hit the end of the file.  
                        reportDiagnostic(end, 0, TypeScript.DiagnosticCode._0_expected, ["`"]);
                        break;
                    }
                    var ch = str.charCodeAt(index);
                    index++;
                    if (ch === 96 /* backtick */) {
                        break;
                    }
                    if (ch === 36 /* $ */ && index < end && str.charCodeAt(index) === 123 /* openBrace */) {
                        index++;
                        return startedWithBacktick ? 14 /* TemplateStartToken */ : 15 /* TemplateMiddleToken */;
                    }
                }
                return startedWithBacktick ? 13 /* NoSubstitutionTemplateToken */ : 16 /* TemplateEndToken */;
            }
            function scanAmpersandToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 117 /* AmpersandEqualsToken */;
                }
                else if (character === 38 /* ampersand */) {
                    index++;
                    return 105 /* AmpersandAmpersandToken */;
                }
                else {
                    return 100 /* AmpersandToken */;
                }
            }
            function scanPercentToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 113 /* PercentEqualsToken */;
                }
                else {
                    return 94 /* PercentToken */;
                }
            }
            function scanMinusToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 111 /* MinusEqualsToken */;
                }
                else if (character === 45 /* minus */) {
                    index++;
                    return 96 /* MinusMinusToken */;
                }
                else {
                    return 92 /* MinusToken */;
                }
            }
            function scanPlusToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 110 /* PlusEqualsToken */;
                }
                else if (character === 43 /* plus */) {
                    index++;
                    return 95 /* PlusPlusToken */;
                }
                else {
                    return 91 /* PlusToken */;
                }
            }
            function scanAsteriskToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 112 /* AsteriskEqualsToken */;
                }
                else {
                    return 93 /* AsteriskToken */;
                }
            }
            function scanEqualsToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 89 /* EqualsEqualsEqualsToken */;
                    }
                    else {
                        return 86 /* EqualsEqualsToken */;
                    }
                }
                else if (character === 62 /* greaterThan */) {
                    index++;
                    return 87 /* EqualsGreaterThanToken */;
                }
                else {
                    return 109 /* EqualsToken */;
                }
            }
            function scanDotToken() {
                var nextChar = str.charCodeAt(index);
                if (TypeScript.CharacterInfo.isDecimalDigit(nextChar)) {
                    scanDecimalNumericLiteralAfterDot();
                    return 11 /* NumericLiteral */;
                }
                if (nextChar === 46 /* dot */ && str.charCodeAt(index + 1) === 46 /* dot */) {
                    index += 2;
                    return 79 /* DotDotDotToken */;
                }
                else {
                    return 78 /* DotToken */;
                }
            }
            function scanSlashToken(allowContextualToken) {
                // NOTE: By default, we do not try scanning a / as a regexp here.  We instead consider it a
                // div or div-assign.  Later on, if the parser runs into a situation where it would like a 
                // term, and it sees one of these then it may restart us asking specifically if we could 
                // scan out a regex.
                if (allowContextualToken) {
                    var result = tryScanRegularExpressionToken();
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 121 /* SlashEqualsToken */;
                }
                else {
                    return 120 /* SlashToken */;
                }
            }
            function tryScanRegularExpressionToken() {
                var startIndex = index;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = str.charCodeAt(index);
                    if (isNaN(ch) || isNewLineCharacter(ch)) {
                        index = startIndex;
                        return 0 /* None */;
                    }
                    index++;
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }
                    switch (ch) {
                        case 92 /* backslash */:
                            // We're now in an escape.  Consume the next character we see (unless it's
                            // a newline or undefined.
                            inEscape = true;
                            continue;
                        case 91 /* openBracket */:
                            // If we see a [ then we're starting an character class.  Note: it's ok if 
                            // we then hit another [ inside a character class.  We'll just set the value
                            // to true again and that's ok.
                            inCharacterClass = true;
                            continue;
                        case 93 /* closeBracket */:
                            // If we ever hit a cloe bracket then we're now no longer in a character 
                            // class.  If we weren't in a character class to begin with, then this has 
                            // no effect.
                            inCharacterClass = false;
                            continue;
                        case 47 /* slash */:
                            // If we see a slash, and we're in a character class, then ignore it.
                            if (inCharacterClass) {
                                continue;
                            }
                            break;
                        default:
                            continue;
                    }
                    break;
                }
                while (isIdentifierPartCharacter[str.charCodeAt(index)]) {
                    index++;
                }
                return 10 /* RegularExpressionLiteral */;
            }
            function scanExclamationToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 90 /* ExclamationEqualsEqualsToken */;
                    }
                    else {
                        return 88 /* ExclamationEqualsToken */;
                    }
                }
                else {
                    return 103 /* ExclamationToken */;
                }
            }
            // Convert text into a printable form usable for an error message.  This will both quote the 
            // string, and ensure all characters printable (i.e. by using unicode escapes when they're not).
            function getErrorMessageText(text) {
                // For just a simple backslash, we return it as is.  The default behavior of JSON.stringify
                // is not what we want here.
                if (text === "\\") {
                    return '"\\"';
                }
                return JSON.stringify(text);
            }
            function skipEscapeSequence() {
                var rewindPoint = index;
                // Consume the backslash.
                index++;
                // Get the char after the backslash
                var ch = str.charCodeAt(index);
                if (isNaN(ch)) {
                    // if we're at teh end of the file, just return, the string scanning code will 
                    // report an appropriate error.
                    return;
                }
                index++;
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        index = rewindPoint;
                        var value = scanUnicodeOrHexEscape(true);
                        break;
                    case 13 /* carriageReturn */:
                        // If it's \r\n then consume both characters.
                        if (str.charCodeAt(index) === 10 /* lineFeed */) {
                            index++;
                        }
                        break;
                    default:
                        break;
                }
            }
            function scanStringLiteral(quoteCharacter) {
                // Debug.assert(quoteCharacter === CharacterCodes.singleQuote || quoteCharacter === CharacterCodes.doubleQuote);
                while (true) {
                    var ch = str.charCodeAt(index);
                    if (ch === 92 /* backslash */) {
                        skipEscapeSequence();
                    }
                    else if (ch === quoteCharacter) {
                        index++;
                        break;
                    }
                    else if (isNaN(ch) || isNewLineCharacter(ch)) {
                        reportDiagnostic(Math.min(index, end), 1, TypeScript.DiagnosticCode.Missing_close_quote_character, undefined);
                        break;
                    }
                    else {
                        index++;
                    }
                }
                return 12 /* StringLiteral */;
            }
            function isUnicodeEscape(character) {
                return character === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */;
            }
            function peekCharOrUnicodeEscape() {
                var character = str.charCodeAt(index);
                if (isUnicodeEscape(character)) {
                    return peekUnicodeOrHexEscape();
                }
                else {
                    return character;
                }
            }
            function peekUnicodeOrHexEscape() {
                var startIndex = index;
                // if we're peeking, then we don't want to change the position
                var ch = scanUnicodeOrHexEscape(false);
                index = startIndex;
                return ch;
            }
            // Returns true if this was a unicode escape.
            function scanCharOrUnicodeEscape() {
                if (str.charCodeAt(index) === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */) {
                    scanUnicodeOrHexEscape(true);
                }
                else {
                    index++;
                }
            }
            function scanUnicodeOrHexEscape(report) {
                var start = index;
                var character = str.charCodeAt(index);
                // Debug.assert(character === CharacterCodes.backslash);
                index++;
                character = str.charCodeAt(index);
                // Debug.assert(character === CharacterCodes.u || character === CharacterCodes.x);
                var intChar = 0;
                index++;
                var count = character === 117 /* u */ ? 4 : 2;
                for (var i = 0; i < count; i++) {
                    var ch2 = str.charCodeAt(index);
                    if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                        if (report) {
                            reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, undefined);
                        }
                        break;
                    }
                    intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                    index++;
                }
                return intChar;
            }
            function fillTokenInfo(token, text, tokenInfo) {
                var fullStart = token.fullStart();
                var fullEnd = fullStart + token.fullWidth();
                reset(text, fullStart, fullEnd);
                scanTriviaInfo();
                var start = index;
                tokenInfo.leadingTriviaWidth = start - fullStart;
            }
            reset(text, 0, text.length());
            return {
                setIndex: setIndex,
                scan: scan,
                fillTokenInfo: fillTokenInfo,
                scanTrivia: scanTrivia
            };
        }
        function isValidIdentifier(text, languageVersion) {
            var hadError = false;
            var scanner = createScanner(languageVersion, text, function () { return hadError = true; });
            var token = scanner.scan(false);
            return !hadError && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && TypeScript.width(token) === text.length();
        }
        Scanner.isValidIdentifier = isValidIdentifier;
        // Parser source used in batch scenarios.  Directly calls into an underlying text scanner and
        // supports none of the functionality to reuse nodes.  Good for when you just want want to do
        // a single parse of a file.
        function createParserSource(fileName, text, languageVersion) {
            // The absolute position we're at in the text we're reading from.
            var _absolutePosition = 0;
            // The diagnostics we get while scanning.  Note: this never gets rewound when we do a normal
            // rewind.  That's because rewinding doesn't affect the tokens created.  It only affects where
            // in the token stream we're pointing at.  However, it will get modified if we we decide to
            // reparse a / or /= as a regular expression.
            var _tokenDiagnostics = [];
            // Pool of rewind points we give out if the parser needs one.
            var rewindPointPool = [];
            var rewindPointPoolCount = 0;
            var lastDiagnostic = undefined;
            var reportDiagnostic = function (position, fullWidth, diagnosticKey, args) {
                lastDiagnostic = new TypeScript.Diagnostic(fileName, text.lineMap(), position, fullWidth, diagnosticKey, args);
            };
            // The sliding window that we store tokens in.
            var slidingWindow = new TypeScript.SlidingWindow(fetchNextItem, TypeScript.ArrayUtilities.createArray(1024, undefined), undefined);
            // The scanner we're pulling tokens from.
            var scanner = createScanner(languageVersion, text, reportDiagnostic);
            function release() {
                slidingWindow = undefined;
                scanner = undefined;
                _tokenDiagnostics = [];
                rewindPointPool = [];
                lastDiagnostic = undefined;
                reportDiagnostic = undefined;
            }
            function currentNode() {
                // The normal parser source never returns nodes.  They're only returned by the 
                // incremental parser source.
                return undefined;
            }
            function consumeNode(node) {
                throw TypeScript.Errors.invalidOperation();
            }
            function absolutePosition() {
                return _absolutePosition;
            }
            function tokenDiagnostics() {
                return _tokenDiagnostics;
            }
            function getOrCreateRewindPoint() {
                if (rewindPointPoolCount === 0) {
                    return {};
                }
                rewindPointPoolCount--;
                var result = rewindPointPool[rewindPointPoolCount];
                rewindPointPool[rewindPointPoolCount] = undefined;
                return result;
            }
            function getRewindPoint() {
                var slidingWindowIndex = slidingWindow.getAndPinAbsoluteIndex();
                var rewindPoint = getOrCreateRewindPoint();
                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.absolutePosition = _absolutePosition;
                // rewindPoint.pinCount = slidingWindow.pinCount();
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);
                _absolutePosition = rewindPoint.absolutePosition;
            }
            function releaseRewindPoint(rewindPoint) {
                // Debug.assert(slidingWindow.pinCount() === rewindPoint.pinCount);
                slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint.absoluteIndex);
                rewindPointPool[rewindPointPoolCount] = rewindPoint;
                rewindPointPoolCount++;
            }
            function fetchNextItem(allowContextualToken) {
                // Assert disabled because it is actually expensive enugh to affect perf.
                // Debug.assert(spaceAvailable > 0);
                var token = scanner.scan(allowContextualToken);
                if (lastDiagnostic === undefined) {
                    return token;
                }
                // If we produced any diagnostics while creating this token, then realize the token so 
                // it won't be reused in incremental scenarios.
                _tokenDiagnostics.push(lastDiagnostic);
                lastDiagnostic = undefined;
                return TypeScript.Syntax.realizeToken(token, text);
            }
            function peekToken(n) {
                return slidingWindow.peekItemN(n);
            }
            function consumeToken(token) {
                // Debug.assert(token.fullWidth() > 0 || token.kind === SyntaxKind.EndOfFileToken);
                // Debug.assert(currentToken() === token);
                _absolutePosition += token.fullWidth();
                slidingWindow.moveToNextItem();
            }
            function currentToken() {
                return slidingWindow.currentItem(false);
            }
            function removeDiagnosticsOnOrAfterPosition(position) {
                // walk backwards, removing any diagnostics that came after the the current token's
                // full start position.
                var tokenDiagnosticsLength = _tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = _tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                        _tokenDiagnostics.pop();
                    }
                    else {
                        break;
                    }
                }
            }
            function resetToPosition(absolutePosition) {
                TypeScript.Debug.assert(absolutePosition <= text.length(), "Trying to set the position outside the bounds of the text!");
                var resetBackward = absolutePosition <= _absolutePosition;
                _absolutePosition = absolutePosition;
                if (resetBackward) {
                    // First, remove any diagnostics that came after this position.
                    removeDiagnosticsOnOrAfterPosition(absolutePosition);
                }
                // Now, tell our sliding window to throw away all tokens after this position as well.
                slidingWindow.disgardAllItemsFromCurrentIndexOnwards();
                // Now tell the scanner to reset its position to this position as well.  That way
                // when we try to scan the next item, we'll be at the right location.
                scanner.setIndex(absolutePosition);
            }
            function currentContextualToken() {
                // We better be on a / or > token right now.
                // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken().kind));
                // First, we're going to rewind all our data to the point where this / or /= token started.
                // That's because if it does turn out to be a regular expression, then any tokens or token 
                // diagnostics we produced after the original / may no longer be valid.  This would actually
                // be a  fairly expected case.  For example, if you had:  / ... gibberish ... /, we may have 
                // produced several diagnostics in the process of scanning the tokens after the first / as
                // they may not have been legal javascript okens.
                //
                // We also need to remove all the tokens we've gotten from the slash and onwards.  They may
                // not have been what the scanner would have produced if it decides that this is actually
                // a regular expresion.
                resetToPosition(_absolutePosition);
                // Now actually fetch the token again from the scanner. This time let it know that it
                // can scan it as a regex token if it wants to.
                var token = slidingWindow.currentItem(true);
                // We have better gotten some sort of regex token.  Otherwise, something *very* wrong has
                // occurred.
                // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.kind));
                return token;
            }
            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release,
                absolutePosition: absolutePosition,
                resetToPosition: resetToPosition
            };
        }
        Scanner.createParserSource = createParserSource;
        var fixedWidthArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 5, 8, 8, 7, 6, 2, 4, 5, 7, 3, 8, 2, 2, 10, 3, 4, 6, 6, 4, 5, 4, 3, 6, 3, 4, 5, 4, 5, 5, 4, 6, 7, 6, 5, 10, 9, 3, 7, 7, 9, 6, 6, 5, 3, 7, 11, 7, 3, 6, 7, 6, 3, 6, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 2, 2, 2, 1, 2];
        function fixedWidthTokenLength(kind) {
            return fixedWidthArray[kind];
        }
    })(Scanner = TypeScript.Scanner || (TypeScript.Scanner = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities;
    (function (ScannerUtilities) {
        function identifierKind(str, start, length) {
            switch (length) {
                case 2:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 111 /* o */) ? 24 /* DoKeyword */ : 9 /* IdentifierName */;
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 102 /* f */: return 30 /* IfKeyword */;
                                case 110 /* n */: return 31 /* InKeyword */;
                                default: return 9 /* IdentifierName */;
                            }
                        default: return 9 /* IdentifierName */;
                    }
                case 3:
                    switch (str.charCodeAt(start)) {
                        case 97 /* a */: return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 121 /* y */) ? 62 /* AnyKeyword */ : 9 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 114 /* r */) ? 28 /* ForKeyword */ : 9 /* IdentifierName */;
                        case 103 /* g */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 66 /* GetKeyword */ : 9 /* IdentifierName */;
                        case 108 /* l */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 55 /* LetKeyword */ : 9 /* IdentifierName */;
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 119 /* w */) ? 33 /* NewKeyword */ : 9 /* IdentifierName */;
                        case 115 /* s */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 70 /* SetKeyword */ : 9 /* IdentifierName */;
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 121 /* y */) ? 40 /* TryKeyword */ : 9 /* IdentifierName */;
                        case 118 /* v */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 114 /* r */) ? 42 /* VarKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 4:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 18 /* CaseKeyword */ : 9 /* IdentifierName */;
                        case 101 /* e */:
                            switch (str.charCodeAt(start + 1)) {
                                case 108 /* l */: return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 25 /* ElseKeyword */ : 9 /* IdentifierName */;
                                case 110 /* n */: return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 109 /* m */) ? 48 /* EnumKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 108 /* l */) ? 34 /* NullKeyword */ : 9 /* IdentifierName */;
                        case 116 /* t */:
                            switch (str.charCodeAt(start + 1)) {
                                case 104 /* h */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 115 /* s */) ? 37 /* ThisKeyword */ : 9 /* IdentifierName */;
                                case 114 /* r */: return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 101 /* e */) ? 39 /* TrueKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        case 118 /* v */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 100 /* d */) ? 43 /* VoidKeyword */ : 9 /* IdentifierName */;
                        case 119 /* w */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 104 /* h */) ? 45 /* WithKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 5:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 107 /* k */) ? 17 /* BreakKeyword */ : 9 /* IdentifierName */;
                        case 99 /* c */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */: return (str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 104 /* h */) ? 19 /* CatchKeyword */ : 9 /* IdentifierName */;
                                case 108 /* l */: return (str.charCodeAt(start + 2) === 97 /* a */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 115 /* s */) ? 46 /* ClassKeyword */ : 9 /* IdentifierName */;
                                case 111 /* o */: return (str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */) ? 47 /* ConstKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 101 /* e */) ? 26 /* FalseKeyword */ : 9 /* IdentifierName */;
                        case 115 /* s */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */) ? 52 /* SuperKeyword */ : 9 /* IdentifierName */;
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 114 /* r */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 119 /* w */) ? 38 /* ThrowKeyword */ : 9 /* IdentifierName */;
                        case 119 /* w */: return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */) ? 44 /* WhileKeyword */ : 9 /* IdentifierName */;
                        case 121 /* y */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 100 /* d */) ? 61 /* YieldKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 6:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 101 /* e */) ? 23 /* DeleteKeyword */ : 9 /* IdentifierName */;
                        case 101 /* e */: return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 49 /* ExportKeyword */ : 9 /* IdentifierName */;
                        case 105 /* i */: return (str.charCodeAt(start + 1) === 109 /* m */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 51 /* ImportKeyword */ : 9 /* IdentifierName */;
                        case 109 /* m */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 100 /* d */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 101 /* e */) ? 67 /* ModuleKeyword */ : 9 /* IdentifierName */;
                        case 110 /* n */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 109 /* m */ && str.charCodeAt(start + 3) === 98 /* b */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 114 /* r */) ? 69 /* NumberKeyword */ : 9 /* IdentifierName */;
                        case 112 /* p */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 59 /* PublicKeyword */ : 9 /* IdentifierName */;
                        case 114 /* r */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 110 /* n */) ? 35 /* ReturnKeyword */ : 9 /* IdentifierName */;
                        case 115 /* s */:
                            switch (str.charCodeAt(start + 1)) {
                                case 116 /* t */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 97 /* a */: return (str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 60 /* StaticKeyword */ : 9 /* IdentifierName */;
                                        case 114 /* r */: return (str.charCodeAt(start + 3) === 105 /* i */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 103 /* g */) ? 71 /* StringKeyword */ : 9 /* IdentifierName */;
                                        default: return 9 /* IdentifierName */;
                                    }
                                case 119 /* w */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 99 /* c */ && str.charCodeAt(start + 5) === 104 /* h */) ? 36 /* SwitchKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        case 116 /* t */: return (str.charCodeAt(start + 1) === 121 /* y */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 111 /* o */ && str.charCodeAt(start + 5) === 102 /* f */) ? 41 /* TypeOfKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 7:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 97 /* a */ && str.charCodeAt(start + 6) === 110 /* n */) ? 63 /* BooleanKeyword */ : 9 /* IdentifierName */;
                        case 100 /* d */:
                            switch (str.charCodeAt(start + 1)) {
                                case 101 /* e */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 99 /* c */: return (str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 65 /* DeclareKeyword */ : 9 /* IdentifierName */;
                                        case 102 /* f */: return (str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 117 /* u */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 116 /* t */) ? 22 /* DefaultKeyword */ : 9 /* IdentifierName */;
                                        default: return 9 /* IdentifierName */;
                                    }
                                default: return 9 /* IdentifierName */;
                            }
                        case 101 /* e */: return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 100 /* d */ && str.charCodeAt(start + 6) === 115 /* s */) ? 50 /* ExtendsKeyword */ : 9 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 121 /* y */) ? 27 /* FinallyKeyword */ : 9 /* IdentifierName */;
                        case 112 /* p */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */: return (str.charCodeAt(start + 2) === 99 /* c */ && str.charCodeAt(start + 3) === 107 /* k */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */) ? 56 /* PackageKeyword */ : 9 /* IdentifierName */;
                                case 114 /* r */: return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 118 /* v */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 116 /* t */ && str.charCodeAt(start + 6) === 101 /* e */) ? 57 /* PrivateKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        case 114 /* r */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 113 /* q */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 68 /* RequireKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 8:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */: return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 101 /* e */) ? 20 /* ContinueKeyword */ : 9 /* IdentifierName */;
                        case 100 /* d */: return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 103 /* g */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 114 /* r */) ? 21 /* DebuggerKeyword */ : 9 /* IdentifierName */;
                        case 102 /* f */: return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 105 /* i */ && str.charCodeAt(start + 6) === 111 /* o */ && str.charCodeAt(start + 7) === 110 /* n */) ? 29 /* FunctionKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 9:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */: return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 102 /* f */ && str.charCodeAt(start + 6) === 97 /* a */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 101 /* e */) ? 54 /* InterfaceKeyword */ : 9 /* IdentifierName */;
                        case 112 /* p */: return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 99 /* c */ && str.charCodeAt(start + 6) === 116 /* t */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 100 /* d */) ? 58 /* ProtectedKeyword */ : 9 /* IdentifierName */;
                        default: return 9 /* IdentifierName */;
                    }
                case 10:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 109 /* m */: return (str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 109 /* m */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 110 /* n */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 115 /* s */) ? 53 /* ImplementsKeyword */ : 9 /* IdentifierName */;
                                case 110 /* n */: return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 99 /* c */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 111 /* o */ && str.charCodeAt(start + 9) === 102 /* f */) ? 32 /* InstanceOfKeyword */ : 9 /* IdentifierName */;
                                default: return 9 /* IdentifierName */;
                            }
                        default: return 9 /* IdentifierName */;
                    }
                case 11: return (str.charCodeAt(start) === 99 /* c */ && str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 111 /* o */ && str.charCodeAt(start + 10) === 114 /* r */) ? 64 /* ConstructorKeyword */ : 9 /* IdentifierName */;
                default: return 9 /* IdentifierName */;
            }
        }
        ScannerUtilities.identifierKind = identifierKind;
    })(ScannerUtilities = TypeScript.ScannerUtilities || (TypeScript.ScannerUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(// Underlying source that we retrieve items from.
            fetchNextItem, 
            // A window of items that has been read in from the underlying source.
            window, 
            // The default value to return when there are no more items left in the window.
            defaultValue, 
            // The length of the source we're reading from if we know it up front.  -1 if we do not.
            sourceLength) {
            if (sourceLength === void 0) { sourceLength = -1; }
            this.fetchNextItem = fetchNextItem;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            // The number of valid items in window.
            this.windowCount = 0;
            // The *absolute* index in the *full* array of items the *window* array starts at.  i.e.
            // if there were 100 items, and window contains tokens [70, 80), then this value would be
            // 70.
            this.windowAbsoluteStartIndex = 0;
            // The index in the window array that we're at. i.e. if there 100 items and 
            // window contains tokens [70, 80), and we're on item 75, then this value would be '5'.
            // Note: it is not absolute.  It is relative to the start of the window.
            this.currentRelativeItemIndex = 0;
            // The number of pinned points there are.  As long as there is at least one  pinned point, we 
            // will not advance the start of the window array past the item marked by that pin point.
            this._pinCount = 0;
            // If there are any outstanding rewind points, this is index in the full array of items
            // that the first rewind point points to.  If this is not -1, then we will not shift the
            // start of the items array past this point.
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            var sourceLength = this.sourceLength;
            if (sourceLength >= 0 && this.absoluteIndex() >= sourceLength) {
                return false;
            }
            // First, make room for the new items if we're out of room.
            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }
            var item = this.fetchNextItem(argument);
            this.window[this.windowCount] = item;
            // Assert disabled because it is actually expensive enugh to affect perf.
            this.windowCount++;
            return true;
        };
        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            // We want to shift if our current item is past the halfway point of the current item window.
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);
            // However, we can only shift if we have no outstanding rewind points.  Or, if we have an 
            // outstanding rewind point, that it points to some point after the start of the window.
            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;
            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                // Figure out where we're going to start shifting from. If we have no oustanding rewind 
                // points, then we'll start shifting over all the items starting from the current 
                // token we're point out.  Otherwise, we'll shift starting from the first item that 
                // the rewind point is pointing at.
                // 
                // We'll call that point 'N' from now on. 
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;
                // We have to shift the number of elements between the start index and the number of 
                // items in the window.
                var shiftCount = this.windowCount - shiftStartIndex;
                // Debug.assert(shiftStartIndex > 0);
                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }
                // The window has now moved over to the right by N.
                this.windowAbsoluteStartIndex += shiftStartIndex;
                // The number of valid items in the window has now decreased by N.
                this.windowCount -= shiftStartIndex;
                // The current item now starts further to the left in the window.
                this.currentRelativeItemIndex -= shiftStartIndex;
            }
            else {
                // Grow the exisitng array.
                // this.window[this.window.length * 2 - 1] = this.defaultValue;
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };
        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };
        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };
        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            // Find the absolute index of this pin point.  i.e. it's the index as if we had an 
            // array containing *all* tokens.  
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                // If this is the first pinned point, then store off this index.  We will ensure that
                // we never shift the window past this point.
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }
            return absoluteIndex;
        };
        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                // If we just released the last outstanding pin, then we no longer need to 'fix' the 
                // token window so it can't move forward.  Set the index to -1 so that we can shift 
                // things over the next time we read past the end of the array.
                this.firstPinnedAbsoluteIndex = -1;
            }
        };
        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            // The rewind point shows which absolute item we want to rewind to.  Get the relative 
            // index in the actual array that we want to point to.
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;
            // Make sure we haven't screwed anything up.
            // Debug.assert(relativeIndex >= 0 && relativeIndex < this.windowCount);
            // Set ourselves back to that point.
            this.currentRelativeItemIndex = relativeIndex;
        };
        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex];
        };
        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(undefined)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex + n];
        };
        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };
        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            // By setting the window count to the current relative offset, we are effectively making
            // any items we added to the window from the current offset onwards unusable.  When we
            // try to get the next item, we'll be forced to refetch them from the underlying source.
            this.windowCount = this.currentRelativeItemIndex;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        Syntax._nextSyntaxID = 1;
        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < TypeScript.childCount(node); i++) {
                var child = TypeScript.childAt(node, i);
                if (TypeScript.isToken(child)) {
                    var token = child;
                    // If a token is skipped, return true. Or if it is a missing token. The only empty token that is not missing is EOF
                    if (token.hasLeadingSkippedToken() || (TypeScript.fullWidth(token) === 0 && token.kind !== 8 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;
        function isUnterminatedStringLiteral(token) {
            if (token && token.kind === 12 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }
            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;
        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind === 4 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;
        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                }
                else if (position === end) {
                    return trivia.kind === 5 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }
            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;
        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent) {
                if (positionedToken.parent.kind === kind) {
                    return positionedToken.parent;
                }
                positionedToken = positionedToken.parent;
            }
            return undefined;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;
        function hasAncestorOfKind(positionedToken, kind) {
            return !!getAncestorOfKind(positionedToken, kind);
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;
        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind) {
                    case 169 /* PrefixUnaryExpression */:
                        var prefixExpr = expression;
                        if (prefixExpr.operatorToken.kind == 91 /* PlusToken */ || prefixExpr.operatorToken.kind === 92 /* MinusToken */) {
                            // Note: if there is a + or - sign, we can only allow a normal integer following
                            // (and not a hex integer).  i.e. -0xA is a legal expression, but it is not a 
                            // *literal*.
                            expression = prefixExpr.operand;
                            return TypeScript.isToken(expression) && TypeScript.IntegerUtilities.isInteger(expression.text());
                        }
                        return false;
                    case 11 /* NumericLiteral */:
                        // If it doesn't have a + or -, then either an integer literal or a hex literal
                        // is acceptable.
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }
            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;
        function containingNode(element) {
            var current = element.parent;
            while (current && !TypeScript.isNode(current)) {
                current = current.parent;
            }
            return current;
        }
        Syntax.containingNode = containingNode;
        function findTokenOnLeft(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);
            var _start = TypeScript.start(positionedToken);
            // Position better fall within this token.
            // Debug.assert(position >= positionedToken.fullStart());
            // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);
            // if position is after the start of the token, then this token is the token on the left.
            if (position > _start) {
                return positionedToken;
            }
            // we're in the trivia before the start of the token.  Need to return the previous token.
            if (positionedToken.fullStart() === 0) {
                // Already on the first token.  Nothing before us.
                return undefined;
            }
            return TypeScript.previousToken(positionedToken);
        }
        Syntax.findTokenOnLeft = findTokenOnLeft;
        function findCompleteTokenOnLeft(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);
            // Position better fall within this token.
            // Debug.assert(position >= positionedToken.fullStart());
            // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);
            // if position is after the end of the token, then this token is the token on the left.
            if (TypeScript.width(positionedToken) > 0 && position >= TypeScript.fullEnd(positionedToken)) {
                return positionedToken;
            }
            return TypeScript.previousToken(positionedToken);
        }
        Syntax.findCompleteTokenOnLeft = findCompleteTokenOnLeft;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function syntaxTree(element) {
        if (element) {
            while (element) {
                if (element.kind === 122 /* SourceUnit */) {
                    return element.syntaxTree;
                }
                element = element.parent;
            }
        }
        return undefined;
    }
    TypeScript.syntaxTree = syntaxTree;
    function parsedInStrictMode(node) {
        var info = node.__data;
        if (info === undefined) {
            return false;
        }
        return (info & 4 /* NodeParsedInStrictModeMask */) !== 0;
    }
    TypeScript.parsedInStrictMode = parsedInStrictMode;
    function previousToken(token) {
        var start = token.fullStart();
        if (start === 0) {
            return undefined;
        }
        return findToken(syntaxTree(token).sourceUnit(), start - 1);
    }
    TypeScript.previousToken = previousToken;
    /**
     * Finds a token according to the following rules:
     * 1) If position matches the End of the node/s FullSpan and the node is SourceUnitSyntax,
     *    then the EOF token is returned.
     *
     *  2) If node.FullSpan.Contains(position) then the token that contains given position is
     *     returned.
     *
     *  3) Otherwise an ArgumentOutOfRangeException is thrown
     *
     * Note: findToken will always return a non-missing token with width greater than or equal to
     * 1 (except for EOF).  Empty tokens synthesized by the parser are never returned.
     */
    function findToken(sourceUnit, position) {
        if (position < 0) {
            throw TypeScript.Errors.argumentOutOfRange("position");
        }
        var token = findTokenInNodeOrToken(sourceUnit, 0, position);
        if (token) {
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return token;
        }
        if (position === fullWidth(sourceUnit)) {
            return sourceUnit.endOfFileToken;
        }
        if (position > fullWidth(sourceUnit)) {
            throw TypeScript.Errors.argumentOutOfRange("position");
        }
        throw TypeScript.Errors.invalidOperation();
    }
    TypeScript.findToken = findToken;
    function findTokenWorker(element, elementPosition, position) {
        if (isList(element)) {
            return findTokenInList(element, elementPosition, position);
        }
        else {
            return findTokenInNodeOrToken(element, elementPosition, position);
        }
    }
    function findTokenInList(list, elementPosition, position) {
        for (var i = 0, n = list.length; i < n; i++) {
            var child = list[i];
            var childFullWidth = fullWidth(child);
            var elementEndPosition = elementPosition + childFullWidth;
            if (position < elementEndPosition) {
                return findTokenWorker(child, elementPosition, position);
            }
            elementPosition = elementEndPosition;
        }
        return undefined;
    }
    function findTokenInNodeOrToken(nodeOrToken, elementPosition, position) {
        if (isToken(nodeOrToken)) {
            return nodeOrToken;
        }
        for (var i = 0, n = TypeScript.childCount(nodeOrToken); i < n; i++) {
            var child = nodeOrToken.childAt(i);
            if (child) {
                var childFullWidth = fullWidth(child);
                var elementEndPosition = elementPosition + childFullWidth;
                if (position < elementEndPosition) {
                    return findTokenWorker(child, elementPosition, position);
                }
                elementPosition = elementEndPosition;
            }
        }
        return undefined;
    }
    function tryGetEndOfFileAt(element, position) {
        if (element.kind === 122 /* SourceUnit */ && position === fullWidth(element)) {
            var sourceUnit = element;
            return sourceUnit.endOfFileToken;
        }
        return undefined;
    }
    function nextToken(token, text) {
        if (token.kind === 8 /* EndOfFileToken */) {
            return undefined;
        }
        return findToken(syntaxTree(token).sourceUnit(), fullEnd(token));
    }
    TypeScript.nextToken = nextToken;
    function isNode(element) {
        if (element) {
            var kind = element.kind;
            return kind >= TypeScript.SyntaxKind.FirstNode && kind <= TypeScript.SyntaxKind.LastNode;
        }
        return false;
    }
    TypeScript.isNode = isNode;
    function isTokenKind(kind) {
        return kind >= TypeScript.SyntaxKind.FirstToken && kind <= TypeScript.SyntaxKind.LastToken;
    }
    function isToken(element) {
        if (element) {
            return isTokenKind(element.kind);
        }
        return false;
    }
    TypeScript.isToken = isToken;
    function isList(element) {
        return element instanceof Array;
    }
    TypeScript.isList = isList;
    function syntaxID(element) {
        //if (isShared(element)) {
        //    throw Errors.invalidOperation("Should not use shared syntax element as a key.");
        //}
        var obj = element;
        if (obj._syntaxID === undefined) {
            obj._syntaxID = TypeScript.Syntax._nextSyntaxID++;
        }
        return obj._syntaxID;
    }
    TypeScript.syntaxID = syntaxID;
    function collectTextElements(element, elements, text) {
        if (element) {
            if (isToken(element)) {
                elements.push(element.fullText(text));
            }
            else {
                for (var i = 0, n = TypeScript.childCount(element); i < n; i++) {
                    collectTextElements(TypeScript.childAt(element, i), elements, text);
                }
            }
        }
    }
    function fullText(element, text) {
        if (isToken(element)) {
            return element.fullText(text);
        }
        var elements = [];
        collectTextElements(element, elements, text);
        return elements.join("");
    }
    TypeScript.fullText = fullText;
    function leadingTriviaWidth(element, text) {
        var token = firstToken(element);
        return token ? token.leadingTriviaWidth(text) : 0;
    }
    TypeScript.leadingTriviaWidth = leadingTriviaWidth;
    function firstToken(element) {
        if (element) {
            var kind = element.kind;
            if (isTokenKind(kind)) {
                return element.fullWidth() > 0 || kind === 8 /* EndOfFileToken */ ? element : undefined;
            }
            for (var i = 0, n = TypeScript.childCount(element); i < n; i++) {
                var token = firstToken(TypeScript.childAt(element, i));
                if (token) {
                    return token;
                }
            }
        }
        return undefined;
    }
    TypeScript.firstToken = firstToken;
    function lastToken(element) {
        if (isToken(element)) {
            return fullWidth(element) > 0 || element.kind === 8 /* EndOfFileToken */ ? element : undefined;
        }
        if (element.kind === 122 /* SourceUnit */) {
            return element.endOfFileToken;
        }
        for (var i = TypeScript.childCount(element) - 1; i >= 0; i--) {
            var child = TypeScript.childAt(element, i);
            if (child) {
                var token = lastToken(child);
                if (token) {
                    return token;
                }
            }
        }
        return undefined;
    }
    TypeScript.lastToken = lastToken;
    function fullStart(element) {
        // Debug.assert(!isShared(element));
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() : -1;
    }
    TypeScript.fullStart = fullStart;
    function fullWidth(element) {
        if (isToken(element)) {
            return element.fullWidth();
        }
        var info = data(element);
        return info >>> 3 /* NodeFullWidthShift */;
    }
    TypeScript.fullWidth = fullWidth;
    function isIncrementallyUnusable(element) {
        if (isToken(element)) {
            return element.isIncrementallyUnusable();
        }
        return (data(element) & 2 /* NodeIncrementallyUnusableMask */) !== 0;
    }
    TypeScript.isIncrementallyUnusable = isIncrementallyUnusable;
    function data(element) {
        // Debug.assert(isNode(element) || isList(element));
        // Lists and nodes all have a 'data' element.
        var dataElement = element;
        var info = dataElement.__data;
        if (info === undefined) {
            info = 0;
        }
        if ((info & 1 /* NodeDataComputed */) === 0) {
            info |= computeData(element);
            dataElement.__data = info;
        }
        return info;
    }
    function combineData(fullWidth, isIncrementallyUnusable) {
        return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
    }
    function listComputeData(list) {
        var fullWidth = 0;
        var isIncrementallyUnusable = false;
        for (var i = 0, n = list.length; i < n; i++) {
            var child = list[i];
            fullWidth += TypeScript.fullWidth(child);
            isIncrementallyUnusable = isIncrementallyUnusable || TypeScript.isIncrementallyUnusable(child);
        }
        return combineData(fullWidth, isIncrementallyUnusable);
    }
    function computeData(element) {
        if (isList(element)) {
            return listComputeData(element);
        }
        else {
            return nodeOrTokenComputeData(element);
        }
    }
    function nodeOrTokenComputeData(nodeOrToken) {
        var fullWidth = 0;
        var slotCount = nodeOrToken.childCount;
        // If we have no children (like an OmmittedExpressionSyntax), we're automatically not reusable.
        var isIncrementallyUnusable = slotCount === 0;
        for (var i = 0, n = slotCount; i < n; i++) {
            var child = nodeOrToken.childAt(i);
            if (child) {
                fullWidth += TypeScript.fullWidth(child);
                isIncrementallyUnusable = isIncrementallyUnusable || TypeScript.isIncrementallyUnusable(child);
            }
        }
        return combineData(fullWidth, isIncrementallyUnusable);
    }
    function start(element, text) {
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() + token.leadingTriviaWidth(text) : -1;
    }
    TypeScript.start = start;
    function width(element, text) {
        if (isToken(element)) {
            return element.text().length;
        }
        return fullWidth(element) - leadingTriviaWidth(element, text);
    }
    TypeScript.width = width;
    function fullEnd(element) {
        return fullStart(element) + fullWidth(element);
    }
    TypeScript.fullEnd = fullEnd;
    function existsNewLineBetweenTokens(token1, token2, text) {
        if (token1 === token2) {
            return false;
        }
        if (!token1 || !token2) {
            return true;
        }
        var lineMap = text.lineMap();
        return lineMap.getLineNumberFromPosition(fullEnd(token1)) !== lineMap.getLineNumberFromPosition(start(token2, text));
    }
    TypeScript.existsNewLineBetweenTokens = existsNewLineBetweenTokens;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            return node.kind === 154 /* ExpressionStatement */ && node.expression.kind === 12 /* StringLiteral */;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;
        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;
            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;
        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.kind;
            return tokenKind === 9 /* IdentifierName */ || SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
        function isAccessibilityModifier(kind) {
            switch (kind) {
                case 59 /* PublicKeyword */:
                case 57 /* PrivateKeyword */:
                case 58 /* ProtectedKeyword */:
                    return true;
            }
            return false;
        }
        SyntaxFacts.isAccessibilityModifier = isAccessibilityModifier;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function separatorCount(list) {
        return list.length >> 1;
    }
    TypeScript.separatorCount = separatorCount;
    function nonSeparatorCount(list) {
        return (list.length + 1) >> 1;
    }
    TypeScript.nonSeparatorCount = nonSeparatorCount;
    function separatorAt(list, index) {
        return list[(index << 1) + 1];
    }
    TypeScript.separatorAt = separatorAt;
    function nonSeparatorAt(list, index) {
        return list[index << 1];
    }
    TypeScript.nonSeparatorAt = nonSeparatorAt;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        function addArrayPrototypeValue(name, val) {
            if (Object.defineProperty && Array.prototype[name] === undefined) {
                Object.defineProperty(Array.prototype, name, { value: val, writable: false });
            }
            else {
                Array.prototype[name] = val;
            }
        }
        addArrayPrototypeValue("kind", 1 /* List */);
        function list(nodes) {
            for (var i = 0, n = nodes.length; i < n; i++) {
                nodes[i].parent = nodes;
            }
            return nodes;
        }
        Syntax.list = list;
        function separatedList(nodesAndTokens) {
            for (var i = 0, n = nodesAndTokens.length; i < n; i++) {
                nodesAndTokens[i].parent = nodesAndTokens;
            }
            return nodesAndTokens;
        }
        Syntax.separatedList = separatedList;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function tokenValue(token) {
        if (token.fullWidth() === 0) {
            return undefined;
        }
        var kind = token.kind;
        var text = token.text();
        if (kind === 9 /* IdentifierName */) {
            return massageEscapes(text);
        }
        switch (kind) {
            case 39 /* TrueKeyword */:
                return true;
            case 26 /* FalseKeyword */:
                return false;
            case 34 /* NullKeyword */:
                return undefined;
        }
        if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
            return TypeScript.SyntaxFacts.getText(kind);
        }
        if (kind === 11 /* NumericLiteral */) {
            return TypeScript.IntegerUtilities.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
        }
        else if (kind === 12 /* StringLiteral */) {
            return (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) ? massageEscapes(text.substr(1, text.length - "''".length)) : massageEscapes(text.substr(1));
        }
        else if (kind === 13 /* NoSubstitutionTemplateToken */ || kind === 16 /* TemplateEndToken */) {
            // Both of these template types may be missing their closing backtick (if they were at 
            // the end of the file).  Check to make sure it is there before grabbing the portion
            // we're examining.
            return (text.length > 1 && text.charCodeAt(text.length - 1) === 96 /* backtick */) ? massageTemplate(text.substr(1, text.length - "``".length)) : massageTemplate(text.substr(1));
        }
        else if (kind === 14 /* TemplateStartToken */ || kind === 15 /* TemplateMiddleToken */) {
            // Both these tokens must have been properly ended.  i.e. if it didn't end with a ${
            // then we would not have parsed a start or middle token out at all.  So we don't
            // need to check for an incomplete token.
            return massageTemplate(text.substr(1, text.length - "`${".length));
        }
        else if (kind === 10 /* RegularExpressionLiteral */) {
            return regularExpressionValue(text);
        }
        else if (kind === 8 /* EndOfFileToken */ || kind === 7 /* ErrorToken */) {
            return undefined;
        }
        else {
            throw TypeScript.Errors.invalidOperation();
        }
    }
    TypeScript.tokenValue = tokenValue;
    function tokenValueText(token) {
        var value = tokenValue(token);
        return value === undefined ? "" : massageDisallowedIdentifiers(value.toString());
    }
    TypeScript.tokenValueText = tokenValueText;
    function massageTemplate(text) {
        // First, convert all carriage-return newlines into line-feed newlines.  This is due to:
        //
        // The TRV of LineTerminatorSequence :: <CR> is the code unit value 0x000A.
        // ...
        // The TRV of LineTerminatorSequence :: <CR><LF> is the sequence consisting of the code unit value 0x000A.
        text = text.replace("\r\n", "\n").replace("\r", "\n");
        // Now remove any escape characters that may be in the string.
        return massageEscapes(text);
    }
    function massageEscapes(text) {
        return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
    }
    TypeScript.massageEscapes = massageEscapes;
    function regularExpressionValue(text) {
        try {
            var lastSlash = text.lastIndexOf("/");
            var body = text.substring(1, lastSlash);
            var flags = text.substring(lastSlash + 1);
            return new RegExp(body, flags);
        }
        catch (e) {
            return undefined;
        }
    }
    function massageDisallowedIdentifiers(text) {
        // We routinely store the 'valueText' for a token as keys in dictionaries.  However, as those
        // dictionaries are usually just a javascript object, we run into issues when teh keys collide
        // with certain predefined keys they depend on (like __proto__).  To workaround this
        // we ensure that the valueText of any token is not __proto__ but is instead ___proto__.
        //
        // We also prepend a _ to any identifier starting with two __ .  That allows us to carve 
        // out the entire namespace of identifiers starting with __ for ourselves.
        if (text.charCodeAt(0) === 95 /* _ */ && text.charCodeAt(1) === 95 /* _ */) {
            return "_" + text;
        }
        return text;
    }
    var characterArray = [];
    function convertEscapes(text) {
        characterArray.length = 0;
        var result = "";
        for (var i = 0, n = text.length; i < n; i++) {
            var ch = text.charCodeAt(i);
            if (ch === 92 /* backslash */) {
                i++;
                if (i < n) {
                    ch = text.charCodeAt(i);
                    switch (ch) {
                        case 48 /* _0 */:
                            characterArray.push(0 /* nullCharacter */);
                            continue;
                        case 98 /* b */:
                            characterArray.push(8 /* backspace */);
                            continue;
                        case 102 /* f */:
                            characterArray.push(12 /* formFeed */);
                            continue;
                        case 110 /* n */:
                            characterArray.push(10 /* lineFeed */);
                            continue;
                        case 114 /* r */:
                            characterArray.push(13 /* carriageReturn */);
                            continue;
                        case 116 /* t */:
                            characterArray.push(9 /* tab */);
                            continue;
                        case 118 /* v */:
                            characterArray.push(11 /* verticalTab */);
                            continue;
                        case 120 /* x */:
                            characterArray.push(hexValue(text, i + 1, 2));
                            i += 2;
                            continue;
                        case 117 /* u */:
                            characterArray.push(hexValue(text, i + 1, 4));
                            i += 4;
                            continue;
                        case 13 /* carriageReturn */:
                            var nextIndex = i + 1;
                            if (nextIndex < text.length && text.charCodeAt(nextIndex) === 10 /* lineFeed */) {
                                // Skip the entire \r\n sequence.
                                i++;
                            }
                            continue;
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            continue;
                        default:
                    }
                }
            }
            characterArray.push(ch);
            if (i && !(i % 1024)) {
                result = result.concat(String.fromCharCode.apply(undefined, characterArray));
                characterArray.length = 0;
            }
        }
        if (characterArray.length) {
            result = result.concat(String.fromCharCode.apply(undefined, characterArray));
        }
        return result;
    }
    function hexValue(text, start, length) {
        var intChar = 0;
        for (var i = 0; i < length; i++) {
            var ch2 = text.charCodeAt(start + i);
            if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                break;
            }
            intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
        }
        return intChar;
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        function realizeToken(token, text) {
            return new RealizedToken(token.fullStart(), token.kind, token.isKeywordConvertedToIdentifier(), token.leadingTrivia(text), token.text());
        }
        Syntax.realizeToken = realizeToken;
        function convertKeywordToIdentifier(token) {
            return new ConvertedKeywordToken(token);
        }
        Syntax.convertKeywordToIdentifier = convertKeywordToIdentifier;
        function withLeadingTrivia(token, leadingTrivia, text) {
            return new RealizedToken(token.fullStart(), token.kind, token.isKeywordConvertedToIdentifier(), leadingTrivia, token.text());
        }
        Syntax.withLeadingTrivia = withLeadingTrivia;
        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;
        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.kind = kind;
            }
            EmptyToken.prototype.setFullStart = function (fullStart) {
                // An empty token is always at the -1 position.
            };
            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.invalidOperation();
            };
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.kind);
            };
            // Empty tokens are never incrementally reusable.
            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            EmptyToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.position = function () {
                // It's hard for us to tell the position of an empty token at the eact time we create 
                // it.  For example, we may have:
                //
                //      a / finally
                //
                // There will be a missing token detected after the forward slash, so it would be 
                // tempting to set its position as the full-end of hte slash token. However, 
                // immediately after that, the 'finally' token will be skipped and will be attached
                // as skipped text to the forward slash.  This means the 'full-end' of the forward
                // slash will change, and thus the empty token will now appear to be embedded inside
                // another token.  This violates are rule that all tokens must only touch at the end,
                // and makes enforcing invariants much harder.
                //
                // To address this we create the empty token with no known position, and then we 
                // determine what it's position should be based on where it lies in the tree.  
                // Specifically, we find the previous non-zero-width syntax element, and we consider
                // the full-start of this token to be at the full-end of that element.
                var previousElement = this.previousNonZeroWidthElement();
                return !previousElement ? 0 : TypeScript.fullStart(previousElement) + TypeScript.fullWidth(previousElement);
            };
            EmptyToken.prototype.previousNonZeroWidthElement = function () {
                var current = this;
                while (true) {
                    var parent = current.parent;
                    if (parent === undefined) {
                        TypeScript.Debug.assert(current.kind === 122 /* SourceUnit */, "We had a node without a parent that was not the root node!");
                        // We walked all the way to the top, and never found a previous element.  This 
                        // can happen with code like:
                        //
                        //      / b;
                        //
                        // We will have an empty identifier token as the first token in the tree.  In
                        // this case, return undefined so that the position of the empty token will be 
                        // considered to be 0.
                        return undefined;
                    }
                    for (var i = 0, n = TypeScript.childCount(parent); i < n; i++) {
                        if (TypeScript.childAt(parent, i) === current) {
                            break;
                        }
                    }
                    TypeScript.Debug.assert(i !== n, "Could not find current element in parent's child list!");
                    for (var j = i - 1; j >= 0; j--) {
                        var sibling = TypeScript.childAt(parent, j);
                        if (sibling && TypeScript.fullWidth(sibling) > 0) {
                            return sibling;
                        }
                    }
                    // We couldn't find a non-zero-width sibling.  We were either the first element, or
                    // all preceding elements are empty.  So, move up to our parent so we we can find
                    // its preceding sibling.
                    current = current.parent;
                }
            };
            EmptyToken.prototype.fullStart = function () {
                return this.position();
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingSkippedToken = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            return EmptyToken;
        })();
        EmptyToken.prototype.childCount = 0;
        var RealizedToken = (function () {
            function RealizedToken(fullStart, kind, isKeywordConvertedToIdentifier, leadingTrivia, text) {
                this.kind = kind;
                this._fullStart = fullStart;
                this._isKeywordConvertedToIdentifier = isKeywordConvertedToIdentifier;
                this._text = text;
                this._leadingTrivia = leadingTrivia.clone();
                if (!this._leadingTrivia.isShared()) {
                    this._leadingTrivia.parent = this;
                }
            }
            RealizedToken.prototype.setFullStart = function (fullStart) {
                this._fullStart = fullStart;
            };
            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.invalidOperation();
            };
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this._fullStart, this.kind, this._isKeywordConvertedToIdentifier, this._leadingTrivia, this._text);
            };
            // Realized tokens are created from the parser.  They are *never* incrementally reusable.
            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            RealizedToken.prototype.isKeywordConvertedToIdentifier = function () {
                return this._isKeywordConvertedToIdentifier;
            };
            RealizedToken.prototype.fullStart = function () {
                return this._fullStart;
            };
            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this._text.length;
            };
            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text();
            };
            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingNewLine = function () {
                return this._leadingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasLeadingSkippedToken = function () {
                return this._leadingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };
            return RealizedToken;
        })();
        RealizedToken.prototype.childCount = 0;
        var ConvertedKeywordToken = (function () {
            function ConvertedKeywordToken(underlyingToken) {
                this.underlyingToken = underlyingToken;
            }
            ConvertedKeywordToken.prototype.setFullStart = function (fullStart) {
                this.underlyingToken.setFullStart(fullStart);
            };
            ConvertedKeywordToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.invalidOperation();
            };
            ConvertedKeywordToken.prototype.fullStart = function () {
                return this.underlyingToken.fullStart();
            };
            ConvertedKeywordToken.prototype.fullWidth = function () {
                return this.underlyingToken.fullWidth();
            };
            ConvertedKeywordToken.prototype.text = function () {
                return this.underlyingToken.text();
            };
            ConvertedKeywordToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };
            ConvertedKeywordToken.prototype.fullText = function (text) {
                return this.underlyingToken.fullText(this.syntaxTreeText(text));
            };
            ConvertedKeywordToken.prototype.hasLeadingTrivia = function () {
                return this.underlyingToken.hasLeadingTrivia();
            };
            ConvertedKeywordToken.prototype.hasLeadingNewLine = function () {
                return this.underlyingToken.hasLeadingNewLine();
            };
            ConvertedKeywordToken.prototype.hasLeadingComment = function () {
                return this.underlyingToken.hasLeadingComment();
            };
            ConvertedKeywordToken.prototype.hasLeadingSkippedToken = function () {
                return this.underlyingToken.hasLeadingSkippedToken();
            };
            ConvertedKeywordToken.prototype.leadingTrivia = function (text) {
                var result = this.underlyingToken.leadingTrivia(this.syntaxTreeText(text));
                result.parent = this;
                return result;
            };
            ConvertedKeywordToken.prototype.leadingTriviaWidth = function (text) {
                return this.underlyingToken.leadingTriviaWidth(this.syntaxTreeText(text));
            };
            ConvertedKeywordToken.prototype.isKeywordConvertedToIdentifier = function () {
                return true;
            };
            ConvertedKeywordToken.prototype.isIncrementallyUnusable = function () {
                // We're incrementally unusable if our underlying token is unusable.
                // For example, we may have: this.public \
                // In this case we will keyword converted to an identifier that is still unusable because
                // it has a trailing skipped token.
                return this.underlyingToken.isIncrementallyUnusable();
            };
            ConvertedKeywordToken.prototype.clone = function () {
                return new ConvertedKeywordToken(this.underlyingToken);
            };
            return ConvertedKeywordToken;
        })();
        ConvertedKeywordToken.prototype.kind = 9 /* IdentifierName */;
        ConvertedKeywordToken.prototype.childCount = 0;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var AbstractTrivia = (function () {
            function AbstractTrivia(kind) {
                this.kind = kind;
            }
            AbstractTrivia.prototype.clone = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullStart = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullWidth = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullText = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.isWhitespace = function () {
                return this.kind === 2 /* WhitespaceTrivia */;
            };
            AbstractTrivia.prototype.isComment = function () {
                return this.kind === 5 /* SingleLineCommentTrivia */ || this.kind === 4 /* MultiLineCommentTrivia */;
            };
            AbstractTrivia.prototype.isNewLine = function () {
                return this.kind === 3 /* NewLineTrivia */;
            };
            AbstractTrivia.prototype.isSkippedToken = function () {
                return this.kind === 6 /* SkippedTokenTrivia */;
            };
            return AbstractTrivia;
        })();
        var SkippedTokenTrivia = (function (_super) {
            __extends(SkippedTokenTrivia, _super);
            function SkippedTokenTrivia(_skippedToken, _fullText) {
                _super.call(this, 6 /* SkippedTokenTrivia */);
                this._skippedToken = _skippedToken;
                this._fullText = _fullText;
                _skippedToken.parent = this;
            }
            SkippedTokenTrivia.prototype.clone = function () {
                return new SkippedTokenTrivia(this._skippedToken.clone(), this._fullText);
            };
            SkippedTokenTrivia.prototype.fullStart = function () {
                return this._skippedToken.fullStart();
            };
            SkippedTokenTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            SkippedTokenTrivia.prototype.fullText = function () {
                return this._fullText;
            };
            SkippedTokenTrivia.prototype.skippedToken = function () {
                return this._skippedToken;
            };
            return SkippedTokenTrivia;
        })(AbstractTrivia);
        var DeferredTrivia = (function (_super) {
            __extends(DeferredTrivia, _super);
            function DeferredTrivia(kind, _text, _fullStart, _fullWidth) {
                _super.call(this, kind);
                this._text = _text;
                this._fullStart = _fullStart;
                this._fullWidth = _fullWidth;
            }
            DeferredTrivia.prototype.clone = function () {
                return new DeferredTrivia(this.kind, this._text, this._fullStart, this._fullWidth);
            };
            DeferredTrivia.prototype.fullStart = function () {
                return this._fullStart;
            };
            DeferredTrivia.prototype.fullWidth = function () {
                return this._fullWidth;
            };
            DeferredTrivia.prototype.fullText = function () {
                return this._text.substr(this._fullStart, this._fullWidth);
            };
            DeferredTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            return DeferredTrivia;
        })(AbstractTrivia);
        function deferredTrivia(kind, text, fullStart, fullWidth) {
            return new DeferredTrivia(kind, text, fullStart, fullWidth);
        }
        Syntax.deferredTrivia = deferredTrivia;
        function skippedTokenTrivia(token, text) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SkippedTokenTrivia(token, token.fullText(text));
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;
        // Breaks a multiline trivia up into individual line components.  If the trivia doesn't span
        // any lines, then the result will be a single string with the entire text of the trivia. 
        // Otherwise, there will be one entry in the array for each line spanned by the trivia.  Each
        // entry will contain the line separator at the end of the string.
        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            // Debug.assert(trivia.kind === SyntaxKind.MultiLineCommentTrivia);
            var result = [];
            var triviaText = trivia.fullText();
            var currentIndex = 0;
            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            // Consume the \r
                            i++;
                        }
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        // Eat from the last starting position through to the end of the newline.
                        result.push(triviaText.substring(currentIndex, i + 1));
                        // Set the current index to *after* the newline.
                        currentIndex = i + 1;
                        continue;
                }
            }
            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var EmptyTriviaList = (function () {
            function EmptyTriviaList() {
            }
            EmptyTriviaList.prototype.isShared = function () {
                return true;
            };
            EmptyTriviaList.prototype.count = function () {
                return 0;
            };
            EmptyTriviaList.prototype.syntaxTriviaAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyTriviaList.prototype.last = function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyTriviaList.prototype.fullWidth = function () {
                return 0;
            };
            EmptyTriviaList.prototype.fullText = function () {
                return "";
            };
            EmptyTriviaList.prototype.hasComment = function () {
                return false;
            };
            EmptyTriviaList.prototype.hasNewLine = function () {
                return false;
            };
            EmptyTriviaList.prototype.hasSkippedToken = function () {
                return false;
            };
            EmptyTriviaList.prototype.toArray = function () {
                return [];
            };
            EmptyTriviaList.prototype.clone = function () {
                return this;
            };
            return EmptyTriviaList;
        })();
        ;
        Syntax.emptyTriviaList = new EmptyTriviaList();
        function isComment(trivia) {
            return trivia.kind === 4 /* MultiLineCommentTrivia */ || trivia.kind === 5 /* SingleLineCommentTrivia */;
        }
        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item.clone();
                this.item.parent = this;
            }
            SingletonSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };
            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };
            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };
            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind === 3 /* NewLineTrivia */;
            };
            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind === 6 /* SkippedTokenTrivia */;
            };
            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSyntaxTriviaList.prototype.clone = function () {
                return new SingletonSyntaxTriviaList(this.item.clone());
            };
            return SingletonSyntaxTriviaList;
        })();
        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                var _this = this;
                this.trivia = trivia.map(function (t) {
                    var cloned = t.clone();
                    cloned.parent = _this;
                    return cloned;
                });
            }
            NormalSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };
            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };
            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.trivia[index];
            };
            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };
            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) { return t.fullWidth(); });
            };
            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = [];
                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result.push(this.trivia[i].fullText());
                }
                return result.join("");
            };
            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind === 3 /* NewLineTrivia */) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind === 6 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };
            NormalSyntaxTriviaList.prototype.clone = function () {
                return new NormalSyntaxTriviaList(this.trivia.map(function (t) { return t.clone(); }));
            };
            return NormalSyntaxTriviaList;
        })();
        function triviaList(trivia) {
            if (!trivia || trivia.length === 0) {
                return Syntax.emptyTriviaList;
            }
            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }
            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function childCount(element) {
        if (TypeScript.isList(element)) {
            return element.length;
        }
        return element.childCount;
    }
    TypeScript.childCount = childCount;
    function childAt(element, index) {
        if (TypeScript.isList(element)) {
            return element[index];
        }
        return element.childAt(index);
    }
    TypeScript.childAt = childAt;
    var SyntaxUtilities;
    (function (SyntaxUtilities) {
        function isAnyFunctionExpressionOrDeclaration(ast) {
            switch (ast.kind) {
                case 183 /* SimpleArrowFunctionExpression */:
                case 182 /* ParenthesizedArrowFunctionExpression */:
                case 186 /* FunctionExpression */:
                case 134 /* FunctionDeclaration */:
                case 140 /* MemberFunctionDeclaration */:
                case 207 /* FunctionPropertyAssignment */:
                case 142 /* ConstructorDeclaration */:
                case 144 /* GetAccessor */:
                case 145 /* SetAccessor */:
                    return true;
            }
            return false;
        }
        SyntaxUtilities.isAnyFunctionExpressionOrDeclaration = isAnyFunctionExpressionOrDeclaration;
        function isLastTokenOnLine(token, text) {
            var _nextToken = TypeScript.nextToken(token, text);
            if (_nextToken === undefined) {
                return true;
            }
            var lineMap = text.lineMap();
            var tokenLine = lineMap.getLineNumberFromPosition(TypeScript.fullEnd(token));
            var nextTokenLine = lineMap.getLineNumberFromPosition(TypeScript.start(_nextToken, text));
            return tokenLine !== nextTokenLine;
        }
        SyntaxUtilities.isLastTokenOnLine = isLastTokenOnLine;
        function isLeftHandSizeExpression(element) {
            if (element) {
                switch (element.kind) {
                    case 176 /* MemberAccessExpression */:
                    case 185 /* ElementAccessExpression */:
                    case 189 /* TemplateAccessExpression */:
                    case 180 /* ObjectCreationExpression */:
                    case 177 /* InvocationExpression */:
                    case 178 /* ArrayLiteralExpression */:
                    case 181 /* ParenthesizedExpression */:
                    case 179 /* ObjectLiteralExpression */:
                    case 186 /* FunctionExpression */:
                    case 9 /* IdentifierName */:
                    case 10 /* RegularExpressionLiteral */:
                    case 11 /* NumericLiteral */:
                    case 12 /* StringLiteral */:
                    case 26 /* FalseKeyword */:
                    case 34 /* NullKeyword */:
                    case 37 /* ThisKeyword */:
                    case 39 /* TrueKeyword */:
                    case 52 /* SuperKeyword */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isLeftHandSizeExpression = isLeftHandSizeExpression;
        function isSwitchClause(element) {
            if (element) {
                switch (element.kind) {
                    case 198 /* CaseSwitchClause */:
                    case 199 /* DefaultSwitchClause */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isSwitchClause = isSwitchClause;
        function isTypeMember(element) {
            if (element) {
                switch (element.kind) {
                    case 148 /* ConstructSignature */:
                    case 150 /* MethodSignature */:
                    case 149 /* IndexSignature */:
                    case 146 /* PropertySignature */:
                    case 147 /* CallSignature */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isTypeMember = isTypeMember;
        function isClassElement(element) {
            if (element) {
                switch (element.kind) {
                    case 142 /* ConstructorDeclaration */:
                    case 143 /* IndexMemberDeclaration */:
                    case 140 /* MemberFunctionDeclaration */:
                    case 144 /* GetAccessor */:
                    case 145 /* SetAccessor */:
                    case 140 /* MemberFunctionDeclaration */:
                    case 141 /* MemberVariableDeclaration */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isClassElement = isClassElement;
        function isModuleElement(element) {
            if (element) {
                switch (element.kind) {
                    case 138 /* ImportDeclaration */:
                    case 139 /* ExportAssignment */:
                    case 136 /* ClassDeclaration */:
                    case 133 /* InterfaceDeclaration */:
                    case 135 /* ModuleDeclaration */:
                    case 137 /* EnumDeclaration */:
                    case 134 /* FunctionDeclaration */:
                    case 153 /* VariableStatement */:
                    case 151 /* Block */:
                    case 152 /* IfStatement */:
                    case 154 /* ExpressionStatement */:
                    case 162 /* ThrowStatement */:
                    case 155 /* ReturnStatement */:
                    case 156 /* SwitchStatement */:
                    case 157 /* BreakStatement */:
                    case 158 /* ContinueStatement */:
                    case 160 /* ForInStatement */:
                    case 159 /* ForStatement */:
                    case 163 /* WhileStatement */:
                    case 168 /* WithStatement */:
                    case 161 /* EmptyStatement */:
                    case 164 /* TryStatement */:
                    case 165 /* LabeledStatement */:
                    case 166 /* DoStatement */:
                    case 167 /* DebuggerStatement */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isModuleElement = isModuleElement;
        function isStatement(element) {
            if (element) {
                switch (element.kind) {
                    case 134 /* FunctionDeclaration */:
                    case 153 /* VariableStatement */:
                    case 151 /* Block */:
                    case 152 /* IfStatement */:
                    case 154 /* ExpressionStatement */:
                    case 162 /* ThrowStatement */:
                    case 155 /* ReturnStatement */:
                    case 156 /* SwitchStatement */:
                    case 157 /* BreakStatement */:
                    case 158 /* ContinueStatement */:
                    case 160 /* ForInStatement */:
                    case 159 /* ForStatement */:
                    case 163 /* WhileStatement */:
                    case 168 /* WithStatement */:
                    case 161 /* EmptyStatement */:
                    case 164 /* TryStatement */:
                    case 165 /* LabeledStatement */:
                    case 166 /* DoStatement */:
                    case 167 /* DebuggerStatement */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isStatement = isStatement;
        function isAngleBracket(positionedElement) {
            var element = positionedElement;
            var parent = positionedElement.parent;
            if (parent && (element.kind === 82 /* LessThanToken */ || element.kind === 83 /* GreaterThanToken */)) {
                switch (parent.kind) {
                    case 194 /* TypeArgumentList */:
                    case 195 /* TypeParameterList */:
                    case 184 /* CastExpression */:
                        return true;
                }
            }
            return false;
        }
        SyntaxUtilities.isAngleBracket = isAngleBracket;
        function getToken(list, kind) {
            for (var i = 0, n = list.length; i < n; i++) {
                var token = list[i];
                if (token.kind === kind) {
                    return token;
                }
            }
            return undefined;
        }
        SyntaxUtilities.getToken = getToken;
        function containsToken(list, kind) {
            return !!SyntaxUtilities.getToken(list, kind);
        }
        SyntaxUtilities.containsToken = containsToken;
        function hasExportKeyword(moduleElement) {
            return !!SyntaxUtilities.getExportKeyword(moduleElement);
        }
        SyntaxUtilities.hasExportKeyword = hasExportKeyword;
        function getExportKeyword(moduleElement) {
            switch (moduleElement.kind) {
                case 135 /* ModuleDeclaration */:
                case 136 /* ClassDeclaration */:
                case 134 /* FunctionDeclaration */:
                case 153 /* VariableStatement */:
                case 137 /* EnumDeclaration */:
                case 133 /* InterfaceDeclaration */:
                case 138 /* ImportDeclaration */:
                    return SyntaxUtilities.getToken(moduleElement.modifiers, 49 /* ExportKeyword */);
                default:
                    return undefined;
            }
        }
        SyntaxUtilities.getExportKeyword = getExportKeyword;
        function isAmbientDeclarationSyntax(positionNode) {
            if (!positionNode) {
                return false;
            }
            var node = positionNode;
            switch (node.kind) {
                case 135 /* ModuleDeclaration */:
                case 136 /* ClassDeclaration */:
                case 134 /* FunctionDeclaration */:
                case 153 /* VariableStatement */:
                case 137 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */)) {
                        return true;
                    }
                case 138 /* ImportDeclaration */:
                case 142 /* ConstructorDeclaration */:
                case 140 /* MemberFunctionDeclaration */:
                case 144 /* GetAccessor */:
                case 145 /* SetAccessor */:
                case 141 /* MemberVariableDeclaration */:
                    if (SyntaxUtilities.isClassElement(node) || SyntaxUtilities.isModuleElement(node)) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
                    }
                case 209 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(TypeScript.Syntax.containingNode(positionNode)));
                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
            }
        }
        SyntaxUtilities.isAmbientDeclarationSyntax = isAmbientDeclarationSyntax;
    })(SyntaxUtilities = TypeScript.SyntaxUtilities || (TypeScript.SyntaxUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function visitNodeOrToken(visitor, element) {
        if (element === undefined) {
            return undefined;
        }
        switch (element.kind) {
            case 122 /* SourceUnit */: return visitor.visitSourceUnit(element);
            case 123 /* QualifiedName */: return visitor.visitQualifiedName(element);
            case 124 /* ObjectType */: return visitor.visitObjectType(element);
            case 125 /* FunctionType */: return visitor.visitFunctionType(element);
            case 126 /* ArrayType */: return visitor.visitArrayType(element);
            case 127 /* ConstructorType */: return visitor.visitConstructorType(element);
            case 128 /* GenericType */: return visitor.visitGenericType(element);
            case 129 /* TypeQuery */: return visitor.visitTypeQuery(element);
            case 130 /* TupleType */: return visitor.visitTupleType(element);
            case 131 /* UnionType */: return visitor.visitUnionType(element);
            case 132 /* ParenthesizedType */: return visitor.visitParenthesizedType(element);
            case 133 /* InterfaceDeclaration */: return visitor.visitInterfaceDeclaration(element);
            case 134 /* FunctionDeclaration */: return visitor.visitFunctionDeclaration(element);
            case 135 /* ModuleDeclaration */: return visitor.visitModuleDeclaration(element);
            case 136 /* ClassDeclaration */: return visitor.visitClassDeclaration(element);
            case 137 /* EnumDeclaration */: return visitor.visitEnumDeclaration(element);
            case 138 /* ImportDeclaration */: return visitor.visitImportDeclaration(element);
            case 139 /* ExportAssignment */: return visitor.visitExportAssignment(element);
            case 140 /* MemberFunctionDeclaration */: return visitor.visitMemberFunctionDeclaration(element);
            case 141 /* MemberVariableDeclaration */: return visitor.visitMemberVariableDeclaration(element);
            case 142 /* ConstructorDeclaration */: return visitor.visitConstructorDeclaration(element);
            case 143 /* IndexMemberDeclaration */: return visitor.visitIndexMemberDeclaration(element);
            case 144 /* GetAccessor */: return visitor.visitGetAccessor(element);
            case 145 /* SetAccessor */: return visitor.visitSetAccessor(element);
            case 146 /* PropertySignature */: return visitor.visitPropertySignature(element);
            case 147 /* CallSignature */: return visitor.visitCallSignature(element);
            case 148 /* ConstructSignature */: return visitor.visitConstructSignature(element);
            case 149 /* IndexSignature */: return visitor.visitIndexSignature(element);
            case 150 /* MethodSignature */: return visitor.visitMethodSignature(element);
            case 151 /* Block */: return visitor.visitBlock(element);
            case 152 /* IfStatement */: return visitor.visitIfStatement(element);
            case 153 /* VariableStatement */: return visitor.visitVariableStatement(element);
            case 154 /* ExpressionStatement */: return visitor.visitExpressionStatement(element);
            case 155 /* ReturnStatement */: return visitor.visitReturnStatement(element);
            case 156 /* SwitchStatement */: return visitor.visitSwitchStatement(element);
            case 157 /* BreakStatement */: return visitor.visitBreakStatement(element);
            case 158 /* ContinueStatement */: return visitor.visitContinueStatement(element);
            case 159 /* ForStatement */: return visitor.visitForStatement(element);
            case 160 /* ForInStatement */: return visitor.visitForInStatement(element);
            case 161 /* EmptyStatement */: return visitor.visitEmptyStatement(element);
            case 162 /* ThrowStatement */: return visitor.visitThrowStatement(element);
            case 163 /* WhileStatement */: return visitor.visitWhileStatement(element);
            case 164 /* TryStatement */: return visitor.visitTryStatement(element);
            case 165 /* LabeledStatement */: return visitor.visitLabeledStatement(element);
            case 166 /* DoStatement */: return visitor.visitDoStatement(element);
            case 167 /* DebuggerStatement */: return visitor.visitDebuggerStatement(element);
            case 168 /* WithStatement */: return visitor.visitWithStatement(element);
            case 169 /* PrefixUnaryExpression */: return visitor.visitPrefixUnaryExpression(element);
            case 170 /* DeleteExpression */: return visitor.visitDeleteExpression(element);
            case 171 /* TypeOfExpression */: return visitor.visitTypeOfExpression(element);
            case 172 /* VoidExpression */: return visitor.visitVoidExpression(element);
            case 173 /* ConditionalExpression */: return visitor.visitConditionalExpression(element);
            case 174 /* BinaryExpression */: return visitor.visitBinaryExpression(element);
            case 175 /* PostfixUnaryExpression */: return visitor.visitPostfixUnaryExpression(element);
            case 176 /* MemberAccessExpression */: return visitor.visitMemberAccessExpression(element);
            case 177 /* InvocationExpression */: return visitor.visitInvocationExpression(element);
            case 178 /* ArrayLiteralExpression */: return visitor.visitArrayLiteralExpression(element);
            case 179 /* ObjectLiteralExpression */: return visitor.visitObjectLiteralExpression(element);
            case 180 /* ObjectCreationExpression */: return visitor.visitObjectCreationExpression(element);
            case 181 /* ParenthesizedExpression */: return visitor.visitParenthesizedExpression(element);
            case 182 /* ParenthesizedArrowFunctionExpression */: return visitor.visitParenthesizedArrowFunctionExpression(element);
            case 183 /* SimpleArrowFunctionExpression */: return visitor.visitSimpleArrowFunctionExpression(element);
            case 184 /* CastExpression */: return visitor.visitCastExpression(element);
            case 185 /* ElementAccessExpression */: return visitor.visitElementAccessExpression(element);
            case 186 /* FunctionExpression */: return visitor.visitFunctionExpression(element);
            case 187 /* OmittedExpression */: return visitor.visitOmittedExpression(element);
            case 188 /* TemplateExpression */: return visitor.visitTemplateExpression(element);
            case 189 /* TemplateAccessExpression */: return visitor.visitTemplateAccessExpression(element);
            case 190 /* VariableDeclaration */: return visitor.visitVariableDeclaration(element);
            case 191 /* VariableDeclarator */: return visitor.visitVariableDeclarator(element);
            case 192 /* ArgumentList */: return visitor.visitArgumentList(element);
            case 193 /* ParameterList */: return visitor.visitParameterList(element);
            case 194 /* TypeArgumentList */: return visitor.visitTypeArgumentList(element);
            case 195 /* TypeParameterList */: return visitor.visitTypeParameterList(element);
            case 196 /* HeritageClause */: return visitor.visitHeritageClause(element);
            case 197 /* EqualsValueClause */: return visitor.visitEqualsValueClause(element);
            case 198 /* CaseSwitchClause */: return visitor.visitCaseSwitchClause(element);
            case 199 /* DefaultSwitchClause */: return visitor.visitDefaultSwitchClause(element);
            case 200 /* ElseClause */: return visitor.visitElseClause(element);
            case 201 /* CatchClause */: return visitor.visitCatchClause(element);
            case 202 /* FinallyClause */: return visitor.visitFinallyClause(element);
            case 203 /* TemplateClause */: return visitor.visitTemplateClause(element);
            case 204 /* TypeParameter */: return visitor.visitTypeParameter(element);
            case 205 /* Constraint */: return visitor.visitConstraint(element);
            case 206 /* SimplePropertyAssignment */: return visitor.visitSimplePropertyAssignment(element);
            case 207 /* FunctionPropertyAssignment */: return visitor.visitFunctionPropertyAssignment(element);
            case 208 /* Parameter */: return visitor.visitParameter(element);
            case 209 /* EnumElement */: return visitor.visitEnumElement(element);
            case 210 /* TypeAnnotation */: return visitor.visitTypeAnnotation(element);
            case 211 /* ComputedPropertyName */: return visitor.visitComputedPropertyName(element);
            case 212 /* ExternalModuleReference */: return visitor.visitExternalModuleReference(element);
            case 213 /* ModuleNameModuleReference */: return visitor.visitModuleNameModuleReference(element);
            default: return visitor.visitToken(element);
        }
    }
    TypeScript.visitNodeOrToken = visitNodeOrToken;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };
        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === undefined) {
                return;
            }
            this.visitToken(token);
        };
        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.length; i < n; i++) {
                TypeScript.visitNodeOrToken(this, list[i]);
            }
        };
        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };
        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            TypeScript.visitNodeOrToken(this, node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };
        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitFunctionType = function (node) {
            TypeScript.visitNodeOrToken(this, node.typeParameterList);
            TypeScript.visitNodeOrToken(this, node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            TypeScript.visitNodeOrToken(this, node.type);
        };
        SyntaxWalker.prototype.visitArrayType = function (node) {
            TypeScript.visitNodeOrToken(this, node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            TypeScript.visitNodeOrToken(this, node.typeParameterList);
            TypeScript.visitNodeOrToken(this, node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            TypeScript.visitNodeOrToken(this, node.type);
        };
        SyntaxWalker.prototype.visitGenericType = function (node) {
            TypeScript.visitNodeOrToken(this, node.name);
            TypeScript.visitNodeOrToken(this, node.typeArgumentList);
        };
        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            TypeScript.visitNodeOrToken(this, node.name);
        };
        SyntaxWalker.prototype.visitTupleType = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitList(node.types);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitUnionType = function (node) {
            TypeScript.visitNodeOrToken(this, node.left);
            this.visitToken(node.barToken);
            TypeScript.visitNodeOrToken(this, node.right);
        };
        SyntaxWalker.prototype.visitParenthesizedType = function (node) {
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.type);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.typeParameterList);
            this.visitList(node.heritageClauses);
            TypeScript.visitNodeOrToken(this, node.body);
        };
        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            TypeScript.visitNodeOrToken(this, node.name);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            TypeScript.visitNodeOrToken(this, node.moduleReference);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            TypeScript.visitNodeOrToken(this, node.variableDeclarator);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.constructorKeyword);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitIndexMemberDeclaration = function (node) {
            this.visitList(node.modifiers);
            TypeScript.visitNodeOrToken(this, node.indexSignature);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitGetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitSetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            this.visitOptionalToken(node.questionToken);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitCallSignature = function (node) {
            TypeScript.visitNodeOrToken(this, node.typeParameterList);
            TypeScript.visitNodeOrToken(this, node.parameterList);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            TypeScript.visitNodeOrToken(this, node.callSignature);
        };
        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitList(node.parameters);
            this.visitToken(node.closeBracketToken);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            this.visitOptionalToken(node.questionToken);
            TypeScript.visitNodeOrToken(this, node.callSignature);
        };
        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.statement);
            TypeScript.visitNodeOrToken(this, node.elseClause);
        };
        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            TypeScript.visitNodeOrToken(this, node.variableDeclaration);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.variableDeclaration);
            TypeScript.visitNodeOrToken(this, node.initializer);
            this.visitToken(node.firstSemicolonToken);
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.secondSemicolonToken);
            TypeScript.visitNodeOrToken(this, node.incrementor);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.variableDeclaration);
            TypeScript.visitNodeOrToken(this, node.left);
            this.visitToken(node.inKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            TypeScript.visitNodeOrToken(this, node.block);
            TypeScript.visitNodeOrToken(this, node.catchClause);
            TypeScript.visitNodeOrToken(this, node.finallyClause);
        };
        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            TypeScript.visitNodeOrToken(this, node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.closeParenToken);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            TypeScript.visitNodeOrToken(this, node.operand);
        };
        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.condition);
            this.visitToken(node.questionToken);
            TypeScript.visitNodeOrToken(this, node.whenTrue);
            this.visitToken(node.colonToken);
            TypeScript.visitNodeOrToken(this, node.whenFalse);
        };
        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.left);
            this.visitToken(node.operatorToken);
            TypeScript.visitNodeOrToken(this, node.right);
        };
        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.operand);
            this.visitToken(node.operatorToken);
        };
        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };
        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            TypeScript.visitNodeOrToken(this, node.argumentList);
        };
        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
            TypeScript.visitNodeOrToken(this, node.argumentList);
        };
        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            TypeScript.visitNodeOrToken(this, node.block);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.parameter);
            this.visitToken(node.equalsGreaterThanToken);
            TypeScript.visitNodeOrToken(this, node.block);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            TypeScript.visitNodeOrToken(this, node.type);
            this.visitToken(node.greaterThanToken);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.openBracketToken);
            TypeScript.visitNodeOrToken(this, node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };
        SyntaxWalker.prototype.visitTemplateExpression = function (node) {
            this.visitToken(node.templateStartToken);
            this.visitList(node.templateClauses);
        };
        SyntaxWalker.prototype.visitTemplateAccessExpression = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            TypeScript.visitNodeOrToken(this, node.templateExpression);
        };
        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitList(node.variableDeclarators);
        };
        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
            TypeScript.visitNodeOrToken(this, node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitArgumentList = function (node) {
            TypeScript.visitNodeOrToken(this, node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitList(node.arguments);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitList(node.parameters);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitList(node.typeNames);
        };
        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            TypeScript.visitNodeOrToken(this, node.value);
        };
        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            TypeScript.visitNodeOrToken(this, node.statement);
        };
        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitTemplateClause = function (node) {
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.templateMiddleOrEndToken);
        };
        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            TypeScript.visitNodeOrToken(this, node.constraint);
        };
        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            TypeScript.visitNodeOrToken(this, node.typeOrExpression);
        };
        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            this.visitToken(node.colonToken);
            TypeScript.visitNodeOrToken(this, node.expression);
        };
        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.callSignature);
            TypeScript.visitNodeOrToken(this, node.block);
        };
        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitList(node.modifiers);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            TypeScript.visitNodeOrToken(this, node.typeAnnotation);
            TypeScript.visitNodeOrToken(this, node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitEnumElement = function (node) {
            TypeScript.visitNodeOrToken(this, node.propertyName);
            TypeScript.visitNodeOrToken(this, node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            TypeScript.visitNodeOrToken(this, node.type);
        };
        SyntaxWalker.prototype.visitComputedPropertyName = function (node) {
            this.visitToken(node.openBracketToken);
            TypeScript.visitNodeOrToken(this, node.expression);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            TypeScript.visitNodeOrToken(this, node.moduleName);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Parser;
    (function (Parser) {
        // Contains the actual logic to parse typescript/javascript.  This is the code that generally
        // represents the logic necessary to handle all the language grammar constructs.  When the 
        // language changes, this should generally only be the place necessary to fix up.
        function createParseSyntaxTree() {
            // Name of the file we're parsing.
            var fileName;
            // Underlying source where we pull nodes and tokens from.
            var source;
            var languageVersion;
            // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
            // parsing logic already handles storing/restoring this and should work properly even if we're
            // speculative parsing.
            var listParsingState = 0;
            // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
            // that some tokens that would be considered identifiers may be considered keywords.  When 
            // rewinding, we need to store and restore this as the mode may have changed.
            //
            // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
            // parsing logic already handles storing/restoring this and should work properly even if we're
            // speculative parsing.
            var isInStrictMode = false;
            // Current state of the parser.  If we need to rewind we will store and reset these values as
            // appropriate.
            // Diagnostics created when parsing invalid code.  Any diagnosics created when speculative 
            // parsing need to removed when rewinding.  To do this we store the count of diagnostics when 
            // we start speculative parsing.  And if we rewind, we restore this to the same count that we 
            // started at.
            var diagnostics = [];
            var parseNodeData = 0;
            var _skippedTokens = undefined;
            function parseSyntaxTree(_source, isDeclaration) {
                // First, set up our state.
                fileName = _source.fileName;
                source = _source;
                languageVersion = source.languageVersion;
                // Now actually parse the tree.
                var result = parseSyntaxTreeWorker(isDeclaration);
                // Now, clear out our state so that our singleton parser doesn't keep things alive.
                diagnostics = [];
                parseNodeData = 0 /* None */;
                fileName = undefined;
                source.release();
                source = undefined;
                _source = undefined;
                return result;
            }
            function parseSyntaxTreeWorker(isDeclaration) {
                var sourceUnit = parseSourceUnit();
                var allDiagnostics = source.tokenDiagnostics().concat(diagnostics);
                allDiagnostics.sort(function (a, b) { return a.start() - b.start(); });
                return new TypeScript.SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, fileName, source.text, languageVersion);
            }
            function getRewindPoint() {
                var rewindPoint = source.getRewindPoint();
                // See the comments in IParserRewindPoint for the explanation on why we need to store
                // this data, and what it is used for.
                rewindPoint.diagnosticsCount = diagnostics.length;
                rewindPoint.skippedTokens = _skippedTokens ? _skippedTokens.slice(0) : undefined;
                // Values we keep around for debug asserting purposes.
                rewindPoint.isInStrictMode = isInStrictMode;
                rewindPoint.listParsingState = listParsingState;
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                source.rewind(rewindPoint);
                diagnostics.length = rewindPoint.diagnosticsCount;
                _skippedTokens = rewindPoint.skippedTokens;
            }
            function releaseRewindPoint(rewindPoint) {
                // Debug.assert(listParsingState === rewindPoint.listParsingState);
                // Debug.assert(isInStrictMode === rewindPoint.isInStrictMode);
                source.releaseRewindPoint(rewindPoint);
            }
            function currentNode() {
                // If we have any outstanding tokens, then don't reuse a node.  
                // TODO(cyrusn): This may be too conservative.  Perhaps we could reuse hte node and
                // attach the skipped tokens in front?  For now though, being conservative is nice and
                // safe, and likely won't ever affect perf.
                if (_skippedTokens) {
                    return null;
                }
                var node = source.currentNode();
                // We can only reuse a node if it was parsed under the same strict mode that we're 
                // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
                // the user added 'using strict' at the top of the file, then we can't use that node
                // again as the presense of strict mode may cause us to parse the tokens in the file
                // differetly.
                //
                // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
                // are unaffected by strict mode.  It's just the parser will decide what to do with it
                // differently depending on what mode it is in.
                if (!node || TypeScript.parsedInStrictMode(node) !== isInStrictMode) {
                    return undefined;
                }
                return node;
            }
            function currentToken() {
                return source.currentToken();
            }
            function currentContextualToken() {
                // We're mutating the source here.  We are potentially overwriting the original token we
                // scanned with a regex token.  So we have to clear our state.
                return source.currentContextualToken();
            }
            function peekToken(n) {
                return source.peekToken(n);
            }
            function skipToken(token) {
                _skippedTokens = _skippedTokens || [];
                _skippedTokens.push(token);
                // directly tell the source to just consume the token we're skipping.  i.e. do not 
                // call 'consumeToken'.  Doing so would attempt to add any previous skipped tokens
                // to this token we're skipping.  We don't want to do that.  Instead, we want to add
                // all the skipped tokens when we finally eat the next good token.
                source.consumeToken(token);
            }
            function consumeToken(token) {
                // Debug.assert(token.fullWidth() > 0 || token.kind === SyntaxKind.EndOfFileToken);
                // First, tell our source that the token has been consumed.
                source.consumeToken(token);
                // Now, if we had any skipped tokens, we want to add them to the start of this token
                // we're consuming.
                if (_skippedTokens) {
                    token = addSkippedTokensBeforeToken(token, _skippedTokens);
                    _skippedTokens = undefined;
                }
                return token;
            }
            function addSkippedTokensBeforeToken(token, skippedTokens) {
                //Debug.assert(token.fullWidth() > 0 || token.kind === SyntaxKind.EndOfFileToken);
                //Debug.assert(skippedTokens.length > 0);
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    var skippedToken = skippedTokens[i];
                    addSkippedTokenToTriviaArray(leadingTrivia, skippedToken);
                }
                addTriviaTo(token.leadingTrivia(source.text), leadingTrivia);
                var updatedToken = TypeScript.Syntax.withLeadingTrivia(token, TypeScript.Syntax.triviaList(leadingTrivia), source.text);
                // We've prepending this token with new leading trivia.  This means the full start of
                // the token is not where the scanner originally thought it was, but is instead at the
                // start of the first skipped token.
                updatedToken.setFullStart(skippedTokens[0].fullStart());
                return updatedToken;
            }
            function addSkippedTokenToTriviaArray(array, skippedToken) {
                // Debug.assert(skippedToken.text().length > 0);
                // first, add the leading trivia of the skipped token to the array
                addTriviaTo(skippedToken.leadingTrivia(source.text), array);
                // now, add the text of the token as skipped text to the trivia array.
                var trimmedToken = TypeScript.Syntax.withLeadingTrivia(skippedToken, TypeScript.Syntax.emptyTriviaList, source.text);
                // Because we removed the leading trivia from the skipped token, the full start of the
                // trimmed token is the start of the skipped token.
                trimmedToken.setFullStart(TypeScript.start(skippedToken, source.text));
                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken, source.text));
            }
            function addTriviaTo(list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            }
            function consumeNode(node) {
                TypeScript.Debug.assert(_skippedTokens === undefined);
                source.consumeNode(node);
            }
            //this method is called very frequently
            //we should keep it simple so that it can be inlined.
            function eatToken(kind) {
                var token = currentToken();
                if (token.kind === kind) {
                    return consumeToken(token);
                }
                //slow part of EatToken(SyntaxKind kind)
                return createMissingToken(kind, token);
            }
            // Eats the token if it is there.  Otherwise does nothing.  Will not report errors.
            function tryEatToken(kind) {
                var _currentToken = currentToken();
                if (_currentToken.kind === kind) {
                    return consumeToken(_currentToken);
                }
                return undefined;
            }
            // An identifier is basically any word, unless it is a reserved keyword.  so 'foo' is an 
            // identifier and 'return' is not.  Note: a word may or may not be an identifier depending 
            // on the state of the parser.  For example, 'yield' is an identifier *unless* the parser 
            // is in strict mode.
            function isIdentifier(token) {
                var tokenKind = token.kind;
                if (tokenKind === 9 /* IdentifierName */) {
                    return true;
                }
                // Keywords are only identifiers if they're FutureReservedStrictWords and we're in 
                // strict mode.  *Or* if it's a typescript 'keyword'. 
                if (tokenKind >= TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword) {
                    if (tokenKind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword) {
                        // Could be a keyword or identifier.  It's an identifier if we're not in strict
                        // mode.
                        return !isInStrictMode;
                    }
                    // If it's typescript keyword, then it's actually a javascript identifier.
                    return tokenKind <= TypeScript.SyntaxKind.LastTypeScriptKeyword;
                }
                // Anything else is not an identifier.
                return false;
            }
            // This method should be called when the grammar calls for an *IdentifierName* and not an
            // *Identifier*.
            function eatIdentifierNameToken() {
                var token = currentToken();
                // If we have an identifier name, then consume and return it.
                var tokenKind = token.kind;
                if (tokenKind === 9 /* IdentifierName */) {
                    return consumeToken(token);
                }
                // If we have a keyword, then it can be used as an identifier name.  However, we need 
                // to convert it to an identifier so that no later parts of the systems see it as a 
                // keyword.
                if (TypeScript.SyntaxFacts.isAnyKeyword(tokenKind)) {
                    return TypeScript.Syntax.convertKeywordToIdentifier(consumeToken(token));
                }
                return createMissingToken(9 /* IdentifierName */, token);
            }
            function eatOptionalIdentifierToken() {
                return isIdentifier(currentToken()) ? eatIdentifierToken() : undefined;
            }
            // This method should be called when the grammar calls for an *Identifier* and not an
            // *IdentifierName*.
            function eatIdentifierToken(diagnosticCode) {
                var token = currentToken();
                if (isIdentifier(token)) {
                    if (token.kind === 9 /* IdentifierName */) {
                        return consumeToken(token);
                    }
                    return TypeScript.Syntax.convertKeywordToIdentifier(consumeToken(token));
                }
                return createMissingToken(9 /* IdentifierName */, token, diagnosticCode);
            }
            function isOnDifferentLineThanPreviousToken(token) {
                return token.hasLeadingNewLine();
            }
            function canEatAutomaticSemicolon(allowWithoutNewLine) {
                var token = currentToken();
                // An automatic semicolon is always allowed if we're at the end of the file.
                var tokenKind = token.kind;
                if (tokenKind === 8 /* EndOfFileToken */) {
                    return true;
                }
                // Or if the next token is a close brace (regardless of which line it is on).
                if (tokenKind === 73 /* CloseBraceToken */) {
                    return true;
                }
                if (allowWithoutNewLine) {
                    return true;
                }
                // It is also allowed if there is a newline between the last token seen and the next one.
                if (isOnDifferentLineThanPreviousToken(token)) {
                    return true;
                }
                return false;
            }
            function canEatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();
                if (token.kind === 80 /* SemicolonToken */) {
                    return true;
                }
                return canEatAutomaticSemicolon(allowWithoutNewline);
            }
            function eatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();
                // If we see a semicolon, then we can definitely eat it.
                if (token.kind === 80 /* SemicolonToken */) {
                    return consumeToken(token);
                }
                // Check if an automatic semicolon could go here.  If so, then there's no problem and
                // we can proceed without error.  Return 'undefined' as there's no actual token for this 
                // position. 
                if (canEatAutomaticSemicolon(allowWithoutNewline)) {
                    return undefined;
                }
                // No semicolon could be consumed here at all.  Just call the standard eating function
                // so we get the token and the error for it.
                return eatToken(80 /* SemicolonToken */);
            }
            function createMissingToken(expectedKind, actual, diagnosticCode) {
                var diagnostic = getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode);
                addDiagnostic(diagnostic);
                // The missing token will be at the full start of the current token.  That way empty tokens
                // will always be between real tokens and not inside an actual token.
                return TypeScript.Syntax.emptyToken(expectedKind);
            }
            function getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode) {
                var token = currentToken();
                var args = undefined;
                // If a specialized diagnostic message was provided, just use that.
                if (!diagnosticCode) {
                    // They wanted something specific, just report that that token was missing.
                    if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                        diagnosticCode = TypeScript.DiagnosticCode._0_expected;
                        args = [TypeScript.SyntaxFacts.getText(expectedKind)];
                    }
                    else {
                        // They wanted an identifier.
                        // If the user supplied a keyword, give them a specialized message.
                        if (actual && TypeScript.SyntaxFacts.isAnyKeyword(actual.kind)) {
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected_0_is_a_keyword;
                            args = [TypeScript.SyntaxFacts.getText(actual.kind)];
                        }
                        else {
                            // Otherwise just report that an identifier was expected.
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected;
                        }
                    }
                }
                return new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), diagnosticCode, args);
            }
            function getBinaryExpressionPrecedence(tokenKind) {
                switch (tokenKind) {
                    case 106 /* BarBarToken */: return 2 /* LogicalOrExpressionPrecedence */;
                    case 105 /* AmpersandAmpersandToken */: return 3 /* LogicalAndExpressionPrecedence */;
                    case 101 /* BarToken */: return 4 /* BitwiseOrExpressionPrecedence */;
                    case 102 /* CaretToken */: return 5 /* BitwiseExclusiveOrExpressionPrecedence */;
                    case 100 /* AmpersandToken */: return 6 /* BitwiseAndExpressionPrecedence */;
                    case 86 /* EqualsEqualsToken */:
                    case 88 /* ExclamationEqualsToken */:
                    case 89 /* EqualsEqualsEqualsToken */:
                    case 90 /* ExclamationEqualsEqualsToken */:
                        return 7 /* EqualityExpressionPrecedence */;
                    case 82 /* LessThanToken */:
                    case 83 /* GreaterThanToken */:
                    case 84 /* LessThanEqualsToken */:
                    case 85 /* GreaterThanEqualsToken */:
                    case 32 /* InstanceOfKeyword */:
                    case 31 /* InKeyword */:
                        return 8 /* RelationalExpressionPrecedence */;
                    case 97 /* LessThanLessThanToken */:
                    case 98 /* GreaterThanGreaterThanToken */:
                    case 99 /* GreaterThanGreaterThanGreaterThanToken */:
                        return 9 /* ShiftExpressionPrecdence */;
                    case 91 /* PlusToken */:
                    case 92 /* MinusToken */:
                        return 10 /* AdditiveExpressionPrecedence */;
                    case 93 /* AsteriskToken */:
                    case 120 /* SlashToken */:
                    case 94 /* PercentToken */:
                        return 11 /* MultiplicativeExpressionPrecedence */;
                }
                throw TypeScript.Errors.invalidOperation();
            }
            function setStrictMode(_isInStrictMode) {
                isInStrictMode = _isInStrictMode;
                parseNodeData = _isInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
            }
            function parseSourceUnit() {
                // Note: saving and restoring the 'isInStrictMode' state is not really necessary here
                // (as it will never be read afterwards).  However, for symmetry with the rest of the
                // parsing code, we do the same here.
                var savedIsInStrictMode = isInStrictMode;
                // Note: any skipped tokens produced after the end of all the module elements will be
                // added as skipped trivia to the start of the EOF token.
                var moduleElements = parseSyntaxList(0 /* SourceUnit_ModuleElements */, updateStrictModeState);
                setStrictMode(savedIsInStrictMode);
                var sourceUnit = new TypeScript.SourceUnitSyntax(parseNodeData, moduleElements, consumeToken(currentToken()));
                if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                    TypeScript.Debug.assert(TypeScript.fullWidth(sourceUnit) === source.text.length());
                    if (TypeScript.Debug.shouldAssert(3 /* VeryAggressive */)) {
                        TypeScript.Debug.assert(TypeScript.fullText(sourceUnit) === source.text.substr(0, source.text.length()));
                    }
                }
                return sourceUnit;
            }
            function isDirectivePrologueElement(node) {
                return node.kind === 154 /* ExpressionStatement */ && node.expression.kind === 12 /* StringLiteral */;
            }
            function updateStrictModeState(items) {
                if (!isInStrictMode) {
                    for (var i = 0, n = items.length; i < n; i++) {
                        if (!isDirectivePrologueElement(items[i])) {
                            return;
                        }
                    }
                    setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            }
            function isModuleElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isModuleElement(currentNode())) {
                    return true;
                }
                var _modifierCount = modifierCount();
                return isInterfaceEnumClassModuleImportOrExport(_modifierCount) || isStatement(_modifierCount, inErrorRecovery);
            }
            function tryParseModuleElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isModuleElement(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var _modifierCount = modifierCount();
                if (_modifierCount) {
                    switch (peekToken(_modifierCount).kind) {
                        case 51 /* ImportKeyword */: return parseImportDeclaration();
                        case 67 /* ModuleKeyword */: return parseModuleDeclaration();
                        case 54 /* InterfaceKeyword */: return parseInterfaceDeclaration();
                        case 46 /* ClassKeyword */: return parseClassDeclaration();
                        case 48 /* EnumKeyword */: return parseEnumDeclaration();
                    }
                }
                // No modifiers.  If we see 'class, enum, import and export' we could technically 
                // aggressively consume them as they can't start another construct.  However, it's 
                // not uncommon in error recovery to run into a situation where we see those keywords,
                // but the code was using it as the name of an object property.  To avoid overzealously
                // consuming these, we only parse them out if we can see enough context to 'prove' that
                // they really do start the module element
                var nextToken = peekToken(1);
                var currentTokenKind = _currentToken.kind;
                switch (currentTokenKind) {
                    case 67 /* ModuleKeyword */:
                        if (isIdentifier(nextToken) || nextToken.kind === 12 /* StringLiteral */) {
                            return parseModuleDeclaration();
                        }
                        break;
                    case 51 /* ImportKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseImportDeclaration();
                        }
                        break;
                    case 46 /* ClassKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseClassDeclaration();
                        }
                        break;
                    case 48 /* EnumKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseEnumDeclaration();
                        }
                        break;
                    case 54 /* InterfaceKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseInterfaceDeclaration();
                        }
                        break;
                    case 49 /* ExportKeyword */:
                        // 'export' could be a modifier on a statement (like export var ...).  So we 
                        // only want to parse out an export assignment here if we actually see the equals.
                        if (nextToken.kind === 109 /* EqualsToken */) {
                            return parseExportAssignment();
                        }
                        break;
                }
                return tryParseStatementWorker(_currentToken, currentTokenKind, _modifierCount, inErrorRecovery);
            }
            function parseImportDeclaration() {
                return new TypeScript.ImportDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(51 /* ImportKeyword */), eatIdentifierToken(), eatToken(109 /* EqualsToken */), parseModuleReference(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseExportAssignment() {
                return new TypeScript.ExportAssignmentSyntax(parseNodeData, eatToken(49 /* ExportKeyword */), eatToken(109 /* EqualsToken */), eatIdentifierToken(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseModuleReference() {
                return isExternalModuleReference() ? parseExternalModuleReference() : parseModuleNameModuleReference();
            }
            function isExternalModuleReference() {
                return currentToken().kind === 68 /* RequireKeyword */ && peekToken(1).kind === 74 /* OpenParenToken */;
            }
            function parseExternalModuleReference() {
                return new TypeScript.ExternalModuleReferenceSyntax(parseNodeData, eatToken(68 /* RequireKeyword */), eatToken(74 /* OpenParenToken */), eatToken(12 /* StringLiteral */), eatToken(75 /* CloseParenToken */));
            }
            function parseModuleNameModuleReference() {
                return new TypeScript.ModuleNameModuleReferenceSyntax(parseNodeData, parseName(false));
            }
            function tryParseTypeArgumentList(inExpression) {
                var _currentToken = currentToken();
                if (_currentToken.kind !== 82 /* LessThanToken */) {
                    return undefined;
                }
                if (!inExpression) {
                    // if we're not in an expression, this must be a type argument list.  Just parse
                    // it out as such.
                    return new TypeScript.TypeArgumentListSyntax(parseNodeData, consumeToken(_currentToken), parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */), eatToken(83 /* GreaterThanToken */));
                }
                // If we're in an expression, then we only want to consume this as a type argument list
                // if we're sure that it's a type arg list and not an arithmetic expression.
                var rewindPoint = getRewindPoint();
                // We've seen a '<'.  Try to parse it out as a type argument list.
                var lessThanToken = consumeToken(_currentToken);
                var typeArguments = parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */);
                var greaterThanToken = eatToken(83 /* GreaterThanToken */);
                // We're in a context where '<' could be the start of a type argument list, or part
                // of an arithmetic expression.  We'll presume it's the latter unless we see the '>'
                // and a following token that guarantees that it's supposed to be a type argument list.
                if (greaterThanToken.fullWidth() === 0 || !canFollowTypeArgumentListInExpression(currentToken().kind)) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return undefined;
                }
                else {
                    releaseRewindPoint(rewindPoint);
                    return new TypeScript.TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, greaterThanToken);
                }
            }
            function canFollowTypeArgumentListInExpression(kind) {
                switch (kind) {
                    case 74 /* OpenParenToken */:
                    case 78 /* DotToken */:
                    case 75 /* CloseParenToken */:
                    case 77 /* CloseBracketToken */:
                    case 108 /* ColonToken */:
                    case 80 /* SemicolonToken */:
                    case 81 /* CommaToken */:
                    case 107 /* QuestionToken */:
                    case 86 /* EqualsEqualsToken */:
                    case 89 /* EqualsEqualsEqualsToken */:
                    case 88 /* ExclamationEqualsToken */:
                    case 90 /* ExclamationEqualsEqualsToken */:
                    case 105 /* AmpersandAmpersandToken */:
                    case 106 /* BarBarToken */:
                    case 102 /* CaretToken */:
                    case 100 /* AmpersandToken */:
                    case 101 /* BarToken */:
                    case 73 /* CloseBraceToken */:
                    case 8 /* EndOfFileToken */:
                        // these cases can't legally follow a type arg list.  However, they're not legal 
                        // expressions either.  The user is probably in the middle of a generic type. So
                        // treat it as such.
                        return true;
                    default:
                        // Anything else treat as an expression.
                        return false;
                }
            }
            function parseName(allowIdentifierName) {
                return tryParseName(allowIdentifierName) || eatIdentifierToken();
            }
            function eatRightSideOfName(allowIdentifierNames) {
                var _currentToken = currentToken();
                // Technically a keyword is valid here as all keywords are identifier names.
                // However, often we'll encounter this in error situations when the keyword
                // is actually starting another valid construct.
                // So, we check for the following specific case:
                //      name.
                //      keyword identifierNameOrKeyword
                // Note: the newlines are important here.  For example, if that above code 
                // were rewritten into:
                //      name.keyword
                //      identifierNameOrKeyword
                // Then we would consider it valid.  That's because ASI would take effect and
                // the code would be implicitly: "name.keyword; identifierNameOrKeyword".  
                // In the first case though, ASI will not take effect because there is not a
                // line terminator after the keyword.
                if (TypeScript.SyntaxFacts.isAnyKeyword(_currentToken.kind) && isOnDifferentLineThanPreviousToken(_currentToken)) {
                    var token1 = peekToken(1);
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, token1, source.text) && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                        return createMissingToken(9 /* IdentifierName */, _currentToken);
                    }
                }
                return allowIdentifierNames ? eatIdentifierNameToken() : eatIdentifierToken();
            }
            function tryParseName(allowIdentifierNames) {
                var token0 = currentToken();
                var shouldContinue = isIdentifier(token0);
                if (!shouldContinue) {
                    return undefined;
                }
                // Call eatIdentifierName to convert the token to an identifier if it is as keyword.
                var current = eatIdentifierToken();
                while (shouldContinue && currentToken().kind === 78 /* DotToken */) {
                    var dotToken = consumeToken(currentToken());
                    var identifierName = eatRightSideOfName(allowIdentifierNames);
                    current = new TypeScript.QualifiedNameSyntax(parseNodeData, current, dotToken, identifierName);
                    shouldContinue = identifierName.fullWidth() > 0;
                }
                return current;
            }
            function parseEnumDeclaration() {
                var modifiers = parseModifiers();
                var enumKeyword = eatToken(48 /* EnumKeyword */);
                var identifier = eatIdentifierToken();
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var enumElements;
                if (openBraceToken.fullWidth() > 0) {
                    enumElements = parseSeparatedSyntaxList(8 /* EnumDeclaration_EnumElements */);
                }
                return new TypeScript.EnumDeclarationSyntax(parseNodeData, modifiers, enumKeyword, identifier, openBraceToken, enumElements || [], eatToken(73 /* CloseBraceToken */));
            }
            function isEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node && node.kind === 209 /* EnumElement */) {
                    return true;
                }
                return isPropertyName(0, inErrorRecovery);
            }
            function tryParseEnumElementEqualsValueClause() {
                return isEqualsValueClause(false) ? parseEqualsValueClause(true) : undefined;
            }
            function tryParseEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node && node.kind === 209 /* EnumElement */) {
                    consumeNode(node);
                    return node;
                }
                if (!isPropertyName(0, inErrorRecovery)) {
                    return undefined;
                }
                return new TypeScript.EnumElementSyntax(parseNodeData, parsePropertyName(), tryParseEnumElementEqualsValueClause());
            }
            function isModifierKind(kind) {
                switch (kind) {
                    case 49 /* ExportKeyword */:
                    case 59 /* PublicKeyword */:
                    case 57 /* PrivateKeyword */:
                    case 58 /* ProtectedKeyword */:
                    case 60 /* StaticKeyword */:
                    case 65 /* DeclareKeyword */:
                        return true;
                }
                return false;
            }
            function isModifier(token, index) {
                if (isModifierKind(token.kind)) {
                    // These are modifiers only if we see an actual keyword, identifier, string literal
                    // or number following.
                    // Note: we also allow [ for error conditions.  
                    // [   is for:     static [a: number]
                    var nextToken = peekToken(index + 1);
                    var nextTokenKind = nextToken.kind;
                    switch (nextTokenKind) {
                        case 9 /* IdentifierName */:
                        case 76 /* OpenBracketToken */:
                        case 11 /* NumericLiteral */:
                        case 12 /* StringLiteral */:
                            return true;
                        default:
                            return TypeScript.SyntaxFacts.isAnyKeyword(nextTokenKind);
                    }
                }
                return false;
            }
            function modifierCount() {
                var modifierCount = 0;
                while (isModifier(peekToken(modifierCount), modifierCount)) {
                    modifierCount++;
                }
                return modifierCount;
            }
            function parseModifiers() {
                var tokens = [];
                while (true) {
                    var token = currentToken();
                    if (isModifier(token, 0)) {
                        tokens.push(consumeToken(token));
                        continue;
                    }
                    break;
                }
                return TypeScript.Syntax.list(tokens);
            }
            function parseHeritageClauses() {
                var heritageClauses;
                if (isHeritageClause()) {
                    // NOTE: we can pass "undefined" for the skipped tokens here as we know we can't get
                    // any leading skipped tokens. We have an 'extends' or 'implements' keyword, so 
                    // any skipped tokeds will get attached to that instead.
                    heritageClauses = parseSyntaxList(10 /* ClassOrInterfaceDeclaration_HeritageClauses */, undefined);
                }
                return heritageClauses || [];
            }
            function tryParseHeritageClauseTypeName() {
                return isHeritageClauseTypeName() ? tryParseNameOrGenericType() : undefined;
            }
            function parseClassDeclaration() {
                var modifiers = parseModifiers();
                var classKeyword = eatToken(46 /* ClassKeyword */);
                var identifier = eatIdentifierToken();
                var typeParameterList = tryParseTypeParameterList(false);
                var heritageClauses = parseHeritageClauses();
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var classElements;
                if (openBraceToken.fullWidth() > 0) {
                    classElements = parseSyntaxList(1 /* ClassDeclaration_ClassElements */);
                }
                ;
                return new TypeScript.ClassDeclarationSyntax(parseNodeData, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements || [], eatToken(73 /* CloseBraceToken */));
            }
            function isAccessor(modifierCount, inErrorRecovery) {
                var tokenKind = peekToken(modifierCount).kind;
                if (tokenKind !== 66 /* GetKeyword */ && tokenKind !== 70 /* SetKeyword */) {
                    return false;
                }
                return isPropertyName(modifierCount + 1, inErrorRecovery);
            }
            function parseAccessor(checkForStrictMode) {
                var modifiers = parseModifiers();
                var _currenToken = currentToken();
                var tokenKind = _currenToken.kind;
                if (tokenKind === 66 /* GetKeyword */) {
                    return parseGetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                }
                else if (tokenKind === 70 /* SetKeyword */) {
                    return parseSetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                }
                else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }
            function parseGetMemberAccessorDeclaration(modifiers, getKeyword, checkForStrictMode) {
                return new TypeScript.GetAccessorSyntax(parseNodeData, modifiers, consumeToken(getKeyword), parsePropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }
            function parseSetMemberAccessorDeclaration(modifiers, setKeyword, checkForStrictMode) {
                return new TypeScript.SetAccessorSyntax(parseNodeData, modifiers, consumeToken(setKeyword), parsePropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }
            function isClassElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isClassElement(currentNode())) {
                    return true;
                }
                // Note: the order of these calls is important.  Specifically, isMemberVariableDeclaration
                // checks for a subset of the conditions of the previous two calls.
                var _modifierCount = modifierCount();
                return isConstructorDeclaration(_modifierCount) || isAccessor(_modifierCount, inErrorRecovery) || isIndexMemberDeclaration(_modifierCount) || isMemberVariableOrFunctionDeclaration(_modifierCount, inErrorRecovery);
            }
            function isMemberVariableOrFunctionDeclaration(peekIndex, inErrorRecovery) {
                // Check if its the start of a property or method.  Both must start with a property name.
                if (!isPropertyName(peekIndex, inErrorRecovery)) {
                    return false;
                }
                if (!TypeScript.SyntaxFacts.isAnyKeyword(peekToken(peekIndex).kind)) {
                    // It wasn't a keyword.  So this is definitely a member variable or function.
                    return true;
                }
                // Keywords *can* technically start properties and methods.  However, they often
                // are actually intended to start a real ts/js construct.  Only accept a keyword
                // if it is definitely a property or method.
                // keywords are also property names.  Only accept a keyword as a property 
                // name if is of the form:
                //      public;
                //      public=
                //      public:
                //      public }
                //      public(
                //      public<
                //      public <eof>
                //      public <newline>
                var nextToken = peekToken(peekIndex + 1);
                switch (nextToken.kind) {
                    case 80 /* SemicolonToken */:
                    case 109 /* EqualsToken */:
                    case 108 /* ColonToken */:
                    case 73 /* CloseBraceToken */:
                    case 74 /* OpenParenToken */:
                    case 82 /* LessThanToken */:
                    case 8 /* EndOfFileToken */:
                        return true;
                    default:
                        return isOnDifferentLineThanPreviousToken(nextToken);
                }
            }
            function tryParseClassElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isClassElement(node)) {
                    consumeNode(node);
                    return node;
                }
                // Have to check for indexers before anything else.  That way if we see "[foo:" we 
                // parse it out as an indexer and not a member function or variable.
                var _modifierCount = modifierCount();
                if (isConstructorDeclaration(_modifierCount)) {
                    return parseConstructorDeclaration();
                }
                else if (isIndexMemberDeclaration(_modifierCount)) {
                    return parseIndexMemberDeclaration();
                }
                else if (isAccessor(_modifierCount, inErrorRecovery)) {
                    return parseAccessor(false);
                }
                else if (isMemberVariableOrFunctionDeclaration(_modifierCount, inErrorRecovery)) {
                    var modifiers = parseModifiers();
                    var propertyName = parsePropertyName();
                    if (isCallSignature(0)) {
                        return parseMemberFunctionDeclaration(modifiers, propertyName);
                    }
                    else {
                        return parseMemberVariableDeclaration(modifiers, propertyName);
                    }
                }
                else {
                    return undefined;
                }
            }
            function isConstructorDeclaration(modifierCount) {
                // Note: we deviate slightly from the spec here.  If we see 'constructor' then we 
                // assume this is a constructor.  That means, if a user writes "public constructor;"
                // it won't be viewed as a member.  As a workaround, they can simply write:
                //      public 'constructor';
                return peekToken(modifierCount).kind === 64 /* ConstructorKeyword */;
            }
            function parseConstructorDeclaration() {
                var modifiers = parseModifiers();
                var constructorKeyword = eatToken(64 /* ConstructorKeyword */);
                var callSignature = parseCallSignature(false);
                var semicolonToken = undefined;
                var block = undefined;
                if (isBlock()) {
                    block = parseBlock(false, true);
                }
                else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }
                return new TypeScript.ConstructorDeclarationSyntax(parseNodeData, modifiers, constructorKeyword, callSignature, block, semicolonToken);
            }
            function parseMemberFunctionDeclaration(modifiers, propertyName) {
                var callSignature = parseCallSignature(false);
                // If we got an errant => then we want to parse what's coming up without requiring an
                // open brace.
                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var block = undefined;
                var semicolon = undefined;
                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                }
                else {
                    semicolon = eatExplicitOrAutomaticSemicolon(false);
                }
                return new TypeScript.MemberFunctionDeclarationSyntax(parseNodeData, modifiers, propertyName, callSignature, block, semicolon);
            }
            function parseMemberVariableDeclaration(modifiers, propertyName) {
                return new TypeScript.MemberVariableDeclarationSyntax(parseNodeData, modifiers, new TypeScript.VariableDeclaratorSyntax(parseNodeData, propertyName, parseOptionalTypeAnnotation(false), isEqualsValueClause(false) ? parseEqualsValueClause(true) : undefined), eatExplicitOrAutomaticSemicolon(false));
            }
            function isIndexMemberDeclaration(modifierCount) {
                return isIndexSignature(modifierCount);
            }
            function parseIndexMemberDeclaration() {
                return new TypeScript.IndexMemberDeclarationSyntax(parseNodeData, parseModifiers(), parseIndexSignature(), eatExplicitOrAutomaticSemicolon(false));
            }
            function tryAddUnexpectedEqualsGreaterThanToken(callSignature) {
                var token0 = currentToken();
                var hasEqualsGreaterThanToken = token0.kind === 87 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    // We can only do this if the call signature actually contains a final token that we 
                    // could add the => to.
                    var _lastToken = TypeScript.lastToken(callSignature);
                    if (_lastToken && _lastToken.fullWidth() > 0) {
                        // Previously the language allowed "function f() => expr;" as a shorthand for 
                        // "function f() { return expr; }.
                        // 
                        // Detect if the user is typing this and attempt recovery.
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [TypeScript.SyntaxFacts.getText(72 /* OpenBraceToken */)]);
                        addDiagnostic(diagnostic);
                        // Skip over the =>   It will get attached to whatever comes next.
                        skipToken(token0);
                        return true;
                    }
                }
                return false;
            }
            function isFunctionDeclaration(modifierCount) {
                return peekToken(modifierCount).kind === 29 /* FunctionKeyword */;
            }
            function parseFunctionDeclaration() {
                var modifiers = parseModifiers();
                var functionKeyword = eatToken(29 /* FunctionKeyword */);
                var identifier = eatIdentifierToken();
                var callSignature = parseCallSignature(false);
                // If we got an errant => then we want to parse what's coming up without requiring an
                // open brace.
                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var semicolonToken = undefined;
                var block = undefined;
                // Parse a block if we're on a bock, or if we saw a '=>'
                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                }
                else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }
                return new TypeScript.FunctionDeclarationSyntax(parseNodeData, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            }
            function parseModuleDeclaration() {
                var modifiers = parseModifiers();
                var moduleKeyword = eatToken(67 /* ModuleKeyword */);
                var moduleName = undefined;
                var stringLiteral = undefined;
                if (currentToken().kind === 12 /* StringLiteral */) {
                    stringLiteral = eatToken(12 /* StringLiteral */);
                }
                else {
                    moduleName = parseName(false);
                }
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var moduleElements;
                if (openBraceToken.fullWidth() > 0) {
                    moduleElements = parseSyntaxList(2 /* ModuleDeclaration_ModuleElements */);
                }
                return new TypeScript.ModuleDeclarationSyntax(parseNodeData, modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements || [], eatToken(73 /* CloseBraceToken */));
            }
            function parseInterfaceDeclaration() {
                return new TypeScript.InterfaceDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(54 /* InterfaceKeyword */), eatIdentifierToken(), tryParseTypeParameterList(false), parseHeritageClauses(), parseObjectType());
            }
            function parseObjectType() {
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var typeMembers;
                if (openBraceToken.fullWidth() > 0) {
                    typeMembers = parseSeparatedSyntaxList(9 /* ObjectType_TypeMembers */);
                }
                return new TypeScript.ObjectTypeSyntax(parseNodeData, openBraceToken, typeMembers || [], eatToken(73 /* CloseBraceToken */));
            }
            function parseTupleType(currentToken) {
                return new TypeScript.TupleTypeSyntax(parseNodeData, consumeToken(currentToken), parseSeparatedSyntaxList(21 /* TupleType_Types */), eatToken(77 /* CloseBracketToken */));
            }
            function isTypeMember(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isTypeMember(currentNode())) {
                    return true;
                }
                return isCallSignature(0) || isConstructSignature() || isIndexSignature(0) || isMethodOrPropertySignature(inErrorRecovery);
            }
            function isMethodOrPropertySignature(inErrorRecovery) {
                var _currentToken = currentToken();
                // Keywords can start properties.  However, they're often intended to start something
                // else.  If we see a modifier before something that can be a property, then don't
                // try parse it out as a property.  For example, if we have:
                //
                //      public foo
                //
                // Then don't parse 'public' as a property name.  Note: if you have:
                //
                //      public
                //      foo
                //
                // Then we *should* parse it as a property name, as ASI takes effect here.
                if (isModifier(_currentToken, 0)) {
                    var token1 = peekToken(1);
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, token1, source.text) && isPropertyNameToken(token1, inErrorRecovery)) {
                        return false;
                    }
                }
                // Note: property names also start function signatures.  So it's important that we call this
                // after we calll isFunctionSignature.
                return isPropertyName(0, inErrorRecovery);
            }
            function tryParseTypeMember(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isTypeMember(node)) {
                    consumeNode(node);
                    return node;
                }
                if (isCallSignature(0)) {
                    return parseCallSignature(false);
                }
                else if (isConstructSignature()) {
                    return parseConstructSignature();
                }
                else if (isIndexSignature(0)) {
                    return parseIndexSignature();
                }
                else if (isMethodOrPropertySignature(inErrorRecovery)) {
                    var propertyName = parsePropertyName();
                    var questionToken = tryEatToken(107 /* QuestionToken */);
                    if (isCallSignature(0)) {
                        return parseMethodSignature(propertyName, questionToken);
                    }
                    else {
                        return parsePropertySignature(propertyName, questionToken);
                    }
                }
                else {
                    return undefined;
                }
            }
            function parseConstructSignature() {
                return new TypeScript.ConstructSignatureSyntax(parseNodeData, eatToken(33 /* NewKeyword */), parseCallSignature(false));
            }
            function parseIndexSignature() {
                return new TypeScript.IndexSignatureSyntax(parseNodeData, eatToken(76 /* OpenBracketToken */), parseSeparatedSyntaxList(18 /* IndexSignature_Parameters */), eatToken(77 /* CloseBracketToken */), parseOptionalTypeAnnotation(false));
            }
            function parseMethodSignature(propertyName, questionToken) {
                return new TypeScript.MethodSignatureSyntax(parseNodeData, propertyName, questionToken, parseCallSignature(false));
            }
            function parsePropertySignature(propertyName, questionToken) {
                return new TypeScript.PropertySignatureSyntax(parseNodeData, propertyName, questionToken, parseOptionalTypeAnnotation(false));
            }
            function isCallSignature(peekIndex) {
                var tokenKind = peekToken(peekIndex).kind;
                return tokenKind === 74 /* OpenParenToken */ || tokenKind === 82 /* LessThanToken */;
            }
            function isConstructSignature() {
                if (currentToken().kind !== 33 /* NewKeyword */) {
                    return false;
                }
                return isCallSignature(1);
            }
            function isIndexSignature(peekIndex) {
                // In order to be considered an index signature, we need to see at least:
                //
                //      [a:
                //      [...
                //      [a,
                //      [public a
                //      []
                //
                // Otherwise, we will think that this is the start of a computed property name
                // for a function or variable.
                if (peekToken(peekIndex).kind === 76 /* OpenBracketToken */) {
                    var token1 = peekToken(peekIndex + 1);
                    if (token1.kind === 79 /* DotDotDotToken */ || token1.kind === 77 /* CloseBracketToken */) {
                        return true;
                    }
                    if (isIdentifier(token1)) {
                        var token2 = peekToken(peekIndex + 2);
                        if (token2.kind === 108 /* ColonToken */ || token2.kind === 81 /* CommaToken */) {
                            return true;
                        }
                    }
                    if (token1.kind === 59 /* PublicKeyword */ || token1.kind === 57 /* PrivateKeyword */) {
                        var token2 = peekToken(peekIndex + 2);
                        return isIdentifier(token2);
                    }
                }
                return false;
            }
            function isHeritageClause() {
                var tokenKind = currentToken().kind;
                return tokenKind === 50 /* ExtendsKeyword */ || tokenKind === 53 /* ImplementsKeyword */;
            }
            function isNotHeritageClauseTypeName() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 53 /* ImplementsKeyword */ || tokenKind === 50 /* ExtendsKeyword */) {
                    return isIdentifier(peekToken(1));
                }
                return false;
            }
            function isHeritageClauseTypeName() {
                if (isIdentifier(currentToken())) {
                    // We want to make sure that the "extends" in "extends foo" or the "implements" in
                    // "implements foo" is not considered a type name.
                    return !isNotHeritageClauseTypeName();
                }
                return false;
            }
            function tryParseHeritageClause() {
                var extendsOrImplementsKeyword = currentToken();
                var tokenKind = extendsOrImplementsKeyword.kind;
                if (tokenKind !== 50 /* ExtendsKeyword */ && tokenKind !== 53 /* ImplementsKeyword */) {
                    return undefined;
                }
                return new TypeScript.HeritageClauseSyntax(parseNodeData, consumeToken(extendsOrImplementsKeyword), parseSeparatedSyntaxList(11 /* HeritageClause_TypeNameList */));
            }
            function isInterfaceEnumClassModuleImportOrExport(modifierCount, _currentToken) {
                if (modifierCount) {
                    switch (peekToken(modifierCount).kind) {
                        case 51 /* ImportKeyword */:
                        case 67 /* ModuleKeyword */:
                        case 54 /* InterfaceKeyword */:
                        case 46 /* ClassKeyword */:
                        case 48 /* EnumKeyword */:
                            return true;
                    }
                }
                _currentToken = _currentToken || currentToken();
                // no modifiers.  While certain of these keywords are javascript keywords as well, it
                // is possible to run into them in some circumstances in error recovery where we don't
                // want to consider them the start of the module element construct.  For example, they
                // might be hte name in an object literal.  Because of that, we check the next token to
                // make sure it really is the start of a module element.
                var nextToken = peekToken(1);
                switch (_currentToken.kind) {
                    case 67 /* ModuleKeyword */:
                        return isIdentifier(nextToken) || nextToken.kind === 12 /* StringLiteral */;
                    case 51 /* ImportKeyword */:
                    case 46 /* ClassKeyword */:
                    case 48 /* EnumKeyword */:
                    case 54 /* InterfaceKeyword */:
                        return isIdentifier(nextToken);
                    case 49 /* ExportKeyword */:
                        return nextToken.kind === 109 /* EqualsToken */;
                }
                return false;
            }
            function isStatement(modifierCount, inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isStatement(currentNode())) {
                    return true;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind;
                switch (currentTokenKind) {
                    case 59 /* PublicKeyword */:
                    case 57 /* PrivateKeyword */:
                    case 58 /* ProtectedKeyword */:
                    case 60 /* StaticKeyword */:
                        // None of the above are actually keywords.  And they might show up in a real
                        // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                        // that can't possibly be a statement (and instead will be a class element), 
                        // and we should not parse it out here.
                        var token1 = peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            // Definitely not a statement.
                            return false;
                        }
                        break;
                    case 30 /* IfKeyword */:
                    case 72 /* OpenBraceToken */:
                    case 35 /* ReturnKeyword */:
                    case 36 /* SwitchKeyword */:
                    case 38 /* ThrowKeyword */:
                    case 17 /* BreakKeyword */:
                    case 20 /* ContinueKeyword */:
                    case 28 /* ForKeyword */:
                    case 44 /* WhileKeyword */:
                    case 45 /* WithKeyword */:
                    case 24 /* DoKeyword */:
                    case 40 /* TryKeyword */:
                    case 21 /* DebuggerKeyword */:
                        return true;
                }
                // Check for common things that might appear where we expect a statement, but which we 
                // do not want to consume.  This can happen when the user does not terminate their 
                // existing block properly.  We don't want to accidently consume these as expression 
                // below.
                if (isInterfaceEnumClassModuleImportOrExport(modifierCount, _currentToken)) {
                    return false;
                }
                // More complicated cases.
                return isLabeledStatement(_currentToken) || isVariableStatement(modifierCount) || isFunctionDeclaration(modifierCount) || isEmptyStatement(_currentToken, inErrorRecovery) || isExpressionStatement(_currentToken);
            }
            function parseStatement(inErrorRecovery) {
                return tryParseStatement(inErrorRecovery) || parseExpressionStatement();
            }
            function tryParseStatement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isStatement(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind;
                return tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount(), inErrorRecovery);
            }
            function tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount, inErrorRecovery) {
                switch (currentTokenKind) {
                    case 59 /* PublicKeyword */:
                    case 57 /* PrivateKeyword */:
                    case 58 /* ProtectedKeyword */:
                    case 60 /* StaticKeyword */:
                        // None of the above are actually keywords.  And they might show up in a real
                        // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                        // that can't possibly be a statement (and instead will be a class element), 
                        // and we should not parse it out here.
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(peekToken(1))) {
                            // Definitely not a statement.
                            return undefined;
                        }
                        else {
                            break;
                        }
                    case 30 /* IfKeyword */: return parseIfStatement(_currentToken);
                    case 72 /* OpenBraceToken */: return parseBlock(false, false);
                    case 35 /* ReturnKeyword */: return parseReturnStatement(_currentToken);
                    case 36 /* SwitchKeyword */: return parseSwitchStatement(_currentToken);
                    case 38 /* ThrowKeyword */: return parseThrowStatement(_currentToken);
                    case 17 /* BreakKeyword */: return parseBreakStatement(_currentToken);
                    case 20 /* ContinueKeyword */: return parseContinueStatement(_currentToken);
                    case 28 /* ForKeyword */: return parseForOrForInStatement(_currentToken);
                    case 44 /* WhileKeyword */: return parseWhileStatement(_currentToken);
                    case 45 /* WithKeyword */: return parseWithStatement(_currentToken);
                    case 24 /* DoKeyword */: return parseDoStatement(_currentToken);
                    case 40 /* TryKeyword */: return parseTryStatement(_currentToken);
                    case 21 /* DebuggerKeyword */: return parseDebuggerStatement(_currentToken);
                }
                // Check for common things that might appear where we expect a statement, but which we 
                // do not want to consume.  This can happen when the user does not terminate their 
                // existing block properly.  We don't want to accidently consume these as expression 
                // below.
                if (isInterfaceEnumClassModuleImportOrExport(modifierCount, _currentToken)) {
                    return undefined;
                }
                else if (isVariableStatement(modifierCount)) {
                    return parseVariableStatement();
                }
                else if (isLabeledStatement(_currentToken)) {
                    return parseLabeledStatement(_currentToken);
                }
                else if (isFunctionDeclaration(modifierCount)) {
                    return parseFunctionDeclaration();
                }
                else if (isEmptyStatement(_currentToken, inErrorRecovery)) {
                    return parseEmptyStatement(_currentToken);
                }
                else if (isExpressionStatement(_currentToken)) {
                    return parseExpressionStatement();
                }
                else {
                    return undefined;
                }
            }
            function parseDebuggerStatement(debuggerKeyword) {
                return new TypeScript.DebuggerStatementSyntax(parseNodeData, consumeToken(debuggerKeyword), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseDoStatement(doKeyword) {
                // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
                // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
                // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
                //  do;while(0)x will have a semicolon inserted before x.
                return new TypeScript.DoStatementSyntax(parseNodeData, consumeToken(doKeyword), parseStatement(false), eatToken(44 /* WhileKeyword */), eatToken(74 /* OpenParenToken */), parseExpression(true), eatToken(75 /* CloseParenToken */), eatExplicitOrAutomaticSemicolon(true));
            }
            function isLabeledStatement(currentToken) {
                return isIdentifier(currentToken) && peekToken(1).kind === 108 /* ColonToken */;
            }
            function parseLabeledStatement(identifierToken) {
                return new TypeScript.LabeledStatementSyntax(parseNodeData, consumeToken(identifierToken), eatToken(108 /* ColonToken */), parseStatement(false));
            }
            function parseTryStatement(tryKeyword) {
                var tryKeyword = consumeToken(tryKeyword);
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 6 /* TryBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;
                var catchClause = undefined;
                if (currentToken().kind === 19 /* CatchKeyword */) {
                    catchClause = parseCatchClause();
                }
                // If we don't have a catch clause, then we must have a finally clause.  Try to parse
                // one out no matter what.
                var finallyClause = undefined;
                if (!catchClause || currentToken().kind === 27 /* FinallyKeyword */) {
                    finallyClause = parseFinallyClause();
                }
                return new TypeScript.TryStatementSyntax(parseNodeData, tryKeyword, block, catchClause, finallyClause);
            }
            function parseCatchClauseBlock() {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 7 /* CatchBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;
                return block;
            }
            function parseCatchClause() {
                return new TypeScript.CatchClauseSyntax(parseNodeData, eatToken(19 /* CatchKeyword */), eatToken(74 /* OpenParenToken */), eatIdentifierToken(), parseOptionalTypeAnnotation(false), eatToken(75 /* CloseParenToken */), parseCatchClauseBlock());
            }
            function parseFinallyClause() {
                return new TypeScript.FinallyClauseSyntax(parseNodeData, eatToken(27 /* FinallyKeyword */), parseBlock(false, false));
            }
            function parseWithStatement(withKeyword) {
                return new TypeScript.WithStatementSyntax(parseNodeData, consumeToken(withKeyword), eatToken(74 /* OpenParenToken */), parseExpression(true), eatToken(75 /* CloseParenToken */), parseStatement(false));
            }
            function parseWhileStatement(whileKeyword) {
                return new TypeScript.WhileStatementSyntax(parseNodeData, consumeToken(whileKeyword), eatToken(74 /* OpenParenToken */), parseExpression(true), eatToken(75 /* CloseParenToken */), parseStatement(false));
            }
            function isEmptyStatement(currentToken, inErrorRecovery) {
                // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                // The problem is that ';' can show up in far too many contexts, and if we see one 
                // and assume it's a statement, then we may bail out innapropriately from whatever 
                // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                // we really don't want to assume the class is over and we're on a statement in the
                // outer module.  We just want to consume and move on.
                if (inErrorRecovery) {
                    return false;
                }
                return currentToken.kind === 80 /* SemicolonToken */;
            }
            function parseEmptyStatement(semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(parseNodeData, consumeToken(semicolonToken));
            }
            function parseForOrForInStatement(forKeyword) {
                // Debug.assert(isForOrForInStatement());
                forKeyword = consumeToken(forKeyword);
                var openParenToken = eatToken(74 /* OpenParenToken */);
                var _currentToken = currentToken();
                var tokenKind = _currentToken.kind;
                if (tokenKind === 42 /* VarKeyword */) {
                    // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                    // for ( var VariableDeclarationNoIn in Expression ) Statement
                    return parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                }
                else if (tokenKind === 80 /* SemicolonToken */) {
                    // for ( ; Expressionopt ; Expressionopt ) Statement
                    return parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken);
                }
                else {
                    // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                    // for ( LeftHandSideExpression in Expression ) Statement
                    return parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            }
            function parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind === SyntaxKind.ForKeyword && openParenToken.kind === SyntaxKind.OpenParenToken);
                // Debug.assert(currentToken().kind === SyntaxKind.VarKeyword);
                // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                var variableDeclaration = parseVariableDeclaration(false);
                return currentToken().kind === 31 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, undefined) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, undefined);
            }
            function parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                return new TypeScript.ForInStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(31 /* InKeyword */), parseExpression(true), eatToken(75 /* CloseParenToken */), parseStatement(false));
            }
            function parseForOrForInStatementWithInitializer(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind === SyntaxKind.ForKeyword && openParenToken.kind === SyntaxKind.OpenParenToken);
                // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                // for ( LeftHandSideExpression in Expression ) Statement
                var initializer = parseExpression(false);
                return currentToken().kind === 31 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, undefined, initializer) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, undefined, initializer);
            }
            function parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind === SyntaxKind.ForKeyword && openParenToken.kind === SyntaxKind.OpenParenToken);
                // Debug.assert(currentToken().kind === SyntaxKind.SemicolonToken);
                // for ( ; Expressionopt ; Expressionopt ) Statement
                return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, undefined, undefined);
            }
            function tryParseForStatementCondition() {
                var tokenKind = currentToken().kind;
                if (tokenKind !== 80 /* SemicolonToken */ && tokenKind !== 75 /* CloseParenToken */ && tokenKind !== 8 /* EndOfFileToken */) {
                    return parseExpression(true);
                }
                return undefined;
            }
            function tryParseForStatementIncrementor() {
                var tokenKind = currentToken().kind;
                if (tokenKind !== 75 /* CloseParenToken */ && tokenKind !== 8 /* EndOfFileToken */) {
                    return parseExpression(true);
                }
                return undefined;
            }
            function parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                // NOTE: From the es5 section on Automatic Semicolon Insertion.
                // a semicolon is never inserted automatically if the semicolon would then ... become 
                // one of the two semicolons in the header of a for statement
                return new TypeScript.ForStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(80 /* SemicolonToken */), tryParseForStatementCondition(), eatToken(80 /* SemicolonToken */), tryParseForStatementIncrementor(), eatToken(75 /* CloseParenToken */), parseStatement(false));
            }
            function tryEatBreakOrContinueLabel() {
                // If there is no newline after the break keyword, then we can consume an optional 
                // identifier.
                var identifier = undefined;
                if (!canEatExplicitOrAutomaticSemicolon(false)) {
                    if (isIdentifier(currentToken())) {
                        return eatIdentifierToken();
                    }
                }
                return undefined;
            }
            function parseBreakStatement(breakKeyword) {
                return new TypeScript.BreakStatementSyntax(parseNodeData, consumeToken(breakKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseContinueStatement(continueKeyword) {
                return new TypeScript.ContinueStatementSyntax(parseNodeData, consumeToken(continueKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseSwitchStatement(switchKeyword) {
                // Debug.assert(isSwitchStatement());
                switchKeyword = consumeToken(switchKeyword);
                var openParenToken = eatToken(74 /* OpenParenToken */);
                var expression;
                // if we have  "switch {"
                // then don't try to consume the { as the start of an expression.
                if (openParenToken.fullWidth() === 0 && currentToken().kind === 72 /* OpenBraceToken */) {
                    expression = eatIdentifierToken();
                }
                else {
                    expression = parseExpression(true);
                }
                var closeParenToken = eatToken(75 /* CloseParenToken */);
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var switchClauses;
                if (openBraceToken.fullWidth() > 0) {
                    switchClauses = parseSyntaxList(3 /* SwitchStatement_SwitchClauses */);
                }
                return new TypeScript.SwitchStatementSyntax(parseNodeData, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses || [], eatToken(73 /* CloseBraceToken */));
            }
            function isSwitchClause() {
                if (TypeScript.SyntaxUtilities.isSwitchClause(currentNode())) {
                    return true;
                }
                var currentTokenKind = currentToken().kind;
                return currentTokenKind === 18 /* CaseKeyword */ || currentTokenKind === 22 /* DefaultKeyword */;
            }
            function tryParseSwitchClause() {
                // Debug.assert(isSwitchClause());
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isSwitchClause(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var kind = _currentToken.kind;
                if (kind === 18 /* CaseKeyword */) {
                    return parseCaseSwitchClause(_currentToken);
                }
                else if (kind === 22 /* DefaultKeyword */) {
                    return parseDefaultSwitchClause(_currentToken);
                }
                else {
                    return undefined;
                }
            }
            function parseCaseSwitchClause(caseKeyword) {
                // Debug.assert(isCaseSwitchClause());
                return new TypeScript.CaseSwitchClauseSyntax(parseNodeData, consumeToken(caseKeyword), parseExpression(true), eatToken(108 /* ColonToken */), parseSyntaxList(4 /* SwitchClause_Statements */));
            }
            function parseDefaultSwitchClause(defaultKeyword) {
                // Debug.assert(isDefaultSwitchClause());
                return new TypeScript.DefaultSwitchClauseSyntax(parseNodeData, consumeToken(defaultKeyword), eatToken(108 /* ColonToken */), parseSyntaxList(4 /* SwitchClause_Statements */));
            }
            function parseThrowStatementExpression() {
                // Because of automatic semicolon insertion, we need to report error if this 
                // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
                // directly as that might consume an expression on the following line.  
                return canEatExplicitOrAutomaticSemicolon(false) ? createMissingToken(9 /* IdentifierName */, undefined) : parseExpression(true);
            }
            function parseThrowStatement(throwKeyword) {
                return new TypeScript.ThrowStatementSyntax(parseNodeData, consumeToken(throwKeyword), parseThrowStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }
            function tryParseReturnStatementExpression() {
                return !canEatExplicitOrAutomaticSemicolon(false) ? parseExpression(true) : undefined;
            }
            function parseReturnStatement(returnKeyword) {
                return new TypeScript.ReturnStatementSyntax(parseNodeData, consumeToken(returnKeyword), tryParseReturnStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }
            function isExpressionStatement(currentToken) {
                // As per the gramar, neither { nor 'function' can start an expression statement.
                var tokenKind = currentToken.kind;
                return tokenKind !== 72 /* OpenBraceToken */ && tokenKind !== 29 /* FunctionKeyword */ && isExpression(currentToken);
            }
            function isAssignmentOrOmittedExpression() {
                var _currentToken = currentToken();
                return _currentToken.kind === 81 /* CommaToken */ || isExpression(_currentToken);
            }
            function tryParseAssignmentOrOmittedExpression() {
                // Debug.assert(isAssignmentOrOmittedExpression());
                if (currentToken().kind === 81 /* CommaToken */) {
                    return new TypeScript.OmittedExpressionSyntax(parseNodeData);
                }
                return tryParseAssignmentExpressionOrHigher(false, true);
            }
            function isExpression(currentToken) {
                switch (currentToken.kind) {
                    case 11 /* NumericLiteral */:
                    case 12 /* StringLiteral */:
                    case 10 /* RegularExpressionLiteral */:
                    case 13 /* NoSubstitutionTemplateToken */:
                    case 14 /* TemplateStartToken */:
                    case 76 /* OpenBracketToken */:
                    case 74 /* OpenParenToken */:
                    case 82 /* LessThanToken */:
                    case 95 /* PlusPlusToken */:
                    case 96 /* MinusMinusToken */:
                    case 91 /* PlusToken */:
                    case 92 /* MinusToken */:
                    case 104 /* TildeToken */:
                    case 103 /* ExclamationToken */:
                    case 72 /* OpenBraceToken */:
                    case 87 /* EqualsGreaterThanToken */:
                    case 120 /* SlashToken */:
                    case 121 /* SlashEqualsToken */:
                    case 52 /* SuperKeyword */:
                    case 37 /* ThisKeyword */:
                    case 39 /* TrueKeyword */:
                    case 26 /* FalseKeyword */:
                    case 34 /* NullKeyword */:
                    case 33 /* NewKeyword */:
                    case 23 /* DeleteKeyword */:
                    case 43 /* VoidKeyword */:
                    case 41 /* TypeOfKeyword */:
                    case 29 /* FunctionKeyword */:
                        return true;
                }
                return isIdentifier(currentToken);
            }
            function parseExpressionStatement() {
                return new TypeScript.ExpressionStatementSyntax(parseNodeData, parseExpression(true), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseIfStatement(ifKeyword) {
                return new TypeScript.IfStatementSyntax(parseNodeData, consumeToken(ifKeyword), eatToken(74 /* OpenParenToken */), parseExpression(true), eatToken(75 /* CloseParenToken */), parseStatement(false), parseOptionalElseClause());
            }
            function parseOptionalElseClause() {
                return currentToken().kind === 25 /* ElseKeyword */ ? parseElseClause() : undefined;
            }
            function parseElseClause() {
                return new TypeScript.ElseClauseSyntax(parseNodeData, eatToken(25 /* ElseKeyword */), parseStatement(false));
            }
            function isVariableStatement(modifierCount) {
                return peekToken(modifierCount).kind === 42 /* VarKeyword */;
            }
            function parseVariableStatement() {
                return new TypeScript.VariableStatementSyntax(parseNodeData, parseModifiers(), parseVariableDeclaration(true), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseVariableDeclaration(allowIn) {
                // Debug.assert(currentToken().kind === SyntaxKind.VarKeyword);
                var listParsingState = allowIn ? 12 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */;
                return new TypeScript.VariableDeclarationSyntax(parseNodeData, eatToken(42 /* VarKeyword */), parseSeparatedSyntaxList(listParsingState));
            }
            function isVariableDeclarator() {
                var node = currentNode();
                if (node && node.kind === 191 /* VariableDeclarator */) {
                    return true;
                }
                return isIdentifier(currentToken());
            }
            function canReuseVariableDeclaratorNode(node) {
                if (!node || node.kind !== 191 /* VariableDeclarator */) {
                    return false;
                }
                // Very subtle incremental parsing bug.  Consider the following code:
                //
                //      var v = new List < A, B
                //
                // This is actually legal code.  It's a list of variable declarators "v = new List<A" 
                // on one side and "B" on the other. If you then change that to:
                //
                //      var v = new List < A, B >()
                // 
                // then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
                // start reparsing at "B" and we completely fail to handle this properly.
                //
                // In order to prevent this, we do not allow a variable declarator to be reused if it
                // has an initializer.
                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === undefined;
            }
            function tryParseVariableDeclarator(allowIn) {
                // TODO(cyrusn): What if the 'allowIn' context has changed between when we last parsed 
                // and now?  We could end up with an incorrect tree.  For example, say we had in the old 
                // tree "var i = a in b".  Then, in the new tree the declarator portion moved into:
                // "for (var i = a in b".  We would not want to reuse the declarator as the "in b" portion 
                // would need to be consumed by the for declaration instead.  Need to see if it is possible
                // to hit this case.
                var node = currentNode();
                if (canReuseVariableDeclaratorNode(node)) {
                    consumeNode(node);
                    return node;
                }
                if (!isIdentifier(currentToken())) {
                    return undefined;
                }
                var propertyName = eatIdentifierToken();
                var equalsValueClause = undefined;
                var typeAnnotation = undefined;
                if (TypeScript.fullWidth(propertyName) > 0) {
                    typeAnnotation = parseOptionalTypeAnnotation(false);
                    if (isEqualsValueClause(false)) {
                        equalsValueClause = parseEqualsValueClause(allowIn);
                    }
                }
                return new TypeScript.VariableDeclaratorSyntax(parseNodeData, propertyName, typeAnnotation, equalsValueClause);
            }
            function isEqualsValueClause(inParameter) {
                var token0 = currentToken();
                if (token0.kind === 109 /* EqualsToken */) {
                    return true;
                }
                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
                // there is no newline after the last token and if we're on an expression.  If so, parse
                // this as an equals-value clause with a missing equals.
                if (!isOnDifferentLineThanPreviousToken(token0)) {
                    var tokenKind = token0.kind;
                    // The 'isExpression' call below returns true for "=>".  That's because it smartly
                    // assumes that there is just a missing identifier and the user wanted a lambda.  
                    // While this is sensible, we don't want to allow that here as that would mean we're
                    // glossing over multiple erorrs and we're probably making things worse.  So don't
                    // treat this as an equals value clause and let higher up code handle things.
                    if (tokenKind === 87 /* EqualsGreaterThanToken */) {
                        return false;
                    }
                    // There are two places where we allow equals-value clauses.  The first is in a 
                    // variable declarator.  The second is with a parameter.  For variable declarators
                    // it's more likely that a { would be a allowed (as an object literal).  While this
                    // is also allowed for parameters, the risk is that we consume the { as an object
                    // literal when it really will be for the block following the parameter.
                    if (tokenKind === 72 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }
                    return isExpression(token0);
                }
                return false;
            }
            function parseEqualsValueClause(allowIn) {
                return new TypeScript.EqualsValueClauseSyntax(parseNodeData, eatToken(109 /* EqualsToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }
            function parseExpression(allowIn) {
                // Expression[in]:
                //      AssignmentExpression[in] 
                //      Expression[in] , AssignmentExpression[in]
                var leftOperand = tryParseAssignmentExpressionOrHigher(true, allowIn);
                while (true) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind !== 81 /* CommaToken */) {
                        break;
                    }
                    leftOperand = new TypeScript.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                }
                return leftOperand;
            }
            // Called when you need to parse an expression, but you do not want to allow 'CommaExpressions'.
            // i.e. if you have "var a = 1, b = 2" then when we parse '1' we want to parse with higher 
            // precedence than 'comma'.  Otherwise we'll get: "var a = (1, (b = 2))", instead of
            // "var a = (1), b = (2)");
            function tryParseAssignmentExpressionOrHigher(force, allowIn) {
                // Augmented by TypeScript:
                //
                //  AssignmentExpression[in]:
                //      1) ConditionalExpression[in]
                //      2) LeftHandSideExpression = AssignmentExpression[in]
                //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
                //      4) ArrowFunctionExpression <-- added by TypeScript
                //
                // Open spec question.  Right now, there is no 'ArrowFunctionExpression[in]' variant.
                // Thus, if the user has:
                //
                //      for (var a = () => b in c) {}
                //
                // Then we will fail to parse (because the 'in' will be consumed as part of the body of
                // the lambda, and not as part of the 'for' statement).  This is likely not an issue
                // whatsoever as there seems to be no good reason why anyone would ever write code like
                // the above.
                //
                // Note: for ease of implementation we treat productions '2' and '3' as the same thing. 
                // (i.e. they're both BinaryExpressions with an assignment operator in it).
                // First, check if we have production '4' (an arrow function).  Note that if we do, we
                // must *not* recurse for productsion 1, 2 or 3. An ArrowFunction is not a 
                // LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done 
                // with AssignmentExpression if we see one.
                var _currentToken = currentToken();
                var arrowFunction = tryParseAnyArrowFunctionExpression(_currentToken);
                if (arrowFunction) {
                    return arrowFunction;
                }
                // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
                // start with a LogicalOrExpression, while the assignment productions can only start with
                // LeftHandSideExpressions.
                //
                // So, first, we try to just parse out a BinaryExpression.  If we get something that is a 
                // LeftHandSide or higher, then we can try to parse out the assignment expression part.  
                // Otherwise, we try to parse out the conditional expression bit.  We want to allow any 
                // binary expression here, so we pass in the 'lowest' precedence here so that it matches
                // and consumes anything.
                var leftOperand = tryParseBinaryExpressionOrHigher(_currentToken, force, 1 /* Lowest */, allowIn);
                if (leftOperand === undefined) {
                    return undefined;
                }
                if (TypeScript.SyntaxUtilities.isLeftHandSizeExpression(leftOperand)) {
                    // Note: we call currentOperatorToken so that we get an appropriately merged token
                    // for cases like > > =  becoming >>=
                    var operatorToken = currentOperatorToken();
                    // Check for recursive assignment expressions.
                    if (TypeScript.SyntaxFacts.isAssignmentOperatorToken(operatorToken.kind)) {
                        return new TypeScript.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                    }
                }
                // It wasn't an assignment or a lambda.  This is a conditional expression:
                return parseConditionalExpressionRest(allowIn, leftOperand);
            }
            function tryParseAnyArrowFunctionExpression(_currentToken) {
                return isSimpleArrowFunctionExpression(_currentToken) ? parseSimpleArrowFunctionExpression() : tryParseParenthesizedArrowFunctionExpression();
            }
            function tryParseUnaryExpressionOrHigher(_currentToken, force) {
                var currentTokenKind = _currentToken.kind;
                switch (currentTokenKind) {
                    case 91 /* PlusToken */:
                    case 92 /* MinusToken */:
                    case 104 /* TildeToken */:
                    case 103 /* ExclamationToken */:
                    case 95 /* PlusPlusToken */:
                    case 96 /* MinusMinusToken */:
                        return new TypeScript.PrefixUnaryExpressionSyntax(parseNodeData, consumeToken(_currentToken), tryParseUnaryExpressionOrHigher(currentToken(), true));
                    case 41 /* TypeOfKeyword */: return parseTypeOfExpression(_currentToken);
                    case 43 /* VoidKeyword */: return parseVoidExpression(_currentToken);
                    case 23 /* DeleteKeyword */: return parseDeleteExpression(_currentToken);
                    case 82 /* LessThanToken */: return parseCastExpression(_currentToken);
                    default:
                        return tryParsePostfixExpressionOrHigher(_currentToken, force);
                }
            }
            function tryParseBinaryExpressionOrHigher(_currentToken, force, precedence, allowIn) {
                // The binary expressions are incredibly left recursive in their definitions. We 
                // clearly can't implement that through recursion.  So, instead, we first bottom out 
                // of all the recursion by jumping to this production and consuming a UnaryExpression 
                // first.
                //
                // MultiplicativeExpression: See 11.5 
                //      UnaryExpression 
                var leftOperand = tryParseUnaryExpressionOrHigher(_currentToken, force);
                if (leftOperand === undefined) {
                    return undefined;
                }
                // We then pop up the stack consuming the other side of the binary exprssion if it exists.
                return parseBinaryExpressionRest(precedence, allowIn, leftOperand);
            }
            function parseConditionalExpressionRest(allowIn, leftOperand) {
                // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.
                var _currentToken = currentToken();
                // Now check for conditional expression.
                if (_currentToken.kind !== 107 /* QuestionToken */) {
                    return leftOperand;
                }
                // Note: we explicitly do *not* pass 'allowIn' to the whenTrue part.  An 'in' expression is always
                // allowed in the 'true' part of a conditional expression.
                return new TypeScript.ConditionalExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, true), eatToken(108 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }
            function parseBinaryExpressionRest(precedence, allowIn, leftOperand) {
                while (true) {
                    // We either have a binary operator here, or we're finished.  We call 
                    // currentOperatorToken versus currentToken here so that we merge token sequences
                    // like > and = into >=
                    var operatorToken = currentOperatorToken();
                    var tokenKind = operatorToken.kind;
                    // Only proceed if we see binary expression token.  However we don't parse 
                    // assignment expressions or comma expressions here.  Those are taken care of 
                    // respectively in parseAssignmentExpression and parseExpression.
                    if (!TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(tokenKind) || tokenKind === 81 /* CommaToken */ || TypeScript.SyntaxFacts.isAssignmentOperatorToken(tokenKind)) {
                        break;
                    }
                    // also, if it's the 'in' operator, only allow if our caller allows it.
                    if (tokenKind === 31 /* InKeyword */ && !allowIn) {
                        break;
                    }
                    var newPrecedence = getBinaryExpressionPrecedence(tokenKind);
                    // All binary operators must have precedence > 0
                    // Debug.assert(newPrecedence > 0);
                    // Check the precedence to see if we should "take" this operator
                    if (newPrecedence <= precedence) {
                        break;
                    }
                    // Precedence is okay, so we'll "take" this operator.
                    // Now skip the operator token we're on.
                    leftOperand = new TypeScript.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseBinaryExpressionOrHigher(currentToken(), true, newPrecedence, allowIn));
                }
                return leftOperand;
            }
            function currentOperatorToken() {
                var token0 = currentToken();
                // If we see a > we need to see if we can actually merge this contextually into a 
                // >>  >>>  >=  >>=  >>>=  token.
                if (token0.kind === 83 /* GreaterThanToken */) {
                    return currentContextualToken();
                }
                return token0;
            }
            function tryParseMemberExpressionOrHigher(_currentToken, force, inObjectCreation) {
                // Note: to make our lives simpler, we decompose the the NewExpression productions and
                // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.
                // like so:
                //
                //   PrimaryExpression : See 11.1 
                //      this
                //      Identifier
                //      Literal
                //      ArrayLiteral
                //      ObjectLiteral
                //      (Expression) 
                //      FunctionExpression
                //      new MemberExpression Arguments?
                //
                //   MemberExpression : See 11.2 
                //      PrimaryExpression 
                //      MemberExpression[Expression]
                //      MemberExpression.IdentifierName
                //
                //   CallExpression : See 11.2 
                //      MemberExpression 
                //      CallExpression Arguments
                //      CallExpression[Expression]
                //      CallExpression.IdentifierName 
                //
                // Technically this is ambiguous.  i.e. CallExpression defines:
                //
                //   CallExpression:
                //      CallExpression Arguments
                // 
                // If you see: "new Foo()"
                //
                // Then that could be treated as a single ObjectCreationExpression, or it could be 
                // treated as the invocation of "new Foo".  We disambiguate that in code (to match
                // the original grammar) by making sure that if we see an ObjectCreationExpression
                // we always consume arguments if they are there. So we treat "new Foo()" as an
                // object creation only, and not at all as an invocation)  Another way to think 
                // about this is that for every "new" that we see, we will consume an argument list if
                // it is there as part of the *associated* object creation node.  Any additional
                // argument lists we see, will become invocation expressions.
                //
                // Because there are no other places in the grammar now that refer to FunctionExpression
                // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression
                // production.
                //
                // Because CallExpression and MemberExpression are left recursive, we need to bottom out
                // of the recursion immediately.  So we parse out a primary expression to start with.
                var expression = tryParsePrimaryExpression(_currentToken, force);
                if (expression === undefined) {
                    return undefined;
                }
                return parseMemberExpressionRest(expression, inObjectCreation);
            }
            function parseCallExpressionRest(expression) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind;
                    switch (currentTokenKind) {
                        case 74 /* OpenParenToken */:
                            expression = new TypeScript.InvocationExpressionSyntax(parseNodeData, expression, parseArgumentList(undefined, _currentToken));
                            continue;
                        case 82 /* LessThanToken */:
                            // See if this is the start of a generic invocation.  If so, consume it and
                            // keep checking for postfix expressions.  Otherwise, it's just a '<' that's 
                            // part of an arithmetic expression.  Break out so we consume it higher in the
                            // stack.
                            var argumentList = tryParseArgumentList();
                            if (argumentList === undefined) {
                                break;
                            }
                            expression = new TypeScript.InvocationExpressionSyntax(parseNodeData, expression, argumentList);
                            continue;
                        case 76 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, false);
                            continue;
                        case 78 /* DotToken */:
                            expression = new TypeScript.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                        case 13 /* NoSubstitutionTemplateToken */:
                        case 14 /* TemplateStartToken */:
                            expression = new TypeScript.TemplateAccessExpressionSyntax(parseNodeData, expression, parseTemplateExpression(_currentToken));
                            continue;
                    }
                    return expression;
                }
            }
            function parseMemberExpressionRest(expression, inObjectCreation) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind;
                    switch (currentTokenKind) {
                        case 76 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, inObjectCreation);
                            continue;
                        case 78 /* DotToken */:
                            expression = new TypeScript.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                        case 13 /* NoSubstitutionTemplateToken */:
                        case 14 /* TemplateStartToken */:
                            expression = new TypeScript.TemplateAccessExpressionSyntax(parseNodeData, expression, parseTemplateExpression(_currentToken));
                            continue;
                    }
                    return expression;
                }
            }
            function tryParseLeftHandSideExpressionOrHigher(_currentToken, force) {
                // Original Ecma:
                // LeftHandSideExpression: See 11.2 
                //      NewExpression
                //      CallExpression 
                //
                // Our simplification:
                //
                // LeftHandSideExpression: See 11.2 
                //      MemberExpression  
                //      CallExpression 
                //
                // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
                // MemberExpression to make our lives easier.
                //
                // to best understand the below code, it's important to see how CallExpression expands
                // out into its own productions:
                //
                // CallExpression:
                //      MemberExpression Arguments 
                //      CallExpression Arguments
                //      CallExpression[Expression]
                //      CallExpression.IdentifierName
                //      super   (   ArgumentListopt   )
                //      super.IdentifierName
                //
                // Because of the recursion in these calls, we need to bottom out first.  There are two 
                // bottom out states we can run into.  Either we see 'super' which must start either of
                // the last two CallExpression productions.  Or we have a MemberExpression which either
                // completes the LeftHandSideExpression, or starts the beginning of the first four
                // CallExpression productions.
                var expression = undefined;
                if (_currentToken.kind === 52 /* SuperKeyword */) {
                    expression = parseSuperExpression(_currentToken);
                }
                else {
                    expression = tryParseMemberExpressionOrHigher(_currentToken, force, false);
                    if (expression === undefined) {
                        return undefined;
                    }
                }
                // Now, we *may* be complete.  However, we might have consumed the start of a 
                // CallExpression.  As such, we need to consume the rest of it here to be complete.
                return parseCallExpressionRest(expression);
            }
            function parseSuperExpression(superToken) {
                var expression = consumeToken(superToken);
                // If we have seen "super" it must be followed by '(' or '.'.
                // If it wasn't then just try to parse out a '.' and report an error.
                var currentTokenKind = currentToken().kind;
                return currentTokenKind === 74 /* OpenParenToken */ || currentTokenKind === 78 /* DotToken */ ? expression : new TypeScript.MemberAccessExpressionSyntax(parseNodeData, expression, eatToken(78 /* DotToken */), eatIdentifierNameToken());
            }
            function tryParsePostfixExpressionOrHigher(_currentToken, force) {
                var expression = tryParseLeftHandSideExpressionOrHigher(_currentToken, force);
                if (expression === undefined) {
                    return undefined;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind;
                switch (currentTokenKind) {
                    case 95 /* PlusPlusToken */:
                    case 96 /* MinusMinusToken */:
                        // Because of automatic semicolon insertion, we should only consume the ++ or -- 
                        // if it is on the same line as the previous token.
                        if (isOnDifferentLineThanPreviousToken(_currentToken)) {
                            break;
                        }
                        return new TypeScript.PostfixUnaryExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken));
                }
                return expression;
            }
            function tryParseGenericArgumentList() {
                // Debug.assert(currentToken().kind === SyntaxKind.LessThanToken);
                // If we have a '<', then only parse this as a arugment list if the type arguments
                // are complete and we have an open paren.  if we don't, rewind and return nothing.
                var rewindPoint = getRewindPoint();
                var typeArgumentList = tryParseTypeArgumentList(true);
                var token0 = currentToken();
                var tokenKind = token0.kind;
                var isOpenParen = tokenKind === 74 /* OpenParenToken */;
                var isDot = tokenKind === 78 /* DotToken */;
                var isOpenParenOrDot = isOpenParen || isDot;
                var argumentList = undefined;
                if (!typeArgumentList || !isOpenParenOrDot) {
                    // Wasn't generic.  Rewind to where we started so this can be parsed as an 
                    // arithmetic expression.
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return undefined;
                }
                else {
                    TypeScript.Debug.assert(typeArgumentList && isOpenParenOrDot);
                    releaseRewindPoint(rewindPoint);
                    // It's not uncommon for a user to type: "Foo<T>."
                    //
                    // This is not legal in typescript (as an parameter list must follow the type
                    // arguments).  We want to give a good error message for this as otherwise
                    // we'll bail out here and give a poor error message when we try to parse this
                    // as an arithmetic expression.
                    if (isDot) {
                        // A parameter list must follow a generic type argument list.
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, undefined);
                        addDiagnostic(diagnostic);
                        return new TypeScript.ArgumentListSyntax(parseNodeData, typeArgumentList, TypeScript.Syntax.emptyToken(74 /* OpenParenToken */), [], TypeScript.Syntax.emptyToken(75 /* CloseParenToken */));
                    }
                    else {
                        TypeScript.Debug.assert(token0.kind === 74 /* OpenParenToken */);
                        return parseArgumentList(typeArgumentList, token0);
                    }
                }
            }
            function tryParseArgumentList() {
                var _currentToken = currentToken();
                var tokenKind = _currentToken.kind;
                if (tokenKind === 82 /* LessThanToken */) {
                    return tryParseGenericArgumentList();
                }
                if (tokenKind === 74 /* OpenParenToken */) {
                    return parseArgumentList(undefined, _currentToken);
                }
                return undefined;
            }
            function parseArgumentList(typeArgumentList, openParenToken) {
                TypeScript.Debug.assert(openParenToken.kind === 74 /* OpenParenToken */ && openParenToken.fullWidth() > 0);
                return new TypeScript.ArgumentListSyntax(parseNodeData, typeArgumentList, consumeToken(openParenToken), parseSeparatedSyntaxList(14 /* ArgumentList_AssignmentExpressions */), eatToken(75 /* CloseParenToken */));
            }
            function tryParseArgumentListExpression() {
                // Generally while parsing lists, we don't want to 'force' the parser to parse
                // the item.  That way, if the expected item isn't htere, we can bail out and
                // move to a higher stage of list parsing.  However, it's extremely common to 
                // see something like "Foo(, a".  in this case, even though there isn't an expression
                // after the open paren, we still want to force parsing an expression (which will
                // cause a missing identiifer to be created), so that we will then consume the
                // comma and the following list items).
                var force = currentToken().kind === 81 /* CommaToken */;
                return tryParseAssignmentExpressionOrHigher(force, true);
            }
            function parseElementAccessArgumentExpression(openBracketToken, inObjectCreation) {
                // It's not uncommon for a user to write: "new Type[]".  Check for that common pattern
                // and report a better error message.
                if (inObjectCreation && currentToken().kind === 77 /* CloseBracketToken */) {
                    var errorStart = TypeScript.start(openBracketToken, source.text);
                    var errorEnd = TypeScript.fullEnd(currentToken());
                    var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), errorStart, errorEnd - errorStart, TypeScript.DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, undefined);
                    addDiagnostic(diagnostic);
                    return TypeScript.Syntax.emptyToken(9 /* IdentifierName */);
                }
                else {
                    return parseExpression(true);
                }
            }
            function parseElementAccessExpression(expression, openBracketToken, inObjectCreation) {
                // Debug.assert(currentToken().kind === SyntaxKind.OpenBracketToken);
                return new TypeScript.ElementAccessExpressionSyntax(parseNodeData, expression, consumeToken(openBracketToken), parseElementAccessArgumentExpression(openBracketToken, inObjectCreation), eatToken(77 /* CloseBracketToken */));
            }
            function tryParsePrimaryExpression(_currentToken, force) {
                if (isIdentifier(_currentToken)) {
                    return eatIdentifierToken();
                }
                var currentTokenKind = _currentToken.kind;
                switch (currentTokenKind) {
                    case 37 /* ThisKeyword */:
                    case 39 /* TrueKeyword */:
                    case 26 /* FalseKeyword */:
                    case 34 /* NullKeyword */:
                    case 11 /* NumericLiteral */:
                    case 10 /* RegularExpressionLiteral */:
                    case 12 /* StringLiteral */:
                        return consumeToken(_currentToken);
                    case 29 /* FunctionKeyword */: return parseFunctionExpression(_currentToken);
                    case 76 /* OpenBracketToken */: return parseArrayLiteralExpression(_currentToken);
                    case 72 /* OpenBraceToken */: return parseObjectLiteralExpression(_currentToken);
                    case 74 /* OpenParenToken */: return parseParenthesizedExpression(_currentToken);
                    case 33 /* NewKeyword */: return parseObjectCreationExpression(_currentToken);
                    case 13 /* NoSubstitutionTemplateToken */:
                    case 14 /* TemplateStartToken */:
                        return parseTemplateExpression(_currentToken);
                    case 120 /* SlashToken */:
                    case 121 /* SlashEqualsToken */:
                        // If we see a standalone / or /= and we're expecting a term, then try to reparse
                        // it as a regular expression.
                        var result = tryReparseDivideAsRegularExpression();
                        // If we get a result, then use it. Otherwise, create a missing identifier so
                        // that parsing can continue.  Note: we do this even if 'force' is false.  That's
                        // because we *do* want to consider a standalone / as an expression that should be
                        // returned from tryParseExpression even when 'force' is set to false.
                        return result || eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
                }
                if (!force) {
                    return undefined;
                }
                // Nothing else worked, report an error and produce a missing token.
                return eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
            }
            function tryReparseDivideAsRegularExpression() {
                // If we see a / or /= token, then that may actually be the start of a regex in certain 
                // contexts.
                // var currentToken = this.currentToken();
                // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken.kind));
                // Ok, from our quick lexical check, this could be a place where a regular expression could
                // go.  Now we have to do a bunch of work.  Ask the source to retrive the token at the 
                // current position again.  But this time allow it to retrieve it as a regular expression.
                var currentToken = currentContextualToken();
                // Note: we *must* have gotten a /, /= or regular expression.  Or else something went *very*
                // wrong with our logic above.
                // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(currentToken.kind));
                var tokenKind = currentToken.kind;
                if (tokenKind === 120 /* SlashToken */ || tokenKind === 121 /* SlashEqualsToken */) {
                    // Still came back as a / or /=.   This is not a regular expression literal.
                    return undefined;
                }
                else if (tokenKind === 10 /* RegularExpressionLiteral */) {
                    return consumeToken(currentToken);
                }
                else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }
            function parseTypeOfExpression(typeOfKeyword) {
                return new TypeScript.TypeOfExpressionSyntax(parseNodeData, consumeToken(typeOfKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseDeleteExpression(deleteKeyword) {
                return new TypeScript.DeleteExpressionSyntax(parseNodeData, consumeToken(deleteKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseVoidExpression(voidKeyword) {
                return new TypeScript.VoidExpressionSyntax(parseNodeData, consumeToken(voidKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseFunctionExpression(functionKeyword) {
                return new TypeScript.FunctionExpressionSyntax(parseNodeData, consumeToken(functionKeyword), eatOptionalIdentifierToken(), parseCallSignature(false), parseBlock(false, true));
            }
            function parseObjectCreationExpression(newKeyword) {
                // ObjectCreationExpression
                //      new MemberExpression Arguments?
                //
                // Note: if we see arguments we absolutely take them and attach them tightly to this
                // object creation expression.
                //
                // See comment in tryParseMemberExpressionOrHigher for a more complete explanation of
                // this decision.
                return new TypeScript.ObjectCreationExpressionSyntax(parseNodeData, consumeToken(newKeyword), tryParseMemberExpressionOrHigher(currentToken(), true, true), tryParseArgumentList());
            }
            function parseTemplateExpression(startToken) {
                startToken = consumeToken(startToken);
                if (startToken.kind === 13 /* NoSubstitutionTemplateToken */) {
                    return startToken;
                }
                var templateClauses = [];
                do {
                    // Keep consuming template spans as long as the last one we keep getting template
                    // middle pieces.
                    templateClauses.push(parseTemplateClause());
                } while (templateClauses[templateClauses.length - 1].templateMiddleOrEndToken.kind === 15 /* TemplateMiddleToken */);
                return new TypeScript.TemplateExpressionSyntax(parseNodeData, startToken, TypeScript.Syntax.list(templateClauses));
            }
            function parseTemplateClause() {
                var expression = parseExpression(true);
                var token = currentToken();
                if (token.kind === 73 /* CloseBraceToken */) {
                    token = currentContextualToken();
                    TypeScript.Debug.assert(token.kind === 15 /* TemplateMiddleToken */ || token.kind === 16 /* TemplateEndToken */);
                    token = consumeToken(token);
                }
                else {
                    var diagnostic = getExpectedTokenDiagnostic(73 /* CloseBraceToken */);
                    addDiagnostic(diagnostic);
                    token = TypeScript.Syntax.emptyToken(16 /* TemplateEndToken */);
                }
                return new TypeScript.TemplateClauseSyntax(parseNodeData, expression, token);
            }
            function parseCastExpression(lessThanToken) {
                return new TypeScript.CastExpressionSyntax(parseNodeData, consumeToken(lessThanToken), parseType(), eatToken(83 /* GreaterThanToken */), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseParenthesizedExpression(openParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(parseNodeData, consumeToken(openParenToken), parseExpression(true), eatToken(75 /* CloseParenToken */));
            }
            function tryParseParenthesizedArrowFunctionExpression() {
                var tokenKind = currentToken().kind;
                if (tokenKind !== 74 /* OpenParenToken */ && tokenKind !== 82 /* LessThanToken */) {
                    return undefined;
                }
                // Because arrow functions and parenthesized expressions look similar, we have to check far
                // enough ahead to be sure we've actually got an arrow function. For example, both nodes can
                // start with:
                //    (a = b, c = d, ..., e = f).
                //So we effectively need infinite lookahead to decide which node we're in.
                //
                // First, check for things that definitely have enough information to let us know it's an
                // arrow function.
                if (isDefinitelyArrowFunctionExpression()) {
                    // We have something like "() =>" or "(a) =>".  Definitely a lambda, so parse it
                    // unilaterally as such.
                    return tryParseParenthesizedArrowFunctionExpressionWorker(false);
                }
                // Now, look for cases where we're sure it's not an arrow function.  This will help save us
                // a costly parse.
                if (!isPossiblyArrowFunctionExpression()) {
                    return undefined;
                }
                // Then, try to actually parse it as a arrow function, and only return if we see an => 
                var rewindPoint = getRewindPoint();
                var arrowFunction = tryParseParenthesizedArrowFunctionExpressionWorker(true);
                if (arrowFunction === undefined) {
                    rewind(rewindPoint);
                }
                releaseRewindPoint(rewindPoint);
                return arrowFunction;
            }
            function tryParseParenthesizedArrowFunctionExpressionWorker(requireArrow) {
                var _currentToken = currentToken();
                // Debug.assert(currentToken.kind === SyntaxKind.OpenParenToken || currentToken.kind === SyntaxKind.LessThanToken);
                var callSignature = parseCallSignature(true);
                if (requireArrow && currentToken().kind !== 87 /* EqualsGreaterThanToken */) {
                    return undefined;
                }
                var equalsGreaterThanToken = eatToken(87 /* EqualsGreaterThanToken */);
                var block = tryParseArrowFunctionBlock();
                var expression = undefined;
                if (block === undefined) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(parseNodeData, callSignature, equalsGreaterThanToken, block, expression);
            }
            function tryParseArrowFunctionBlock() {
                if (isBlock()) {
                    return parseBlock(false, false);
                }
                else {
                    // We didn't have a block.  However, we may be in an error situation.  For example,
                    // if the user wrote:
                    //
                    //  a => 
                    //      var v = 0;
                    //  }
                    //
                    // (i.e. they're missing the open brace).  See if that's the case so we can try to 
                    // recover better.  If we don't do this, then the next close curly we see may end
                    // up preemptively closing the containing construct.
                    var _modifierCount = modifierCount();
                    if (isStatement(_modifierCount, false) && !isExpressionStatement(currentToken()) && !isFunctionDeclaration(_modifierCount)) {
                        // We've seen a statement (and it isn't an expressionStatement like 'foo()'), 
                        // so treat this like a block with a missing open brace.
                        return parseBlock(true, false);
                    }
                    else {
                        return undefined;
                    }
                }
            }
            function isSimpleArrowFunctionExpression(_currentToken) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function as that's likely what
                // the user intended to write.
                if (_currentToken.kind === 87 /* EqualsGreaterThanToken */) {
                    return true;
                }
                return isIdentifier(_currentToken) && peekToken(1).kind === 87 /* EqualsGreaterThanToken */;
            }
            function parseSimpleArrowFunctionExpression() {
                // Debug.assert(isSimpleArrowFunctionExpression());
                var parameter = eatSimpleParameter();
                var equalsGreaterThanToken = eatToken(87 /* EqualsGreaterThanToken */);
                var block = tryParseArrowFunctionBlock();
                var expression = undefined;
                if (block === undefined) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(parseNodeData, parameter, equalsGreaterThanToken, block, expression);
            }
            function isBlock() {
                return currentToken().kind === 72 /* OpenBraceToken */;
            }
            function isDefinitelyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind !== 74 /* OpenParenToken */) {
                    // If it didn't start with an (, then it could be generic.  That's too complicated 
                    // and we can't say it's 'definitely' an arrow function.             
                    return false;
                }
                var token1 = peekToken(1);
                var token1Kind = token1.kind;
                var token2;
                if (token1Kind === 75 /* CloseParenToken */) {
                    // ()
                    // Definitely an arrow function.  Could never be a parenthesized expression.  
                    // *However*, because of error situations, we could end up with things like "().foo".
                    // In this case, we don't want to think of this as the start of an arrow function.
                    // To prevent this, we are a little stricter, and we require that we at least see:
                    //      "():"  or  "() =>"  or "() {}".  Note: the last one is illegal.  However it
                    // most likely is a missing => and not a parenthesized expression.
                    token2 = peekToken(2);
                    var token2Kind = token2.kind;
                    return token2Kind === 108 /* ColonToken */ || token2Kind === 87 /* EqualsGreaterThanToken */ || token2Kind === 72 /* OpenBraceToken */;
                }
                if (token1Kind === 79 /* DotDotDotToken */) {
                    // (...
                    // Definitely an arrow function.  Could never be a parenthesized expression.
                    return true;
                }
                token2 = peekToken(2);
                token2Kind = token2.kind;
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(token1Kind)) {
                    if (isIdentifier(token2)) {
                        // "(public id" or "(function id".  Definitely an arrow function.  Could never 
                        // be a parenthesized expression.  Note: this will be an *illegal* arrow 
                        // function (as accessibility modifiers are not allowed in it).  However, that
                        // will be reported by the grammar checker walker.
                        return true;
                    }
                }
                if (!isIdentifier(token1)) {
                    // All other arrow functions must start with (id
                    // so this is definitely not an arrow function.
                    return false;
                }
                // (id
                //
                // Lots of options here.  Check for things that make us certain it's an
                // arrow function.
                if (token2Kind === 108 /* ColonToken */) {
                    // (id:
                    // Definitely an arrow function.  Could never be a parenthesized expression.
                    return true;
                }
                var token3 = peekToken(3);
                var token3Kind = token3.kind;
                if (token2Kind === 107 /* QuestionToken */) {
                    // (id?
                    // Could be an arrow function, or a parenthesized conditional expression.
                    // Check for the things that could only be arrow functions.
                    if (token3Kind === 108 /* ColonToken */ || token3Kind === 75 /* CloseParenToken */ || token3Kind === 81 /* CommaToken */) {
                        // (id?:
                        // (id?)
                        // (id?,
                        // These are the only cases where this could be an arrow function.
                        // And none of them can be parenthesized expression.
                        return true;
                    }
                }
                if (token2Kind === 75 /* CloseParenToken */) {
                    // (id)
                    // Could be an arrow function, or a parenthesized conditional expression.
                    if (token3Kind === 87 /* EqualsGreaterThanToken */) {
                        // (id) =>
                        // Definitely an arrow function.  Could not be a parenthesized expression.
                        return true;
                    }
                }
                // TODO: Add more cases if you're sure that there is enough information to know to 
                // parse this as an arrow function.  Note: be very careful here.
                // Anything else wasn't clear enough.  Try to parse the expression as an arrow function and bail out
                // if we fail.
                return false;
            }
            function isPossiblyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind !== 74 /* OpenParenToken */) {
                    // If it didn't start with an (, then it could be generic.  That's too complicated 
                    // and we have to say it's possibly an arrow function.
                    return true;
                }
                var token1 = peekToken(1);
                if (!isIdentifier(token1)) {
                    // All other arrow functions must start with (id
                    // so this is definitely not an arrow function.
                    return false;
                }
                var token2 = peekToken(2);
                var token2Kind = token2.kind;
                if (token2Kind === 109 /* EqualsToken */) {
                    // (id =
                    //
                    // This *could* be an arrow function.  i.e. (id = 0) => { }
                    // Or it could be a parenthesized expression.  So we'll have to actually
                    // try to parse it.
                    return true;
                }
                if (token2Kind === 81 /* CommaToken */) {
                    // (id,
                    // This *could* be an arrow function.  i.e. (id, id2) => { }
                    // Or it could be a parenthesized expression (as javascript supports
                    // the comma operator).  So we'll have to actually try to parse it.
                    return true;
                }
                if (token2Kind === 75 /* CloseParenToken */) {
                    // (id)
                    var token3 = peekToken(3);
                    if (token3.kind === 108 /* ColonToken */) {
                        // (id):
                        //
                        // This could be an arrow function. i.e. (id): number => { }
                        // Or it could be parenthesized exprssion: foo ? (id) :
                        // So we'll have to actually try to parse it.
                        return true;
                    }
                }
                // Nothing else could be an arrow function.
                return false;
            }
            function parseObjectLiteralExpression(openBraceToken) {
                // Debug.assert(currentToken().kind === SyntaxKind.OpenBraceToken);
                return new TypeScript.ObjectLiteralExpressionSyntax(parseNodeData, consumeToken(openBraceToken), parseSeparatedSyntaxList(15 /* ObjectLiteralExpression_PropertyAssignments */), eatToken(73 /* CloseBraceToken */));
            }
            function tryParsePropertyAssignment(inErrorRecovery) {
                // Debug.assert(isPropertyAssignment(/*inErrorRecovery:*/ false));
                if (isAccessor(modifierCount(), inErrorRecovery)) {
                    return parseAccessor(true);
                }
                // Note: we don't want to call parsePropertyName here yet as it will convert a keyword
                // to an identifier name.  We don't want to do that yet as a keyword is not legal as a
                // shorthand property assignment.
                var _currentToken = currentToken();
                if (isIdentifier(_currentToken)) {
                    var token1 = peekToken(1);
                    if (token1.kind !== 108 /* ColonToken */ && token1.kind !== 74 /* OpenParenToken */ && token1.kind !== 82 /* LessThanToken */) {
                        // If we don't have one of:
                        //
                        // id:
                        // id(
                        // id<
                        //
                        // then this is a shorthand property assignment.  Just return the identifier 
                        // token as is.
                        return consumeToken(_currentToken);
                    }
                }
                // All the rest of the property assignments start with property names.  They are:
                //      id: e
                //      [e1]: e2
                //      id() { }
                //      [e]() { } 
                if (isPropertyName(0, inErrorRecovery)) {
                    var propertyName = parsePropertyName();
                    if (isCallSignature(0)) {
                        return parseFunctionPropertyAssignment(propertyName);
                    }
                    else {
                        // If we didn't have an identifier, then we must have gotten a keyword or a
                        // literal.  Neither of these are allowed in a shorthand property, so this must
                        // be a simple property assignment.
                        //
                        // Also, if we have an identifier and it is followed by a colon then this is 
                        // definitely a simple property assignment.
                        return new TypeScript.SimplePropertyAssignmentSyntax(parseNodeData, propertyName, eatToken(108 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, true));
                    }
                }
                return undefined;
            }
            function isPropertyAssignment(inErrorRecovery) {
                return isAccessor(modifierCount(), inErrorRecovery) || isPropertyName(0, inErrorRecovery);
            }
            function isPropertyName(peekIndex, inErrorRecovery) {
                var token = peekToken(peekIndex);
                if (token.kind === 76 /* OpenBracketToken */) {
                    // A '[' only starts a property name as long as we're sure it doesn't start an
                    // index signature.
                    return !isIndexSignature(peekIndex);
                }
                return isPropertyNameToken(token, inErrorRecovery);
            }
            function isPropertyNameToken(token, inErrorRecovery) {
                // NOTE: we do *not* want to check "isIdentifier" here.  Any IdentifierName is 
                // allowed here, even reserved words like keywords.
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    // Except: if we're in error recovery, then we don't want to consider keywords. 
                    // After all, if we have:
                    //
                    //      { a: 1
                    //      return
                    //
                    // we don't want consider 'return' to be the next property in the object literal.
                    if (inErrorRecovery) {
                        return isIdentifier(token);
                    }
                    else {
                        return true;
                    }
                }
                return isLiteralPropertyName(token);
            }
            function isLiteralPropertyName(token) {
                // We allow a template literal while parser for error tolerance.  We'll report errors
                // on this later in the grammar checker walker.
                var kind = token.kind;
                return kind === 12 /* StringLiteral */ || kind === 11 /* NumericLiteral */ || kind === 13 /* NoSubstitutionTemplateToken */;
            }
            function parsePropertyName() {
                var _currentToken = currentToken();
                if (_currentToken.kind === 76 /* OpenBracketToken */) {
                    return parseComputedPropertyName(_currentToken);
                }
                else if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(_currentToken)) {
                    // If it was a keyword, convert it to an identifier name.
                    return eatIdentifierNameToken();
                }
                else {
                    // Must have been a literal.
                    return consumeToken(_currentToken);
                }
            }
            function parseComputedPropertyName(openBracketToken) {
                return new TypeScript.ComputedPropertyNameSyntax(parseNodeData, consumeToken(openBracketToken), tryParseAssignmentExpressionOrHigher(true, true), eatToken(77 /* CloseBracketToken */));
            }
            function parseFunctionPropertyAssignment(propertyName) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(parseNodeData, propertyName, parseCallSignature(false), parseBlock(false, true));
            }
            function parseArrayLiteralExpression(openBracketToken) {
                // Debug.assert(currentToken().kind === SyntaxKind.OpenBracketToken);
                return new TypeScript.ArrayLiteralExpressionSyntax(parseNodeData, consumeToken(openBracketToken), parseSeparatedSyntaxList(16 /* ArrayLiteralExpression_AssignmentExpressions */), eatToken(77 /* CloseBracketToken */));
            }
            function parseBlock(parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = eatToken(72 /* OpenBraceToken */);
                var statements;
                if (parseBlockEvenWithNoOpenBrace || openBraceToken.fullWidth() > 0) {
                    var savedIsInStrictMode = isInStrictMode;
                    var processItems = checkForStrictMode ? updateStrictModeState : undefined;
                    var statements = parseSyntaxList(5 /* Block_Statements */, processItems);
                    setStrictMode(savedIsInStrictMode);
                }
                return new TypeScript.BlockSyntax(parseNodeData, openBraceToken, statements || [], eatToken(73 /* CloseBraceToken */));
            }
            function parseCallSignature(requireCompleteTypeParameterList) {
                return new TypeScript.CallSignatureSyntax(parseNodeData, tryParseTypeParameterList(requireCompleteTypeParameterList), parseParameterList(), parseOptionalTypeAnnotation(false));
            }
            function tryParseTypeParameterList(requireCompleteTypeParameterList) {
                var _currentToken = currentToken();
                if (_currentToken.kind !== 82 /* LessThanToken */) {
                    return undefined;
                }
                var rewindPoint = getRewindPoint();
                var lessThanToken = consumeToken(_currentToken);
                var typeParameters = parseSeparatedSyntaxList(20 /* TypeParameterList_TypeParameters */);
                var greaterThanToken = eatToken(83 /* GreaterThanToken */);
                // return undefined if we were required to have a '>' token and we did not  have one.
                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return undefined;
                }
                else {
                    releaseRewindPoint(rewindPoint);
                    return new TypeScript.TypeParameterListSyntax(parseNodeData, lessThanToken, typeParameters, greaterThanToken);
                }
            }
            function isTypeParameter() {
                return isIdentifier(currentToken());
            }
            function tryParseTypeParameter() {
                // Debug.assert(isTypeParameter());
                if (!isIdentifier(currentToken())) {
                    return undefined;
                }
                return new TypeScript.TypeParameterSyntax(parseNodeData, eatIdentifierToken(), tryParseConstraint());
            }
            function tryParseConstraint() {
                if (currentToken().kind !== 50 /* ExtendsKeyword */) {
                    return undefined;
                }
                return new TypeScript.ConstraintSyntax(parseNodeData, eatToken(50 /* ExtendsKeyword */), parseTypeOrExpression());
            }
            function tryParseParameterList() {
                if (currentToken().kind === 74 /* OpenParenToken */) {
                    var token1 = peekToken(1);
                    if (token1.kind === 75 /* CloseParenToken */ || isParameterHelper(token1)) {
                        return parseParameterList();
                    }
                }
                return undefined;
            }
            function parseParameterList() {
                var openParenToken = eatToken(74 /* OpenParenToken */);
                var parameters;
                if (openParenToken.fullWidth() > 0) {
                    parameters = parseSeparatedSyntaxList(17 /* ParameterList_Parameters */);
                }
                return new TypeScript.ParameterListSyntax(parseNodeData, openParenToken, parameters || [], eatToken(75 /* CloseParenToken */));
            }
            function parseOptionalTypeAnnotation(allowStringLiteral) {
                return currentToken().kind === 108 /* ColonToken */ ? parseTypeAnnotation(allowStringLiteral) : undefined;
            }
            function parseTypeAnnotationType(allowStringLiteral) {
                if (allowStringLiteral) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind === 12 /* StringLiteral */) {
                        return consumeToken(_currentToken);
                    }
                }
                return parseType();
            }
            function parseTypeAnnotation(allowStringLiteral) {
                return new TypeScript.TypeAnnotationSyntax(parseNodeData, consumeToken(currentToken()), parseTypeAnnotationType(allowStringLiteral));
            }
            function isType() {
                var _currentToken = currentToken();
                switch (_currentToken.kind) {
                    case 41 /* TypeOfKeyword */:
                    case 62 /* AnyKeyword */:
                    case 69 /* NumberKeyword */:
                    case 63 /* BooleanKeyword */:
                    case 71 /* StringKeyword */:
                    case 43 /* VoidKeyword */:
                    case 72 /* OpenBraceToken */:
                    case 74 /* OpenParenToken */:
                    case 82 /* LessThanToken */:
                    case 33 /* NewKeyword */:
                        return true;
                    default:
                        return isIdentifier(_currentToken);
                }
            }
            function parseTypeOrExpression() {
                var result = tryParseType();
                if (result) {
                    return result;
                }
                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    // We parse out an expression here, but we very specifically ask for a unary 
                    // expression, and not just any expression.  That's because if we have:
                    //
                    //      <X extends "">
                    //
                    // We do not want the  >  to be consumed as part of the "" expression.  By starting
                    // at 'unary' expression and not 'binary' expression, we ensure that we don't accidently
                    // consume the >.
                    return tryParseUnaryExpressionOrHigher(_currentToken, true);
                }
                return eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }
            function parseType() {
                return tryParseType() || eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }
            function tryParseType() {
                if (isFunctionType()) {
                    return parseFunctionType();
                }
                if (currentToken().kind === 33 /* NewKeyword */) {
                    return parseConstructorType();
                }
                return tryParseUnionTypeOrHigher();
            }
            function tryParseUnionTypeOrHigher() {
                var type = tryParsePrimaryType();
                if (type) {
                    var barToken;
                    while ((barToken = currentToken()).kind === 101 /* BarToken */) {
                        type = new TypeScript.UnionTypeSyntax(parseNodeData, type, consumeToken(barToken), parsePrimaryType());
                    }
                }
                return type;
            }
            function parsePrimaryType() {
                return tryParsePrimaryType() || eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }
            function tryParsePrimaryType() {
                // First consume any underlying element type.
                var type = tryParseNonArrayType();
                while (type) {
                    var _currentToken = currentToken();
                    if (isOnDifferentLineThanPreviousToken(_currentToken) || _currentToken.kind !== 76 /* OpenBracketToken */) {
                        break;
                    }
                    type = new TypeScript.ArrayTypeSyntax(parseNodeData, type, consumeToken(_currentToken), eatToken(77 /* CloseBracketToken */));
                }
                return type;
            }
            function parseTypeQuery(typeOfKeyword) {
                return new TypeScript.TypeQuerySyntax(parseNodeData, consumeToken(typeOfKeyword), parseName(true));
            }
            function tryParseNonArrayType() {
                var _currentToken = currentToken();
                switch (_currentToken.kind) {
                    case 62 /* AnyKeyword */:
                    case 69 /* NumberKeyword */:
                    case 63 /* BooleanKeyword */:
                    case 71 /* StringKeyword */:
                        // if any of these are followed by '.', then this is actually a module name,
                        // and these keywords will be reinterpreted as an identifier.
                        if (peekToken(1).kind === 78 /* DotToken */) {
                            break;
                        }
                        return consumeToken(_currentToken);
                    case 43 /* VoidKeyword */: return consumeToken(_currentToken);
                    case 74 /* OpenParenToken */: return parseParenthesizedType(_currentToken);
                    case 72 /* OpenBraceToken */: return parseObjectType();
                    case 41 /* TypeOfKeyword */: return parseTypeQuery(_currentToken);
                    case 76 /* OpenBracketToken */: return parseTupleType(_currentToken);
                }
                return tryParseNameOrGenericType();
            }
            function parseParenthesizedType(openParenToken) {
                return new TypeScript.ParenthesizedTypeSyntax(parseNodeData, consumeToken(openParenToken), parseType(), eatToken(75 /* CloseParenToken */));
            }
            function tryParseNameOrGenericType() {
                var name = tryParseName(false);
                if (name === undefined) {
                    return undefined;
                }
                // TypeReference:
                //      TypeName   [no LineTerminator here]   TypeArgumentsopt
                //
                // Only consume type arguments if they appear on the same line.
                if (isOnDifferentLineThanPreviousToken(currentToken())) {
                    return name;
                }
                var typeArgumentList = tryParseTypeArgumentList(false);
                return !typeArgumentList ? name : new TypeScript.GenericTypeSyntax(parseNodeData, name, typeArgumentList);
            }
            function isFunctionType() {
                var token0 = currentToken();
                var token0Kind = token0.kind;
                // If we see a  <  then we consider ourselves to be definitely in a (generic) function type.
                if (token0Kind === 82 /* LessThanToken */) {
                    return true;
                }
                // If we don't see a  <  then we have to see an open paren for this to be a function 
                // type.  However, an open paren may also start a parenthesized type.  So we need to
                // do some lookahead to see what we've actually got.  If we don't see enough to be
                // sure that it's a function type, then we go ahead with the assumption that it's a 
                // parenthesized type.
                if (token0Kind === 74 /* OpenParenToken */) {
                    var token1 = peekToken(1);
                    var token1Kind = token1.kind;
                    if (token1Kind === 75 /* CloseParenToken */ || token1Kind === 79 /* DotDotDotToken */) {
                        // () 
                        // (...
                        //
                        // Both are definitely function types, and could not be paren types.
                        return true;
                    }
                    if (isModifierKind(token1Kind) || isIdentifier(token1)) {
                        // (id
                        // could be a function type or a parenthesized type.
                        var token2 = peekToken(2);
                        var token2Kind = token2.kind;
                        if (token2Kind === 108 /* ColonToken */ || token2Kind === 81 /* CommaToken */ || token2Kind === 107 /* QuestionToken */ || token2Kind === 109 /* EqualsToken */ || isIdentifier(token2) || isModifierKind(token2Kind)) {
                            // ( id :
                            // ( id ,
                            // ( id ?
                            // ( id =
                            // ( modifier id
                            //
                            // All of these are definitely a function type and not a parenthesized type.
                            return true;
                        }
                        if (token2Kind === 75 /* CloseParenToken */) {
                            // ( id )
                            //
                            // Only a function type if we see an arrow following it.
                            return peekToken(3).kind === 87 /* EqualsGreaterThanToken */;
                        }
                    }
                }
                // Anything else is a parenthesized type.
                return false;
            }
            function parseFunctionType() {
                var typeParameterList = tryParseTypeParameterList(false);
                var parameterList = parseParameterList();
                return new TypeScript.FunctionTypeSyntax(parseNodeData, typeParameterList, parameterList, eatToken(87 /* EqualsGreaterThanToken */), parseType());
            }
            function parseConstructorType() {
                return new TypeScript.ConstructorTypeSyntax(parseNodeData, eatToken(33 /* NewKeyword */), tryParseTypeParameterList(false), parseParameterList(), eatToken(87 /* EqualsGreaterThanToken */), parseType());
            }
            function isParameter() {
                if (currentNode() && currentNode().kind === 208 /* Parameter */) {
                    return true;
                }
                return isParameterHelper(currentToken());
            }
            function isParameterHelper(token) {
                var tokenKind = token.kind;
                return tokenKind === 79 /* DotDotDotToken */ || isModifierKind(tokenKind) || isIdentifier(token);
            }
            function eatSimpleParameter() {
                return new TypeScript.ParameterSyntax(parseNodeData, undefined, [], eatIdentifierToken(), undefined, undefined, undefined);
            }
            function tryParseParameter() {
                var node = currentNode();
                if (node && node.kind === 208 /* Parameter */) {
                    consumeNode(node);
                    return node;
                }
                var dotDotDotToken = tryEatToken(79 /* DotDotDotToken */);
                var modifiers = parseModifiers();
                // If we're not forcing, and we don't see anything to indicate this is a parameter, then 
                // bail out.
                var _currentToken = currentToken();
                if (!isIdentifier(_currentToken) && !dotDotDotToken && modifiers.length === 0) {
                    // ERROR RECOVERY:
                    // If we see a modifier alone in a parameter list, like:      foo(static)
                    //
                    // then treat it like modifier, and continue parsing the parameter.
                    if (isModifierKind(_currentToken.kind)) {
                        modifiers = TypeScript.Syntax.list([consumeToken(_currentToken)]);
                    }
                    else {
                        return undefined;
                    }
                }
                var identifier = eatIdentifierToken();
                var questionToken = tryEatToken(107 /* QuestionToken */);
                var typeAnnotation = parseOptionalTypeAnnotation(true);
                var equalsValueClause = undefined;
                if (isEqualsValueClause(true)) {
                    equalsValueClause = parseEqualsValueClause(true);
                }
                return new TypeScript.ParameterSyntax(parseNodeData, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause);
            }
            function parseSyntaxList(currentListType, processItems) {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);
                var result = parseSyntaxListWorker(currentListType, processItems);
                listParsingState = savedListParsingState;
                return result;
            }
            function parseSeparatedSyntaxList(currentListType) {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);
                var result = parseSeparatedSyntaxListWorker(currentListType);
                listParsingState = savedListParsingState;
                return result;
            }
            // Returns true if we should abort parsing.
            function abortParsingListOrMoveToNextToken(currentListType, nodeAndSeparators) {
                // Ok.  We're at a token that is not a terminator for the list and wasn't the start of 
                // an item in the list. Definitely report an error for this token.
                reportUnexpectedTokenDiagnostic(currentListType);
                for (var state = ListParsingState.LastListParsingState; state >= ListParsingState.FirstListParsingState; state--) {
                    if ((listParsingState & (1 << state)) !== 0) {
                        if (isExpectedListTerminator(state) || isExpectedListItem(state, true)) {
                            // Abort parsing this list.
                            return true;
                        }
                    }
                }
                // Otherwise, if none of the lists we're in can capture this token, then we need to 
                // unilaterally skip it.  Note: we've already reported an error above.
                skipToken(currentToken());
                // Continue parsing this list.  Attach this token to whatever we've seen already.
                return false;
            }
            function tryParseExpectedListItem(currentListType, inErrorRecovery, items, processItems) {
                var item = tryParseExpectedListItemWorker(currentListType, inErrorRecovery);
                if (item === undefined) {
                    return false;
                }
                // Debug.assert(item !== undefined);
                items.push(item);
                if (processItems) {
                    processItems(items);
                }
                return true;
            }
            function listIsTerminated(currentListType) {
                return isExpectedListTerminator(currentListType) || currentToken().kind === 8 /* EndOfFileToken */;
            }
            function parseSyntaxListWorker(currentListType, processItems) {
                var items = [];
                while (true) {
                    // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                    // continue parsing.
                    var succeeded = tryParseExpectedListItem(currentListType, false, items, processItems);
                    if (!succeeded) {
                        // We weren't able to parse out a list element.
                        // That may have been because the list is complete.  In that case, break out 
                        // and return the items we were able parse.
                        if (listIsTerminated(currentListType)) {
                            break;
                        }
                        // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                        // or skip a token and continue.
                        var abort = abortParsingListOrMoveToNextToken(currentListType, items);
                        if (abort) {
                            break;
                        }
                    }
                }
                return TypeScript.Syntax.list(items);
            }
            function parseSeparatedSyntaxListWorker(currentListType) {
                var nodesAndSeparators = [];
                // Debug.assert(nodes.length === 0);
                // Debug.assert(separators.length === 0);
                // Debug.assert(skippedTokens.length === 0);
                // Debug.assert(<any>skippedTokens !== nodes);
                // Debug.assert(skippedTokens !== separators);
                // Debug.assert(<any>nodes !== separators);
                var _separatorKind = currentListType === 9 /* ObjectType_TypeMembers */ ? 80 /* SemicolonToken */ : 81 /* CommaToken */;
                var allowAutomaticSemicolonInsertion = _separatorKind === 80 /* SemicolonToken */;
                var inErrorRecovery = false;
                while (true) {
                    // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                    // continue parsing.
                    // Debug.assert(oldItemsCount % 2 === 0);
                    var succeeded = tryParseExpectedListItem(currentListType, inErrorRecovery, nodesAndSeparators, undefined);
                    if (!succeeded) {
                        // We weren't able to parse out a list element.
                        // Debug.assert(items === undefined || items.length % 2 === 0);
                        // That may have been because the list is complete.  In that case, break out 
                        // and return the items we were able parse.
                        if (listIsTerminated(currentListType)) {
                            break;
                        }
                        // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                        // or skip a token and continue.
                        var abort = abortParsingListOrMoveToNextToken(currentListType, nodesAndSeparators);
                        if (abort) {
                            break;
                        }
                        else {
                            // We just skipped a token.  We're now in error recovery mode.
                            inErrorRecovery = true;
                            continue;
                        }
                    }
                    // Debug.assert(newItemsCount % 2 === 1);
                    // We were able to successfully parse out a list item.  So we're no longer in error
                    // recovery.
                    inErrorRecovery = false;
                    // Now, we have to see if we have a separator or not.  If we do have a separator
                    // we've got to consume it and continue trying to parse list items.  Note: we always
                    // allow 'comma' as a separator (for error tolerance).  We will later do a post pass
                    // to report when a comma was used improperly in a list that needed semicolons.
                    var _currentToken = currentToken();
                    var tokenKind = _currentToken.kind;
                    if (tokenKind === _separatorKind || tokenKind === 81 /* CommaToken */) {
                        // Consume the last separator and continue parsing list elements.
                        nodesAndSeparators.push(consumeToken(_currentToken));
                        continue;
                    }
                    // We didn't see the expected separator.  There are two reasons this might happen.
                    // First, we may actually be at the end of the list.  If we are, then we're done
                    // parsing list elements.  
                    if (listIsTerminated(currentListType)) {
                        break;
                    }
                    // Otherwise, it might be a case where we can parse out an implicit semicolon.
                    // Note: it's important that we check this *after* the check above for
                    // 'listIsTerminated'.  Consider the following case:
                    //
                    //      {
                    //          a       // <-- just finished parsing 'a'
                    //      }
                    //
                    // Automatic semicolon insertion rules state: "When, as the program is parsed from
                    // left to right, a token (called the offending token) is encountered that is not 
                    // allowed by any production of the grammar".  So we should only ever insert a 
                    // semicolon if we couldn't consume something normally.  in the above case, we can
                    // consume the '}' just fine.  So ASI doesn't apply.
                    if (allowAutomaticSemicolonInsertion && canEatAutomaticSemicolon(false)) {
                        var semicolonToken = eatExplicitOrAutomaticSemicolon(false) || TypeScript.Syntax.emptyToken(80 /* SemicolonToken */);
                        nodesAndSeparators.push(semicolonToken);
                        continue;
                    }
                    // We weren't at the end of the list.  And thre was no separator we could parse out.
                    // Try parse the separator we expected, and continue parsing more list elements.
                    // This time mark that we're in error recovery mode though.
                    //
                    // Note: trying to eat this token will emit the appropriate diagnostic.
                    nodesAndSeparators.push(eatToken(_separatorKind));
                    // Now that we're in 'error recovery' mode we cantweak some parsing rules as 
                    // appropriate.  For example, if we have:
                    //
                    //      var v = { a
                    //      return
                    //
                    // Then we'll be missing the comma.  As such, we want to parse 'return' in a less
                    // tolerant manner.  Normally 'return' could be a property in an object literal.
                    // However, in error recovery mode, we do *not* want it to be.
                    //
                    // Continue trying to parse out list elements.
                    inErrorRecovery = true;
                }
                return TypeScript.Syntax.separatedList(nodesAndSeparators);
            }
            function reportUnexpectedTokenDiagnostic(listType) {
                var token = currentToken();
                var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [getExpectedListElementType(listType)]);
                addDiagnostic(diagnostic);
            }
            function addDiagnostic(diagnostic) {
                // Except: if we already have a diagnostic for this position, don't report another one.
                if (diagnostics.length > 0 && diagnostics[diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }
                diagnostics.push(diagnostic);
            }
            function isExpectedListTerminator(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return isExpectedSourceUnit_ModuleElementsTerminator();
                    case 1 /* ClassDeclaration_ClassElements */: return isExpectedClassDeclaration_ClassElementsTerminator();
                    case 2 /* ModuleDeclaration_ModuleElements */: return isExpectedModuleDeclaration_ModuleElementsTerminator();
                    case 3 /* SwitchStatement_SwitchClauses */: return isExpectedSwitchStatement_SwitchClausesTerminator();
                    case 4 /* SwitchClause_Statements */: return isExpectedSwitchClause_StatementsTerminator();
                    case 5 /* Block_Statements */: return isExpectedBlock_StatementsTerminator();
                    case 6 /* TryBlock_Statements */: return isExpectedTryBlock_StatementsTerminator();
                    case 7 /* CatchBlock_Statements */: return isExpectedCatchBlock_StatementsTerminator();
                    case 8 /* EnumDeclaration_EnumElements */: return isExpectedEnumDeclaration_EnumElementsTerminator();
                    case 9 /* ObjectType_TypeMembers */: return isExpectedObjectType_TypeMembersTerminator();
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();
                    case 11 /* HeritageClause_TypeNameList */: return isExpectedHeritageClause_TypeNameListTerminator();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();
                    case 14 /* ArgumentList_AssignmentExpressions */: return isExpectedArgumentList_AssignmentExpressionsTerminator();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return isExpectedLiteralExpression_AssignmentExpressionsTerminator();
                    case 17 /* ParameterList_Parameters */: return isExpectedParameterList_ParametersTerminator();
                    case 18 /* IndexSignature_Parameters */: return isExpectedIndexSignature_ParametersTerminator();
                    case 19 /* TypeArgumentList_Types */: return isExpectedTypeArgumentList_TypesTerminator();
                    case 20 /* TypeParameterList_TypeParameters */: return isExpectedTypeParameterList_TypeParametersTerminator();
                    case 21 /* TupleType_Types */: return isExpectedTupleType_TypesTerminator();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            function isExpectedSourceUnit_ModuleElementsTerminator() {
                return currentToken().kind === 8 /* EndOfFileToken */;
            }
            function isExpectedEnumDeclaration_EnumElementsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedModuleDeclaration_ModuleElementsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedObjectType_TypeMembersTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedLiteralExpression_AssignmentExpressionsTerminator() {
                return currentToken().kind === 77 /* CloseBracketToken */;
            }
            function isExpectedTypeArgumentList_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind;
                if (tokenKind === 83 /* GreaterThanToken */) {
                    return true;
                }
                // If we're at a token that can follow the type argument list, then we'll also consider
                // the list terminated.
                if (canFollowTypeArgumentListInExpression(tokenKind)) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedTupleType_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind;
                if (tokenKind === 77 /* CloseBracketToken */) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedTypeParameterList_TypeParametersTerminator() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 83 /* GreaterThanToken */) {
                    return true;
                }
                // These commonly follow type parameter lists.
                if (tokenKind === 74 /* OpenParenToken */ || tokenKind === 72 /* OpenBraceToken */ || tokenKind === 50 /* ExtendsKeyword */ || tokenKind === 53 /* ImplementsKeyword */) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedParameterList_ParametersTerminator() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 75 /* CloseParenToken */) {
                    return true;
                }
                // We may also see a { in an error case.  i.e.:
                // function (a, b, c  {
                if (tokenKind === 72 /* OpenBraceToken */) {
                    return true;
                }
                // We may also see a => in an error case.  i.e.:
                // (f: number => { ... }
                if (tokenKind === 87 /* EqualsGreaterThanToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedIndexSignature_ParametersTerminator() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 77 /* CloseBracketToken */) {
                    return true;
                }
                // We may also see a { in an error case.  i.e.:
                // function (a, b, c  {
                if (tokenKind === 72 /* OpenBraceToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator() {
                // This is the case when we're parsing variable declarations in a for/for-in statement.
                var tokenKind = currentToken().kind;
                if (tokenKind === 80 /* SemicolonToken */ || tokenKind === 75 /* CloseParenToken */) {
                    return true;
                }
                if (tokenKind === 31 /* InKeyword */) {
                    return true;
                }
                return false;
            }
            function isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator() {
                //// This is the case when we're parsing variable declarations in a variable statement.
                // ERROR RECOVERY TWEAK:
                // For better error recovery, if we see a => then we just stop immediately.  We've got an
                // arrow function here and it's going to be very unlikely that we'll resynchronize and get
                // another variable declaration.
                if (currentToken().kind === 87 /* EqualsGreaterThanToken */) {
                    return true;
                }
                // We're done when we can eat a semicolon.
                return canEatExplicitOrAutomaticSemicolon(false);
            }
            function isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 72 /* OpenBraceToken */ || tokenKind === 73 /* CloseBraceToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedHeritageClause_TypeNameListTerminator() {
                var tokenKind = currentToken().kind;
                if (tokenKind === 50 /* ExtendsKeyword */ || tokenKind === 53 /* ImplementsKeyword */) {
                    return true;
                }
                if (isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }
                return false;
            }
            function isExpectedArgumentList_AssignmentExpressionsTerminator() {
                var token0 = currentToken();
                var tokenKind = token0.kind;
                return tokenKind === 75 /* CloseParenToken */ || tokenKind === 80 /* SemicolonToken */;
            }
            function isExpectedClassDeclaration_ClassElementsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedSwitchStatement_SwitchClausesTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedSwitchClause_StatementsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */ || isSwitchClause();
            }
            function isExpectedBlock_StatementsTerminator() {
                return currentToken().kind === 73 /* CloseBraceToken */;
            }
            function isExpectedTryBlock_StatementsTerminator() {
                var tokenKind = currentToken().kind;
                return tokenKind === 19 /* CatchKeyword */ || tokenKind === 27 /* FinallyKeyword */;
            }
            function isExpectedCatchBlock_StatementsTerminator() {
                return currentToken().kind === 27 /* FinallyKeyword */;
            }
            function isExpectedListItem(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return isModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */: return isClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */: return isModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */: return isSwitchClause();
                    case 4 /* SwitchClause_Statements */: return isStatement(modifierCount(), inErrorRecovery);
                    case 5 /* Block_Statements */: return isStatement(modifierCount(), inErrorRecovery);
                    case 6 /* TryBlock_Statements */: return false;
                    case 7 /* CatchBlock_Statements */: return false;
                    case 8 /* EnumDeclaration_EnumElements */: return isEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */: return isTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return isHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */: return isHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return isVariableDeclarator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return isVariableDeclarator();
                    case 14 /* ArgumentList_AssignmentExpressions */: return isExpectedArgumentList_AssignmentExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return isPropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return isAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */: return isParameter();
                    case 18 /* IndexSignature_Parameters */: return isParameter();
                    case 19 /* TypeArgumentList_Types */: return isType();
                    case 20 /* TypeParameterList_TypeParameters */: return isTypeParameter();
                    case 21 /* TupleType_Types */: return isType();
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }
            function isExpectedArgumentList_AssignmentExpression() {
                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    return true;
                }
                // If we're on a comma then the user has written something like "Foo(a,," or "Foo(,".
                // Instead of skipping the comma, create an empty expression to go before the comma 
                // so that the tree is more well formed and doesn't have skipped tokens.
                if (_currentToken.kind === 81 /* CommaToken */) {
                    return true;
                }
                return false;
            }
            function tryParseExpectedListItemWorker(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return tryParseModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */: return tryParseClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */: return tryParseModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */: return tryParseSwitchClause();
                    case 4 /* SwitchClause_Statements */: return tryParseStatement(inErrorRecovery);
                    case 5 /* Block_Statements */: return tryParseStatement(inErrorRecovery);
                    case 6 /* TryBlock_Statements */: return tryParseStatement(inErrorRecovery);
                    case 7 /* CatchBlock_Statements */: return tryParseStatement(inErrorRecovery);
                    case 8 /* EnumDeclaration_EnumElements */: return tryParseEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */: return tryParseTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return tryParseHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */: return tryParseHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return tryParseVariableDeclarator(true);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return tryParseVariableDeclarator(false);
                    case 14 /* ArgumentList_AssignmentExpressions */: return tryParseArgumentListExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return tryParsePropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return tryParseAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */: return tryParseParameter();
                    case 18 /* IndexSignature_Parameters */: return tryParseParameter();
                    case 19 /* TypeArgumentList_Types */: return tryParseType();
                    case 20 /* TypeParameterList_TypeParameters */: return tryParseTypeParameter();
                    case 21 /* TupleType_Types */: return tryParseType();
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }
            function getExpectedListElementType(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, undefined);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */: return '{';
                    case 1 /* ClassDeclaration_ClassElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.constructor_function_accessor_or_variable, undefined);
                    case 2 /* ModuleDeclaration_ModuleElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, undefined);
                    case 3 /* SwitchStatement_SwitchClauses */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.case_or_default_clause, undefined);
                    case 4 /* SwitchClause_Statements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, undefined);
                    case 5 /* Block_Statements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, undefined);
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, undefined);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, undefined);
                    case 8 /* EnumDeclaration_EnumElements */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, undefined);
                    case 9 /* ObjectType_TypeMembers */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.call_construct_index_property_or_function_signature, undefined);
                    case 14 /* ArgumentList_AssignmentExpressions */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, undefined);
                    case 11 /* HeritageClause_TypeNameList */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, undefined);
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.property_or_accessor, undefined);
                    case 17 /* ParameterList_Parameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, undefined);
                    case 18 /* IndexSignature_Parameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, undefined);
                    case 19 /* TypeArgumentList_Types */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, undefined);
                    case 20 /* TypeParameterList_TypeParameters */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, undefined);
                    case 21 /* TupleType_Types */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, undefined);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */: return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, undefined);
                    default: throw TypeScript.Errors.invalidOperation();
                }
            }
            return parseSyntaxTree;
        }
        // The precedence of expressions in typescript.  While we're parsing an expression, we will 
        // continue to consume and form new trees if the precedence is *strictly* greater than our current
        // precedence.  For example, if we have: a + b * c, we will first parse 'a' with precedence 1 (Lowest). 
        // We will then see the + with precedence 10.  10 is greater than 1 so we will decide to create
        // a binary expression with the result of parsing the sub expression "b * c".  We'll then parse
        // the term 'b' (passing in precedence 10).  We will then see the * with precedence 11.  11 is
        // greater than 10, so we will create a binary expression from "b" and "c", return that, and 
        // join it with "a" producing:
        //
        //      +
        //     / \
        //    a   *
        //       / \
        //      b   c
        //
        // If we instead had: "a * b + c", we would first parser 'a' with precedence 1 (lowest).  We would then see 
        // the * with precedence 11.  11 is greater than 1 so we will decide to create a binary expression
        // with the result of parsing the sub expression "b + c".  We'll then parse the term 'b' (passing in
        // precedence 11).  We will then see the + with precedence 10.  10 is less than 11, so we won't 
        // continue parsing subexpressions and will just return the expression 'b'.  The caller will join 
        // that into "a * b" (and will be back at precedence 1). It will then see the + with precedence 10.
        // 10 is greater than 1 so it will parse the sub expression and make a binary expression out of it
        // producing:
        //
        //        +
        //       / \
        //      *   c
        //     / \
        //    a   b
        //
        // Note: because all these binary expressions have left-to-right precedence, if we see a * b * c 
        // then we parse it as:
        //
        //        *
        //       / \
        //      *   c
        //     / \
        //    a   b
        //
        // The code to do this uses the above logic.  It will see an operator with the same precedence,
        // and so it won't consume it.
        var BinaryExpressionPrecedence;
        (function (BinaryExpressionPrecedence) {
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["Lowest"] = 1] = "Lowest";
            // Intuitively, logical || have the lowest precedence.  "a || b && c" is "a || (b && c)", not
            // "(a || b) && c"
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalOrExpressionPrecedence"] = 2] = "LogicalOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalAndExpressionPrecedence"] = 3] = "LogicalAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 4] = "BitwiseOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 5] = "BitwiseExclusiveOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 6] = "BitwiseAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["EqualityExpressionPrecedence"] = 7] = "EqualityExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["RelationalExpressionPrecedence"] = 8] = "RelationalExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["ShiftExpressionPrecdence"] = 9] = "ShiftExpressionPrecdence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["AdditiveExpressionPrecedence"] = 10] = "AdditiveExpressionPrecedence";
            // Intuitively, multiplicative expressions have the highest precedence.  After all, if you have:
            //   a + b * c
            //
            // Then you have "a + (b * c)" not "(a + b) * c"
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 11] = "MultiplicativeExpressionPrecedence";
        })(BinaryExpressionPrecedence || (BinaryExpressionPrecedence = {}));
        // The current state of the parser wrt to list parsing.  The way to read these is as:
        // CurrentProduction_SubList.  i.e. "Block_Statements" means "we're parsing a Block, and we're 
        // currently parsing list of statements within it".  This is used by the list parsing mechanism
        // to parse the elements of the lists, and recover from errors we encounter when we run into 
        // unexpected code.
        // 
        // For example, when we are in ArgumentList_Arguments, we will continue trying to consume code 
        // as long as "isArgument" is true.  If we run into a token for which "isArgument" is not true 
        // we will do the following:
        //
        // If the token is a StopToken for ArgumentList_Arguments (like ")" ) then we will stop parsing
        // the list of arguments with no error.
        //
        // Otherwise, we *do* report an error for this unexpected token, and then enter error recovery 
        // mode to decide how to try to recover from this unexpected token.
        //
        // Error recovery will walk up the list of states we're in seeing if the token is a stop token
        // for that construct *or* could start another element within what construct.  For example, if
        // the unexpected token was '}' then that would be a stop token for Block_Statements. 
        // Alternatively, if the unexpected token was 'return', then that would be a start token for 
        // the next statment in Block_Statements.
        // 
        // If either of those cases are true, We will then return *without* consuming  that token. 
        // (Remember, we've already reported an error).  Now we're just letting the higher up parse 
        // constructs eventually try to consume that token.
        //
        // If none of the higher up states consider this a stop or start token, then we will simply 
        // consume the token and add it to our list of 'skipped tokens'.  We will then repeat the 
        // above algorithm until we resynchronize at some point.
        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["IndexSignature_Parameters"] = 18] = "IndexSignature_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 19] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 20] = "TypeParameterList_TypeParameters";
            ListParsingState[ListParsingState["TupleType_Types"] = 21] = "TupleType_Types";
            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TupleType_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));
        // We keep the parser around as a singleton.  This is because calling createParser is actually
        // expensive in V8 currently.  We then clear it after a parse so that it doesn't  keep state 
        // alive unintentionally.
        var parseSyntaxTree = createParseSyntaxTree();
        function parse(fileName, text, languageVersion, isDeclaration) {
            return parseSource(TypeScript.Scanner.createParserSource(fileName, text, languageVersion), isDeclaration);
        }
        Parser.parse = parse;
        function parseSource(source, isDeclaration) {
            return parseSyntaxTree(source, isDeclaration);
        }
        Parser.parseSource = parseSource;
    })(Parser = TypeScript.Parser || (TypeScript.Parser = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    TypeScript.SourceUnitSyntax = function (data, moduleElements, endOfFileToken) {
        if (data) {
            this.__data = data;
        }
        this.moduleElements = moduleElements, this.endOfFileToken = endOfFileToken, moduleElements.parent = this, endOfFileToken.parent = this;
    };
    TypeScript.SourceUnitSyntax.prototype.kind = 122 /* SourceUnit */;
    TypeScript.SourceUnitSyntax.prototype.childCount = 2;
    TypeScript.SourceUnitSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.moduleElements;
            case 1: return this.endOfFileToken;
        }
    };
    TypeScript.QualifiedNameSyntax = function (data, left, dotToken, right) {
        if (data) {
            this.__data = data;
        }
        this.left = left, this.dotToken = dotToken, this.right = right, left.parent = this, dotToken.parent = this, right.parent = this;
    };
    TypeScript.QualifiedNameSyntax.prototype.kind = 123 /* QualifiedName */;
    TypeScript.QualifiedNameSyntax.prototype.childCount = 3;
    TypeScript.QualifiedNameSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
        }
    };
    TypeScript.ObjectTypeSyntax = function (data, openBraceToken, typeMembers, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.openBraceToken = openBraceToken, this.typeMembers = typeMembers, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, typeMembers.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.ObjectTypeSyntax.prototype.kind = 124 /* ObjectType */;
    TypeScript.ObjectTypeSyntax.prototype.childCount = 3;
    TypeScript.ObjectTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBraceToken;
            case 1: return this.typeMembers;
            case 2: return this.closeBraceToken;
        }
    };
    TypeScript.FunctionTypeSyntax = function (data, typeParameterList, parameterList, equalsGreaterThanToken, type) {
        if (data) {
            this.__data = data;
        }
        this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
    };
    TypeScript.FunctionTypeSyntax.prototype.kind = 125 /* FunctionType */;
    TypeScript.FunctionTypeSyntax.prototype.childCount = 4;
    TypeScript.FunctionTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.equalsGreaterThanToken;
            case 3: return this.type;
        }
    };
    TypeScript.ArrayTypeSyntax = function (data, type, openBracketToken, closeBracketToken) {
        if (data) {
            this.__data = data;
        }
        this.type = type, this.openBracketToken = openBracketToken, this.closeBracketToken = closeBracketToken, type.parent = this, openBracketToken.parent = this, closeBracketToken.parent = this;
    };
    TypeScript.ArrayTypeSyntax.prototype.kind = 126 /* ArrayType */;
    TypeScript.ArrayTypeSyntax.prototype.childCount = 3;
    TypeScript.ArrayTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.type;
            case 1: return this.openBracketToken;
            case 2: return this.closeBracketToken;
        }
    };
    TypeScript.ConstructorTypeSyntax = function (data, newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
        if (data) {
            this.__data = data;
        }
        this.newKeyword = newKeyword, this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, newKeyword.parent = this, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
    };
    TypeScript.ConstructorTypeSyntax.prototype.kind = 127 /* ConstructorType */;
    TypeScript.ConstructorTypeSyntax.prototype.childCount = 5;
    TypeScript.ConstructorTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.newKeyword;
            case 1: return this.typeParameterList;
            case 2: return this.parameterList;
            case 3: return this.equalsGreaterThanToken;
            case 4: return this.type;
        }
    };
    TypeScript.GenericTypeSyntax = function (data, name, typeArgumentList) {
        if (data) {
            this.__data = data;
        }
        this.name = name, this.typeArgumentList = typeArgumentList, name.parent = this, typeArgumentList.parent = this;
    };
    TypeScript.GenericTypeSyntax.prototype.kind = 128 /* GenericType */;
    TypeScript.GenericTypeSyntax.prototype.childCount = 2;
    TypeScript.GenericTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.name;
            case 1: return this.typeArgumentList;
        }
    };
    TypeScript.TypeQuerySyntax = function (data, typeOfKeyword, name) {
        if (data) {
            this.__data = data;
        }
        this.typeOfKeyword = typeOfKeyword, this.name = name, typeOfKeyword.parent = this, name.parent = this;
    };
    TypeScript.TypeQuerySyntax.prototype.kind = 129 /* TypeQuery */;
    TypeScript.TypeQuerySyntax.prototype.childCount = 2;
    TypeScript.TypeQuerySyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.typeOfKeyword;
            case 1: return this.name;
        }
    };
    TypeScript.TupleTypeSyntax = function (data, openBracketToken, types, closeBracketToken) {
        if (data) {
            this.__data = data;
        }
        this.openBracketToken = openBracketToken, this.types = types, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, types.parent = this, closeBracketToken.parent = this;
    };
    TypeScript.TupleTypeSyntax.prototype.kind = 130 /* TupleType */;
    TypeScript.TupleTypeSyntax.prototype.childCount = 3;
    TypeScript.TupleTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBracketToken;
            case 1: return this.types;
            case 2: return this.closeBracketToken;
        }
    };
    TypeScript.UnionTypeSyntax = function (data, left, barToken, right) {
        if (data) {
            this.__data = data;
        }
        this.left = left, this.barToken = barToken, this.right = right, left.parent = this, barToken.parent = this, right.parent = this;
    };
    TypeScript.UnionTypeSyntax.prototype.kind = 131 /* UnionType */;
    TypeScript.UnionTypeSyntax.prototype.childCount = 3;
    TypeScript.UnionTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.left;
            case 1: return this.barToken;
            case 2: return this.right;
        }
    };
    TypeScript.ParenthesizedTypeSyntax = function (data, openParenToken, type, closeParenToken) {
        if (data) {
            this.__data = data;
        }
        this.openParenToken = openParenToken, this.type = type, this.closeParenToken = closeParenToken, openParenToken.parent = this, type.parent = this, closeParenToken.parent = this;
    };
    TypeScript.ParenthesizedTypeSyntax.prototype.kind = 132 /* ParenthesizedType */;
    TypeScript.ParenthesizedTypeSyntax.prototype.childCount = 3;
    TypeScript.ParenthesizedTypeSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.closeParenToken;
        }
    };
    TypeScript.InterfaceDeclarationSyntax = function (data, modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.interfaceKeyword = interfaceKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.body = body, modifiers.parent = this, interfaceKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), heritageClauses.parent = this, body.parent = this;
    };
    TypeScript.InterfaceDeclarationSyntax.prototype.kind = 133 /* InterfaceDeclaration */;
    TypeScript.InterfaceDeclarationSyntax.prototype.childCount = 6;
    TypeScript.InterfaceDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.interfaceKeyword;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.heritageClauses;
            case 5: return this.body;
        }
    };
    TypeScript.FunctionDeclarationSyntax = function (data, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, modifiers.parent = this, functionKeyword.parent = this, identifier.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.FunctionDeclarationSyntax.prototype.kind = 134 /* FunctionDeclaration */;
    TypeScript.FunctionDeclarationSyntax.prototype.childCount = 6;
    TypeScript.FunctionDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.functionKeyword;
            case 2: return this.identifier;
            case 3: return this.callSignature;
            case 4: return this.block;
            case 5: return this.semicolonToken;
        }
    };
    TypeScript.ModuleDeclarationSyntax = function (data, modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.moduleKeyword = moduleKeyword, this.name = name, this.stringLiteral = stringLiteral, this.openBraceToken = openBraceToken, this.moduleElements = moduleElements, this.closeBraceToken = closeBraceToken, modifiers.parent = this, moduleKeyword.parent = this, name && (name.parent = this), stringLiteral && (stringLiteral.parent = this), openBraceToken.parent = this, moduleElements.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.ModuleDeclarationSyntax.prototype.kind = 135 /* ModuleDeclaration */;
    TypeScript.ModuleDeclarationSyntax.prototype.childCount = 7;
    TypeScript.ModuleDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.moduleKeyword;
            case 2: return this.name;
            case 3: return this.stringLiteral;
            case 4: return this.openBraceToken;
            case 5: return this.moduleElements;
            case 6: return this.closeBraceToken;
        }
    };
    TypeScript.ClassDeclarationSyntax = function (data, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.classKeyword = classKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.openBraceToken = openBraceToken, this.classElements = classElements, this.closeBraceToken = closeBraceToken, modifiers.parent = this, classKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), heritageClauses.parent = this, openBraceToken.parent = this, classElements.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.ClassDeclarationSyntax.prototype.kind = 136 /* ClassDeclaration */;
    TypeScript.ClassDeclarationSyntax.prototype.childCount = 8;
    TypeScript.ClassDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.classKeyword;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.heritageClauses;
            case 5: return this.openBraceToken;
            case 6: return this.classElements;
            case 7: return this.closeBraceToken;
        }
    };
    TypeScript.EnumDeclarationSyntax = function (data, modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.enumKeyword = enumKeyword, this.identifier = identifier, this.openBraceToken = openBraceToken, this.enumElements = enumElements, this.closeBraceToken = closeBraceToken, modifiers.parent = this, enumKeyword.parent = this, identifier.parent = this, openBraceToken.parent = this, enumElements.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.EnumDeclarationSyntax.prototype.kind = 137 /* EnumDeclaration */;
    TypeScript.EnumDeclarationSyntax.prototype.childCount = 6;
    TypeScript.EnumDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.enumKeyword;
            case 2: return this.identifier;
            case 3: return this.openBraceToken;
            case 4: return this.enumElements;
            case 5: return this.closeBraceToken;
        }
    };
    TypeScript.ImportDeclarationSyntax = function (data, modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.importKeyword = importKeyword, this.identifier = identifier, this.equalsToken = equalsToken, this.moduleReference = moduleReference, this.semicolonToken = semicolonToken, modifiers.parent = this, importKeyword.parent = this, identifier.parent = this, equalsToken.parent = this, moduleReference.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ImportDeclarationSyntax.prototype.kind = 138 /* ImportDeclaration */;
    TypeScript.ImportDeclarationSyntax.prototype.childCount = 6;
    TypeScript.ImportDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.importKeyword;
            case 2: return this.identifier;
            case 3: return this.equalsToken;
            case 4: return this.moduleReference;
            case 5: return this.semicolonToken;
        }
    };
    TypeScript.ExportAssignmentSyntax = function (data, exportKeyword, equalsToken, identifier, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.exportKeyword = exportKeyword, this.equalsToken = equalsToken, this.identifier = identifier, this.semicolonToken = semicolonToken, exportKeyword.parent = this, equalsToken.parent = this, identifier.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ExportAssignmentSyntax.prototype.kind = 139 /* ExportAssignment */;
    TypeScript.ExportAssignmentSyntax.prototype.childCount = 4;
    TypeScript.ExportAssignmentSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.exportKeyword;
            case 1: return this.equalsToken;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
        }
    };
    TypeScript.MemberFunctionDeclarationSyntax = function (data, modifiers, propertyName, callSignature, block, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, modifiers.parent = this, propertyName.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.MemberFunctionDeclarationSyntax.prototype.kind = 140 /* MemberFunctionDeclaration */;
    TypeScript.MemberFunctionDeclarationSyntax.prototype.childCount = 5;
    TypeScript.MemberFunctionDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.propertyName;
            case 2: return this.callSignature;
            case 3: return this.block;
            case 4: return this.semicolonToken;
        }
    };
    TypeScript.MemberVariableDeclarationSyntax = function (data, modifiers, variableDeclarator, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.variableDeclarator = variableDeclarator, this.semicolonToken = semicolonToken, modifiers.parent = this, variableDeclarator.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.MemberVariableDeclarationSyntax.prototype.kind = 141 /* MemberVariableDeclaration */;
    TypeScript.MemberVariableDeclarationSyntax.prototype.childCount = 3;
    TypeScript.MemberVariableDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.variableDeclarator;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.ConstructorDeclarationSyntax = function (data, modifiers, constructorKeyword, callSignature, block, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.constructorKeyword = constructorKeyword, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, modifiers.parent = this, constructorKeyword.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ConstructorDeclarationSyntax.prototype.kind = 142 /* ConstructorDeclaration */;
    TypeScript.ConstructorDeclarationSyntax.prototype.childCount = 5;
    TypeScript.ConstructorDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.constructorKeyword;
            case 2: return this.callSignature;
            case 3: return this.block;
            case 4: return this.semicolonToken;
        }
    };
    TypeScript.IndexMemberDeclarationSyntax = function (data, modifiers, indexSignature, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.indexSignature = indexSignature, this.semicolonToken = semicolonToken, modifiers.parent = this, indexSignature.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.IndexMemberDeclarationSyntax.prototype.kind = 143 /* IndexMemberDeclaration */;
    TypeScript.IndexMemberDeclarationSyntax.prototype.childCount = 3;
    TypeScript.IndexMemberDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.indexSignature;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.GetAccessorSyntax = function (data, modifiers, getKeyword, propertyName, callSignature, block) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.getKeyword = getKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, modifiers.parent = this, getKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
    };
    TypeScript.GetAccessorSyntax.prototype.kind = 144 /* GetAccessor */;
    TypeScript.GetAccessorSyntax.prototype.childCount = 5;
    TypeScript.GetAccessorSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.getKeyword;
            case 2: return this.propertyName;
            case 3: return this.callSignature;
            case 4: return this.block;
        }
    };
    TypeScript.SetAccessorSyntax = function (data, modifiers, setKeyword, propertyName, callSignature, block) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.setKeyword = setKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, modifiers.parent = this, setKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
    };
    TypeScript.SetAccessorSyntax.prototype.kind = 145 /* SetAccessor */;
    TypeScript.SetAccessorSyntax.prototype.childCount = 5;
    TypeScript.SetAccessorSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.setKeyword;
            case 2: return this.propertyName;
            case 3: return this.callSignature;
            case 4: return this.block;
        }
    };
    TypeScript.PropertySignatureSyntax = function (data, propertyName, questionToken, typeAnnotation) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, propertyName.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this);
    };
    TypeScript.PropertySignatureSyntax.prototype.kind = 146 /* PropertySignature */;
    TypeScript.PropertySignatureSyntax.prototype.childCount = 3;
    TypeScript.PropertySignatureSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.questionToken;
            case 2: return this.typeAnnotation;
        }
    };
    TypeScript.CallSignatureSyntax = function (data, typeParameterList, parameterList, typeAnnotation) {
        if (data) {
            this.__data = data;
        }
        this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.typeAnnotation = typeAnnotation, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, typeAnnotation && (typeAnnotation.parent = this);
    };
    TypeScript.CallSignatureSyntax.prototype.kind = 147 /* CallSignature */;
    TypeScript.CallSignatureSyntax.prototype.childCount = 3;
    TypeScript.CallSignatureSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.typeAnnotation;
        }
    };
    TypeScript.ConstructSignatureSyntax = function (data, newKeyword, callSignature) {
        if (data) {
            this.__data = data;
        }
        this.newKeyword = newKeyword, this.callSignature = callSignature, newKeyword.parent = this, callSignature.parent = this;
    };
    TypeScript.ConstructSignatureSyntax.prototype.kind = 148 /* ConstructSignature */;
    TypeScript.ConstructSignatureSyntax.prototype.childCount = 2;
    TypeScript.ConstructSignatureSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.newKeyword;
            case 1: return this.callSignature;
        }
    };
    TypeScript.IndexSignatureSyntax = function (data, openBracketToken, parameters, closeBracketToken, typeAnnotation) {
        if (data) {
            this.__data = data;
        }
        this.openBracketToken = openBracketToken, this.parameters = parameters, this.closeBracketToken = closeBracketToken, this.typeAnnotation = typeAnnotation, openBracketToken.parent = this, parameters.parent = this, closeBracketToken.parent = this, typeAnnotation && (typeAnnotation.parent = this);
    };
    TypeScript.IndexSignatureSyntax.prototype.kind = 149 /* IndexSignature */;
    TypeScript.IndexSignatureSyntax.prototype.childCount = 4;
    TypeScript.IndexSignatureSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            case 3: return this.typeAnnotation;
        }
    };
    TypeScript.MethodSignatureSyntax = function (data, propertyName, questionToken, callSignature) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.questionToken = questionToken, this.callSignature = callSignature, propertyName.parent = this, questionToken && (questionToken.parent = this), callSignature.parent = this;
    };
    TypeScript.MethodSignatureSyntax.prototype.kind = 150 /* MethodSignature */;
    TypeScript.MethodSignatureSyntax.prototype.childCount = 3;
    TypeScript.MethodSignatureSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.questionToken;
            case 2: return this.callSignature;
        }
    };
    TypeScript.BlockSyntax = function (data, openBraceToken, statements, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.openBraceToken = openBraceToken, this.statements = statements, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, statements.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.BlockSyntax.prototype.kind = 151 /* Block */;
    TypeScript.BlockSyntax.prototype.childCount = 3;
    TypeScript.BlockSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
        }
    };
    TypeScript.IfStatementSyntax = function (data, ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
        if (data) {
            this.__data = data;
        }
        this.ifKeyword = ifKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, this.elseClause = elseClause, ifKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this, elseClause && (elseClause.parent = this);
    };
    TypeScript.IfStatementSyntax.prototype.kind = 152 /* IfStatement */;
    TypeScript.IfStatementSyntax.prototype.childCount = 6;
    TypeScript.IfStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.elseClause;
        }
    };
    TypeScript.VariableStatementSyntax = function (data, modifiers, variableDeclaration, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.modifiers = modifiers, this.variableDeclaration = variableDeclaration, this.semicolonToken = semicolonToken, modifiers.parent = this, variableDeclaration.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.VariableStatementSyntax.prototype.kind = 153 /* VariableStatement */;
    TypeScript.VariableStatementSyntax.prototype.childCount = 3;
    TypeScript.VariableStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.modifiers;
            case 1: return this.variableDeclaration;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.ExpressionStatementSyntax = function (data, expression, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.semicolonToken = semicolonToken, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ExpressionStatementSyntax.prototype.kind = 154 /* ExpressionStatement */;
    TypeScript.ExpressionStatementSyntax.prototype.childCount = 2;
    TypeScript.ExpressionStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
        }
    };
    TypeScript.ReturnStatementSyntax = function (data, returnKeyword, expression, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.returnKeyword = returnKeyword, this.expression = expression, this.semicolonToken = semicolonToken, returnKeyword.parent = this, expression && (expression.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ReturnStatementSyntax.prototype.kind = 155 /* ReturnStatement */;
    TypeScript.ReturnStatementSyntax.prototype.childCount = 3;
    TypeScript.ReturnStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.SwitchStatementSyntax = function (data, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.switchKeyword = switchKeyword, this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, this.openBraceToken = openBraceToken, this.switchClauses = switchClauses, this.closeBraceToken = closeBraceToken, switchKeyword.parent = this, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this, openBraceToken.parent = this, switchClauses.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.SwitchStatementSyntax.prototype.kind = 156 /* SwitchStatement */;
    TypeScript.SwitchStatementSyntax.prototype.childCount = 7;
    TypeScript.SwitchStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.switchClauses;
            case 6: return this.closeBraceToken;
        }
    };
    TypeScript.BreakStatementSyntax = function (data, breakKeyword, identifier, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.breakKeyword = breakKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, breakKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.BreakStatementSyntax.prototype.kind = 157 /* BreakStatement */;
    TypeScript.BreakStatementSyntax.prototype.childCount = 3;
    TypeScript.BreakStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.breakKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.ContinueStatementSyntax = function (data, continueKeyword, identifier, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.continueKeyword = continueKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, continueKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ContinueStatementSyntax.prototype.kind = 158 /* ContinueStatement */;
    TypeScript.ContinueStatementSyntax.prototype.childCount = 3;
    TypeScript.ContinueStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.continueKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.ForStatementSyntax = function (data, forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
        if (data) {
            this.__data = data;
        }
        this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.initializer = initializer, this.firstSemicolonToken = firstSemicolonToken, this.condition = condition, this.secondSemicolonToken = secondSemicolonToken, this.incrementor = incrementor, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), initializer && (initializer.parent = this), firstSemicolonToken.parent = this, condition && (condition.parent = this), secondSemicolonToken.parent = this, incrementor && (incrementor.parent = this), closeParenToken.parent = this, statement.parent = this;
    };
    TypeScript.ForStatementSyntax.prototype.kind = 159 /* ForStatement */;
    TypeScript.ForStatementSyntax.prototype.childCount = 10;
    TypeScript.ForStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.initializer;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementor;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
        }
    };
    TypeScript.ForInStatementSyntax = function (data, forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
        if (data) {
            this.__data = data;
        }
        this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.left = left, this.inKeyword = inKeyword, this.expression = expression, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), left && (left.parent = this), inKeyword.parent = this, expression.parent = this, closeParenToken.parent = this, statement.parent = this;
    };
    TypeScript.ForInStatementSyntax.prototype.kind = 160 /* ForInStatement */;
    TypeScript.ForInStatementSyntax.prototype.childCount = 8;
    TypeScript.ForInStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.left;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
        }
    };
    TypeScript.EmptyStatementSyntax = function (data, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.semicolonToken = semicolonToken, semicolonToken.parent = this;
    };
    TypeScript.EmptyStatementSyntax.prototype.kind = 161 /* EmptyStatement */;
    TypeScript.EmptyStatementSyntax.prototype.childCount = 1;
    TypeScript.EmptyStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.semicolonToken;
        }
    };
    TypeScript.ThrowStatementSyntax = function (data, throwKeyword, expression, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.throwKeyword = throwKeyword, this.expression = expression, this.semicolonToken = semicolonToken, throwKeyword.parent = this, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.ThrowStatementSyntax.prototype.kind = 162 /* ThrowStatement */;
    TypeScript.ThrowStatementSyntax.prototype.childCount = 3;
    TypeScript.ThrowStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
        }
    };
    TypeScript.WhileStatementSyntax = function (data, whileKeyword, openParenToken, condition, closeParenToken, statement) {
        if (data) {
            this.__data = data;
        }
        this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
    };
    TypeScript.WhileStatementSyntax.prototype.kind = 163 /* WhileStatement */;
    TypeScript.WhileStatementSyntax.prototype.childCount = 5;
    TypeScript.WhileStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
        }
    };
    TypeScript.TryStatementSyntax = function (data, tryKeyword, block, catchClause, finallyClause) {
        if (data) {
            this.__data = data;
        }
        this.tryKeyword = tryKeyword, this.block = block, this.catchClause = catchClause, this.finallyClause = finallyClause, tryKeyword.parent = this, block.parent = this, catchClause && (catchClause.parent = this), finallyClause && (finallyClause.parent = this);
    };
    TypeScript.TryStatementSyntax.prototype.kind = 164 /* TryStatement */;
    TypeScript.TryStatementSyntax.prototype.childCount = 4;
    TypeScript.TryStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catchClause;
            case 3: return this.finallyClause;
        }
    };
    TypeScript.LabeledStatementSyntax = function (data, identifier, colonToken, statement) {
        if (data) {
            this.__data = data;
        }
        this.identifier = identifier, this.colonToken = colonToken, this.statement = statement, identifier.parent = this, colonToken.parent = this, statement.parent = this;
    };
    TypeScript.LabeledStatementSyntax.prototype.kind = 165 /* LabeledStatement */;
    TypeScript.LabeledStatementSyntax.prototype.childCount = 3;
    TypeScript.LabeledStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
        }
    };
    TypeScript.DoStatementSyntax = function (data, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.doKeyword = doKeyword, this.statement = statement, this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.semicolonToken = semicolonToken, doKeyword.parent = this, statement.parent = this, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.DoStatementSyntax.prototype.kind = 166 /* DoStatement */;
    TypeScript.DoStatementSyntax.prototype.childCount = 7;
    TypeScript.DoStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
        }
    };
    TypeScript.DebuggerStatementSyntax = function (data, debuggerKeyword, semicolonToken) {
        if (data) {
            this.__data = data;
        }
        this.debuggerKeyword = debuggerKeyword, this.semicolonToken = semicolonToken, debuggerKeyword.parent = this, semicolonToken && (semicolonToken.parent = this);
    };
    TypeScript.DebuggerStatementSyntax.prototype.kind = 167 /* DebuggerStatement */;
    TypeScript.DebuggerStatementSyntax.prototype.childCount = 2;
    TypeScript.DebuggerStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.debuggerKeyword;
            case 1: return this.semicolonToken;
        }
    };
    TypeScript.WithStatementSyntax = function (data, withKeyword, openParenToken, condition, closeParenToken, statement) {
        if (data) {
            this.__data = data;
        }
        this.withKeyword = withKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, withKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
    };
    TypeScript.WithStatementSyntax.prototype.kind = 168 /* WithStatement */;
    TypeScript.WithStatementSyntax.prototype.childCount = 5;
    TypeScript.WithStatementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.withKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
        }
    };
    TypeScript.PrefixUnaryExpressionSyntax = function (data, operatorToken, operand) {
        if (data) {
            this.__data = data;
        }
        this.operatorToken = operatorToken, this.operand = operand, operatorToken.parent = this, operand.parent = this;
    };
    TypeScript.PrefixUnaryExpressionSyntax.prototype.kind = 169 /* PrefixUnaryExpression */;
    TypeScript.PrefixUnaryExpressionSyntax.prototype.childCount = 2;
    TypeScript.PrefixUnaryExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.operatorToken;
            case 1: return this.operand;
        }
    };
    TypeScript.DeleteExpressionSyntax = function (data, deleteKeyword, expression) {
        if (data) {
            this.__data = data;
        }
        this.deleteKeyword = deleteKeyword, this.expression = expression, deleteKeyword.parent = this, expression.parent = this;
    };
    TypeScript.DeleteExpressionSyntax.prototype.kind = 170 /* DeleteExpression */;
    TypeScript.DeleteExpressionSyntax.prototype.childCount = 2;
    TypeScript.DeleteExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.deleteKeyword;
            case 1: return this.expression;
        }
    };
    TypeScript.TypeOfExpressionSyntax = function (data, typeOfKeyword, expression) {
        if (data) {
            this.__data = data;
        }
        this.typeOfKeyword = typeOfKeyword, this.expression = expression, typeOfKeyword.parent = this, expression.parent = this;
    };
    TypeScript.TypeOfExpressionSyntax.prototype.kind = 171 /* TypeOfExpression */;
    TypeScript.TypeOfExpressionSyntax.prototype.childCount = 2;
    TypeScript.TypeOfExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.typeOfKeyword;
            case 1: return this.expression;
        }
    };
    TypeScript.VoidExpressionSyntax = function (data, voidKeyword, expression) {
        if (data) {
            this.__data = data;
        }
        this.voidKeyword = voidKeyword, this.expression = expression, voidKeyword.parent = this, expression.parent = this;
    };
    TypeScript.VoidExpressionSyntax.prototype.kind = 172 /* VoidExpression */;
    TypeScript.VoidExpressionSyntax.prototype.childCount = 2;
    TypeScript.VoidExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.voidKeyword;
            case 1: return this.expression;
        }
    };
    TypeScript.ConditionalExpressionSyntax = function (data, condition, questionToken, whenTrue, colonToken, whenFalse) {
        if (data) {
            this.__data = data;
        }
        this.condition = condition, this.questionToken = questionToken, this.whenTrue = whenTrue, this.colonToken = colonToken, this.whenFalse = whenFalse, condition.parent = this, questionToken.parent = this, whenTrue.parent = this, colonToken.parent = this, whenFalse.parent = this;
    };
    TypeScript.ConditionalExpressionSyntax.prototype.kind = 173 /* ConditionalExpression */;
    TypeScript.ConditionalExpressionSyntax.prototype.childCount = 5;
    TypeScript.ConditionalExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
        }
    };
    TypeScript.BinaryExpressionSyntax = function (data, left, operatorToken, right) {
        if (data) {
            this.__data = data;
        }
        this.left = left, this.operatorToken = operatorToken, this.right = right, left.parent = this, operatorToken.parent = this, right.parent = this;
    };
    TypeScript.BinaryExpressionSyntax.prototype.kind = 174 /* BinaryExpression */;
    TypeScript.BinaryExpressionSyntax.prototype.childCount = 3;
    TypeScript.BinaryExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
        }
    };
    TypeScript.PostfixUnaryExpressionSyntax = function (data, operand, operatorToken) {
        if (data) {
            this.__data = data;
        }
        this.operand = operand, this.operatorToken = operatorToken, operand.parent = this, operatorToken.parent = this;
    };
    TypeScript.PostfixUnaryExpressionSyntax.prototype.kind = 175 /* PostfixUnaryExpression */;
    TypeScript.PostfixUnaryExpressionSyntax.prototype.childCount = 2;
    TypeScript.PostfixUnaryExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.operand;
            case 1: return this.operatorToken;
        }
    };
    TypeScript.MemberAccessExpressionSyntax = function (data, expression, dotToken, name) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.dotToken = dotToken, this.name = name, expression.parent = this, dotToken.parent = this, name.parent = this;
    };
    TypeScript.MemberAccessExpressionSyntax.prototype.kind = 176 /* MemberAccessExpression */;
    TypeScript.MemberAccessExpressionSyntax.prototype.childCount = 3;
    TypeScript.MemberAccessExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.dotToken;
            case 2: return this.name;
        }
    };
    TypeScript.InvocationExpressionSyntax = function (data, expression, argumentList) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.argumentList = argumentList, expression.parent = this, argumentList.parent = this;
    };
    TypeScript.InvocationExpressionSyntax.prototype.kind = 177 /* InvocationExpression */;
    TypeScript.InvocationExpressionSyntax.prototype.childCount = 2;
    TypeScript.InvocationExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.argumentList;
        }
    };
    TypeScript.ArrayLiteralExpressionSyntax = function (data, openBracketToken, expressions, closeBracketToken) {
        if (data) {
            this.__data = data;
        }
        this.openBracketToken = openBracketToken, this.expressions = expressions, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, expressions.parent = this, closeBracketToken.parent = this;
    };
    TypeScript.ArrayLiteralExpressionSyntax.prototype.kind = 178 /* ArrayLiteralExpression */;
    TypeScript.ArrayLiteralExpressionSyntax.prototype.childCount = 3;
    TypeScript.ArrayLiteralExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBracketToken;
            case 1: return this.expressions;
            case 2: return this.closeBracketToken;
        }
    };
    TypeScript.ObjectLiteralExpressionSyntax = function (data, openBraceToken, propertyAssignments, closeBraceToken) {
        if (data) {
            this.__data = data;
        }
        this.openBraceToken = openBraceToken, this.propertyAssignments = propertyAssignments, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, propertyAssignments.parent = this, closeBraceToken.parent = this;
    };
    TypeScript.ObjectLiteralExpressionSyntax.prototype.kind = 179 /* ObjectLiteralExpression */;
    TypeScript.ObjectLiteralExpressionSyntax.prototype.childCount = 3;
    TypeScript.ObjectLiteralExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBraceToken;
            case 1: return this.propertyAssignments;
            case 2: return this.closeBraceToken;
        }
    };
    TypeScript.ObjectCreationExpressionSyntax = function (data, newKeyword, expression, argumentList) {
        if (data) {
            this.__data = data;
        }
        this.newKeyword = newKeyword, this.expression = expression, this.argumentList = argumentList, newKeyword.parent = this, expression.parent = this, argumentList && (argumentList.parent = this);
    };
    TypeScript.ObjectCreationExpressionSyntax.prototype.kind = 180 /* ObjectCreationExpression */;
    TypeScript.ObjectCreationExpressionSyntax.prototype.childCount = 3;
    TypeScript.ObjectCreationExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.newKeyword;
            case 1: return this.expression;
            case 2: return this.argumentList;
        }
    };
    TypeScript.ParenthesizedExpressionSyntax = function (data, openParenToken, expression, closeParenToken) {
        if (data) {
            this.__data = data;
        }
        this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this;
    };
    TypeScript.ParenthesizedExpressionSyntax.prototype.kind = 181 /* ParenthesizedExpression */;
    TypeScript.ParenthesizedExpressionSyntax.prototype.childCount = 3;
    TypeScript.ParenthesizedExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
        }
    };
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = function (data, callSignature, equalsGreaterThanToken, block, expression) {
        if (data) {
            this.__data = data;
        }
        this.callSignature = callSignature, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, callSignature.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
    };
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = 182 /* ParenthesizedArrowFunctionExpression */;
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = 4;
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.callSignature;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.block;
            case 3: return this.expression;
        }
    };
    TypeScript.SimpleArrowFunctionExpressionSyntax = function (data, parameter, equalsGreaterThanToken, block, expression) {
        if (data) {
            this.__data = data;
        }
        this.parameter = parameter, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, parameter.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
    };
    TypeScript.SimpleArrowFunctionExpressionSyntax.prototype.kind = 183 /* SimpleArrowFunctionExpression */;
    TypeScript.SimpleArrowFunctionExpressionSyntax.prototype.childCount = 4;
    TypeScript.SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.parameter;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.block;
            case 3: return this.expression;
        }
    };
    TypeScript.CastExpressionSyntax = function (data, lessThanToken, type, greaterThanToken, expression) {
        if (data) {
            this.__data = data;
        }
        this.lessThanToken = lessThanToken, this.type = type, this.greaterThanToken = greaterThanToken, this.expression = expression, lessThanToken.parent = this, type.parent = this, greaterThanToken.parent = this, expression.parent = this;
    };
    TypeScript.CastExpressionSyntax.prototype.kind = 184 /* CastExpression */;
    TypeScript.CastExpressionSyntax.prototype.childCount = 4;
    TypeScript.CastExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.lessThanToken;
            case 1: return this.type;
            case 2: return this.greaterThanToken;
            case 3: return this.expression;
        }
    };
    TypeScript.ElementAccessExpressionSyntax = function (data, expression, openBracketToken, argumentExpression, closeBracketToken) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.openBracketToken = openBracketToken, this.argumentExpression = argumentExpression, this.closeBracketToken = closeBracketToken, expression.parent = this, openBracketToken.parent = this, argumentExpression.parent = this, closeBracketToken.parent = this;
    };
    TypeScript.ElementAccessExpressionSyntax.prototype.kind = 185 /* ElementAccessExpression */;
    TypeScript.ElementAccessExpressionSyntax.prototype.childCount = 4;
    TypeScript.ElementAccessExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.openBracketToken;
            case 2: return this.argumentExpression;
            case 3: return this.closeBracketToken;
        }
    };
    TypeScript.FunctionExpressionSyntax = function (data, functionKeyword, identifier, callSignature, block) {
        if (data) {
            this.__data = data;
        }
        this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, functionKeyword.parent = this, identifier && (identifier.parent = this), callSignature.parent = this, block.parent = this;
    };
    TypeScript.FunctionExpressionSyntax.prototype.kind = 186 /* FunctionExpression */;
    TypeScript.FunctionExpressionSyntax.prototype.childCount = 4;
    TypeScript.FunctionExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.functionKeyword;
            case 1: return this.identifier;
            case 2: return this.callSignature;
            case 3: return this.block;
        }
    };
    TypeScript.OmittedExpressionSyntax = function (data) {
        if (data) {
            this.__data = data;
        }
    };
    TypeScript.OmittedExpressionSyntax.prototype.kind = 187 /* OmittedExpression */;
    TypeScript.OmittedExpressionSyntax.prototype.childCount = 0;
    TypeScript.OmittedExpressionSyntax.prototype.childAt = function (index) {
        throw TypeScript.Errors.invalidOperation();
    };
    TypeScript.TemplateExpressionSyntax = function (data, templateStartToken, templateClauses) {
        if (data) {
            this.__data = data;
        }
        this.templateStartToken = templateStartToken, this.templateClauses = templateClauses, templateStartToken.parent = this, templateClauses.parent = this;
    };
    TypeScript.TemplateExpressionSyntax.prototype.kind = 188 /* TemplateExpression */;
    TypeScript.TemplateExpressionSyntax.prototype.childCount = 2;
    TypeScript.TemplateExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.templateStartToken;
            case 1: return this.templateClauses;
        }
    };
    TypeScript.TemplateAccessExpressionSyntax = function (data, expression, templateExpression) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.templateExpression = templateExpression, expression.parent = this, templateExpression.parent = this;
    };
    TypeScript.TemplateAccessExpressionSyntax.prototype.kind = 189 /* TemplateAccessExpression */;
    TypeScript.TemplateAccessExpressionSyntax.prototype.childCount = 2;
    TypeScript.TemplateAccessExpressionSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.templateExpression;
        }
    };
    TypeScript.VariableDeclarationSyntax = function (data, varKeyword, variableDeclarators) {
        if (data) {
            this.__data = data;
        }
        this.varKeyword = varKeyword, this.variableDeclarators = variableDeclarators, varKeyword.parent = this, variableDeclarators.parent = this;
    };
    TypeScript.VariableDeclarationSyntax.prototype.kind = 190 /* VariableDeclaration */;
    TypeScript.VariableDeclarationSyntax.prototype.childCount = 2;
    TypeScript.VariableDeclarationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.varKeyword;
            case 1: return this.variableDeclarators;
        }
    };
    TypeScript.VariableDeclaratorSyntax = function (data, propertyName, typeAnnotation, equalsValueClause) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, propertyName.parent = this, typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
    };
    TypeScript.VariableDeclaratorSyntax.prototype.kind = 191 /* VariableDeclarator */;
    TypeScript.VariableDeclaratorSyntax.prototype.childCount = 3;
    TypeScript.VariableDeclaratorSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.typeAnnotation;
            case 2: return this.equalsValueClause;
        }
    };
    TypeScript.ArgumentListSyntax = function (data, typeArgumentList, openParenToken, _arguments, closeParenToken) {
        if (data) {
            this.__data = data;
        }
        this.typeArgumentList = typeArgumentList, this.openParenToken = openParenToken, this.arguments = _arguments, this.closeParenToken = closeParenToken, typeArgumentList && (typeArgumentList.parent = this), openParenToken.parent = this, _arguments.parent = this, closeParenToken.parent = this;
    };
    TypeScript.ArgumentListSyntax.prototype.kind = 192 /* ArgumentList */;
    TypeScript.ArgumentListSyntax.prototype.childCount = 4;
    TypeScript.ArgumentListSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.typeArgumentList;
            case 1: return this.openParenToken;
            case 2: return this.arguments;
            case 3: return this.closeParenToken;
        }
    };
    TypeScript.ParameterListSyntax = function (data, openParenToken, parameters, closeParenToken) {
        if (data) {
            this.__data = data;
        }
        this.openParenToken = openParenToken, this.parameters = parameters, this.closeParenToken = closeParenToken, openParenToken.parent = this, parameters.parent = this, closeParenToken.parent = this;
    };
    TypeScript.ParameterListSyntax.prototype.kind = 193 /* ParameterList */;
    TypeScript.ParameterListSyntax.prototype.childCount = 3;
    TypeScript.ParameterListSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
        }
    };
    TypeScript.TypeArgumentListSyntax = function (data, lessThanToken, typeArguments, greaterThanToken) {
        if (data) {
            this.__data = data;
        }
        this.lessThanToken = lessThanToken, this.typeArguments = typeArguments, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, typeArguments.parent = this, greaterThanToken.parent = this;
    };
    TypeScript.TypeArgumentListSyntax.prototype.kind = 194 /* TypeArgumentList */;
    TypeScript.TypeArgumentListSyntax.prototype.childCount = 3;
    TypeScript.TypeArgumentListSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.lessThanToken;
            case 1: return this.typeArguments;
            case 2: return this.greaterThanToken;
        }
    };
    TypeScript.TypeParameterListSyntax = function (data, lessThanToken, typeParameters, greaterThanToken) {
        if (data) {
            this.__data = data;
        }
        this.lessThanToken = lessThanToken, this.typeParameters = typeParameters, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, typeParameters.parent = this, greaterThanToken.parent = this;
    };
    TypeScript.TypeParameterListSyntax.prototype.kind = 195 /* TypeParameterList */;
    TypeScript.TypeParameterListSyntax.prototype.childCount = 3;
    TypeScript.TypeParameterListSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.lessThanToken;
            case 1: return this.typeParameters;
            case 2: return this.greaterThanToken;
        }
    };
    TypeScript.HeritageClauseSyntax = function (data, extendsOrImplementsKeyword, typeNames) {
        if (data) {
            this.__data = data;
        }
        this.extendsOrImplementsKeyword = extendsOrImplementsKeyword, this.typeNames = typeNames, extendsOrImplementsKeyword.parent = this, typeNames.parent = this;
    };
    TypeScript.HeritageClauseSyntax.prototype.kind = 196 /* HeritageClause */;
    TypeScript.HeritageClauseSyntax.prototype.childCount = 2;
    TypeScript.HeritageClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.extendsOrImplementsKeyword;
            case 1: return this.typeNames;
        }
    };
    TypeScript.EqualsValueClauseSyntax = function (data, equalsToken, value) {
        if (data) {
            this.__data = data;
        }
        this.equalsToken = equalsToken, this.value = value, equalsToken.parent = this, value.parent = this;
    };
    TypeScript.EqualsValueClauseSyntax.prototype.kind = 197 /* EqualsValueClause */;
    TypeScript.EqualsValueClauseSyntax.prototype.childCount = 2;
    TypeScript.EqualsValueClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.equalsToken;
            case 1: return this.value;
        }
    };
    TypeScript.CaseSwitchClauseSyntax = function (data, caseKeyword, expression, colonToken, statements) {
        if (data) {
            this.__data = data;
        }
        this.caseKeyword = caseKeyword, this.expression = expression, this.colonToken = colonToken, this.statements = statements, caseKeyword.parent = this, expression.parent = this, colonToken.parent = this, statements.parent = this;
    };
    TypeScript.CaseSwitchClauseSyntax.prototype.kind = 198 /* CaseSwitchClause */;
    TypeScript.CaseSwitchClauseSyntax.prototype.childCount = 4;
    TypeScript.CaseSwitchClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.caseKeyword;
            case 1: return this.expression;
            case 2: return this.colonToken;
            case 3: return this.statements;
        }
    };
    TypeScript.DefaultSwitchClauseSyntax = function (data, defaultKeyword, colonToken, statements) {
        if (data) {
            this.__data = data;
        }
        this.defaultKeyword = defaultKeyword, this.colonToken = colonToken, this.statements = statements, defaultKeyword.parent = this, colonToken.parent = this, statements.parent = this;
    };
    TypeScript.DefaultSwitchClauseSyntax.prototype.kind = 199 /* DefaultSwitchClause */;
    TypeScript.DefaultSwitchClauseSyntax.prototype.childCount = 3;
    TypeScript.DefaultSwitchClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.defaultKeyword;
            case 1: return this.colonToken;
            case 2: return this.statements;
        }
    };
    TypeScript.ElseClauseSyntax = function (data, elseKeyword, statement) {
        if (data) {
            this.__data = data;
        }
        this.elseKeyword = elseKeyword, this.statement = statement, elseKeyword.parent = this, statement.parent = this;
    };
    TypeScript.ElseClauseSyntax.prototype.kind = 200 /* ElseClause */;
    TypeScript.ElseClauseSyntax.prototype.childCount = 2;
    TypeScript.ElseClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
        }
    };
    TypeScript.CatchClauseSyntax = function (data, catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
        if (data) {
            this.__data = data;
        }
        this.catchKeyword = catchKeyword, this.openParenToken = openParenToken, this.identifier = identifier, this.typeAnnotation = typeAnnotation, this.closeParenToken = closeParenToken, this.block = block, catchKeyword.parent = this, openParenToken.parent = this, identifier.parent = this, typeAnnotation && (typeAnnotation.parent = this), closeParenToken.parent = this, block.parent = this;
    };
    TypeScript.CatchClauseSyntax.prototype.kind = 201 /* CatchClause */;
    TypeScript.CatchClauseSyntax.prototype.childCount = 6;
    TypeScript.CatchClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.catchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.identifier;
            case 3: return this.typeAnnotation;
            case 4: return this.closeParenToken;
            case 5: return this.block;
        }
    };
    TypeScript.FinallyClauseSyntax = function (data, finallyKeyword, block) {
        if (data) {
            this.__data = data;
        }
        this.finallyKeyword = finallyKeyword, this.block = block, finallyKeyword.parent = this, block.parent = this;
    };
    TypeScript.FinallyClauseSyntax.prototype.kind = 202 /* FinallyClause */;
    TypeScript.FinallyClauseSyntax.prototype.childCount = 2;
    TypeScript.FinallyClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
        }
    };
    TypeScript.TemplateClauseSyntax = function (data, expression, templateMiddleOrEndToken) {
        if (data) {
            this.__data = data;
        }
        this.expression = expression, this.templateMiddleOrEndToken = templateMiddleOrEndToken, expression.parent = this, templateMiddleOrEndToken.parent = this;
    };
    TypeScript.TemplateClauseSyntax.prototype.kind = 203 /* TemplateClause */;
    TypeScript.TemplateClauseSyntax.prototype.childCount = 2;
    TypeScript.TemplateClauseSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.expression;
            case 1: return this.templateMiddleOrEndToken;
        }
    };
    TypeScript.TypeParameterSyntax = function (data, identifier, constraint) {
        if (data) {
            this.__data = data;
        }
        this.identifier = identifier, this.constraint = constraint, identifier.parent = this, constraint && (constraint.parent = this);
    };
    TypeScript.TypeParameterSyntax.prototype.kind = 204 /* TypeParameter */;
    TypeScript.TypeParameterSyntax.prototype.childCount = 2;
    TypeScript.TypeParameterSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.identifier;
            case 1: return this.constraint;
        }
    };
    TypeScript.ConstraintSyntax = function (data, extendsKeyword, typeOrExpression) {
        if (data) {
            this.__data = data;
        }
        this.extendsKeyword = extendsKeyword, this.typeOrExpression = typeOrExpression, extendsKeyword.parent = this, typeOrExpression.parent = this;
    };
    TypeScript.ConstraintSyntax.prototype.kind = 205 /* Constraint */;
    TypeScript.ConstraintSyntax.prototype.childCount = 2;
    TypeScript.ConstraintSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.extendsKeyword;
            case 1: return this.typeOrExpression;
        }
    };
    TypeScript.SimplePropertyAssignmentSyntax = function (data, propertyName, colonToken, expression) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.colonToken = colonToken, this.expression = expression, propertyName.parent = this, colonToken.parent = this, expression.parent = this;
    };
    TypeScript.SimplePropertyAssignmentSyntax.prototype.kind = 206 /* SimplePropertyAssignment */;
    TypeScript.SimplePropertyAssignmentSyntax.prototype.childCount = 3;
    TypeScript.SimplePropertyAssignmentSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.colonToken;
            case 2: return this.expression;
        }
    };
    TypeScript.FunctionPropertyAssignmentSyntax = function (data, propertyName, callSignature, block) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, propertyName.parent = this, callSignature.parent = this, block.parent = this;
    };
    TypeScript.FunctionPropertyAssignmentSyntax.prototype.kind = 207 /* FunctionPropertyAssignment */;
    TypeScript.FunctionPropertyAssignmentSyntax.prototype.childCount = 3;
    TypeScript.FunctionPropertyAssignmentSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.callSignature;
            case 2: return this.block;
        }
    };
    TypeScript.ParameterSyntax = function (data, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
        if (data) {
            this.__data = data;
        }
        this.dotDotDotToken = dotDotDotToken, this.modifiers = modifiers, this.identifier = identifier, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, dotDotDotToken && (dotDotDotToken.parent = this), modifiers.parent = this, identifier.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
    };
    TypeScript.ParameterSyntax.prototype.kind = 208 /* Parameter */;
    TypeScript.ParameterSyntax.prototype.childCount = 6;
    TypeScript.ParameterSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.dotDotDotToken;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.questionToken;
            case 4: return this.typeAnnotation;
            case 5: return this.equalsValueClause;
        }
    };
    TypeScript.EnumElementSyntax = function (data, propertyName, equalsValueClause) {
        if (data) {
            this.__data = data;
        }
        this.propertyName = propertyName, this.equalsValueClause = equalsValueClause, propertyName.parent = this, equalsValueClause && (equalsValueClause.parent = this);
    };
    TypeScript.EnumElementSyntax.prototype.kind = 209 /* EnumElement */;
    TypeScript.EnumElementSyntax.prototype.childCount = 2;
    TypeScript.EnumElementSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.propertyName;
            case 1: return this.equalsValueClause;
        }
    };
    TypeScript.TypeAnnotationSyntax = function (data, colonToken, type) {
        if (data) {
            this.__data = data;
        }
        this.colonToken = colonToken, this.type = type, colonToken.parent = this, type.parent = this;
    };
    TypeScript.TypeAnnotationSyntax.prototype.kind = 210 /* TypeAnnotation */;
    TypeScript.TypeAnnotationSyntax.prototype.childCount = 2;
    TypeScript.TypeAnnotationSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.colonToken;
            case 1: return this.type;
        }
    };
    TypeScript.ComputedPropertyNameSyntax = function (data, openBracketToken, expression, closeBracketToken) {
        if (data) {
            this.__data = data;
        }
        this.openBracketToken = openBracketToken, this.expression = expression, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, expression.parent = this, closeBracketToken.parent = this;
    };
    TypeScript.ComputedPropertyNameSyntax.prototype.kind = 211 /* ComputedPropertyName */;
    TypeScript.ComputedPropertyNameSyntax.prototype.childCount = 3;
    TypeScript.ComputedPropertyNameSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.openBracketToken;
            case 1: return this.expression;
            case 2: return this.closeBracketToken;
        }
    };
    TypeScript.ExternalModuleReferenceSyntax = function (data, requireKeyword, openParenToken, stringLiteral, closeParenToken) {
        if (data) {
            this.__data = data;
        }
        this.requireKeyword = requireKeyword, this.openParenToken = openParenToken, this.stringLiteral = stringLiteral, this.closeParenToken = closeParenToken, requireKeyword.parent = this, openParenToken.parent = this, stringLiteral.parent = this, closeParenToken.parent = this;
    };
    TypeScript.ExternalModuleReferenceSyntax.prototype.kind = 212 /* ExternalModuleReference */;
    TypeScript.ExternalModuleReferenceSyntax.prototype.childCount = 4;
    TypeScript.ExternalModuleReferenceSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.requireKeyword;
            case 1: return this.openParenToken;
            case 2: return this.stringLiteral;
            case 3: return this.closeParenToken;
        }
    };
    TypeScript.ModuleNameModuleReferenceSyntax = function (data, moduleName) {
        if (data) {
            this.__data = data;
        }
        this.moduleName = moduleName, moduleName.parent = this;
    };
    TypeScript.ModuleNameModuleReferenceSyntax.prototype.kind = 213 /* ModuleNameModuleReference */;
    TypeScript.ModuleNameModuleReferenceSyntax.prototype.childCount = 1;
    TypeScript.ModuleNameModuleReferenceSyntax.prototype.childAt = function (index) {
        switch (index) {
            case 0: return this.moduleName;
        }
    };
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    TypeScript.syntaxDiagnosticsTime = 0;
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, text, languageVersion) {
            this.text = text;
            this._allDiagnostics = undefined;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = text.lineMap();
            this._languageVersion = languageVersion;
            sourceUnit.syntaxTree = this;
        }
        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };
        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };
        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }
            // No parser reported diagnostics.  Check for any additional grammar diagnostics.
            var diagnostics = [];
            TypeScript.visitNodeOrToken(new GrammarCheckerWalker(this, diagnostics), this.sourceUnit());
            return diagnostics;
        };
        SyntaxTree.prototype.diagnostics = function () {
            if (!this._allDiagnostics) {
                var start = new Date().getTime();
                this._allDiagnostics = this.computeDiagnostics();
                TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            }
            return this._allDiagnostics;
        };
        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };
        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };
        SyntaxTree.prototype.languageVersion = function () {
            return this._languageVersion;
        };
        SyntaxTree.prototype.cacheSyntaxTreeInfo = function () {
            // If we're not keeping around the syntax tree, store the diagnostics and line
            // map so they don't have to be recomputed.
            var firstToken = firstSyntaxTreeToken(this);
            var leadingTrivia = firstToken.leadingTrivia(this.text);
            this._isExternalModule = !!externalModuleIndicatorSpanWorker(this, firstToken);
            var amdDependencies = [];
            for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        amdDependencies.push(amdDependency);
                    }
                }
            }
            this._amdDependencies = amdDependencies;
        };
        SyntaxTree.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : undefined;
        };
        SyntaxTree.prototype.isExternalModule = function () {
            // October 11, 2013
            // External modules are written as separate source files that contain at least one 
            // external import declaration, export assignment, or top-level exported declaration.
            if (this._isExternalModule === undefined) {
                // force the info about isExternalModule to get created.
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._isExternalModule !== undefined);
            }
            return this._isExternalModule;
        };
        SyntaxTree.prototype.amdDependencies = function () {
            if (this._amdDependencies === undefined) {
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._amdDependencies !== undefined);
            }
            return this._amdDependencies;
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;
    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.inObjectLiteralExpression = false;
            this.text = syntaxTree.text;
        }
        GrammarCheckerWalker.prototype.pushDiagnostic = function (element, diagnosticKey, args) {
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), this.syntaxTree.lineMap(), TypeScript.start(element, this.text), TypeScript.width(element), diagnosticKey, args));
        };
        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (this.checkForCatchClauseTypeAnnotation(node) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitCatchClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForCatchClauseTypeAnnotation = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(node.typeAnnotation.colonToken, TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var seenOptionalParameter = false;
            var parameterCount = TypeScript.nonSeparatorCount(node.parameters);
            for (var i = 0; i < parameterCount; i++) {
                var parameter = TypeScript.nonSeparatorAt(node.parameters, i);
                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return true;
                    }
                    if (parameter.questionToken) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_be_optional);
                        return true;
                    }
                    if (parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer);
                        return true;
                    }
                }
                else if (parameter.questionToken || parameter.equalsValueClause) {
                    seenOptionalParameter = true;
                    if (parameter.questionToken && parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                        return true;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter);
                        return true;
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            for (var i = 0, n = TypeScript.nonSeparatorCount(node.parameters); i < n; i++) {
                var parameter = TypeScript.nonSeparatorAt(node.parameters, i);
                if (this.checkParameterAccessibilityModifiers(node, parameter)) {
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifiers = function (parameterList, parameter) {
            if (parameter.modifiers.length > 0) {
                var modifiers = parameter.modifiers;
                for (var i = 0, n = modifiers.length; i < n; i++) {
                    var modifier = modifiers[i];
                    if (this.checkParameterAccessibilityModifier(parameterList, modifier, i)) {
                        return true;
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifier = function (parameterList, modifier, modifierIndex) {
            if (!TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind)) {
                this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_parameter, [modifier.text()]);
                return true;
            }
            else {
                if (modifierIndex > 0) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForTrailingComma = function (list) {
            // If we have at least one child, and we have an even number of children, then that 
            // means we have an illegal trailing separator.
            if (list.length === 0 || list.length % 2 === 1) {
                return false;
            }
            var child = list[list.length - 1];
            this.pushDiagnostic(child, TypeScript.DiagnosticCode.Trailing_comma_not_allowed);
            return true;
        };
        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (list, reportToken, listKind) {
            if (TypeScript.childCount(list) > 0) {
                return false;
            }
            this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode._0_list_cannot_be_empty, [listKind]);
            return true;
        };
        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingComma(node.parameters)) {
                return;
            }
            _super.prototype.visitParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingComma(node.typeNames) || this.checkForAtLeastOneElement(node.typeNames, node.extendsOrImplementsKeyword, TypeScript.SyntaxFacts.getText(node.extendsOrImplementsKeyword.kind))) {
                return;
            }
            _super.prototype.visitHeritageClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingComma(node.arguments)) {
                return;
            }
            _super.prototype.visitArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForAtLeastOneElement(node.variableDeclarators, node.varKeyword, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.variable_declaration, undefined)) || this.checkForTrailingComma(node.variableDeclarators)) {
                return;
            }
            _super.prototype.visitVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingComma(node.typeArguments) || this.checkForAtLeastOneElement(node.typeArguments, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_argument, undefined))) {
                return;
            }
            _super.prototype.visitTypeArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTupleType = function (node) {
            if (this.checkForTrailingComma(node.types) || this.checkForAtLeastOneElement(node.types, node.openBracketToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, undefined))) {
                return;
            }
            _super.prototype.visitTupleType.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingComma(node.typeParameters) || this.checkForAtLeastOneElement(node.typeParameters, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, undefined))) {
                return;
            }
            _super.prototype.visitTypeParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            if (node.parameters.length !== 1) {
                this.pushDiagnostic(node.openBracketToken, TypeScript.DiagnosticCode.Index_signature_must_have_exactly_one_parameter);
                return true;
            }
            var parameter = TypeScript.nonSeparatorAt(node.parameters, 0);
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            }
            else if (parameter.modifiers.length > 0) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            }
            else if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            }
            else if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            }
            else if (!parameter.typeAnnotation) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            }
            else if (parameter.typeAnnotation.type.kind !== 71 /* StringKeyword */ && parameter.typeAnnotation.type.kind !== 69 /* NumberKeyword */) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                return;
            }
            if (!node.typeAnnotation) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                return;
            }
            _super.prototype.visitIndexSignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses[i];
                if (heritageClause.extendsOrImplementsKeyword.kind === 50 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }
                    if (TypeScript.nonSeparatorCount(heritageClause.typeNames) > 1) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind === 53 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }
                    seenImplementsClause = true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                // If we're already in an ambient declaration, then 'declare' is not allowed.
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 65 /* DeclareKeyword */);
                if (declareToken) {
                    this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, reportToken, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                // We're at the top level in a declaration file, a 'declare' modifiers is required
                // on most module elements.
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 65 /* DeclareKeyword */)) {
                    this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
                    return true;
                }
            }
        };
        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;
            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses[i];
                if (heritageClause.extendsOrImplementsKeyword.kind === 50 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind === 53 /* ImplementsKeyword */);
                    this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (modifier.kind === 65 /* DeclareKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_interface_declaration);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                return;
            }
            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;
            for (var i = 0, n = list.length; i < n; i++) {
                var modifier = list[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind)) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }
                    if (seenStaticModifier) {
                        var previousToken = list[i - 1];
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }
                    seenAccessibilityModifier = true;
                }
                else if (modifier.kind === 60 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }
                    seenStaticModifier = true;
                }
                else {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }
            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitMethodSignature = function (node) {
            if (this.checkForDisallowedTemplatePropertyName(node.propertyName) || this.checkForDisallowedComputedPropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitMethodSignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitPropertySignature = function (node) {
            if (this.checkForDisallowedTemplatePropertyName(node.propertyName) || this.checkForDisallowedComputedPropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitPropertySignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkGetAccessorParameter = function (node) {
            if (node.callSignature.parameterList.parameters.length !== 0) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexMemberDeclaration = function (node) {
            if (this.checkIndexMemberModifiers(node)) {
                return;
            }
            _super.prototype.visitIndexMemberDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexMemberModifiers = function (node) {
            if (node.modifiers.length > 0) {
                this.pushDiagnostic(node.modifiers[0], TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (reportToken, languageVersion, diagnosticKey) {
            if (this.syntaxTree.languageVersion() < languageVersion) {
                this.pushDiagnostic(reportToken, diagnosticKey);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectLiteralExpression = function (node) {
            var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
            this.inObjectLiteralExpression = true;
            _super.prototype.visitObjectLiteralExpression.call(this, node);
            this.inObjectLiteralExpression = savedInObjectLiteralExpression;
        };
        GrammarCheckerWalker.prototype.visitGetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node.getKeyword, 1 /* ES5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkGetAccessorParameter(node) || this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitGetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedSetAccessorTypeAnnotation = function (accessor) {
            if (accessor.callSignature.typeAnnotation) {
                this.pushDiagnostic(accessor.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_set_accessor);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedAccessorTypeParameters = function (callSignature) {
            if (callSignature.typeParameterList) {
                this.pushDiagnostic(callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_an_accessor);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForAccessorDeclarationInAmbientContext = function (accessor) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic(accessor, TypeScript.DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkSetAccessorParameter = function (node) {
            var parameters = node.callSignature.parameterList.parameters;
            if (TypeScript.nonSeparatorCount(parameters) !== 1) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.set_accessor_must_have_exactly_one_parameter);
                return true;
            }
            var parameter = TypeScript.nonSeparatorAt(parameters, 0);
            if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }
            if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitSimplePropertyAssignment = function (node) {
            if (this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitSimplePropertyAssignment.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitSetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node.setKeyword, 1 /* ES5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkForDisallowedSetAccessorTypeAnnotation(node) || this.checkSetAccessorParameter(node) || this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitSetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var previousValueWasComputed = false;
            for (var i = 0, n = TypeScript.nonSeparatorCount(node.enumElements); i < n; i++) {
                var enumElement = TypeScript.nonSeparatorAt(node.enumElements, i);
                if (!enumElement.equalsValueClause && previousValueWasComputed) {
                    this.pushDiagnostic(enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer);
                    return true;
                }
                if (enumElement.equalsValueClause) {
                    var value = enumElement.equalsValueClause.value;
                    previousValueWasComputed = !TypeScript.Syntax.isIntegerLiteral(value);
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.checkForDisallowedTemplatePropertyName(node.propertyName) || this.checkForDisallowedComputedPropertyName(node.propertyName)) {
                return;
            }
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic(node.equalsValueClause.value, TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    return;
                }
            }
            _super.prototype.visitEnumElement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind === 52 /* SuperKeyword */ && node.argumentList.typeArgumentList) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }
            _super.prototype.visitInvocationExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var seenExportModifier = false;
            var seenDeclareModifier = false;
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind) || modifier.kind === 60 /* StaticKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }
                if (modifier.kind === 65 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }
                    seenDeclareModifier = true;
                }
                else if (modifier.kind === 49 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(49 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(65 /* DeclareKeyword */)]);
                        return;
                    }
                    seenExportModifier = true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (!node.stringLiteral) {
                for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                    var child = node.moduleElements[i];
                    if (child.kind === 138 /* ImportDeclaration */) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind === 212 /* ExternalModuleReference */) {
                            this.pushDiagnostic(importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                        }
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 65 /* DeclareKeyword */);
            if (declareToken) {
                this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_import_declaration);
                return true;
            }
        };
        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }
            _super.prototype.visitImportDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.stringLiteral ? node.stringLiteral : TypeScript.firstToken(node.name), node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node)) {
                return;
            }
            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */)) {
                    this.pushDiagnostic(node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    return;
                }
            }
            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var child = node.moduleElements[i];
                if (child.kind === 139 /* ExportAssignment */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.checkForBlockInAmbientContext(node)) {
                return;
            }
            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };
        GrammarCheckerWalker.prototype.checkForBlockInAmbientContext = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                // Provide a specialized message for a block as a statement versus the block as a 
                // function body.
                if (node.parent.kind === 1 /* List */) {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                }
                else {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.A_function_implementation_cannot_be_declared_in_an_ambient_context);
                }
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkBreakStatementTarget(node)) {
                return;
            }
            _super.prototype.visitBreakStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkContinueStatementTarget(node)) {
                return;
            }
            _super.prototype.visitContinueStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkBreakStatementTarget = function (node) {
            // Invalid break statements are considered syntax errors in ES5.
            // Note: the order here is important.  If the 'break' has a target, then it can jump to
            // any enclosing laballed statment.  If it has no target, it must be in an iteration or
            // swtich statement.
            if (node.identifier) {
                var breakableLabels = this.getEnclosingLabels(node, true, false);
                if (!TypeScript.ArrayUtilities.any(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var breakableLabels = this.getEnclosingLabels(node, true, true);
                    if (TypeScript.ArrayUtilities.any(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    }
                    else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                    return true;
                }
            }
            else if (!this.inIterationStatement(node, false) && !this.inSwitchStatement(node)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                }
                else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                }
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.inSwitchStatement = function (ast) {
            while (ast) {
                if (ast.kind === 156 /* SwitchStatement */) {
                    return true;
                }
                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.isIterationStatement = function (ast) {
            switch (ast.kind) {
                case 159 /* ForStatement */:
                case 160 /* ForInStatement */:
                case 163 /* WhileStatement */:
                case 166 /* DoStatement */:
                    return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.inIterationStatement = function (element, crossFunctions) {
            while (element) {
                if (this.isIterationStatement(element)) {
                    return true;
                }
                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }
                element = element.parent;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.getEnclosingLabels = function (element, breakable, crossFunctions) {
            var result = [];
            element = element.parent;
            while (element) {
                if (element.kind === 165 /* LabeledStatement */) {
                    var labeledStatement = element;
                    if (breakable) {
                        // Breakable labels can be placed on any construct
                        result.push(labeledStatement);
                    }
                    else {
                        // They're asking for continuable labels.  Continuable labels must be on
                        // a loop construct.
                        if (this.labelIsOnContinuableConstruct(labeledStatement.statement)) {
                            result.push(labeledStatement);
                        }
                    }
                }
                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    break;
                }
                element = element.parent;
            }
            return result;
        };
        GrammarCheckerWalker.prototype.labelIsOnContinuableConstruct = function (statement) {
            switch (statement.kind) {
                case 165 /* LabeledStatement */:
                    // Labels work transitively.  i.e. if you have:
                    //      foo:
                    //      bar:
                    //      while(...)
                    //
                    // Then both 'foo' and 'bar' are in the label set for 'while' and are thus
                    // continuable.
                    return this.labelIsOnContinuableConstruct(statement.statement);
                case 163 /* WhileStatement */:
                case 159 /* ForStatement */:
                case 160 /* ForInStatement */:
                case 166 /* DoStatement */:
                    return true;
                default:
                    return false;
            }
        };
        GrammarCheckerWalker.prototype.checkContinueStatementTarget = function (node) {
            // Invalid continue statements are considered syntax errors in ES5.
            if (!this.inIterationStatement(node, false)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                }
                else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                }
                return true;
            }
            else if (node.identifier) {
                var continuableLabels = this.getEnclosingLabels(node, false, false);
                if (!TypeScript.ArrayUtilities.any(continuableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var continuableLabels = this.getEnclosingLabels(node, false, true);
                    if (TypeScript.ArrayUtilities.any(continuableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    }
                    else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitDebuggerStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitDoStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitEmptyStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitExpressionStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInStatementVariableDeclaration(node) || this.checkForInLeftHandSideExpression(node)) {
                return;
            }
            _super.prototype.visitForInStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForInLeftHandSideExpression = function (node) {
            if (node.left && !TypeScript.SyntaxUtilities.isLeftHandSizeExpression(node.left)) {
                this.pushDiagnostic(node.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_in_for_in_statement);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForInStatementVariableDeclaration = function (node) {
            // The parser accepts a Variable Declaration in a ForInStatement, but the grammar only
            // allows a very restricted form.  Specifically, there must be only a single Variable
            // Declarator in the Declaration.
            if (node.variableDeclaration && node.variableDeclaration.variableDeclarators.length > 1) {
                this.pushDiagnostic(node.variableDeclaration, TypeScript.DiagnosticCode.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitForStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitIfStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInvalidLabelIdentifier(node)) {
                return;
            }
            _super.prototype.visitLabeledStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForInvalidLabelIdentifier = function (node) {
            // Invalid break statements are considered syntax errors in ES5.
            // Note that break/continue are treated differently.  ES5 says this about a break statement:
            // A program is considered syntactically incorrect if ...:
            //
            // The program contains a break statement with the optional Identifier, where Identifier 
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **Statement.**
            // 
            // However, it says this about continue statements:
            //
            // The program contains a continue statement with the optional Identifier, where Identifier
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **IterationStatement.**
            // In other words, you can 'break' to any enclosing statement.  But you can only 'continue'
            // to an enclosing *iteration* statement.
            var labelIdentifier = TypeScript.tokenValueText(node.identifier);
            var breakableLabels = this.getEnclosingLabels(node, true, false);
            // It is invalid to have a label enclosed in a label of the same name.
            var matchingLabel = TypeScript.ArrayUtilities.firstOrDefault(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === labelIdentifier; });
            if (matchingLabel) {
                this.pushDiagnostic(node.identifier, TypeScript.DiagnosticCode.Duplicate_identifier_0, [labelIdentifier]);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForReturnStatementNotInFunctionBody(node)) {
                return;
            }
            _super.prototype.visitReturnStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForReturnStatementNotInFunctionBody = function (node) {
            for (var element = node; element; element = element.parent) {
                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }
            }
            this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.return_statement_must_be_contained_within_a_function_body);
            return true;
        };
        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitSwitchStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitThrowStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitTryStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitWhileStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForWithInStrictMode(node)) {
                return;
            }
            _super.prototype.visitWithStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForWithInStrictMode = function (node) {
            if (TypeScript.parsedInStrictMode(node)) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.with_statements_are_not_allowed_in_strict_mode);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (modifiers) {
            if (this.inBlock || this.inObjectLiteralExpression) {
                if (modifiers.length > 0) {
                    this.pushDiagnostic(modifiers[0], TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionExpression = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitFunctionExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            if (this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitFunctionPropertyAssignment.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration.varKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 65 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkListSeparators = function (list, kind) {
            for (var i = 0, n = TypeScript.separatorCount(list); i < n; i++) {
                var child = TypeScript.separatorAt(list, i);
                if (child.kind !== kind) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node.typeMembers, 80 /* SemicolonToken */)) {
                return;
            }
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.checkVariableDeclaratorInitializer(node) || this.checkVariableDeclaratorIdentifier(node) || this.checkForDisallowedTemplatePropertyName(node.propertyName)) {
                return;
            }
            _super.prototype.visitVariableDeclarator.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedTemplatePropertyName = function (propertyName) {
            if (propertyName.kind === 13 /* NoSubstitutionTemplateToken */) {
                this.pushDiagnostic(propertyName, TypeScript.DiagnosticCode.Template_literal_cannot_be_used_as_an_element_name);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedComputedPropertyName = function (propertyName) {
            if (propertyName.kind === 211 /* ComputedPropertyName */) {
                this.pushDiagnostic(propertyName, TypeScript.DiagnosticCode.Computed_property_names_cannot_be_used_here);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkVariableDeclaratorIdentifier = function (node) {
            if (node.parent.kind !== 141 /* MemberVariableDeclaration */) {
                TypeScript.Debug.assert(TypeScript.isToken(node.propertyName), "A normal variable declarator must always have a token for a name.");
                if (this.checkForDisallowedEvalOrArguments(node, node.propertyName)) {
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkVariableDeclaratorInitializer = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic(TypeScript.firstToken(node.equalsValueClause.value), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkConstructorModifiers(node.modifiers) || this.checkConstructorTypeParameterList(node) || this.checkConstructorTypeAnnotation(node)) {
                return;
            }
            _super.prototype.visitConstructorDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkConstructorModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var child = modifiers[i];
                if (child.kind !== 59 /* PublicKeyword */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_constructor_declaration, [TypeScript.SyntaxFacts.getText(child.kind)]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkConstructorTypeParameterList = function (node) {
            if (node.callSignature.typeParameterList) {
                this.pushDiagnostic(node.callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkConstructorTypeAnnotation = function (node) {
            if (node.callSignature.typeAnnotation) {
                this.pushDiagnostic(node.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBinaryExpression = function (node) {
            if (this.checkIllegalAssignment(node)) {
                return;
            }
            _super.prototype.visitBinaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitPrefixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isPreIncrementOrDecrementExpression(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }
            _super.prototype.visitPrefixUnaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitPostfixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }
            _super.prototype.visitPostfixUnaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitParameter = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitParameter.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedEvalOrArguments = function (node, token) {
            if (token) {
                if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(token)) {
                    this.pushDiagnostic(token, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(token)]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.isPreIncrementOrDecrementExpression = function (node) {
            switch (node.operatorToken.kind) {
                case 96 /* MinusMinusToken */:
                case 95 /* PlusPlusToken */:
                    return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitDeleteExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && node.expression.kind === 9 /* IdentifierName */) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                return;
            }
            _super.prototype.visitDeleteExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIllegalAssignment = function (node) {
            if (TypeScript.parsedInStrictMode(node) && TypeScript.SyntaxFacts.isAssignmentOperatorToken(node.operatorToken.kind) && this.isEvalOrArguments(node.left)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.left)]);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.getEvalOrArguments = function (expr) {
            if (expr.kind === 9 /* IdentifierName */) {
                var text = TypeScript.tokenValueText(expr);
                if (text === "eval" || text === "arguments") {
                    return text;
                }
            }
            return undefined;
        };
        GrammarCheckerWalker.prototype.isEvalOrArguments = function (expr) {
            return !!this.getEvalOrArguments(expr);
        };
        GrammarCheckerWalker.prototype.visitConstraint = function (node) {
            if (this.checkConstraintType(node)) {
                return;
            }
            _super.prototype.visitConstraint.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkConstraintType = function (node) {
            if (!TypeScript.SyntaxFacts.isType(node.typeOrExpression.kind)) {
                this.pushDiagnostic(node.typeOrExpression, TypeScript.DiagnosticCode.Type_expected);
                return true;
            }
            return false;
        };
        return GrammarCheckerWalker;
    })(TypeScript.SyntaxWalker);
    function firstSyntaxTreeToken(syntaxTree) {
        // We don't just access the firstToken of the tree here as the tree may be abstract and may
        // not have a firstToken in it.
        var scanner = TypeScript.Scanner.createScanner(syntaxTree.languageVersion(), syntaxTree.text, function () {
        });
        return scanner.scan(false);
    }
    function externalModuleIndicatorSpan(syntaxTree) {
        var firstToken = firstSyntaxTreeToken(syntaxTree);
        return externalModuleIndicatorSpanWorker(syntaxTree, firstToken);
    }
    TypeScript.externalModuleIndicatorSpan = externalModuleIndicatorSpan;
    function externalModuleIndicatorSpanWorker(syntaxTree, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia(syntaxTree.text);
        return implicitImportSpan(leadingTrivia) || topLevelImportOrExportSpan(syntaxTree.sourceUnit());
    }
    TypeScript.externalModuleIndicatorSpanWorker = externalModuleIndicatorSpanWorker;
    function implicitImportSpan(sourceUnitLeadingTrivia) {
        for (var i = 0, n = sourceUnitLeadingTrivia.count(); i < n; i++) {
            var trivia = sourceUnitLeadingTrivia.syntaxTriviaAt(i);
            if (trivia.isComment()) {
                var span = implicitImportSpanWorker(trivia);
                if (span) {
                    return span;
                }
            }
        }
        return undefined;
    }
    function implicitImportSpanWorker(trivia) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(trivia.fullText());
        if (match) {
            return new TypeScript.TextSpan(trivia.fullStart(), trivia.fullWidth());
        }
        return undefined;
    }
    function topLevelImportOrExportSpan(node) {
        for (var i = 0, n = node.moduleElements.length; i < n; i++) {
            var moduleElement = node.moduleElements[i];
            var _firstToken = TypeScript.firstToken(moduleElement);
            if (_firstToken && _firstToken.kind === 49 /* ExportKeyword */) {
                return new TypeScript.TextSpan(TypeScript.start(_firstToken), TypeScript.width(_firstToken));
            }
            if (moduleElement.kind === 138 /* ImportDeclaration */) {
                var importDecl = moduleElement;
                if (importDecl.moduleReference.kind === 212 /* ExternalModuleReference */) {
                    var literal = importDecl.moduleReference.stringLiteral;
                    return new TypeScript.TextSpan(TypeScript.start(literal), TypeScript.width(literal));
                }
            }
        }
        return undefined;
    }
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            // Bail out quickly if it couldn't possibly be in the map.
            if (code < map[0]) {
                return false;
            }
            // Perform binary search in one of the unicode range maps
            var lo = 0;
            var hi = map.length;
            var mid;
            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                // mid has to be even to catch a range's beginning
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }
                if (code < map[mid]) {
                    hi = mid;
                }
                else {
                    lo = mid + 2;
                }
            }
            return false;
        };
        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* ES3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            }
            else if (languageVersion >= 1 /* ES5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* ES3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            }
            else if (languageVersion >= 1 /* ES5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        /*
            As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
            IdentifierStart ::
                Can contain Unicode 3.0.0  categories:
                “Uppercase letter (Lu)”,
                “Lowercase letter (Ll)”,
                “Titlecase letter (Lt)”,
                “Modifier letter (Lm)”,
                “Other letter (Lo)”, or
                “Letter number (Nl)”.
            IdentifierPart :: =
                Can contain IdentifierStart + Unicode 3.0.0  categories:
                “Non-spacing mark (Mn)”,
                “Combining spacing mark (Mc)”,
                “Decimal number (Nd)”, or
                “Connector punctuation (Pc)”.

            Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
            http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
        */
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        /*
            As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
            IdentifierStart ::
                Can contain Unicode 6.2  categories:
                “Uppercase letter (Lu)”,
                “Lowercase letter (Ll)”,
                “Titlecase letter (Lt)”,
                “Modifier letter (Lm)”,
                “Other letter (Lo)”, or
                “Letter number (Nl)”.
            IdentifierPart ::
                Can contain IdentifierStart + Unicode 6.2  categories:
                “Non-spacing mark (Mn)”,
                “Combining spacing mark (Mc)”,
                “Decimal number (Nd)”,
                “Connector punctuation (Pc)”,
                <ZWNJ>, or
                <ZWJ>.

            Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
            http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
        */
        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
///<reference path='..\text\references.ts' />
///<reference path="references.ts" />
var TypeScript;
(function (TypeScript) {
    var IncrementalParser;
    (function (IncrementalParser) {
        // Parser source used in incremental scenarios. This parser source wraps an old tree, text 
        // change and new text, and uses all three to provide nodes and tokens to the parser.  In
        // general, nodes from the old tree are returned as long as they do not intersect with the text 
        // change.  Then, once the text change is reached, tokens from the old tree are returned as 
        // long as they do not intersect with the text change.  Then, the text that is actually changed
        // will be scanned using a normal scanner.  Then, once the new text is scanned, the source will
        // attempt to sync back up with nodes or tokens that started where the new tokens end. Once it
        // can do that, then all subsequent data will come from the original tree.
        //
        // This allows for an enormous amount of tree reuse in common scenarios.  Situations that 
        // prevent this level of reuse include substantially destructive operations like introducing
        // "/*" without a "*/" nearby to terminate the comment.
        function createParserSource(oldSyntaxTree, textChangeRange, text) {
            var fileName = oldSyntaxTree.fileName();
            var languageVersion = oldSyntaxTree.languageVersion();
            // The underlying source that we will use to scan tokens from any new text, or any tokens 
            // from the old tree that we decide we can't use for any reason.  We will also continue 
            // scanning tokens from this source until we've decided that we're resynchronized and can
            // read in subsequent data from the old tree.
            //
            // This parser source also keeps track of the absolute position in the text that we're in,
            // and any token diagnostics produced.  That way we dont' have to track that ourselves.
            var _scannerParserSource;
            // The range of text in the *original* text that was changed, and the new length of it after
            // the change.
            var _changeRange;
            // Cached value of _changeRange.newSpan().  Cached for performance.
            var _changeRangeNewSpan;
            // This number represents how our position in the old tree relates to the position we're 
            // pointing at in the new text.  If it is 0 then our positions are in sync and we can read
            // nodes or tokens from the old tree.  If it is non-zero, then our positions are not in 
            // sync and we cannot use nodes or tokens from the old tree.
            //
            // Now, changeDelta could be negative or positive.  Negative means 'the position we're at
            // in the original tree is behind the position we're at in the text'.  In this case we 
            // keep throwing out old nodes or tokens (and thus move forward in the original tree) until
            // changeDelta becomes 0 again or positive.  If it becomes 0 then we are resynched and can
            // read nodes or tokesn from the tree.
            //
            // If changeDelta is positive, that means the current node or token we're pointing at in 
            // the old tree is at a further ahead position than the position we're pointing at in the
            // new text.  In this case we have no choice but to scan tokens from teh new text.  We will
            // continue to do so until, again, changeDelta becomes 0 and we've resynced, or change delta
            // becomes negative and we need to skip nodes or tokes in the original tree.
            var _changeDelta = 0;
            // The cursor we use to navigate through and retrieve nodes and tokens from the old tree.
            var _oldSourceUnitCursor = getSyntaxCursor();
            var oldSourceUnit = oldSyntaxTree.sourceUnit();
            var _outstandingRewindPointCount = 0;
            // Start the cursor pointing at the first element in the source unit (if it exists).
            if (oldSourceUnit.moduleElements.length > 0) {
                _oldSourceUnitCursor.pushElement(TypeScript.childAt(oldSourceUnit.moduleElements, 0), 0);
            }
            // In general supporting multiple individual edits is just not that important.  So we 
            // just collapse this all down to a single range to make the code here easier.  The only
            // time this could be problematic would be if the user made a ton of discontinuous edits.
            // For example, doing a column select on a *large* section of a code.  If this is a 
            // problem, we can always update this code to handle multiple changes.
            _changeRange = extendToAffectedRange(textChangeRange, oldSourceUnit);
            _changeRangeNewSpan = _changeRange.newSpan();
            // The old tree's length, plus whatever length change was caused by the edit
            // Had better equal the new text's length!
            if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                TypeScript.Debug.assert((TypeScript.fullWidth(oldSourceUnit) - _changeRange.span().length() + _changeRange.newLength()) === text.length());
            }
            // Set up a scanner so that we can scan tokens out of the new text.
            _scannerParserSource = TypeScript.Scanner.createParserSource(oldSyntaxTree.fileName(), text, oldSyntaxTree.languageVersion());
            function release() {
                _scannerParserSource.release();
                _scannerParserSource = undefined;
                _oldSourceUnitCursor = undefined;
                _outstandingRewindPointCount = 0;
            }
            function extendToAffectedRange(changeRange, sourceUnit) {
                // Consider the following code:
                //      void foo() { /; }
                //
                // If the text changes with an insertion of / just before the semicolon then we end up with:
                //      void foo() { //; }
                //
                // If we were to just use the changeRange a is, then we would not rescan the { token 
                // (as it does not intersect the actual original change range).  Because an edit may
                // change the token touching it, we actually need to look back *at least* one token so
                // that the prior token sees that change.  
                //
                // Note: i believe (outside of regex tokens) max lookahead is just one token for 
                // TypeScript.  However, if this turns out to be wrong, we may have to increase how much
                // futher we look back. 
                //
                // Note: lookahead handling for regex characters is handled specially in during 
                // incremental parsing, and does not need to be handled here.
                var maxLookahead = 1;
                var start = changeRange.span().start();
                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = TypeScript.findToken(sourceUnit, start);
                    // Debug.assert(token.kind !== SyntaxKind.None);
                    // Debug.assert(token.kind() === SyntaxKind.EndOfFileToken || token.fullWidth() > 0);
                    var position = token.fullStart();
                    start = Math.max(0, position - 1);
                }
                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);
                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            }
            function absolutePosition() {
                return _scannerParserSource.absolutePosition();
            }
            function tokenDiagnostics() {
                return _scannerParserSource.tokenDiagnostics();
            }
            function getRewindPoint() {
                // Get a rewind point for our new text reader and for our old source unit cursor.
                var rewindPoint = _scannerParserSource.getRewindPoint();
                // Clone our cursor.  That way we can restore to that point if hte parser needs to rewind.
                var oldSourceUnitCursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);
                // Store where we were when the rewind point was created.
                rewindPoint.changeDelta = _changeDelta;
                rewindPoint.changeRange = _changeRange;
                rewindPoint.oldSourceUnitCursor = _oldSourceUnitCursor;
                _oldSourceUnitCursor = oldSourceUnitCursorClone;
                // Debug.assert(rewindPoint.pinCount === _oldSourceUnitCursor.pinCount());
                _outstandingRewindPointCount++;
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                // Restore our state to the values when the rewind point was created.
                _changeRange = rewindPoint.changeRange;
                _changeDelta = rewindPoint.changeDelta;
                // Reset the cursor to what it was when we got the rewind point.  Make sure to return 
                // our existing cursor to the pool so it can be reused.
                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = rewindPoint.oldSourceUnitCursor;
                // Null out the cursor that the rewind point points to.  This way we don't try
                // to return it in 'releaseRewindPoint'.
                rewindPoint.oldSourceUnitCursor = undefined;
                _scannerParserSource.rewind(rewindPoint);
            }
            function releaseRewindPoint(rewindPoint) {
                if (rewindPoint.oldSourceUnitCursor) {
                    returnSyntaxCursor(rewindPoint.oldSourceUnitCursor);
                }
                _scannerParserSource.releaseRewindPoint(rewindPoint);
                _outstandingRewindPointCount--;
                TypeScript.Debug.assert(_outstandingRewindPointCount >= 0);
            }
            function isPinned() {
                return _outstandingRewindPointCount > 0;
            }
            function canReadFromOldSourceUnit() {
                // If we're currently pinned, then do not want to touch the cursor.  Here's why.  First,
                // recall that we're 'pinned' when we're speculatively parsing.  So say we were to allow
                // returning old nodes/tokens while speculatively parsing. Then, the parser might start
                // mutating the nodes and tokens we returned (i.e. by setting their parents).   Then, 
                // when we rewound, those nodes and tokens would still have those updated parents.  
                // Parents which we just decided we did *not* want to parse (hence why we rewound).  For
                // Example, say we have something like:
                //
                //          var v = f<a,b,c>e;  // note: this is not generic.
                //
                // When incrementally parsing, we will need to speculatively parse to determine if the
                // above is generic.  This will cause us to reuse the "a, b, c" tokens, and set their 
                // parent to a new type argument list.  A type argument list we will then throw away once
                // we decide that it isn't actually generic.  We will have now 'broken' the original tree.
                //
                // As such, the rule is simple.  We only return nodes/tokens from teh original tree if
                // we know the parser will accept and consume them and never rewind back before them.
                if (isPinned()) {
                    return false;
                }
                // If our current absolute position is in the middle of the changed range in the new text
                // then we definitely can't read from the old source unit right now.
                if (_changeRange && _changeRangeNewSpan.intersectsWithPosition(absolutePosition())) {
                    return false;
                }
                // First, try to sync up with the new text if we're behind.
                syncCursorToNewTextIfBehind();
                // Now, if we're synced up *and* we're not currently pinned in the new text scanner,
                // then we can read a node from the cursor.  If we're pinned in the scanner then we
                // can't read a node from the cursor because we will mess up the pinned scanner when
                // we try to move it forward past this node.
                return _changeDelta === 0 && !_oldSourceUnitCursor.isFinished();
            }
            function updateTokenPosition(token) {
                // If we got a node or token, and we're past the range of edited text, then walk its
                // constituent tokens, making sure all their positions are correct.  We don't need to
                // do this for the tokens before the edited range (since their positions couldn't have 
                // been affected by the edit), and we don't need to do this for the tokens in the 
                // edited range, as their positions will be correct when the underlying parser source 
                // creates them.
                if (isPastChangeRange()) {
                    token.setFullStart(absolutePosition());
                }
            }
            function updateNodePosition(node) {
                // If we got a node or token, and we're past the range of edited text, then walk its
                // constituent tokens, making sure all their positions are correct.  We don't need to
                // do this for the tokens before the edited range (since their positions couldn't have 
                // been affected by the edit), and we don't need to do this for the tokens in the 
                // edited range, as their positions will be correct when the underlying parser source 
                // creates them.
                if (isPastChangeRange()) {
                    var position = absolutePosition();
                    var tokens = getTokens(node);
                    for (var i = 0, n = tokens.length; i < n; i++) {
                        var token = tokens[i];
                        token.setFullStart(position);
                        position += token.fullWidth();
                    }
                }
            }
            function getTokens(node) {
                var tokens = node.__cachedTokens;
                if (!tokens) {
                    tokens = [];
                    tokenCollectorWalker.tokens = tokens;
                    TypeScript.visitNodeOrToken(tokenCollectorWalker, node);
                    node.__cachedTokens = tokens;
                    tokenCollectorWalker.tokens = undefined;
                }
                return tokens;
            }
            function currentNode() {
                if (canReadFromOldSourceUnit()) {
                    // Try to read a node.  If we can't then our caller will call back in and just try
                    // to get a token.
                    var node = tryGetNodeFromOldSourceUnit();
                    if (node) {
                        // Make sure the positions for the tokens in this node are correct.
                        updateNodePosition(node);
                        return node;
                    }
                }
                // Either we were ahead of the old text, or we were pinned.  No node can be read here.
                return undefined;
            }
            function currentToken() {
                if (canReadFromOldSourceUnit()) {
                    var token = tryGetTokenFromOldSourceUnit();
                    if (token) {
                        // Make sure the token's position/text is correct.
                        updateTokenPosition(token);
                        return token;
                    }
                }
                // Either we couldn't read from the old source unit, or we weren't able to successfully
                // get a token from it.  In this case we need to read a token from the underlying text.
                return _scannerParserSource.currentToken();
            }
            function currentContextualToken() {
                // Just delegate to the underlying source to handle 
                return _scannerParserSource.currentContextualToken();
            }
            function syncCursorToNewTextIfBehind() {
                while (true) {
                    if (_oldSourceUnitCursor.isFinished()) {
                        break;
                    }
                    if (_changeDelta >= 0) {
                        break;
                    }
                    // We're behind in the original tree.  Throw out a node or token in an attempt to 
                    // catch up to the position we're at in the new text.
                    var currentNodeOrToken = _oldSourceUnitCursor.currentNodeOrToken();
                    // If we're pointing at a node, and that node's width is less than our delta,
                    // then we can just skip that node.  Otherwise, if we're pointing at a node
                    // whose width is greater than the delta, then crumble it and try again.
                    // Otherwise, we must be pointing at a token.  Just skip it and try again.
                    if (TypeScript.isNode(currentNodeOrToken) && (TypeScript.fullWidth(currentNodeOrToken) > Math.abs(_changeDelta))) {
                        // We were pointing at a node whose width was more than changeDelta.  Crumble the 
                        // node and try again.  Note: we haven't changed changeDelta.  So the callers loop
                        // will just repeat this until we get to a node or token that we can skip over.
                        _oldSourceUnitCursor.moveToFirstChild();
                    }
                    else {
                        _oldSourceUnitCursor.moveToNextSibling();
                        // Get our change delta closer to 0 as we skip past this item.
                        _changeDelta += TypeScript.fullWidth(currentNodeOrToken);
                    }
                }
                // At this point, we must be either:
                //   a) done with the cursor
                //   b) (ideally) caught up to the new text position.
                //   c) ahead of the new text position.
                // In case 'b' we can try to reuse a node from teh old tree.
                // Debug.assert(_oldSourceUnitCursor.isFinished() || _changeDelta >= 0);
            }
            function intersectsWithChangeRangeSpanInOriginalText(start, length) {
                return !isPastChangeRange() && _changeRange.span().intersectsWith(start, length);
            }
            function tryGetNodeFromOldSourceUnit() {
                // Debug.assert(canReadFromOldSourceUnit());
                while (true) {
                    var node = _oldSourceUnitCursor.currentNode();
                    if (node === undefined) {
                        // Couldn't even read a node, nothing to return.
                        return undefined;
                    }
                    if (!intersectsWithChangeRangeSpanInOriginalText(absolutePosition(), TypeScript.fullWidth(node))) {
                        // Didn't intersect with the change range.
                        var isIncrementallyUnusuable = TypeScript.isIncrementallyUnusable(node);
                        if (!isIncrementallyUnusuable) {
                            // Didn't contain anything that would make it unusable.  Awesome.  This is
                            // a node we can reuse.
                            return node;
                        }
                    }
                    // We couldn't use currentNode. Try to move to its first child (in case that's a 
                    // node).  If it is we can try using that.  Otherwise we'll just bail out in the
                    // next iteration of the loop.
                    _oldSourceUnitCursor.moveToFirstChild();
                }
            }
            function canReuseTokenFromOldSourceUnit(position, token) {
                // A token is safe to return if:
                //  a) it does not intersect the changed text.
                //  b) it does not contain skipped text.
                //  c) it is not zero width.
                //  d) it is not a contextual parser token.
                //
                // NOTE: It is safe to get a token regardless of what our strict context was/is.  That's 
                // because the strict context doesn't change what tokens are scanned, only how the 
                // parser reacts to them.
                //
                // NOTE: we don't mark a keyword that was converted to an identifier as 'incrementally 
                // unusable.  This is because we don't want to mark it's containing parent node as 
                // unusable.  i.e. if i have this:  "public Foo(string: Type) { }", then that *entire* node 
                // is reusuable even though "string" was converted to an identifier.  However, we still
                // need to make sure that if that the parser asks for a *token* we don't return it.  
                // Converted identifiers can't ever be created by the scanner, and as such, should not 
                // be returned by this source.
                if (token) {
                    if (!intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        // Didn't intersect with the change range.
                        if (!token.isIncrementallyUnusable() && !TypeScript.Scanner.isContextualToken(token)) {
                            // Didn't contain anything that would make it unusable.  Awesome.  This is
                            // a token we can reuse.
                            return true;
                        }
                    }
                }
                return false;
            }
            function tryGetTokenFromOldSourceUnit() {
                // Debug.assert(canReadFromOldSourceUnit());
                // get the current token that the cursor is pointing at.
                var token = _oldSourceUnitCursor.currentToken();
                return canReuseTokenFromOldSourceUnit(absolutePosition(), token) ? token : undefined;
            }
            function peekToken(n) {
                if (canReadFromOldSourceUnit()) {
                    var token = tryPeekTokenFromOldSourceUnit(n);
                    if (token) {
                        return token;
                    }
                }
                // Couldn't peek this far in the old tree.  Get the token from the new text.
                return _scannerParserSource.peekToken(n);
            }
            function tryPeekTokenFromOldSourceUnit(n) {
                // Debug.assert(canReadFromOldSourceUnit());
                // clone the existing cursor so we can move it forward and then restore ourselves back
                // to where we started from.
                var cursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);
                var token = tryPeekTokenFromOldSourceUnitWorker(n);
                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = cursorClone;
                return token;
            }
            function tryPeekTokenFromOldSourceUnitWorker(n) {
                // In order to peek the 'nth' token we need all the tokens up to that point.  That way
                // we know we know position that the nth token is at.  The position is necessary so 
                // that we can test if this token (or any that precede it cross the change range).
                var currentPosition = absolutePosition();
                // First, make sure the cursor is pointing at a token.
                _oldSourceUnitCursor.moveToFirstToken();
                for (var i = 0; i < n; i++) {
                    var interimToken = _oldSourceUnitCursor.currentToken();
                    if (!canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return undefined;
                    }
                    currentPosition += interimToken.fullWidth();
                    _oldSourceUnitCursor.moveToNextSibling();
                }
                var token = _oldSourceUnitCursor.currentToken();
                return canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : undefined;
            }
            function consumeNode(node) {
                // A node could have only come from the old source unit cursor.  Update it and our 
                // current state.
                // Debug.assert(_changeDelta === 0);
                // Debug.assert(currentNode() === node);
                _oldSourceUnitCursor.moveToNextSibling();
                // Update the underlying source with where it should now be currently pointin.
                var _absolutePosition = absolutePosition() + TypeScript.fullWidth(node);
                _scannerParserSource.resetToPosition(_absolutePosition);
                // Debug.assert(previousToken !== undefined);
                // Debug.assert(previousToken.width() > 0);
                //if (!isPastChangeRange()) {
                //    // If we still have a change range, then this node must have ended before the 
                //    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                //    Debug.assert(absolutePosition() < _changeRange.span().start());
                //}
            }
            function consumeToken(currentToken) {
                // Debug.assert(currentToken.fullWidth() > 0 || currentToken.kind === SyntaxKind.EndOfFileToken);
                // This token may have come from the old source unit, or from the new text.  Handle
                // both accordingly.
                if (_oldSourceUnitCursor.currentToken() === currentToken) {
                    // The token came from the old source unit.  So our tree and text must be in sync.
                    // Debug.assert(_changeDelta === 0);
                    // Move the cursor past this token.
                    _oldSourceUnitCursor.moveToNextSibling();
                    // Debug.assert(!_normalParserSource.isPinned());
                    // Update the underlying source with where it should now be currently pointing. We 
                    // don't need to do this when the token came from the new text as the source will
                    // automatically be placed in the right position.
                    var _absolutePosition = absolutePosition() + currentToken.fullWidth();
                    _scannerParserSource.resetToPosition(_absolutePosition);
                }
                else {
                    // the token came from the new text.  That means the normal source moved forward,
                    // while the syntax cursor stayed in the same place.  Thus our delta moves even 
                    // further back.
                    _changeDelta -= currentToken.fullWidth();
                    // Move our underlying source forward.
                    _scannerParserSource.consumeToken(currentToken);
                    // Because we read a token from the new text, we may have moved ourselves past the
                    // change range.  If we did, then we may also have to update our change delta to
                    // compensate for the length change between the old and new text.
                    if (!isPastChangeRange()) {
                        // var changeEndInNewText = _changeRange.span().start() + _changeRange.newLength();
                        if (absolutePosition() >= _changeRangeNewSpan.end()) {
                            _changeDelta += _changeRange.newLength() - _changeRange.span().length();
                            // Once we're past the change range, we no longer need it.  Null it out.
                            // From now on we can check if we're past the change range just by seeing
                            // if this is undefined.
                            _changeRange = undefined;
                        }
                    }
                }
            }
            function isPastChangeRange() {
                return _changeRange === undefined;
            }
            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release
            };
        }
        function createSyntaxCursorPiece(element, indexInParent) {
            return { element: element, indexInParent: indexInParent };
        }
        // Pool syntax cursors so we don't churn too much memory when we need temporary cursors.  
        // i.e. when we're speculatively parsing, we can cheaply get a pooled cursor and then
        // return it when we no longer need it.
        var syntaxCursorPool = [];
        var syntaxCursorPoolCount = 0;
        function returnSyntaxCursor(cursor) {
            // Make sure the cursor isn't holding onto any syntax elements.  We don't want to leak 
            // them when we return the cursor to the pool.
            cursor.clean();
            syntaxCursorPool[syntaxCursorPoolCount] = cursor;
            syntaxCursorPoolCount++;
        }
        function getSyntaxCursor() {
            // Get an existing cursor from the pool if we have one.  Or create a new one if we don't.
            var cursor = syntaxCursorPoolCount > 0 ? syntaxCursorPool[syntaxCursorPoolCount - 1] : createSyntaxCursor();
            if (syntaxCursorPoolCount > 0) {
                // If we reused an existing cursor, take it out of the pool so no one else uses it.
                syntaxCursorPoolCount--;
                syntaxCursorPool[syntaxCursorPoolCount] = undefined;
            }
            return cursor;
        }
        function cloneSyntaxCursor(cursor) {
            var newCursor = getSyntaxCursor();
            // Make the new cursor a *deep* copy of the cursor passed in.  This ensures each cursor can
            // be moved without affecting the other.
            newCursor.deepCopyFrom(cursor);
            return newCursor;
        }
        function createSyntaxCursor() {
            // Our list of path pieces.  The piece pointed to by 'currentPieceIndex' must be a node or
            // token.  However, pieces earlier than that may point to list nodes.
            //
            // For perf we reuse pieces as much as possible.  i.e. instead of popping items off the 
            // list, we just will change currentPieceIndex so we can reuse that piece later.
            var pieces = [];
            var currentPieceIndex = -1;
            // Cleans up this cursor so that it doesn't have any references to actual syntax nodes.
            // This sould be done before returning the cursor to the pool so that the Parser module
            // doesn't unnecessarily keep old syntax trees alive.
            function clean() {
                for (var i = 0, n = pieces.length; i < n; i++) {
                    var piece = pieces[i];
                    if (piece.element === undefined) {
                        break;
                    }
                    piece.element = undefined;
                    piece.indexInParent = -1;
                }
                currentPieceIndex = -1;
            }
            // Makes this cursor into a deep copy of the cursor passed in.
            function deepCopyFrom(other) {
                for (var i = 0, n = other.pieces.length; i < n; i++) {
                    var piece = other.pieces[i];
                    if (piece.element === undefined) {
                        break;
                    }
                    pushElement(piece.element, piece.indexInParent);
                }
                // Debug.assert(currentPieceIndex === other.currentPieceIndex);
            }
            function isFinished() {
                return currentPieceIndex < 0;
            }
            function currentNodeOrToken() {
                if (isFinished()) {
                    return undefined;
                }
                var result = pieces[currentPieceIndex].element;
                // The current element must always be a node or a token.
                // Debug.assert(result !== undefined);
                // Debug.assert(result.isNode() || result.isToken());
                return result;
            }
            function currentNode() {
                var element = currentNodeOrToken();
                return TypeScript.isNode(element) ? element : undefined;
            }
            function isEmptyList(element) {
                return TypeScript.isList(element) && element.length === 0;
            }
            function moveToFirstChild() {
                var nodeOrToken = currentNodeOrToken();
                if (nodeOrToken === undefined) {
                    return;
                }
                if (TypeScript.isToken(nodeOrToken)) {
                    // If we're already on a token, there's nothing to do.
                    return;
                }
                for (var i = 0, n = TypeScript.childCount(nodeOrToken); i < n; i++) {
                    var child = TypeScript.childAt(nodeOrToken, i);
                    if (child && !isEmptyList(child)) {
                        // Great, we found a real child.  Push that.
                        pushElement(child, i);
                        // If it was a list, make sure we're pointing at its first element.  We know we
                        // must have one because this is a non-shared list.
                        moveToFirstChildIfList();
                        return;
                    }
                }
                // This element must have been an empty node.  Moving to its 'first child' is equivalent to just
                // moving to the next sibling.
                // Debug.assert(fullWidth(nodeOrToken) === 0);
                moveToNextSibling();
            }
            function moveToNextSibling() {
                while (!isFinished()) {
                    // first look to our parent and see if it has a sibling of us that we can move to.
                    var currentPiece = pieces[currentPieceIndex];
                    var parent = currentPiece.element.parent;
                    for (var i = currentPiece.indexInParent + 1, n = TypeScript.childCount(parent); i < n; i++) {
                        var sibling = TypeScript.childAt(parent, i);
                        if (sibling && !isEmptyList(sibling)) {
                            // We found a good sibling that we can move to.  Just reuse our existing piece
                            // so we don't have to push/pop.
                            currentPiece.element = sibling;
                            currentPiece.indexInParent = i;
                            // The sibling might have been a list.  Move to it's first child.
                            moveToFirstChildIfList();
                            return;
                        }
                    }
                    // Didn't have a sibling for this element.  Go up to our parent and get its sibling.
                    // Clear the data from the old piece.  We don't want to keep any elements around
                    // unintentionally.
                    currentPiece.element = undefined;
                    currentPiece.indexInParent = -1;
                    // Point at the parent.  if we move past the top of the path, then we're finished.
                    currentPieceIndex--;
                }
            }
            function moveToFirstChildIfList() {
                var element = pieces[currentPieceIndex].element;
                if (TypeScript.isList(element)) {
                    // We cannot ever get an empty list in our piece path.  Empty lists are 'shared' and
                    // we make sure to filter that out before pushing any children.
                    // Debug.assert(childCount(element) > 0);
                    pushElement(TypeScript.childAt(element, 0), 0);
                }
            }
            function pushElement(element, indexInParent) {
                // Debug.assert(element !== undefined);
                // Debug.assert(indexInParent >= 0);
                currentPieceIndex++;
                // Reuse an existing piece if we have one.  Otherwise, push a new piece to our list.
                if (currentPieceIndex === pieces.length) {
                    pieces.push(createSyntaxCursorPiece(element, indexInParent));
                }
                else {
                    var piece = pieces[currentPieceIndex];
                    piece.element = element;
                    piece.indexInParent = indexInParent;
                }
            }
            function moveToFirstToken() {
                while (!isFinished()) {
                    var element = pieces[currentPieceIndex].element;
                    if (TypeScript.isNode(element)) {
                        moveToFirstChild();
                        continue;
                    }
                    // Debug.assert(isToken(element));
                    return;
                }
            }
            function currentToken() {
                moveToFirstToken();
                var element = currentNodeOrToken();
                // Debug.assert(element === undefined || element.isToken());
                return element;
            }
            return {
                pieces: pieces,
                clean: clean,
                isFinished: isFinished,
                moveToFirstChild: moveToFirstChild,
                moveToFirstToken: moveToFirstToken,
                moveToNextSibling: moveToNextSibling,
                currentNodeOrToken: currentNodeOrToken,
                currentNode: currentNode,
                currentToken: currentToken,
                pushElement: pushElement,
                deepCopyFrom: deepCopyFrom
            };
        }
        // A simple walker we use to hit all the tokens of a node and update their positions when they
        // are reused in a different location because of an incremental parse.
        var TokenCollectorWalker = (function (_super) {
            __extends(TokenCollectorWalker, _super);
            function TokenCollectorWalker() {
                _super.apply(this, arguments);
                this.tokens = [];
            }
            TokenCollectorWalker.prototype.visitToken = function (token) {
                this.tokens.push(token);
            };
            return TokenCollectorWalker;
        })(TypeScript.SyntaxWalker);
        var tokenCollectorWalker = new TokenCollectorWalker();
        function parse(oldSyntaxTree, textChangeRange, newText) {
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }
            return TypeScript.Parser.parseSource(createParserSource(oldSyntaxTree, textChangeRange, newText), oldSyntaxTree.isDeclaration());
        }
        IncrementalParser.parse = parse;
    })(IncrementalParser = TypeScript.IncrementalParser || (TypeScript.IncrementalParser = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
var ts;
(function (ts) {
    var OutliningElementsCollector;
    (function (OutliningElementsCollector) {
        function collectElements(sourceFile) {
            var elements = [];
            var collapseText = "...";
            function addOutliningSpan(hintSpanNode, startElement, endElement, autoCollapse) {
                if (hintSpanNode && startElement && endElement) {
                    var span = {
                        textSpan: TypeScript.TextSpan.fromBounds(startElement.pos, endElement.end),
                        hintSpan: TypeScript.TextSpan.fromBounds(hintSpanNode.getStart(), hintSpanNode.end),
                        bannerText: collapseText,
                        autoCollapse: autoCollapse
                    };
                    elements.push(span);
                }
            }
            function autoCollapse(node) {
                switch (node.kind) {
                    case 189 /* ModuleBlock */:
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                        return false;
                }
                return true;
            }
            var depth = 0;
            var maxDepth = 20;
            function walk(n) {
                if (depth > maxDepth) {
                    return;
                }
                switch (n.kind) {
                    case 158 /* Block */:
                        var parent = n.parent;
                        var openBrace = ts.findChildOfKind(n, 13 /* OpenBraceToken */, sourceFile);
                        var closeBrace = ts.findChildOfKind(n, 14 /* CloseBraceToken */, sourceFile);
                        // Check if the block is standalone, or 'attached' to some parent statement.
                        // If the latter, we want to collaps the block, but consider its hint span
                        // to be the entire span of the parent.
                        if (parent.kind === 163 /* DoStatement */ || parent.kind === 166 /* ForInStatement */ || parent.kind === 165 /* ForStatement */ || parent.kind === 162 /* IfStatement */ || parent.kind === 164 /* WhileStatement */ || parent.kind === 170 /* WithStatement */) {
                            addOutliningSpan(parent, openBrace, closeBrace, autoCollapse(n));
                        }
                        else {
                            // Block was a standalone block.  In this case we want to only collapse
                            // the span of the block, independent of any parent span.
                            var span = TypeScript.TextSpan.fromBounds(n.getStart(), n.end);
                            elements.push({
                                textSpan: span,
                                hintSpan: span,
                                bannerText: collapseText,
                                autoCollapse: autoCollapse(n)
                            });
                        }
                        break;
                    case 183 /* FunctionBlock */:
                    case 189 /* ModuleBlock */:
                    case 177 /* TryBlock */:
                    case 178 /* CatchBlock */:
                    case 179 /* FinallyBlock */:
                        var openBrace = ts.findChildOfKind(n, 13 /* OpenBraceToken */, sourceFile);
                        var closeBrace = ts.findChildOfKind(n, 14 /* CloseBraceToken */, sourceFile);
                        addOutliningSpan(n.parent, openBrace, closeBrace, autoCollapse(n));
                        break;
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                    case 140 /* ObjectLiteral */:
                    case 171 /* SwitchStatement */:
                        var openBrace = ts.findChildOfKind(n, 13 /* OpenBraceToken */, sourceFile);
                        var closeBrace = ts.findChildOfKind(n, 14 /* CloseBraceToken */, sourceFile);
                        addOutliningSpan(n, openBrace, closeBrace, autoCollapse(n));
                        break;
                    case 139 /* ArrayLiteral */:
                        var openBracket = ts.findChildOfKind(n, 17 /* OpenBracketToken */, sourceFile);
                        var closeBracket = ts.findChildOfKind(n, 18 /* CloseBracketToken */, sourceFile);
                        addOutliningSpan(n, openBracket, closeBracket, autoCollapse(n));
                        break;
                }
                depth++;
                ts.forEachChild(n, walk);
                depth--;
            }
            walk(sourceFile);
            return elements;
        }
        OutliningElementsCollector.collectElements = collectElements;
    })(OutliningElementsCollector = ts.OutliningElementsCollector || (ts.OutliningElementsCollector = {}));
})(ts || (ts = {}));
/// <reference path='services.ts' />
/// <reference path="text/textSpan.ts" />
var ts;
(function (ts) {
    var NavigationBar;
    (function (NavigationBar) {
        function getNavigationBarItems(sourceFile) {
            // If the source file has any child items, then it included in the tree
            // and takes lexical ownership of all other top-level items.
            var hasGlobalNode = false;
            return getItemsWorker(getTopLevelNodes(sourceFile), createTopLevelItem);
            function getIndent(node) {
                // If we have a global node in the tree,
                // then it adds an extra layer of depth to all subnodes.
                var indent = hasGlobalNode ? 1 : 0;
                var current = node.parent;
                while (current) {
                    switch (current.kind) {
                        case 188 /* ModuleDeclaration */:
                            do {
                                current = current.parent;
                            } while (current.kind === 188 /* ModuleDeclaration */);
                        case 184 /* ClassDeclaration */:
                        case 187 /* EnumDeclaration */:
                        case 185 /* InterfaceDeclaration */:
                        case 182 /* FunctionDeclaration */:
                            indent++;
                    }
                    current = current.parent;
                }
                return indent;
            }
            function getChildNodes(nodes) {
                var childNodes = [];
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    if (node.kind === 184 /* ClassDeclaration */ || node.kind === 187 /* EnumDeclaration */ || node.kind === 185 /* InterfaceDeclaration */ || node.kind === 188 /* ModuleDeclaration */ || node.kind === 182 /* FunctionDeclaration */) {
                        childNodes.push(node);
                    }
                    else if (node.kind === 159 /* VariableStatement */) {
                        childNodes.push.apply(childNodes, node.declarations);
                    }
                }
                return sortNodes(childNodes);
            }
            function getTopLevelNodes(node) {
                var topLevelNodes = [];
                topLevelNodes.push(node);
                addTopLevelNodes(node.statements, topLevelNodes);
                return topLevelNodes;
            }
            function sortNodes(nodes) {
                return nodes.slice(0).sort(function (n1, n2) {
                    if (n1.name && n2.name) {
                        // TODO(jfreeman): How do we sort declarations with computed names?
                        return n1.name.text.localeCompare(n2.name.text);
                    }
                    else if (n1.name) {
                        return 1;
                    }
                    else if (n2.name) {
                        return -1;
                    }
                    else {
                        return n1.kind - n2.kind;
                    }
                });
            }
            function addTopLevelNodes(nodes, topLevelNodes) {
                nodes = sortNodes(nodes);
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    switch (node.kind) {
                        case 184 /* ClassDeclaration */:
                        case 187 /* EnumDeclaration */:
                        case 185 /* InterfaceDeclaration */:
                            topLevelNodes.push(node);
                            break;
                        case 188 /* ModuleDeclaration */:
                            var moduleDeclaration = node;
                            topLevelNodes.push(node);
                            addTopLevelNodes(getInnermostModule(moduleDeclaration).body.statements, topLevelNodes);
                            break;
                        case 182 /* FunctionDeclaration */:
                            var functionDeclaration = node;
                            if (isTopLevelFunctionDeclaration(functionDeclaration)) {
                                topLevelNodes.push(node);
                                addTopLevelNodes(functionDeclaration.body.statements, topLevelNodes);
                            }
                            break;
                    }
                }
            }
            function isTopLevelFunctionDeclaration(functionDeclaration) {
                if (functionDeclaration.kind === 182 /* FunctionDeclaration */) {
                    // A function declaration is 'top level' if it contains any function declarations 
                    // within it. 
                    if (functionDeclaration.body && functionDeclaration.body.kind === 183 /* FunctionBlock */) {
                        // Proper function declarations can only have identifier names
                        if (ts.forEach(functionDeclaration.body.statements, function (s) { return s.kind === 182 /* FunctionDeclaration */ && !isEmpty(s.name.text); })) {
                            return true;
                        }
                        // Or if it is not parented by another function.  i.e all functions
                        // at module scope are 'top level'.
                        if (functionDeclaration.parent.kind !== 183 /* FunctionBlock */) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function getItemsWorker(nodes, createItem) {
                var items = [];
                var keyToItem = {};
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var child = nodes[i];
                    var item = createItem(child);
                    if (item !== undefined) {
                        if (item.text.length > 0) {
                            var key = item.text + "-" + item.kind + "-" + item.indent;
                            var itemWithSameName = keyToItem[key];
                            if (itemWithSameName) {
                                // We had an item with the same name.  Merge these items together.
                                merge(itemWithSameName, item);
                            }
                            else {
                                keyToItem[key] = item;
                                items.push(item);
                            }
                        }
                    }
                }
                return items;
            }
            function merge(target, source) {
                // First, add any spans in the source to the target.
                target.spans.push.apply(target.spans, source.spans);
                if (source.childItems) {
                    if (!target.childItems) {
                        target.childItems = [];
                    }
                    outer: for (var i = 0, n = source.childItems.length; i < n; i++) {
                        var sourceChild = source.childItems[i];
                        for (var j = 0, m = target.childItems.length; j < m; j++) {
                            var targetChild = target.childItems[j];
                            if (targetChild.text === sourceChild.text && targetChild.kind === sourceChild.kind) {
                                // Found a match.  merge them.
                                merge(targetChild, sourceChild);
                                continue outer;
                            }
                        }
                        // Didn't find a match, just add this child to the list.
                        target.childItems.push(sourceChild);
                    }
                }
            }
            function createChildItem(node) {
                switch (node.kind) {
                    case 123 /* Parameter */:
                        if ((node.flags & 243 /* Modifier */) === 0) {
                            return undefined;
                        }
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberVariableElement);
                    case 125 /* Method */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberFunctionElement);
                    case 127 /* GetAccessor */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberGetAccessorElement);
                    case 128 /* SetAccessor */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberSetAccessorElement);
                    case 131 /* IndexSignature */:
                        return createItem(node, "[]", ts.ScriptElementKind.indexSignatureElement);
                    case 192 /* EnumMember */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberVariableElement);
                    case 129 /* CallSignature */:
                        return createItem(node, "()", ts.ScriptElementKind.callSignatureElement);
                    case 130 /* ConstructSignature */:
                        return createItem(node, "new()", ts.ScriptElementKind.constructSignatureElement);
                    case 124 /* Property */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.memberVariableElement);
                    case 182 /* FunctionDeclaration */:
                        return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.functionElement);
                    case 181 /* VariableDeclaration */:
                        if (node.flags & 4096 /* Const */) {
                            return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.constantElement);
                        }
                        else {
                            return createItem(node, getTextOfNode(node.name), ts.ScriptElementKind.variableElement);
                        }
                    case 126 /* Constructor */:
                        return createItem(node, "constructor", ts.ScriptElementKind.constructorImplementationElement);
                }
                return undefined;
                function createItem(node, name, scriptElementKind) {
                    return getNavigationBarItem(name, scriptElementKind, ts.getNodeModifiers(node), [getNodeSpan(node)]);
                }
            }
            function isEmpty(text) {
                return !text || text.trim() === "";
            }
            function getNavigationBarItem(text, kind, kindModifiers, spans, childItems, indent) {
                if (childItems === void 0) { childItems = []; }
                if (indent === void 0) { indent = 0; }
                if (isEmpty(text)) {
                    return undefined;
                }
                return {
                    text: text,
                    kind: kind,
                    kindModifiers: kindModifiers,
                    spans: spans,
                    childItems: childItems,
                    indent: indent,
                    bolded: false,
                    grayed: false
                };
            }
            function createTopLevelItem(node) {
                switch (node.kind) {
                    case 193 /* SourceFile */:
                        return createSourceFileItem(node);
                    case 184 /* ClassDeclaration */:
                        return createClassItem(node);
                    case 187 /* EnumDeclaration */:
                        return createEnumItem(node);
                    case 185 /* InterfaceDeclaration */:
                        return createIterfaceItem(node);
                    case 188 /* ModuleDeclaration */:
                        return createModuleItem(node);
                    case 182 /* FunctionDeclaration */:
                        return createFunctionItem(node);
                }
                return undefined;
                function getModuleName(moduleDeclaration) {
                    // We want to maintain quotation marks.
                    if (moduleDeclaration.name.kind === 7 /* StringLiteral */) {
                        return getTextOfNode(moduleDeclaration.name);
                    }
                    // Otherwise, we need to aggregate each identifier to build up the qualified name.
                    var result = [];
                    result.push(moduleDeclaration.name.text);
                    while (moduleDeclaration.body && moduleDeclaration.body.kind === 188 /* ModuleDeclaration */) {
                        moduleDeclaration = moduleDeclaration.body;
                        result.push(moduleDeclaration.name.text);
                    }
                    return result.join(".");
                }
                function createModuleItem(node) {
                    var moduleName = getModuleName(node);
                    var childItems = getItemsWorker(getChildNodes(getInnermostModule(node).body.statements), createChildItem);
                    return getNavigationBarItem(moduleName, ts.ScriptElementKind.moduleElement, ts.getNodeModifiers(node), [getNodeSpan(node)], childItems, getIndent(node));
                }
                function createFunctionItem(node) {
                    if (node.name && node.body && node.body.kind === 183 /* FunctionBlock */) {
                        var childItems = getItemsWorker(sortNodes(node.body.statements), createChildItem);
                        return getNavigationBarItem(node.name.text, ts.ScriptElementKind.functionElement, ts.getNodeModifiers(node), [getNodeSpan(node)], childItems, getIndent(node));
                    }
                    return undefined;
                }
                function createSourceFileItem(node) {
                    var childItems = getItemsWorker(getChildNodes(node.statements), createChildItem);
                    if (childItems === undefined || childItems.length === 0) {
                        return undefined;
                    }
                    hasGlobalNode = true;
                    var rootName = ts.isExternalModule(node) ? "\"" + ts.escapeString(ts.getBaseFilename(ts.removeFileExtension(ts.normalizePath(node.filename)))) + "\"" : "<global>";
                    return getNavigationBarItem(rootName, ts.ScriptElementKind.moduleElement, ts.ScriptElementKindModifier.none, [getNodeSpan(node)], childItems);
                }
                function createClassItem(node) {
                    var childItems;
                    if (node.members) {
                        var constructor = ts.forEach(node.members, function (member) {
                            return member.kind === 126 /* Constructor */ && member;
                        });
                        // Add the constructor parameters in as children of the class (for property parameters).
                        // Note that *all* parameters will be added to the nodes array, but parameters that
                        // are not properties will be filtered out later by createChildItem.
                        var nodes = constructor ? node.members.concat(constructor.parameters) : node.members;
                        var childItems = getItemsWorker(sortNodes(nodes), createChildItem);
                    }
                    return getNavigationBarItem(node.name.text, ts.ScriptElementKind.classElement, ts.getNodeModifiers(node), [getNodeSpan(node)], childItems, getIndent(node));
                }
                function createEnumItem(node) {
                    var childItems = getItemsWorker(sortNodes(node.members), createChildItem);
                    return getNavigationBarItem(node.name.text, ts.ScriptElementKind.enumElement, ts.getNodeModifiers(node), [getNodeSpan(node)], childItems, getIndent(node));
                }
                function createIterfaceItem(node) {
                    var childItems = getItemsWorker(sortNodes(node.members), createChildItem);
                    return getNavigationBarItem(node.name.text, ts.ScriptElementKind.interfaceElement, ts.getNodeModifiers(node), [getNodeSpan(node)], childItems, getIndent(node));
                }
            }
            function getInnermostModule(node) {
                while (node.body.kind === 188 /* ModuleDeclaration */) {
                    node = node.body;
                }
                return node;
            }
            function getNodeSpan(node) {
                return node.kind === 193 /* SourceFile */ ? TypeScript.TextSpan.fromBounds(node.getFullStart(), node.getEnd()) : TypeScript.TextSpan.fromBounds(node.getStart(), node.getEnd());
            }
            function getTextOfNode(node) {
                return ts.getTextOfNodeFromSourceText(sourceFile.text, node);
            }
        }
        NavigationBar.getNavigationBarItems = getNavigationBarItems;
    })(NavigationBar = ts.NavigationBar || (ts.NavigationBar = {}));
})(ts || (ts = {}));
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.
/// <reference path='services.ts' />
var ts;
(function (ts) {
    var BreakpointResolver;
    (function (BreakpointResolver) {
        /**
         * Get the breakpoint span in given sourceFile
         */
        function spanInSourceFileAtLocation(sourceFile, position) {
            // Cannot set breakpoint in dts file
            if (sourceFile.flags & 1024 /* DeclarationFile */) {
                return undefined;
            }
            var tokenAtLocation = ts.getTokenAtPosition(sourceFile, position);
            var lineOfPosition = sourceFile.getLineAndCharacterFromPosition(position).line;
            if (sourceFile.getLineAndCharacterFromPosition(tokenAtLocation.getStart()).line > lineOfPosition) {
                // Get previous token if the token is returned starts on new line
                // eg: var x =10; |--- curser is here
                //     var y = 10; 
                // token at position will return var keyword on second line as the token but we would like to use 
                // token on same line if trailing trivia (comments or white spaces on same line) part of the last token on that line
                tokenAtLocation = ts.findPrecedingToken(tokenAtLocation.pos, sourceFile);
                // Its a blank line
                if (!tokenAtLocation || sourceFile.getLineAndCharacterFromPosition(tokenAtLocation.getEnd()).line !== lineOfPosition) {
                    return undefined;
                }
            }
            // Cannot set breakpoint in ambient declarations
            if (ts.isInAmbientContext(tokenAtLocation)) {
                return undefined;
            }
            // Get the span in the node based on its syntax
            return spanInNode(tokenAtLocation);
            function textSpan(startNode, endNode) {
                return TypeScript.TextSpan.fromBounds(startNode.getStart(), (endNode || startNode).getEnd());
            }
            function spanInNodeIfStartsOnSameLine(node, otherwiseOnNode) {
                if (node && lineOfPosition === sourceFile.getLineAndCharacterFromPosition(node.getStart()).line) {
                    return spanInNode(node);
                }
                return spanInNode(otherwiseOnNode);
            }
            function spanInPreviousNode(node) {
                return spanInNode(ts.findPrecedingToken(node.pos, sourceFile));
            }
            function spanInNextNode(node) {
                return spanInNode(ts.findNextToken(node, node.parent));
            }
            function spanInNode(node) {
                if (node) {
                    if (ts.isExpression(node)) {
                        if (node.parent.kind === 163 /* DoStatement */) {
                            // Set span as if on while keyword
                            return spanInPreviousNode(node);
                        }
                        if (node.parent.kind === 165 /* ForStatement */) {
                            // For now lets set the span on this expression, fix it later
                            return textSpan(node);
                        }
                        if (node.parent.kind === 153 /* BinaryExpression */ && node.parent.operator === 22 /* CommaToken */) {
                            // if this is comma expression, the breakpoint is possible in this expression
                            return textSpan(node);
                        }
                        if (node.parent.kind == 150 /* ArrowFunction */ && node.parent.body == node) {
                            // If this is body of arrow function, it is allowed to have the breakpoint
                            return textSpan(node);
                        }
                    }
                    switch (node.kind) {
                        case 159 /* VariableStatement */:
                            // Span on first variable declaration
                            return spanInVariableDeclaration(node.declarations[0]);
                        case 181 /* VariableDeclaration */:
                        case 124 /* Property */:
                            return spanInVariableDeclaration(node);
                        case 123 /* Parameter */:
                            return spanInParameterDeclaration(node);
                        case 182 /* FunctionDeclaration */:
                        case 125 /* Method */:
                        case 127 /* GetAccessor */:
                        case 128 /* SetAccessor */:
                        case 126 /* Constructor */:
                        case 149 /* FunctionExpression */:
                        case 150 /* ArrowFunction */:
                            return spanInFunctionDeclaration(node);
                        case 183 /* FunctionBlock */:
                            return spanInFunctionBlock(node);
                        case 158 /* Block */:
                        case 177 /* TryBlock */:
                        case 178 /* CatchBlock */:
                        case 179 /* FinallyBlock */:
                        case 189 /* ModuleBlock */:
                            return spanInBlock(node);
                        case 161 /* ExpressionStatement */:
                            // span on the expression
                            return textSpan(node.expression);
                        case 169 /* ReturnStatement */:
                            // span on return keyword and expression if present
                            return textSpan(node.getChildAt(0), node.expression);
                        case 164 /* WhileStatement */:
                            // Span on while(...)
                            return textSpan(node, ts.findNextToken(node.expression, node));
                        case 163 /* DoStatement */:
                            // span in statement of the do statement
                            return spanInNode(node.statement);
                        case 180 /* DebuggerStatement */:
                            // span on debugger keyword
                            return textSpan(node.getChildAt(0));
                        case 162 /* IfStatement */:
                            // set on if(..) span
                            return textSpan(node, ts.findNextToken(node.expression, node));
                        case 174 /* LabeledStatement */:
                            // span in statement
                            return spanInNode(node.statement);
                        case 168 /* BreakStatement */:
                        case 167 /* ContinueStatement */:
                            // On break or continue keyword and label if present
                            return textSpan(node.getChildAt(0), node.label);
                        case 165 /* ForStatement */:
                            return spanInForStatement(node);
                        case 166 /* ForInStatement */:
                            // span on for (a in ...)
                            return textSpan(node, ts.findNextToken(node.expression, node));
                        case 171 /* SwitchStatement */:
                            // span on switch(...)
                            return textSpan(node, ts.findNextToken(node.expression, node));
                        case 172 /* CaseClause */:
                        case 173 /* DefaultClause */:
                            // span in first statement of the clause
                            return spanInNode(node.statements[0]);
                        case 176 /* TryStatement */:
                            // span in try block
                            return spanInBlock(node.tryBlock);
                        case 175 /* ThrowStatement */:
                            // span in throw ...
                            return textSpan(node, node.expression);
                        case 191 /* ExportAssignment */:
                            // span on export = id
                            return textSpan(node, node.exportName);
                        case 190 /* ImportDeclaration */:
                            // import statement without including semicolon
                            return textSpan(node, node.entityName || node.externalModuleName);
                        case 188 /* ModuleDeclaration */:
                            // span on complete module if it is instantiated
                            if (ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {
                                return undefined;
                            }
                        case 184 /* ClassDeclaration */:
                        case 187 /* EnumDeclaration */:
                        case 192 /* EnumMember */:
                        case 144 /* CallExpression */:
                        case 145 /* NewExpression */:
                            // span on complete node
                            return textSpan(node);
                        case 170 /* WithStatement */:
                            // span in statement
                            return spanInNode(node.statement);
                        case 185 /* InterfaceDeclaration */:
                        case 186 /* TypeAliasDeclaration */:
                            return undefined;
                        case 21 /* SemicolonToken */:
                        case 1 /* EndOfFileToken */:
                            return spanInNodeIfStartsOnSameLine(ts.findPrecedingToken(node.pos, sourceFile));
                        case 22 /* CommaToken */:
                            return spanInPreviousNode(node);
                        case 13 /* OpenBraceToken */:
                            return spanInOpenBraceToken(node);
                        case 14 /* CloseBraceToken */:
                            return spanInCloseBraceToken(node);
                        case 15 /* OpenParenToken */:
                            return spanInOpenParenToken(node);
                        case 16 /* CloseParenToken */:
                            return spanInCloseParenToken(node);
                        case 50 /* ColonToken */:
                            return spanInColonToken(node);
                        case 24 /* GreaterThanToken */:
                        case 23 /* LessThanToken */:
                            return spanInGreaterThanOrLessThanToken(node);
                        case 98 /* WhileKeyword */:
                            return spanInWhileKeyword(node);
                        case 74 /* ElseKeyword */:
                        case 66 /* CatchKeyword */:
                        case 79 /* FinallyKeyword */:
                            return spanInNextNode(node);
                        default:
                            // If this is name of property assignment, set breakpoint in the initializer
                            if (node.parent.kind === 141 /* PropertyAssignment */ && node.parent.name === node) {
                                return spanInNode(node.parent.initializer);
                            }
                            // Breakpoint in type assertion goes to its operand
                            if (node.parent.kind === 147 /* TypeAssertion */ && node.parent.type === node) {
                                return spanInNode(node.parent.operand);
                            }
                            // return type of function go to previous token
                            if (ts.isAnyFunction(node.parent) && node.parent.type === node) {
                                return spanInPreviousNode(node);
                            }
                            // Default go to parent to set the breakpoint
                            return spanInNode(node.parent);
                    }
                }
                function spanInVariableDeclaration(variableDeclaration) {
                    // If declaration of for in statement, just set the span in parent
                    if (variableDeclaration.parent.kind === 166 /* ForInStatement */) {
                        return spanInNode(variableDeclaration.parent);
                    }
                    var isParentVariableStatement = variableDeclaration.parent.kind === 159 /* VariableStatement */;
                    var isDeclarationOfForStatement = variableDeclaration.parent.kind === 165 /* ForStatement */ && ts.contains(variableDeclaration.parent.declarations, variableDeclaration);
                    var declarations = isParentVariableStatement ? variableDeclaration.parent.declarations : isDeclarationOfForStatement ? variableDeclaration.parent.declarations : undefined;
                    // Breakpoint is possible in variableDeclaration only if there is initialization
                    if (variableDeclaration.initializer || (variableDeclaration.flags & 1 /* Export */)) {
                        if (declarations && declarations[0] === variableDeclaration) {
                            if (isParentVariableStatement) {
                                // First declaration - include var keyword
                                return textSpan(variableDeclaration.parent, variableDeclaration);
                            }
                            else {
                                ts.Debug.assert(isDeclarationOfForStatement);
                                // Include var keyword from for statement declarations in the span
                                return textSpan(ts.findPrecedingToken(variableDeclaration.pos, sourceFile, variableDeclaration.parent), variableDeclaration);
                            }
                        }
                        else {
                            // Span only on this declaration
                            return textSpan(variableDeclaration);
                        }
                    }
                    else if (declarations && declarations[0] !== variableDeclaration) {
                        // If we cant set breakpoint on this declaration, set it on previous one
                        var indexOfCurrentDeclaration = ts.indexOf(declarations, variableDeclaration);
                        return spanInVariableDeclaration(declarations[indexOfCurrentDeclaration - 1]);
                    }
                }
                function canHaveSpanInParameterDeclaration(parameter) {
                    // Breakpoint is possible on parameter only if it has initializer, is a rest parameter, or has public or private modifier
                    return !!parameter.initializer || !!(parameter.flags & 8 /* Rest */) || !!(parameter.flags & 16 /* Public */) || !!(parameter.flags & 32 /* Private */);
                }
                function spanInParameterDeclaration(parameter) {
                    if (canHaveSpanInParameterDeclaration(parameter)) {
                        return textSpan(parameter);
                    }
                    else {
                        var functionDeclaration = parameter.parent;
                        var indexOfParameter = ts.indexOf(functionDeclaration.parameters, parameter);
                        if (indexOfParameter) {
                            // Not a first parameter, go to previous parameter
                            return spanInParameterDeclaration(functionDeclaration.parameters[indexOfParameter - 1]);
                        }
                        else {
                            // Set breakpoint in the function declaration body
                            return spanInNode(functionDeclaration.body);
                        }
                    }
                }
                function canFunctionHaveSpanInWholeDeclaration(functionDeclaration) {
                    return !!(functionDeclaration.flags & 1 /* Export */) || (functionDeclaration.parent.kind === 184 /* ClassDeclaration */ && functionDeclaration.kind !== 126 /* Constructor */);
                }
                function spanInFunctionDeclaration(functionDeclaration) {
                    // No breakpoints in the function signature
                    if (!functionDeclaration.body) {
                        return undefined;
                    }
                    if (canFunctionHaveSpanInWholeDeclaration(functionDeclaration)) {
                        // Set the span on whole function declaration
                        return textSpan(functionDeclaration);
                    }
                    // Set span in function body
                    return spanInNode(functionDeclaration.body);
                }
                function spanInFunctionBlock(block) {
                    var nodeForSpanInBlock = block.statements.length ? block.statements[0] : block.getLastToken();
                    if (canFunctionHaveSpanInWholeDeclaration(block.parent)) {
                        return spanInNodeIfStartsOnSameLine(block.parent, nodeForSpanInBlock);
                    }
                    return spanInNode(nodeForSpanInBlock);
                }
                function spanInBlock(block) {
                    switch (block.parent.kind) {
                        case 188 /* ModuleDeclaration */:
                            if (ts.getModuleInstanceState(block.parent) !== 1 /* Instantiated */) {
                                return undefined;
                            }
                        case 164 /* WhileStatement */:
                        case 162 /* IfStatement */:
                        case 166 /* ForInStatement */:
                            return spanInNodeIfStartsOnSameLine(block.parent, block.statements[0]);
                        case 165 /* ForStatement */:
                            return spanInNodeIfStartsOnSameLine(ts.findPrecedingToken(block.pos, sourceFile, block.parent), block.statements[0]);
                    }
                    // Default action is to set on first statement
                    return spanInNode(block.statements[0]);
                }
                function spanInForStatement(forStatement) {
                    if (forStatement.declarations) {
                        return spanInNode(forStatement.declarations[0]);
                    }
                    if (forStatement.initializer) {
                        return spanInNode(forStatement.initializer);
                    }
                    if (forStatement.condition) {
                        return textSpan(forStatement.condition);
                    }
                    if (forStatement.iterator) {
                        return textSpan(forStatement.iterator);
                    }
                }
                // Tokens:
                function spanInOpenBraceToken(node) {
                    switch (node.parent.kind) {
                        case 187 /* EnumDeclaration */:
                            var enumDeclaration = node.parent;
                            return spanInNodeIfStartsOnSameLine(ts.findPrecedingToken(node.pos, sourceFile, node.parent), enumDeclaration.members.length ? enumDeclaration.members[0] : enumDeclaration.getLastToken(sourceFile));
                        case 184 /* ClassDeclaration */:
                            var classDeclaration = node.parent;
                            return spanInNodeIfStartsOnSameLine(ts.findPrecedingToken(node.pos, sourceFile, node.parent), classDeclaration.members.length ? classDeclaration.members[0] : classDeclaration.getLastToken(sourceFile));
                        case 171 /* SwitchStatement */:
                            return spanInNodeIfStartsOnSameLine(node.parent, node.parent.clauses[0]);
                    }
                    // Default to parent node
                    return spanInNode(node.parent);
                }
                function spanInCloseBraceToken(node) {
                    switch (node.parent.kind) {
                        case 189 /* ModuleBlock */:
                            // If this is not instantiated module block no bp span
                            if (ts.getModuleInstanceState(node.parent.parent) !== 1 /* Instantiated */) {
                                return undefined;
                            }
                        case 183 /* FunctionBlock */:
                        case 187 /* EnumDeclaration */:
                        case 184 /* ClassDeclaration */:
                            // Span on close brace token
                            return textSpan(node);
                        case 158 /* Block */:
                        case 177 /* TryBlock */:
                        case 178 /* CatchBlock */:
                        case 179 /* FinallyBlock */:
                            return spanInNode(node.parent.statements[node.parent.statements.length - 1]);
                            ;
                        case 171 /* SwitchStatement */:
                            // breakpoint in last statement of the last clause
                            var switchStatement = node.parent;
                            var lastClause = switchStatement.clauses[switchStatement.clauses.length - 1];
                            if (lastClause) {
                                return spanInNode(lastClause.statements[lastClause.statements.length - 1]);
                            }
                            return undefined;
                        default:
                            return spanInNode(node.parent);
                    }
                }
                function spanInOpenParenToken(node) {
                    if (node.parent.kind === 163 /* DoStatement */) {
                        // Go to while keyword and do action instead
                        return spanInPreviousNode(node);
                    }
                    // Default to parent node
                    return spanInNode(node.parent);
                }
                function spanInCloseParenToken(node) {
                    switch (node.parent.kind) {
                        case 149 /* FunctionExpression */:
                        case 182 /* FunctionDeclaration */:
                        case 150 /* ArrowFunction */:
                        case 125 /* Method */:
                        case 127 /* GetAccessor */:
                        case 128 /* SetAccessor */:
                        case 126 /* Constructor */:
                        case 164 /* WhileStatement */:
                        case 163 /* DoStatement */:
                        case 165 /* ForStatement */:
                            return spanInPreviousNode(node);
                        default:
                            return spanInNode(node.parent);
                    }
                    // Default to parent node
                    return spanInNode(node.parent);
                }
                function spanInColonToken(node) {
                    // Is this : specifying return annotation of the function declaration
                    if (ts.isAnyFunction(node.parent) || node.parent.kind === 141 /* PropertyAssignment */) {
                        return spanInPreviousNode(node);
                    }
                    return spanInNode(node.parent);
                }
                function spanInGreaterThanOrLessThanToken(node) {
                    if (node.parent.kind === 147 /* TypeAssertion */) {
                        return spanInNode(node.parent.operand);
                    }
                    return spanInNode(node.parent);
                }
                function spanInWhileKeyword(node) {
                    if (node.parent.kind === 163 /* DoStatement */) {
                        // Set span on while expression
                        return textSpan(node, ts.findNextToken(node.parent.expression, node.parent));
                    }
                    // Default to parent node
                    return spanInNode(node.parent);
                }
            }
        }
        BreakpointResolver.spanInSourceFileAtLocation = spanInSourceFileAtLocation;
    })(BreakpointResolver = ts.BreakpointResolver || (ts.BreakpointResolver = {}));
})(ts || (ts = {}));
var TypeScript;
(function (TypeScript) {
    var Indentation;
    (function (Indentation) {
        // Returns the column that this input string ends at (assuming it starts at column 0).
        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;
        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;
            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);
                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                }
                else {
                    column++;
                }
            }
            return column;
        }
        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = Math.max(0, column);
            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }
            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;
        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }
            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(Indentation = TypeScript.Indentation || (TypeScript.Indentation = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='services.ts' />
var ts;
(function (ts) {
    var SignatureHelp;
    (function (SignatureHelp) {
        // A partially written generic type expression is not guaranteed to have the correct syntax tree. the expression could be parsed as less than/greater than expression or a comma expression
        // or some other combination depending on what the user has typed so far. For the purposes of signature help we need to consider any location after "<" as a possible generic type reference. 
        // To do this, the method will back parse the expression starting at the position required. it will try to parse the current expression as a generic type expression, if it did succeed it 
        // will return the generic identifier that started the expression (e.g. "foo" in "foo<any, |"). It is then up to the caller to ensure that this is a valid generic expression through 
        // looking up the type. The method will also keep track of the parameter index inside the expression.
        //public static isInPartiallyWrittenTypeArgumentList(syntaxTree: TypeScript.SyntaxTree, position: number): any {
        //    var token = Syntax.findTokenOnLeft(syntaxTree.sourceUnit(), position, /*includeSkippedTokens*/ true);
        //    if (token && TypeScript.Syntax.hasAncestorOfKind(token, TypeScript.SyntaxKind.TypeParameterList)) {
        //        // We are in the wrong generic list. bail out
        //        return null;
        //    }
        //    var stack = 0;
        //    var argumentIndex = 0;
        //    whileLoop:
        //    while (token) {
        //        switch (token.kind()) {
        //            case TypeScript.SyntaxKind.LessThanToken:
        //                if (stack === 0) {
        //                    // Found the beginning of the generic argument expression
        //                    var lessThanToken = token;
        //                    token = previousToken(token, /*includeSkippedTokens*/ true);
        //                    if (!token || token.kind() !== TypeScript.SyntaxKind.IdentifierName) {
        //                        break whileLoop;
        //                    }
        //                    // Found the name, return the data
        //                    return {
        //                        genericIdentifer: token,
        //                        lessThanToken: lessThanToken,
        //                        argumentIndex: argumentIndex
        //                    };
        //                }
        //                else if (stack < 0) {
        //                    // Seen one too many less than tokens, bail out
        //                    break whileLoop;
        //                }
        //                else {
        //                    stack--;
        //                }
        //                break;
        //            case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
        //                stack++;
        //            // Intentaion fall through
        //            case TypeScript.SyntaxKind.GreaterThanToken:
        //                stack++;
        //                break;
        //            case TypeScript.SyntaxKind.CommaToken:
        //                if (stack == 0) {
        //                    argumentIndex++;
        //                }
        //                break;
        //            case TypeScript.SyntaxKind.CloseBraceToken:
        //                // This can be object type, skip untill we find the matching open brace token
        //                var unmatchedOpenBraceTokens = 0;
        //                // Skip untill the matching open brace token
        //                token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, TypeScript.SyntaxKind.CloseBraceToken, TypeScript.SyntaxKind.OpenBraceToken);
        //                if (!token) {
        //                    // No matching token was found. bail out
        //                    break whileLoop;
        //                }
        //                break;
        //            case TypeScript.SyntaxKind.EqualsGreaterThanToken:
        //                // This can be a function type or a constructor type. In either case, we want to skip the function defintion
        //                token = previousToken(token, /*includeSkippedTokens*/ true);
        //                if (token && token.kind() === TypeScript.SyntaxKind.CloseParenToken) {
        //                    // Skip untill the matching open paren token
        //                    token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, TypeScript.SyntaxKind.CloseParenToken, TypeScript.SyntaxKind.OpenParenToken);
        //                    if (token && token.kind() === TypeScript.SyntaxKind.GreaterThanToken) {
        //                        // Another generic type argument list, skip it\
        //                        token = SignatureInfoHelpers.moveBackUpTillMatchingTokenKind(token, TypeScript.SyntaxKind.GreaterThanToken, TypeScript.SyntaxKind.LessThanToken);
        //                    }
        //                    if (token && token.kind() === TypeScript.SyntaxKind.NewKeyword) {
        //                        // In case this was a constructor type, skip the new keyword
        //                        token = previousToken(token, /*includeSkippedTokens*/ true);
        //                    }
        //                    if (!token) {
        //                        // No matching token was found. bail out
        //                        break whileLoop;
        //                    }
        //                }
        //                else {
        //                    // This is not a funtion type. exit the main loop
        //                    break whileLoop;
        //                }
        //                break;
        //            case TypeScript.SyntaxKind.IdentifierName:
        //            case TypeScript.SyntaxKind.AnyKeyword:
        //            case TypeScript.SyntaxKind.NumberKeyword:
        //            case TypeScript.SyntaxKind.StringKeyword:
        //            case TypeScript.SyntaxKind.VoidKeyword:
        //            case TypeScript.SyntaxKind.BooleanKeyword:
        //            case TypeScript.SyntaxKind.DotToken:
        //            case TypeScript.SyntaxKind.OpenBracketToken:
        //            case TypeScript.SyntaxKind.CloseBracketToken:
        //                // Valid tokens in a type name. Skip.
        //                break;
        //            default:
        //                break whileLoop;
        //        }
        //        token = previousToken(token, /*includeSkippedTokens*/ true);
        //    }
        //    return null;
        //}
        //private static moveBackUpTillMatchingTokenKind(token: TypeScript.ISyntaxToken, tokenKind: TypeScript.SyntaxKind, matchingTokenKind: TypeScript.SyntaxKind): TypeScript.ISyntaxToken {
        //    if (!token || token.kind() !== tokenKind) {
        //        throw TypeScript.Errors.invalidOperation();
        //    }
        //    // Skip the current token
        //    token = previousToken(token, /*includeSkippedTokens*/ true);
        //    var stack = 0;
        //    while (token) {
        //        if (token.kind() === matchingTokenKind) {
        //            if (stack === 0) {
        //                // Found the matching token, return
        //                return token;
        //            }
        //            else if (stack < 0) {
        //                // tokens overlapped.. bail out.
        //                break;
        //            }
        //            else {
        //                stack--;
        //            }
        //        }
        //        else if (token.kind() === tokenKind) {
        //            stack++;
        //        }
        //        // Move back
        //        token = previousToken(token, /*includeSkippedTokens*/ true);
        //    }
        //    // Did not find matching token
        //    return null;
        //}
        var emptyArray = [];
        function getSignatureHelpItems(sourceFile, position, typeInfoResolver, cancellationToken) {
            // Decide whether to show signature help
            var startingToken = ts.findTokenOnLeftOfPosition(sourceFile, position);
            if (!startingToken) {
                // We are at the beginning of the file
                return undefined;
            }
            var argumentInfo = getContainingArgumentInfo(startingToken);
            cancellationToken.throwIfCancellationRequested();
            // Semantic filtering of signature help
            if (!argumentInfo) {
                return undefined;
            }
            var call = argumentInfo.list.parent;
            var candidates = [];
            var resolvedSignature = typeInfoResolver.getResolvedSignature(call, candidates);
            cancellationToken.throwIfCancellationRequested();
            if (!candidates.length) {
                return undefined;
            }
            return createSignatureHelpItems(candidates, resolvedSignature, argumentInfo);
            /**
             * If node is an argument, returns its index in the argument list.
             * If not, returns -1.
             */
            function getImmediatelyContainingArgumentInfo(node) {
                if (node.parent.kind !== 144 /* CallExpression */ && node.parent.kind !== 145 /* NewExpression */) {
                    return undefined;
                }
                // There are 3 cases to handle:
                //   1. The token introduces a list, and should begin a sig help session
                //   2. The token is either not associated with a list, or ends a list, so the session should end
                //   3. The token is buried inside a list, and should give sig help
                //
                // The following are examples of each:
                //
                //    Case 1:
                //          foo<$T, U>($a, b)    -> The token introduces a list, and should begin a sig help session
                //    Case 2:
                //          fo$o<T, U>$(a, b)$   -> The token is either not associated with a list, or ends a list, so the session should end
                //    Case 3:
                //          foo<T$, U$>(a$, $b$) -> The token is buried inside a list, and should give sig help
                var parent = node.parent;
                // Find out if 'node' is an argument, a type argument, or neither
                if (node.kind === 23 /* LessThanToken */ || node.kind === 15 /* OpenParenToken */) {
                    // Find the list that starts right *after* the < or ( token.
                    // If the user has just opened a list, consider this item 0.
                    var list = getChildListThatStartsWithOpenerToken(parent, node, sourceFile);
                    ts.Debug.assert(list !== undefined);
                    return {
                        list: list,
                        listItemIndex: 0
                    };
                }
                // findListItemInfo can return undefined if we are not in parent's argument list
                // or type argument list. This includes cases where the cursor is:
                //   - To the right of the closing paren
                //   - Between the type arguments and the arguments (greater than token)
                //   - On the target of the call (parent.func)
                //   - On the 'new' keyword in a 'new' expression
                return ts.findListItemInfo(node);
            }
            function getContainingArgumentInfo(node) {
                for (var n = node; n.kind !== 193 /* SourceFile */; n = n.parent) {
                    if (n.kind === 183 /* FunctionBlock */) {
                        return undefined;
                    }
                    // If the node is not a subspan of its parent, this is a big problem.
                    // There have been crashes that might be caused by this violation.
                    if (n.pos < n.parent.pos || n.end > n.parent.end) {
                        ts.Debug.fail("Node of kind " + n.kind + " is not a subspan of its parent of kind " + n.parent.kind);
                    }
                    var argumentInfo = getImmediatelyContainingArgumentInfo(n);
                    if (argumentInfo) {
                        return argumentInfo;
                    }
                }
                return undefined;
            }
            function getChildListThatStartsWithOpenerToken(parent, openerToken, sourceFile) {
                var children = parent.getChildren(sourceFile);
                var indexOfOpenerToken = children.indexOf(openerToken);
                ts.Debug.assert(indexOfOpenerToken >= 0 && children.length > indexOfOpenerToken + 1);
                return children[indexOfOpenerToken + 1];
            }
            /**
             * The selectedItemIndex could be negative for several reasons.
             *     1. There are too many arguments for all of the overloads
             *     2. None of the overloads were type compatible
             * The solution here is to try to pick the best overload by picking
             * either the first one that has an appropriate number of parameters,
             * or the one with the most parameters.
             */
            function selectBestInvalidOverloadIndex(candidates, argumentCount) {
                var maxParamsSignatureIndex = -1;
                var maxParams = -1;
                for (var i = 0; i < candidates.length; i++) {
                    var candidate = candidates[i];
                    if (candidate.hasRestParameter || candidate.parameters.length >= argumentCount) {
                        return i;
                    }
                    if (candidate.parameters.length > maxParams) {
                        maxParams = candidate.parameters.length;
                        maxParamsSignatureIndex = i;
                    }
                }
                return maxParamsSignatureIndex;
            }
            function createSignatureHelpItems(candidates, bestSignature, argumentInfoOrTypeArgumentInfo) {
                var argumentListOrTypeArgumentList = argumentInfoOrTypeArgumentInfo.list;
                var parent = argumentListOrTypeArgumentList.parent;
                var isTypeParameterHelp = parent.typeArguments && parent.typeArguments.pos === argumentListOrTypeArgumentList.pos;
                ts.Debug.assert(isTypeParameterHelp || parent.arguments.pos === argumentListOrTypeArgumentList.pos);
                var callTargetNode = argumentListOrTypeArgumentList.parent.func;
                var callTargetSymbol = typeInfoResolver.getSymbolInfo(callTargetNode);
                var callTargetDisplayParts = callTargetSymbol && ts.symbolToDisplayParts(typeInfoResolver, callTargetSymbol, undefined, undefined);
                var items = ts.map(candidates, function (candidateSignature) {
                    var signatureHelpParameters;
                    var prefixParts = [];
                    var suffixParts = [];
                    if (callTargetDisplayParts) {
                        prefixParts.push.apply(prefixParts, callTargetDisplayParts);
                    }
                    if (isTypeParameterHelp) {
                        prefixParts.push(ts.punctuationPart(23 /* LessThanToken */));
                        var typeParameters = candidateSignature.typeParameters;
                        signatureHelpParameters = typeParameters && typeParameters.length > 0 ? ts.map(typeParameters, createSignatureHelpParameterForTypeParameter) : emptyArray;
                        suffixParts.push(ts.punctuationPart(24 /* GreaterThanToken */));
                        var parameterParts = ts.mapToDisplayParts(function (writer) { return typeInfoResolver.getSymbolDisplayBuilder().buildDisplayForParametersAndDelimiters(candidateSignature.parameters, writer, argumentListOrTypeArgumentList); });
                        suffixParts.push.apply(suffixParts, parameterParts);
                    }
                    else {
                        var typeParameterParts = ts.mapToDisplayParts(function (writer) { return typeInfoResolver.getSymbolDisplayBuilder().buildDisplayForTypeParametersAndDelimiters(candidateSignature.typeParameters, writer, argumentListOrTypeArgumentList); });
                        prefixParts.push.apply(prefixParts, typeParameterParts);
                        prefixParts.push(ts.punctuationPart(15 /* OpenParenToken */));
                        var parameters = candidateSignature.parameters;
                        signatureHelpParameters = parameters.length > 0 ? ts.map(parameters, createSignatureHelpParameterForParameter) : emptyArray;
                        suffixParts.push(ts.punctuationPart(16 /* CloseParenToken */));
                    }
                    var returnTypeParts = ts.mapToDisplayParts(function (writer) { return typeInfoResolver.getSymbolDisplayBuilder().buildReturnTypeDisplay(candidateSignature, writer, argumentListOrTypeArgumentList); });
                    suffixParts.push.apply(suffixParts, returnTypeParts);
                    return {
                        isVariadic: candidateSignature.hasRestParameter,
                        prefixDisplayParts: prefixParts,
                        suffixDisplayParts: suffixParts,
                        separatorDisplayParts: [ts.punctuationPart(22 /* CommaToken */), ts.spacePart()],
                        parameters: signatureHelpParameters,
                        documentation: candidateSignature.getDocumentationComment()
                    };
                });
                // We use full start and skip trivia on the end because we want to include trivia on
                // both sides. For example,
                //
                //    foo(   /*comment */     a, b, c      /*comment*/     )
                //        |                                               |
                //
                // The applicable span is from the first bar to the second bar (inclusive,
                // but not including parentheses)
                var applicableSpanStart = argumentListOrTypeArgumentList.getFullStart();
                var applicableSpanEnd = ts.skipTrivia(sourceFile.text, argumentListOrTypeArgumentList.end, false);
                var applicableSpan = new TypeScript.TextSpan(applicableSpanStart, applicableSpanEnd - applicableSpanStart);
                // The listItemIndex we got back includes commas. Our goal is to return the index of the proper
                // item (not including commas). Here are some examples:
                //    1. foo(a, b, c $) -> the listItemIndex is 4, we want to return 2
                //    2. foo(a, b, $ c) -> listItemIndex is 3, we want to return 2
                //    3. foo($a) -> listItemIndex is 0, we want to return 0
                //
                // In general, we want to subtract the number of commas before the current index.
                // But if we are on a comma, we also want to pretend we are on the argument *following*
                // the comma. That amounts to taking the ceiling of half the index.
                var argumentIndex = (argumentInfoOrTypeArgumentInfo.listItemIndex + 1) >> 1;
                // argumentCount is the number of commas plus one, unless the list is completely empty,
                // in which case there are 0.
                var argumentCount = argumentListOrTypeArgumentList.getChildCount() === 0 ? 0 : 1 + ts.countWhere(argumentListOrTypeArgumentList.getChildren(), function (arg) { return arg.kind === 22 /* CommaToken */; });
                var selectedItemIndex = candidates.indexOf(bestSignature);
                if (selectedItemIndex < 0) {
                    selectedItemIndex = selectBestInvalidOverloadIndex(candidates, argumentCount);
                }
                return {
                    items: items,
                    applicableSpan: applicableSpan,
                    selectedItemIndex: selectedItemIndex,
                    argumentIndex: argumentIndex,
                    argumentCount: argumentCount
                };
                function createSignatureHelpParameterForParameter(parameter) {
                    var displayParts = ts.mapToDisplayParts(function (writer) { return typeInfoResolver.getSymbolDisplayBuilder().buildParameterDisplay(parameter, writer, argumentListOrTypeArgumentList); });
                    var isOptional = !!(parameter.valueDeclaration.flags & 4 /* QuestionMark */);
                    return {
                        name: parameter.name,
                        documentation: parameter.getDocumentationComment(),
                        displayParts: displayParts,
                        isOptional: isOptional
                    };
                }
                function createSignatureHelpParameterForTypeParameter(typeParameter) {
                    var displayParts = ts.mapToDisplayParts(function (writer) { return typeInfoResolver.getSymbolDisplayBuilder().buildTypeParameterDisplay(typeParameter, writer, argumentListOrTypeArgumentList); });
                    return {
                        name: typeParameter.symbol.name,
                        documentation: emptyArray,
                        displayParts: displayParts,
                        isOptional: false
                    };
                }
            }
        }
        SignatureHelp.getSignatureHelpItems = getSignatureHelpItems;
    })(SignatureHelp = ts.SignatureHelp || (ts.SignatureHelp = {}));
})(ts || (ts = {}));
// These utilities are common to multiple language service features.
var ts;
(function (ts) {
    function findListItemInfo(node) {
        var syntaxList = findContainingList(node);
        // It is possible at this point for syntaxList to be undefined, either if
        // node.parent had no list child, or if none of its list children contained
        // the span of node. If this happens, return undefined. The caller should
        // handle this case.
        if (!syntaxList) {
            return undefined;
        }
        var children = syntaxList.getChildren();
        var index = ts.indexOf(children, node);
        return {
            listItemIndex: index,
            list: syntaxList
        };
    }
    ts.findListItemInfo = findListItemInfo;
    function findChildOfKind(n, kind, sourceFile) {
        return ts.forEach(n.getChildren(sourceFile), function (c) { return c.kind === kind && c; });
    }
    ts.findChildOfKind = findChildOfKind;
    function findContainingList(node) {
        // The node might be a list element (nonsynthetic) or a comma (synthetic). Either way, it will
        // be parented by the container of the SyntaxList, not the SyntaxList itself.
        // In order to find the list item index, we first need to locate SyntaxList itself and then search
        // for the position of the relevant node (or comma).
        var syntaxList = ts.forEach(node.parent.getChildren(), function (c) {
            // find syntax list that covers the span of the node
            if (c.kind === 195 /* SyntaxList */ && c.pos <= node.pos && c.end >= node.end) {
                return c;
            }
        });
        return syntaxList;
    }
    ts.findContainingList = findContainingList;
    /**
     * Includes the start position of each child, but excludes the end.
     */
    function findListItemIndexContainingPosition(list, position) {
        ts.Debug.assert(list.kind === 195 /* SyntaxList */);
        var children = list.getChildren();
        for (var i = 0; i < children.length; i++) {
            if (children[i].pos <= position && children[i].end > position) {
                return i;
            }
        }
        return -1;
    }
    ts.findListItemIndexContainingPosition = findListItemIndexContainingPosition;
    /* Gets the token whose text has range [start, end) and
     * position >= start and (position < end or (position === end && token is keyword or identifier))
     */
    function getTouchingWord(sourceFile, position) {
        return getTouchingToken(sourceFile, position, isWord);
    }
    ts.getTouchingWord = getTouchingWord;
    /* Gets the token whose text has range [start, end) and position >= start
     * and (position < end or (position === end && token is keyword or identifier or numeric\string litera))
     */
    function getTouchingPropertyName(sourceFile, position) {
        return getTouchingToken(sourceFile, position, isPropertyName);
    }
    ts.getTouchingPropertyName = getTouchingPropertyName;
    /** Returns the token if position is in [start, end) or if position === end and includeItemAtEndPosition(token) === true */
    function getTouchingToken(sourceFile, position, includeItemAtEndPosition) {
        return getTokenAtPositionWorker(sourceFile, position, false, includeItemAtEndPosition);
    }
    ts.getTouchingToken = getTouchingToken;
    /** Returns a token if position is in [start-of-leading-trivia, end) */
    function getTokenAtPosition(sourceFile, position) {
        return getTokenAtPositionWorker(sourceFile, position, true, undefined);
    }
    ts.getTokenAtPosition = getTokenAtPosition;
    /** Get the token whose text contains the position */
    function getTokenAtPositionWorker(sourceFile, position, allowPositionInLeadingTrivia, includeItemAtEndPosition) {
        var current = sourceFile;
        outer: while (true) {
            if (isToken(current)) {
                // exit early
                return current;
            }
            for (var i = 0, n = current.getChildCount(sourceFile); i < n; i++) {
                var child = current.getChildAt(i);
                var start = allowPositionInLeadingTrivia ? child.getFullStart() : child.getStart(sourceFile);
                if (start <= position) {
                    var end = child.getEnd();
                    if (position < end || (position === end && child.kind === 1 /* EndOfFileToken */)) {
                        current = child;
                        continue outer;
                    }
                    else if (includeItemAtEndPosition && end === position) {
                        var previousToken = findPrecedingToken(position, sourceFile, child);
                        if (previousToken && includeItemAtEndPosition(previousToken)) {
                            return previousToken;
                        }
                    }
                }
            }
            return current;
        }
    }
    /**
      * The token on the left of the position is the token that strictly includes the position
      * or sits to the left of the cursor if it is on a boundary. For example
      *
      *   fo|o               -> will return foo
      *   foo <comment> |bar -> will return foo
      *
      */
    function findTokenOnLeftOfPosition(file, position) {
        // Ideally, getTokenAtPosition should return a token. However, it is currently
        // broken, so we do a check to make sure the result was indeed a token.
        var tokenAtPosition = getTokenAtPosition(file, position);
        if (isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {
            return tokenAtPosition;
        }
        return findPrecedingToken(position, file);
    }
    ts.findTokenOnLeftOfPosition = findTokenOnLeftOfPosition;
    function findNextToken(previousToken, parent) {
        return find(parent);
        function find(n) {
            if (isToken(n) && n.pos === previousToken.end) {
                // this is token that starts at the end of previous token - return it
                return n;
            }
            var children = n.getChildren();
            for (var i = 0, len = children.length; i < len; ++i) {
                var child = children[i];
                var shouldDiveInChildNode = (child.pos <= previousToken.pos && child.end > previousToken.end) || (child.pos === previousToken.end);
                if (shouldDiveInChildNode && nodeHasTokens(child)) {
                    return find(child);
                }
            }
            return undefined;
        }
    }
    ts.findNextToken = findNextToken;
    function findPrecedingToken(position, sourceFile, startNode) {
        return find(startNode || sourceFile);
        function findRightmostToken(n) {
            if (isToken(n)) {
                return n;
            }
            var children = n.getChildren();
            var candidate = findRightmostChildNodeWithTokens(children, children.length);
            return candidate && findRightmostToken(candidate);
        }
        function find(n) {
            if (isToken(n)) {
                return n;
            }
            var children = n.getChildren();
            for (var i = 0, len = children.length; i < len; ++i) {
                var child = children[i];
                if (nodeHasTokens(child)) {
                    if (position <= child.end) {
                        if (child.getStart(sourceFile) >= position) {
                            // actual start of the node is past the position - previous token should be at the end of previous child
                            var candidate = findRightmostChildNodeWithTokens(children, i);
                            return candidate && findRightmostToken(candidate);
                        }
                        else {
                            // candidate should be in this node
                            return find(child);
                        }
                    }
                }
            }
            ts.Debug.assert(startNode !== undefined || n.kind === 193 /* SourceFile */);
            // Here we know that none of child token nodes embrace the position, 
            // the only known case is when position is at the end of the file.
            // Try to find the rightmost token in the file without filtering.
            // Namely we are skipping the check: 'position < node.end'
            if (children.length) {
                var candidate = findRightmostChildNodeWithTokens(children, children.length);
                return candidate && findRightmostToken(candidate);
            }
        }
        /// finds last node that is considered as candidate for search (isCandidate(node) === true) starting from 'exclusiveStartPosition'
        function findRightmostChildNodeWithTokens(children, exclusiveStartPosition) {
            for (var i = exclusiveStartPosition - 1; i >= 0; --i) {
                if (nodeHasTokens(children[i])) {
                    return children[i];
                }
            }
        }
    }
    ts.findPrecedingToken = findPrecedingToken;
    function nodeHasTokens(n) {
        if (n.kind === 161 /* ExpressionStatement */) {
            return nodeHasTokens(n.expression);
        }
        if (n.kind === 1 /* EndOfFileToken */ || n.kind === 157 /* OmittedExpression */ || n.kind === 120 /* Missing */ || n.kind === 0 /* Unknown */) {
            return false;
        }
        // SyntaxList is already realized so getChildCount should be fast and non-expensive
        return n.kind !== 195 /* SyntaxList */ || n.getChildCount() !== 0;
    }
    function getTypeArgumentOrTypeParameterList(node) {
        if (node.kind === 132 /* TypeReference */ || node.kind === 144 /* CallExpression */) {
            return node.typeArguments;
        }
        if (ts.isAnyFunction(node) || node.kind === 184 /* ClassDeclaration */ || node.kind === 185 /* InterfaceDeclaration */) {
            return node.typeParameters;
        }
        return undefined;
    }
    ts.getTypeArgumentOrTypeParameterList = getTypeArgumentOrTypeParameterList;
    function isToken(n) {
        return n.kind >= 1 /* FirstToken */ && n.kind <= 119 /* LastToken */;
    }
    ts.isToken = isToken;
    function isWord(n) {
        return n.kind === 63 /* Identifier */ || ts.isKeyword(n.kind);
    }
    function isPropertyName(n) {
        return n.kind === 7 /* StringLiteral */ || n.kind === 6 /* NumericLiteral */ || isWord(n);
    }
    ts.switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(ts.switchToForwardSlashesRegEx, "/");
    }
    ts.switchToForwardSlashes = switchToForwardSlashes;
    function isComment(n) {
        return n.kind === 2 /* SingleLineCommentTrivia */ || n.kind === 3 /* MultiLineCommentTrivia */;
    }
    ts.isComment = isComment;
    function isPunctuation(n) {
        return 13 /* FirstPunctuation */ <= n.kind && n.kind <= 62 /* LastPunctuation */;
    }
    ts.isPunctuation = isPunctuation;
})(ts || (ts = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextSnapshot = (function () {
                function TextSnapshot(snapshot) {
                    this.snapshot = snapshot;
                    this.lines = [];
                }
                TextSnapshot.prototype.getLength = function () {
                    return this.snapshot.length();
                };
                TextSnapshot.prototype.getText = function (span) {
                    return this.snapshot.substr(span.start(), span.length());
                };
                TextSnapshot.prototype.getLineNumberFromPosition = function (position) {
                    return this.snapshot.lineMap().getLineNumberFromPosition(position);
                };
                TextSnapshot.prototype.getLineFromPosition = function (position) {
                    var lineNumber = this.getLineNumberFromPosition(position);
                    return this.getLineFromLineNumber(lineNumber);
                };
                TextSnapshot.prototype.getLineFromLineNumber = function (lineNumber) {
                    var line = this.lines[lineNumber];
                    if (line === undefined) {
                        line = this.getLineFromLineNumberWorker(lineNumber);
                        this.lines[lineNumber] = line;
                    }
                    return line;
                };
                TextSnapshot.prototype.getLineFromLineNumberWorker = function (lineNumber) {
                    var lineMap = this.snapshot.lineMap().lineStarts();
                    var lineMapIndex = lineNumber; //Note: lineMap is 0-based
                    if (lineMapIndex < 0 || lineMapIndex >= lineMap.length)
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_line_number_0, [lineMapIndex]));
                    var start = lineMap[lineMapIndex];
                    var end;
                    var endIncludingLineBreak;
                    var lineBreak = "";
                    if (lineMapIndex == lineMap.length) {
                        end = endIncludingLineBreak = this.snapshot.length();
                    }
                    else {
                        endIncludingLineBreak = (lineMapIndex >= lineMap.length - 1 ? this.snapshot.length() : lineMap[lineMapIndex + 1]);
                        for (var p = endIncludingLineBreak - 1; p >= start; p--) {
                            var c = this.snapshot.substr(p, 1);
                            //TODO: Other ones?
                            if (c != "\r" && c != "\n") {
                                break;
                            }
                        }
                        end = p + 1;
                        lineBreak = this.snapshot.substr(end, endIncludingLineBreak - end);
                    }
                    var result = new Formatting.TextSnapshotLine(this, lineNumber, start, end, lineBreak);
                    return result;
                };
                return TextSnapshot;
            })();
            Formatting.TextSnapshot = TextSnapshot;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextSnapshotLine = (function () {
                function TextSnapshotLine(_snapshot, _lineNumber, _start, _end, _lineBreak) {
                    this._snapshot = _snapshot;
                    this._lineNumber = _lineNumber;
                    this._start = _start;
                    this._end = _end;
                    this._lineBreak = _lineBreak;
                }
                TextSnapshotLine.prototype.snapshot = function () {
                    return this._snapshot;
                };
                TextSnapshotLine.prototype.start = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._start);
                };
                TextSnapshotLine.prototype.startPosition = function () {
                    return this._start;
                };
                TextSnapshotLine.prototype.end = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end);
                };
                TextSnapshotLine.prototype.endPosition = function () {
                    return this._end;
                };
                TextSnapshotLine.prototype.endIncludingLineBreak = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end + this._lineBreak.length);
                };
                TextSnapshotLine.prototype.endIncludingLineBreakPosition = function () {
                    return this._end + this._lineBreak.length;
                };
                TextSnapshotLine.prototype.length = function () {
                    return this._end - this._start;
                };
                TextSnapshotLine.prototype.lineNumber = function () {
                    return this._lineNumber;
                };
                TextSnapshotLine.prototype.getText = function () {
                    return this._snapshot.getText(TypeScript.TextSpan.fromBounds(this._start, this._end));
                };
                return TextSnapshotLine;
            })();
            Formatting.TextSnapshotLine = TextSnapshotLine;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var SnapshotPoint = (function () {
                function SnapshotPoint(snapshot, position) {
                    this.snapshot = snapshot;
                    this.position = position;
                }
                SnapshotPoint.prototype.getContainingLine = function () {
                    return this.snapshot.getLineFromPosition(this.position);
                };
                SnapshotPoint.prototype.add = function (offset) {
                    return new SnapshotPoint(this.snapshot, this.position + offset);
                };
                return SnapshotPoint;
            })();
            Formatting.SnapshotPoint = SnapshotPoint;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var FormattingContext = (function () {
                function FormattingContext(snapshot, formattingRequestKind) {
                    this.snapshot = snapshot;
                    this.formattingRequestKind = formattingRequestKind;
                    this.currentTokenSpan = null;
                    this.nextTokenSpan = null;
                    this.contextNode = null;
                    this.currentTokenParent = null;
                    this.nextTokenParent = null;
                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                    TypeScript.Debug.assert(this.snapshot != null, "snapshot is null");
                }
                FormattingContext.prototype.updateContext = function (currentTokenSpan, currentTokenParent, nextTokenSpan, nextTokenParent, commonParent) {
                    TypeScript.Debug.assert(currentTokenSpan != null, "currentTokenSpan is null");
                    TypeScript.Debug.assert(currentTokenParent != null, "currentTokenParent is null");
                    TypeScript.Debug.assert(nextTokenSpan != null, "nextTokenSpan is null");
                    TypeScript.Debug.assert(nextTokenParent != null, "nextTokenParent is null");
                    TypeScript.Debug.assert(commonParent != null, "commonParent is null");
                    this.currentTokenSpan = currentTokenSpan;
                    this.currentTokenParent = currentTokenParent;
                    this.nextTokenSpan = nextTokenSpan;
                    this.nextTokenParent = nextTokenParent;
                    this.contextNode = commonParent;
                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                };
                FormattingContext.prototype.ContextNodeAllOnSameLine = function () {
                    if (this.contextNodeAllOnSameLine === null) {
                        this.contextNodeAllOnSameLine = this.NodeIsOnOneLine(this.contextNode);
                    }
                    return this.contextNodeAllOnSameLine;
                };
                FormattingContext.prototype.NextNodeAllOnSameLine = function () {
                    if (this.nextNodeAllOnSameLine === null) {
                        this.nextNodeAllOnSameLine = this.NodeIsOnOneLine(this.nextTokenParent);
                    }
                    return this.nextNodeAllOnSameLine;
                };
                FormattingContext.prototype.TokensAreOnSameLine = function () {
                    if (this.tokensAreOnSameLine === null) {
                        var startLine = this.snapshot.getLineNumberFromPosition(this.currentTokenSpan.start());
                        var endLine = this.snapshot.getLineNumberFromPosition(this.nextTokenSpan.start());
                        this.tokensAreOnSameLine = (startLine == endLine);
                    }
                    return this.tokensAreOnSameLine;
                };
                FormattingContext.prototype.ContextNodeBlockIsOnOneLine = function () {
                    if (this.contextNodeBlockIsOnOneLine === null) {
                        this.contextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.contextNode);
                    }
                    return this.contextNodeBlockIsOnOneLine;
                };
                FormattingContext.prototype.NextNodeBlockIsOnOneLine = function () {
                    if (this.nextNodeBlockIsOnOneLine === null) {
                        this.nextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.nextTokenParent);
                    }
                    return this.nextNodeBlockIsOnOneLine;
                };
                FormattingContext.prototype.NodeIsOnOneLine = function (node) {
                    var startLine = this.snapshot.getLineNumberFromPosition(node.start());
                    var endLine = this.snapshot.getLineNumberFromPosition(node.end());
                    return startLine == endLine;
                };
                // Now we know we have a block (or a fake block represented by some other kind of node with an open and close brace as children).
                // IMPORTANT!!! This relies on the invariant that IsBlockContext must return true ONLY for nodes with open and close braces as immediate children
                FormattingContext.prototype.BlockIsOnOneLine = function (node) {
                    var block = node.node();
                    // Now check if they are on the same line
                    return this.snapshot.getLineNumberFromPosition(TypeScript.fullEnd(block.openBraceToken)) === this.snapshot.getLineNumberFromPosition(TypeScript.start(block.closeBraceToken));
                };
                return FormattingContext;
            })();
            Formatting.FormattingContext = FormattingContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var FormattingManager = (function () {
                function FormattingManager(syntaxTree, snapshot, rulesProvider, editorOptions) {
                    this.syntaxTree = syntaxTree;
                    this.snapshot = snapshot;
                    this.rulesProvider = rulesProvider;
                    //
                    // TODO: convert to use FormattingOptions instead of EditorOptions
                    this.options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
                }
                FormattingManager.prototype.formatSelection = function (minChar, limChar) {
                    var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                    return this.formatSpan(span, 1 /* FormatSelection */);
                };
                FormattingManager.prototype.formatDocument = function () {
                    var span = TypeScript.TextSpan.fromBounds(0, this.snapshot.getLength());
                    return this.formatSpan(span, 0 /* FormatDocument */);
                };
                FormattingManager.prototype.formatOnSemicolon = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var semicolonPositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);
                    if (semicolonPositionedToken.kind === 80 /* SemicolonToken */) {
                        // Find the outer most parent that this semicolon terminates
                        var current = semicolonPositionedToken;
                        while (current.parent !== null && TypeScript.fullEnd(current.parent) === TypeScript.fullEnd(semicolonPositionedToken) && current.parent.kind !== 1 /* List */) {
                            current = current.parent;
                        }
                        // Compute the span
                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));
                        // Format the span
                        return this.formatSpan(span, 3 /* FormatOnSemicolon */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatOnClosingCurlyBrace = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var closeBracePositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);
                    if (closeBracePositionedToken.kind === 73 /* CloseBraceToken */) {
                        // Find the outer most parent that this closing brace terminates
                        var current = closeBracePositionedToken;
                        while (current.parent !== null && TypeScript.fullEnd(current.parent) === TypeScript.fullEnd(closeBracePositionedToken) && current.parent.kind !== 1 /* List */) {
                            current = current.parent;
                        }
                        // Compute the span
                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));
                        // Format the span
                        return this.formatSpan(span, 4 /* FormatOnClosingCurlyBrace */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatOnEnter = function (caretPosition) {
                    var lineNumber = this.snapshot.getLineNumberFromPosition(caretPosition);
                    if (lineNumber > 0) {
                        // Format both lines
                        var prevLine = this.snapshot.getLineFromLineNumber(lineNumber - 1);
                        var currentLine = this.snapshot.getLineFromLineNumber(lineNumber);
                        var span = TypeScript.TextSpan.fromBounds(prevLine.startPosition(), currentLine.endPosition());
                        // Format the span
                        return this.formatSpan(span, 2 /* FormatOnEnter */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatSpan = function (span, formattingRequestKind) {
                    // Always format from the beginning of the line
                    var startLine = this.snapshot.getLineFromPosition(span.start());
                    span = TypeScript.TextSpan.fromBounds(startLine.startPosition(), span.end());
                    var result = [];
                    var formattingEdits = Formatting.Formatter.getEdits(span, this.syntaxTree.sourceUnit(), this.options, true, this.snapshot, this.rulesProvider, formattingRequestKind);
                    //
                    // TODO: Change the ILanguageService interface to return TextEditInfo (with start, and length) instead of TextEdit (with minChar and limChar)
                    formattingEdits.forEach(function (item) {
                        result.push({
                            span: new TypeScript.TextSpan(item.position, item.length),
                            newText: item.replaceWith
                        });
                    });
                    return result;
                };
                return FormattingManager;
            })();
            Formatting.FormattingManager = FormattingManager;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (FormattingRequestKind) {
                FormattingRequestKind[FormattingRequestKind["FormatDocument"] = 0] = "FormatDocument";
                FormattingRequestKind[FormattingRequestKind["FormatSelection"] = 1] = "FormatSelection";
                FormattingRequestKind[FormattingRequestKind["FormatOnEnter"] = 2] = "FormatOnEnter";
                FormattingRequestKind[FormattingRequestKind["FormatOnSemicolon"] = 3] = "FormatOnSemicolon";
                FormattingRequestKind[FormattingRequestKind["FormatOnClosingCurlyBrace"] = 4] = "FormatOnClosingCurlyBrace";
                FormattingRequestKind[FormattingRequestKind["FormatOnPaste"] = 5] = "FormatOnPaste";
            })(Formatting.FormattingRequestKind || (Formatting.FormattingRequestKind = {}));
            var FormattingRequestKind = Formatting.FormattingRequestKind;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Rule = (function () {
                function Rule(Descriptor, Operation, Flag) {
                    if (Flag === void 0) { Flag = 0 /* None */; }
                    this.Descriptor = Descriptor;
                    this.Operation = Operation;
                    this.Flag = Flag;
                }
                Rule.prototype.toString = function () {
                    return "[desc=" + this.Descriptor + "," + "operation=" + this.Operation + "," + "flag=" + this.Flag + "]";
                };
                return Rule;
            })();
            Formatting.Rule = Rule;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (RuleAction) {
                RuleAction[RuleAction["Ignore"] = 0] = "Ignore";
                RuleAction[RuleAction["Space"] = 1] = "Space";
                RuleAction[RuleAction["NewLine"] = 2] = "NewLine";
                RuleAction[RuleAction["Delete"] = 3] = "Delete";
            })(Formatting.RuleAction || (Formatting.RuleAction = {}));
            var RuleAction = Formatting.RuleAction;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleDescriptor = (function () {
                function RuleDescriptor(LeftTokenRange, RightTokenRange) {
                    this.LeftTokenRange = LeftTokenRange;
                    this.RightTokenRange = RightTokenRange;
                }
                RuleDescriptor.prototype.toString = function () {
                    return "[leftRange=" + this.LeftTokenRange + "," + "rightRange=" + this.RightTokenRange + "]";
                };
                RuleDescriptor.create1 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), Formatting.Shared.TokenRange.FromToken(right));
                };
                RuleDescriptor.create2 = function (left, right) {
                    return RuleDescriptor.create4(left, Formatting.Shared.TokenRange.FromToken(right));
                };
                RuleDescriptor.create3 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), right);
                };
                RuleDescriptor.create4 = function (left, right) {
                    return new RuleDescriptor(left, right);
                };
                return RuleDescriptor;
            })();
            Formatting.RuleDescriptor = RuleDescriptor;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (RuleFlags) {
                RuleFlags[RuleFlags["None"] = 0] = "None";
                RuleFlags[RuleFlags["CanDeleteNewLines"] = 1] = "CanDeleteNewLines";
            })(Formatting.RuleFlags || (Formatting.RuleFlags = {}));
            var RuleFlags = Formatting.RuleFlags;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleOperation = (function () {
                function RuleOperation() {
                    this.Context = null;
                    this.Action = null;
                }
                RuleOperation.prototype.toString = function () {
                    return "[context=" + this.Context + "," + "action=" + this.Action + "]";
                };
                RuleOperation.create1 = function (action) {
                    return RuleOperation.create2(Formatting.RuleOperationContext.Any, action);
                };
                RuleOperation.create2 = function (context, action) {
                    var result = new RuleOperation();
                    result.Context = context;
                    result.Action = action;
                    return result;
                };
                return RuleOperation;
            })();
            Formatting.RuleOperation = RuleOperation;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleOperationContext = (function () {
                function RuleOperationContext() {
                    var funcs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        funcs[_i - 0] = arguments[_i];
                    }
                    this.customContextChecks = funcs;
                }
                RuleOperationContext.prototype.IsAny = function () {
                    return this == RuleOperationContext.Any;
                };
                RuleOperationContext.prototype.InContext = function (context) {
                    if (this.IsAny()) {
                        return true;
                    }
                    for (var i = 0, len = this.customContextChecks.length; i < len; i++) {
                        if (!this.customContextChecks[i](context)) {
                            return false;
                        }
                    }
                    return true;
                };
                RuleOperationContext.Any = new RuleOperationContext();
                return RuleOperationContext;
            })();
            Formatting.RuleOperationContext = RuleOperationContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Rules = (function () {
                function Rules() {
                    ///
                    /// Common Rules
                    ///
                    // Leave comments alone
                    this.IgnoreBeforeComment = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.Comments), Formatting.RuleOperation.create1(0 /* Ignore */));
                    this.IgnoreAfterLineComment = new Formatting.Rule(Formatting.RuleDescriptor.create3(5 /* SingleLineCommentTrivia */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create1(0 /* Ignore */));
                    // Space after keyword but not before ; or : or ?
                    this.NoSpaceBeforeSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 80 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeColon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 108 /* ColonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceBeforeQMark = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 107 /* QuestionToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.SpaceAfterColon = new Formatting.Rule(Formatting.RuleDescriptor.create3(108 /* ColonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterQMark = new Formatting.Rule(Formatting.RuleDescriptor.create3(107 /* QuestionToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create3(80 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Space after }.
                    this.SpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(73 /* CloseBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsAfterCodeBlockContext), 1 /* Space */));
                    // Special case for (}, else) and (}, while) since else & while tokens are not part of the tree which makes SpaceAfterCloseBrace rule not applied
                    this.SpaceBetweenCloseBraceAndElse = new Formatting.Rule(Formatting.RuleDescriptor.create1(73 /* CloseBraceToken */, 25 /* ElseKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBetweenCloseBraceAndWhile = new Formatting.Rule(Formatting.RuleDescriptor.create1(73 /* CloseBraceToken */, 44 /* WhileKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(73 /* CloseBraceToken */, Formatting.Shared.TokenRange.FromTokens([75 /* CloseParenToken */, 77 /* CloseBracketToken */, 81 /* CommaToken */, 80 /* SemicolonToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // No space for indexer and dot
                    this.NoSpaceBeforeDot = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 78 /* DotToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterDot = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* DotToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 76 /* OpenBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(76 /* OpenBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 77 /* CloseBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(77 /* CloseBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Place a space before open brace in a function declaration
                    this.FunctionOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.AnyIncludingMultilineComments;
                    this.SpaceBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Place a space before open brace in a TypeScript declaration that has braces as children (class, module, enum, etc)
                    this.TypeScriptOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([9 /* IdentifierName */, 4 /* MultiLineCommentTrivia */]);
                    this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Place a space before open brace in a control flow construct
                    this.ControlOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([75 /* CloseParenToken */, 4 /* MultiLineCommentTrivia */, 24 /* DoKeyword */, 40 /* TryKeyword */, 27 /* FinallyKeyword */, 25 /* ElseKeyword */]);
                    this.SpaceBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Insert a space after { and before } in single-line contexts, but remove space from empty object literals {}.
                    this.SpaceAfterOpenBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.SpaceBeforeCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 73 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.NoSpaceBetweenEmptyBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(72 /* OpenBraceToken */, 73 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectContext), 3 /* Delete */));
                    // Insert new line after { and before } in multi-line contexts.
                    this.NewLineAfterOpenBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));
                    // For functions and control block place } on a new line    [multi-line rule]
                    this.NewLineBeforeCloseBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.AnyIncludingMultilineComments, 73 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));
                    // Special handling of unary operators.
                    // Prefix operators generally shouldn't have a space between
                    // them and their target unary expression.
                    this.NoSpaceAfterUnaryPrefixOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.UnaryPrefixOperators, Formatting.Shared.TokenRange.UnaryPrefixExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPreincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(95 /* PlusPlusToken */, Formatting.Shared.TokenRange.UnaryPreincrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPredecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(96 /* MinusMinusToken */, Formatting.Shared.TokenRange.UnaryPredecrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostincrementExpressions, 95 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostdecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostdecrementExpressions, 96 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // More unary operator special-casing.
                    // DevDiv 181814:  Be careful when removing leading whitespace
                    // around unary operators.  Examples:
                    //      1 - -2  --X-->  1--2
                    //      a + ++b --X-->  a+++b
                    this.SpaceAfterPostincrementWhenFollowedByAdd = new Formatting.Rule(Formatting.RuleDescriptor.create1(95 /* PlusPlusToken */, 91 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByUnaryPlus = new Formatting.Rule(Formatting.RuleDescriptor.create1(91 /* PlusToken */, 91 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByPreincrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(91 /* PlusToken */, 95 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterPostdecrementWhenFollowedBySubtract = new Formatting.Rule(Formatting.RuleDescriptor.create1(96 /* MinusMinusToken */, 92 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByUnaryMinus = new Formatting.Rule(Formatting.RuleDescriptor.create1(92 /* MinusToken */, 92 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByPredecrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(92 /* MinusToken */, 96 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.NoSpaceBeforeComma = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 81 /* CommaToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.SpaceAfterCertainKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([42 /* VarKeyword */, 38 /* ThrowKeyword */, 33 /* NewKeyword */, 23 /* DeleteKeyword */, 35 /* ReturnKeyword */, 41 /* TypeOfKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncCall = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionCallOrNewContext), 3 /* Delete */));
                    this.SpaceAfterFunctionInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create3(29 /* FunctionKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionDeclContext), 3 /* Delete */));
                    this.SpaceAfterVoidOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(43 /* VoidKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsVoidOpContext), 1 /* Space */));
                    this.NoSpaceBetweenReturnAndSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create1(35 /* ReturnKeyword */, 80 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Add a space between statements. All keywords except (do,else,case) has open/close parens after them.
                    // So, we have a rule to add a space for [),Any], [do,Any], [else,Any], and [case,Any]
                    this.SpaceBetweenStatements = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([75 /* CloseParenToken */, 24 /* DoKeyword */, 25 /* ElseKeyword */, 18 /* CaseKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotForContext), 1 /* Space */));
                    // This low-pri rule takes care of "try {" and "finally {" in case the rule SpaceBeforeOpenBraceInControl didn't execute on FormatOnEnter.
                    this.SpaceAfterTryFinally = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([40 /* TryKeyword */, 27 /* FinallyKeyword */]), 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    //      get x() {}
                    //      set x(val) {}
                    this.SpaceAfterGetSetInMember = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([66 /* GetKeyword */, 70 /* SetKeyword */]), 9 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    // Special case for binary operators (that are keywords). For these we have to add a space and shouldn't follow any user options.
                    this.SpaceBeforeBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryKeywordOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryKeywordOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    // TypeScript-specific higher priority rules
                    // Treat constructor as an identifier in a function declaration, and remove spaces between constructor and following left parentheses
                    this.NoSpaceAfterConstructor = new Formatting.Rule(Formatting.RuleDescriptor.create1(64 /* ConstructorKeyword */, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Use of module as a function call. e.g.: import m2 = module("m2");
                    this.NoSpaceAfterModuleImport = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([67 /* ModuleKeyword */, 68 /* RequireKeyword */]), 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Add a space around certain TypeScript keywords
                    this.SpaceAfterCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([46 /* ClassKeyword */, 65 /* DeclareKeyword */, 48 /* EnumKeyword */, 49 /* ExportKeyword */, 50 /* ExtendsKeyword */, 66 /* GetKeyword */, 53 /* ImplementsKeyword */, 51 /* ImportKeyword */, 54 /* InterfaceKeyword */, 67 /* ModuleKeyword */, 57 /* PrivateKeyword */, 59 /* PublicKeyword */, 70 /* SetKeyword */, 60 /* StaticKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.FromTokens([50 /* ExtendsKeyword */, 53 /* ImplementsKeyword */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Treat string literals in module names as identifiers, and add a space between the literal and the opening Brace braces, e.g.: module "m2" {
                    this.SpaceAfterModuleName = new Formatting.Rule(Formatting.RuleDescriptor.create1(12 /* StringLiteral */, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsModuleDeclContext), 1 /* Space */));
                    // Lambda expressions
                    this.SpaceAfterArrow = new Formatting.Rule(Formatting.RuleDescriptor.create3(87 /* EqualsGreaterThanToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Optional parameters and var args
                    this.NoSpaceAfterEllipsis = new Formatting.Rule(Formatting.RuleDescriptor.create1(79 /* DotDotDotToken */, 9 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOptionalParameters = new Formatting.Rule(Formatting.RuleDescriptor.create3(107 /* QuestionToken */, Formatting.Shared.TokenRange.FromTokens([75 /* CloseParenToken */, 81 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    // generics
                    this.NoSpaceBeforeOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.TypeNames, 82 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBetweenCloseParenAndAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create1(75 /* CloseParenToken */, 82 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(82 /* LessThanToken */, Formatting.Shared.TokenRange.TypeNames), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 83 /* GreaterThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(83 /* GreaterThanToken */, Formatting.Shared.TokenRange.FromTokens([74 /* OpenParenToken */, 76 /* OpenBracketToken */, 83 /* GreaterThanToken */, 81 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    // Remove spaces in empty interface literals. e.g.: x: {}
                    this.NoSpaceBetweenEmptyInterfaceBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(72 /* OpenBraceToken */, 73 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectTypeContext), 3 /* Delete */));
                    // These rules are higher in priority than user-configurable rules.
                    this.HighPriorityCommonRules = [
                        this.IgnoreBeforeComment,
                        this.IgnoreAfterLineComment,
                        this.NoSpaceBeforeColon,
                        this.SpaceAfterColon,
                        this.NoSpaceBeforeQMark,
                        this.SpaceAfterQMark,
                        this.NoSpaceBeforeDot,
                        this.NoSpaceAfterDot,
                        this.NoSpaceAfterUnaryPrefixOperator,
                        this.NoSpaceAfterUnaryPreincrementOperator,
                        this.NoSpaceAfterUnaryPredecrementOperator,
                        this.NoSpaceBeforeUnaryPostincrementOperator,
                        this.NoSpaceBeforeUnaryPostdecrementOperator,
                        this.SpaceAfterPostincrementWhenFollowedByAdd,
                        this.SpaceAfterAddWhenFollowedByUnaryPlus,
                        this.SpaceAfterAddWhenFollowedByPreincrement,
                        this.SpaceAfterPostdecrementWhenFollowedBySubtract,
                        this.SpaceAfterSubtractWhenFollowedByUnaryMinus,
                        this.SpaceAfterSubtractWhenFollowedByPredecrement,
                        this.NoSpaceAfterCloseBrace,
                        this.SpaceAfterOpenBrace,
                        this.SpaceBeforeCloseBrace,
                        this.NewLineBeforeCloseBraceInBlockContext,
                        this.SpaceAfterCloseBrace,
                        this.SpaceBetweenCloseBraceAndElse,
                        this.SpaceBetweenCloseBraceAndWhile,
                        this.NoSpaceBetweenEmptyBraceBrackets,
                        this.SpaceAfterFunctionInFuncDecl,
                        this.NewLineAfterOpenBraceInBlockContext,
                        this.SpaceAfterGetSetInMember,
                        this.NoSpaceBetweenReturnAndSemicolon,
                        this.SpaceAfterCertainKeywords,
                        this.NoSpaceBeforeOpenParenInFuncCall,
                        this.SpaceBeforeBinaryKeywordOperator,
                        this.SpaceAfterBinaryKeywordOperator,
                        this.SpaceAfterVoidOperator,
                        this.NoSpaceAfterConstructor,
                        this.NoSpaceAfterModuleImport,
                        this.SpaceAfterCertainTypeScriptKeywords,
                        this.SpaceBeforeCertainTypeScriptKeywords,
                        this.SpaceAfterModuleName,
                        this.SpaceAfterArrow,
                        this.NoSpaceAfterEllipsis,
                        this.NoSpaceAfterOptionalParameters,
                        this.NoSpaceBetweenEmptyInterfaceBraceBrackets,
                        this.NoSpaceBeforeOpenAngularBracket,
                        this.NoSpaceBetweenCloseParenAndAngularBracket,
                        this.NoSpaceAfterOpenAngularBracket,
                        this.NoSpaceBeforeCloseAngularBracket,
                        this.NoSpaceAfterCloseAngularBracket
                    ];
                    // These rules are lower in priority than user-configurable rules.
                    this.LowPriorityCommonRules = [
                        this.NoSpaceBeforeSemicolon,
                        this.SpaceBeforeOpenBraceInControl,
                        this.SpaceBeforeOpenBraceInFunction,
                        this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock,
                        this.NoSpaceBeforeComma,
                        this.NoSpaceBeforeOpenBracket,
                        this.NoSpaceAfterOpenBracket,
                        this.NoSpaceBeforeCloseBracket,
                        this.NoSpaceAfterCloseBracket,
                        this.SpaceAfterSemicolon,
                        this.NoSpaceBeforeOpenParenInFuncDecl,
                        this.SpaceBetweenStatements,
                        this.SpaceAfterTryFinally
                    ];
                    ///
                    /// Rules controlled by user options
                    ///
                    // Insert space after comma delimiter
                    this.SpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(81 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(81 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Insert space before and after binary operators
                    this.SpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.NoSpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));
                    // Insert space after keywords in control flow statements
                    this.SpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 1 /* Space */));
                    this.NoSpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 3 /* Delete */));
                    // Open Brace braces after function
                    //TypeScript: Function can have return types, which can be made of tons of different token kinds
                    this.NewLineBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Open Brace braces after TypeScript module/class/interface
                    this.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Open Brace braces after control block
                    this.NewLineBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 72 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Insert space after semicolon in for statement
                    this.SpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(80 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 1 /* Space */));
                    this.NoSpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(80 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 3 /* Delete */));
                    // Insert space after opening and before closing nonempty parenthesis
                    this.SpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(74 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 75 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBetweenParens = new Formatting.Rule(Formatting.RuleDescriptor.create1(74 /* OpenParenToken */, 75 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(74 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 75 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Insert space after function keyword for anonymous functions
                    this.SpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(29 /* FunctionKeyword */, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(29 /* FunctionKeyword */, 74 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 3 /* Delete */));
                }
                Rules.prototype.getRuleName = function (rule) {
                    var o = this;
                    for (var name in o) {
                        if (o[name] === rule) {
                            return name;
                        }
                    }
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unknown_rule, null));
                };
                ///
                /// Contexts
                ///
                Rules.IsForContext = function (context) {
                    return context.contextNode.kind() === 159 /* ForStatement */;
                };
                Rules.IsNotForContext = function (context) {
                    return !Rules.IsForContext(context);
                };
                Rules.IsBinaryOpContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 174 /* BinaryExpression */:
                        case 173 /* ConditionalExpression */:
                            return true;
                        case 138 /* ImportDeclaration */:
                        case 191 /* VariableDeclarator */:
                        case 197 /* EqualsValueClause */:
                            return context.currentTokenSpan.kind === 109 /* EqualsToken */ || context.nextTokenSpan.kind === 109 /* EqualsToken */;
                        case 160 /* ForInStatement */:
                            return context.currentTokenSpan.kind === 31 /* InKeyword */ || context.nextTokenSpan.kind === 31 /* InKeyword */;
                    }
                    return false;
                };
                Rules.IsNotBinaryOpContext = function (context) {
                    return !Rules.IsBinaryOpContext(context);
                };
                Rules.IsSameLineTokenOrBeforeMultilineBlockContext = function (context) {
                    //// This check is mainly used inside SpaceBeforeOpenBraceInControl and SpaceBeforeOpenBraceInFunction.
                    ////
                    //// Ex: 
                    //// if (1)     { ....
                    ////      * ) and { are on the same line so apply the rule. Here we don't care whether it's same or multi block context
                    ////
                    //// Ex: 
                    //// if (1)
                    //// { ... }
                    ////      * ) and { are on differnet lines. We only need to format if the block is multiline context. So in this case we don't format.
                    ////
                    //// Ex:
                    //// if (1) 
                    //// { ...
                    //// }
                    ////      * ) and { are on differnet lines. We only need to format if the block is multiline context. So in this case we format.
                    return context.TokensAreOnSameLine() || Rules.IsBeforeMultilineBlockContext(context);
                };
                // This check is done before an open brace in a control construct, a function, or a typescript block declaration
                Rules.IsBeforeMultilineBlockContext = function (context) {
                    return Rules.IsBeforeBlockContext(context) && !(context.NextNodeAllOnSameLine() || context.NextNodeBlockIsOnOneLine());
                };
                Rules.IsMultilineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && !(context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };
                Rules.IsSingleLineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && (context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };
                Rules.IsBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.contextNode);
                };
                Rules.IsBeforeBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.nextTokenParent);
                };
                // IMPORTANT!!! This method must return true ONLY for nodes with open and close braces as immediate children
                Rules.NodeIsBlockContext = function (node) {
                    if (Rules.NodeIsTypeScriptDeclWithBlockContext(node)) {
                        // This means we are in a context that looks like a block to the user, but in the grammar is actually not a node (it's a class, module, enum, object type literal, etc).
                        return true;
                    }
                    switch (node.kind()) {
                        case 151 /* Block */:
                        case 156 /* SwitchStatement */:
                        case 179 /* ObjectLiteralExpression */:
                            return true;
                    }
                    return false;
                };
                Rules.IsFunctionDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 134 /* FunctionDeclaration */:
                        case 140 /* MemberFunctionDeclaration */:
                        case 144 /* GetAccessor */:
                        case 145 /* SetAccessor */:
                        case 150 /* MethodSignature */:
                        case 147 /* CallSignature */:
                        case 186 /* FunctionExpression */:
                        case 142 /* ConstructorDeclaration */:
                        case 183 /* SimpleArrowFunctionExpression */:
                        case 182 /* ParenthesizedArrowFunctionExpression */:
                        case 133 /* InterfaceDeclaration */:
                            return true;
                    }
                    return false;
                };
                Rules.IsTypeScriptDeclWithBlockContext = function (context) {
                    return Rules.NodeIsTypeScriptDeclWithBlockContext(context.contextNode);
                };
                Rules.NodeIsTypeScriptDeclWithBlockContext = function (node) {
                    switch (node.kind()) {
                        case 136 /* ClassDeclaration */:
                        case 137 /* EnumDeclaration */:
                        case 124 /* ObjectType */:
                        case 135 /* ModuleDeclaration */:
                            return true;
                    }
                    return false;
                };
                Rules.IsAfterCodeBlockContext = function (context) {
                    switch (context.currentTokenParent.kind()) {
                        case 136 /* ClassDeclaration */:
                        case 135 /* ModuleDeclaration */:
                        case 137 /* EnumDeclaration */:
                        case 151 /* Block */:
                        case 156 /* SwitchStatement */:
                            return true;
                    }
                    return false;
                };
                Rules.IsControlDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 152 /* IfStatement */:
                        case 156 /* SwitchStatement */:
                        case 159 /* ForStatement */:
                        case 160 /* ForInStatement */:
                        case 163 /* WhileStatement */:
                        case 164 /* TryStatement */:
                        case 166 /* DoStatement */:
                        case 168 /* WithStatement */:
                        case 200 /* ElseClause */:
                        case 201 /* CatchClause */:
                        case 202 /* FinallyClause */:
                            return true;
                        default:
                            return false;
                    }
                };
                Rules.IsObjectContext = function (context) {
                    return context.contextNode.kind() === 179 /* ObjectLiteralExpression */;
                };
                Rules.IsFunctionCallContext = function (context) {
                    return context.contextNode.kind() === 177 /* InvocationExpression */;
                };
                Rules.IsNewContext = function (context) {
                    return context.contextNode.kind() === 180 /* ObjectCreationExpression */;
                };
                Rules.IsFunctionCallOrNewContext = function (context) {
                    return Rules.IsFunctionCallContext(context) || Rules.IsNewContext(context);
                };
                Rules.IsSameLineTokenContext = function (context) {
                    return context.TokensAreOnSameLine();
                };
                Rules.IsNotFormatOnEnter = function (context) {
                    return context.formattingRequestKind != 2 /* FormatOnEnter */;
                };
                Rules.IsModuleDeclContext = function (context) {
                    return context.contextNode.kind() === 135 /* ModuleDeclaration */;
                };
                Rules.IsObjectTypeContext = function (context) {
                    return context.contextNode.kind() === 124 /* ObjectType */ && context.contextNode.parent().kind() !== 133 /* InterfaceDeclaration */;
                };
                Rules.IsTypeArgumentOrParameter = function (tokenKind, parentKind) {
                    return ((tokenKind === 82 /* LessThanToken */ || tokenKind === 83 /* GreaterThanToken */) && (parentKind === 195 /* TypeParameterList */ || parentKind === 194 /* TypeArgumentList */));
                };
                Rules.IsTypeArgumentOrParameterContext = function (context) {
                    return Rules.IsTypeArgumentOrParameter(context.currentTokenSpan.kind, context.currentTokenParent.kind()) || Rules.IsTypeArgumentOrParameter(context.nextTokenSpan.kind, context.nextTokenParent.kind());
                };
                Rules.IsVoidOpContext = function (context) {
                    return context.currentTokenSpan.kind === 43 /* VoidKeyword */ && context.currentTokenParent.kind() === 172 /* VoidExpression */;
                };
                return Rules;
            })();
            Formatting.Rules = Rules;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RulesMap = (function () {
                function RulesMap() {
                    this.map = [];
                    this.mapRowLength = 0;
                }
                RulesMap.create = function (rules) {
                    var result = new RulesMap();
                    result.Initialize(rules);
                    return result;
                };
                RulesMap.prototype.Initialize = function (rules) {
                    this.mapRowLength = TypeScript.SyntaxKind.LastToken + 1;
                    this.map = new Array(this.mapRowLength * this.mapRowLength); //new Array<RulesBucket>(this.mapRowLength * this.mapRowLength);
                    // This array is used only during construction of the rulesbucket in the map
                    var rulesBucketConstructionStateList = new Array(this.map.length); //new Array<RulesBucketConstructionState>(this.map.length);
                    this.FillRules(rules, rulesBucketConstructionStateList);
                    return this.map;
                };
                RulesMap.prototype.FillRules = function (rules, rulesBucketConstructionStateList) {
                    var _this = this;
                    rules.forEach(function (rule) {
                        _this.FillRule(rule, rulesBucketConstructionStateList);
                    });
                };
                RulesMap.prototype.GetRuleBucketIndex = function (row, column) {
                    var rulesBucketIndex = (row * this.mapRowLength) + column;
                    //Debug.Assert(rulesBucketIndex < this.map.Length, "Trying to access an index outside the array.");
                    return rulesBucketIndex;
                };
                RulesMap.prototype.FillRule = function (rule, rulesBucketConstructionStateList) {
                    var _this = this;
                    var specificRule = rule.Descriptor.LeftTokenRange != Formatting.Shared.TokenRange.Any && rule.Descriptor.RightTokenRange != Formatting.Shared.TokenRange.Any;
                    rule.Descriptor.LeftTokenRange.GetTokens().forEach(function (left) {
                        rule.Descriptor.RightTokenRange.GetTokens().forEach(function (right) {
                            var rulesBucketIndex = _this.GetRuleBucketIndex(left, right);
                            var rulesBucket = _this.map[rulesBucketIndex];
                            if (rulesBucket == undefined) {
                                rulesBucket = _this.map[rulesBucketIndex] = new RulesBucket();
                            }
                            rulesBucket.AddRule(rule, specificRule, rulesBucketConstructionStateList, rulesBucketIndex);
                        });
                    });
                };
                RulesMap.prototype.GetRule = function (context) {
                    var bucketIndex = this.GetRuleBucketIndex(context.currentTokenSpan.kind, context.nextTokenSpan.kind);
                    var bucket = this.map[bucketIndex];
                    if (bucket != null) {
                        for (var i = 0, len = bucket.Rules().length; i < len; i++) {
                            var rule = bucket.Rules()[i];
                            if (rule.Operation.Context.InContext(context))
                                return rule;
                        }
                    }
                    return null;
                };
                return RulesMap;
            })();
            Formatting.RulesMap = RulesMap;
            var MaskBitSize = 5;
            var Mask = 0x1f;
            (function (RulesPosition) {
                RulesPosition[RulesPosition["IgnoreRulesSpecific"] = 0] = "IgnoreRulesSpecific";
                RulesPosition[RulesPosition["IgnoreRulesAny"] = MaskBitSize * 1] = "IgnoreRulesAny";
                RulesPosition[RulesPosition["ContextRulesSpecific"] = MaskBitSize * 2] = "ContextRulesSpecific";
                RulesPosition[RulesPosition["ContextRulesAny"] = MaskBitSize * 3] = "ContextRulesAny";
                RulesPosition[RulesPosition["NoContextRulesSpecific"] = MaskBitSize * 4] = "NoContextRulesSpecific";
                RulesPosition[RulesPosition["NoContextRulesAny"] = MaskBitSize * 5] = "NoContextRulesAny";
            })(Formatting.RulesPosition || (Formatting.RulesPosition = {}));
            var RulesPosition = Formatting.RulesPosition;
            var RulesBucketConstructionState = (function () {
                function RulesBucketConstructionState() {
                    //// The Rules list contains all the inserted rules into a rulebucket in the following order:
                    ////    1- Ignore rules with specific token combination
                    ////    2- Ignore rules with any token combination
                    ////    3- Context rules with specific token combination
                    ////    4- Context rules with any token combination
                    ////    5- Non-context rules with specific token combination
                    ////    6- Non-context rules with any token combination
                    //// 
                    //// The member rulesInsertionIndexBitmap is used to describe the number of rules
                    //// in each sub-bucket (above) hence can be used to know the index of where to insert 
                    //// the next rule. It's a bitmap which contains 6 different sections each is given 5 bits.
                    ////
                    //// Example:
                    //// In order to insert a rule to the end of sub-bucket (3), we get the index by adding
                    //// the values in the bitmap segments 3rd, 2nd, and 1st.
                    this.rulesInsertionIndexBitmap = 0;
                }
                RulesBucketConstructionState.prototype.GetInsertionIndex = function (maskPosition) {
                    var index = 0;
                    var pos = 0;
                    var indexBitmap = this.rulesInsertionIndexBitmap;
                    while (pos <= maskPosition) {
                        index += (indexBitmap & Mask);
                        indexBitmap >>= MaskBitSize;
                        pos += MaskBitSize;
                    }
                    return index;
                };
                RulesBucketConstructionState.prototype.IncreaseInsertionIndex = function (maskPosition) {
                    var value = (this.rulesInsertionIndexBitmap >> maskPosition) & Mask;
                    value++;
                    TypeScript.Debug.assert((value & Mask) == value, "Adding more rules into the sub-bucket than allowed. Maximum allowed is 32 rules.");
                    var temp = this.rulesInsertionIndexBitmap & ~(Mask << maskPosition);
                    temp |= value << maskPosition;
                    this.rulesInsertionIndexBitmap = temp;
                };
                return RulesBucketConstructionState;
            })();
            Formatting.RulesBucketConstructionState = RulesBucketConstructionState;
            var RulesBucket = (function () {
                function RulesBucket() {
                    this.rules = [];
                }
                RulesBucket.prototype.Rules = function () {
                    return this.rules;
                };
                RulesBucket.prototype.AddRule = function (rule, specificTokens, constructionState, rulesBucketIndex) {
                    var position;
                    if (rule.Operation.Action == 0 /* Ignore */) {
                        position = specificTokens ? 0 /* IgnoreRulesSpecific */ : RulesPosition.IgnoreRulesAny;
                    }
                    else if (!rule.Operation.Context.IsAny()) {
                        position = specificTokens ? RulesPosition.ContextRulesSpecific : RulesPosition.ContextRulesAny;
                    }
                    else {
                        position = specificTokens ? RulesPosition.NoContextRulesSpecific : RulesPosition.NoContextRulesAny;
                    }
                    var state = constructionState[rulesBucketIndex];
                    if (state === undefined) {
                        state = constructionState[rulesBucketIndex] = new RulesBucketConstructionState();
                    }
                    var index = state.GetInsertionIndex(position);
                    this.rules.splice(index, 0, rule);
                    state.IncreaseInsertionIndex(position);
                };
                return RulesBucket;
            })();
            Formatting.RulesBucket = RulesBucket;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RulesProvider = (function () {
                function RulesProvider(logger) {
                    this.logger = logger;
                    this.globalRules = new Formatting.Rules();
                }
                RulesProvider.prototype.getRuleName = function (rule) {
                    return this.globalRules.getRuleName(rule);
                };
                RulesProvider.prototype.getRuleByName = function (name) {
                    return this.globalRules[name];
                };
                RulesProvider.prototype.getRulesMap = function () {
                    return this.rulesMap;
                };
                RulesProvider.prototype.ensureUpToDate = function (options) {
                    if (this.options == null || !ts.compareDataObjects(this.options, options)) {
                        var activeRules = this.createActiveRules(options);
                        var rulesMap = Formatting.RulesMap.create(activeRules);
                        this.activeRules = activeRules;
                        this.rulesMap = rulesMap;
                        this.options = ts.clone(options);
                    }
                };
                RulesProvider.prototype.createActiveRules = function (options) {
                    var rules = this.globalRules.HighPriorityCommonRules.slice(0);
                    if (options.InsertSpaceAfterCommaDelimiter) {
                        rules.push(this.globalRules.SpaceAfterComma);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterComma);
                    }
                    if (options.InsertSpaceAfterFunctionKeywordForAnonymousFunctions) {
                        rules.push(this.globalRules.SpaceAfterAnonymousFunctionKeyword);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterAnonymousFunctionKeyword);
                    }
                    if (options.InsertSpaceAfterKeywordsInControlFlowStatements) {
                        rules.push(this.globalRules.SpaceAfterKeywordInControl);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterKeywordInControl);
                    }
                    if (options.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis) {
                        rules.push(this.globalRules.SpaceAfterOpenParen);
                        rules.push(this.globalRules.SpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterOpenParen);
                        rules.push(this.globalRules.NoSpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    }
                    if (options.InsertSpaceAfterSemicolonInForStatements) {
                        rules.push(this.globalRules.SpaceAfterSemicolonInFor);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterSemicolonInFor);
                    }
                    if (options.InsertSpaceBeforeAndAfterBinaryOperators) {
                        rules.push(this.globalRules.SpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.SpaceAfterBinaryOperator);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.NoSpaceAfterBinaryOperator);
                    }
                    if (options.PlaceOpenBraceOnNewLineForControlBlocks) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInControl);
                    }
                    if (options.PlaceOpenBraceOnNewLineForFunctions) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInFunction);
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock);
                    }
                    rules = rules.concat(this.globalRules.LowPriorityCommonRules);
                    return rules;
                };
                return RulesProvider;
            })();
            Formatting.RulesProvider = RulesProvider;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextEditInfo = (function () {
                function TextEditInfo(position, length, replaceWith) {
                    this.position = position;
                    this.length = length;
                    this.replaceWith = replaceWith;
                }
                TextEditInfo.prototype.toString = function () {
                    return "[ position: " + this.position + ", length: " + this.length + ", replaceWith: '" + this.replaceWith + "' ]";
                };
                return TextEditInfo;
            })();
            Formatting.TextEditInfo = TextEditInfo;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Shared;
            (function (Shared) {
                var TokenRangeAccess = (function () {
                    function TokenRangeAccess(from, to, except) {
                        this.tokens = [];
                        for (var token = from; token <= to; token++) {
                            if (except.indexOf(token) < 0) {
                                this.tokens.push(token);
                            }
                        }
                    }
                    TokenRangeAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };
                    TokenRangeAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };
                    TokenRangeAccess.prototype.toString = function () {
                        return "[tokenRangeStart=" + TypeScript.SyntaxKind[this.tokens[0]] + "," + "tokenRangeEnd=" + TypeScript.SyntaxKind[this.tokens[this.tokens.length - 1]] + "]";
                    };
                    return TokenRangeAccess;
                })();
                Shared.TokenRangeAccess = TokenRangeAccess;
                var TokenValuesAccess = (function () {
                    function TokenValuesAccess(tks) {
                        this.tokens = tks && tks.length ? tks : [];
                    }
                    TokenValuesAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };
                    TokenValuesAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };
                    return TokenValuesAccess;
                })();
                Shared.TokenValuesAccess = TokenValuesAccess;
                var TokenSingleValueAccess = (function () {
                    function TokenSingleValueAccess(token) {
                        this.token = token;
                    }
                    TokenSingleValueAccess.prototype.GetTokens = function () {
                        return [this.token];
                    };
                    TokenSingleValueAccess.prototype.Contains = function (tokenValue) {
                        return tokenValue == this.token;
                    };
                    TokenSingleValueAccess.prototype.toString = function () {
                        return "[singleTokenKind=" + TypeScript.SyntaxKind[this.token] + "]";
                    };
                    return TokenSingleValueAccess;
                })();
                Shared.TokenSingleValueAccess = TokenSingleValueAccess;
                var TokenAllAccess = (function () {
                    function TokenAllAccess() {
                    }
                    TokenAllAccess.prototype.GetTokens = function () {
                        var result = [];
                        for (var token = TypeScript.SyntaxKind.FirstToken; token <= TypeScript.SyntaxKind.LastToken; token++) {
                            result.push(token);
                        }
                        return result;
                    };
                    TokenAllAccess.prototype.Contains = function (tokenValue) {
                        return true;
                    };
                    TokenAllAccess.prototype.toString = function () {
                        return "[allTokens]";
                    };
                    return TokenAllAccess;
                })();
                Shared.TokenAllAccess = TokenAllAccess;
                var TokenRange = (function () {
                    function TokenRange(tokenAccess) {
                        this.tokenAccess = tokenAccess;
                    }
                    TokenRange.FromToken = function (token) {
                        return new TokenRange(new TokenSingleValueAccess(token));
                    };
                    TokenRange.FromTokens = function (tokens) {
                        return new TokenRange(new TokenValuesAccess(tokens));
                    };
                    TokenRange.FromRange = function (f, to, except) {
                        if (except === void 0) { except = []; }
                        return new TokenRange(new TokenRangeAccess(f, to, except));
                    };
                    TokenRange.AllTokens = function () {
                        return new TokenRange(new TokenAllAccess());
                    };
                    TokenRange.prototype.GetTokens = function () {
                        return this.tokenAccess.GetTokens();
                    };
                    TokenRange.prototype.Contains = function (token) {
                        return this.tokenAccess.Contains(token);
                    };
                    TokenRange.prototype.toString = function () {
                        return this.tokenAccess.toString();
                    };
                    TokenRange.Any = TokenRange.AllTokens();
                    TokenRange.AnyIncludingMultilineComments = TokenRange.FromTokens(TokenRange.Any.GetTokens().concat([4 /* MultiLineCommentTrivia */]));
                    TokenRange.Keywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstKeyword, TypeScript.SyntaxKind.LastKeyword);
                    TokenRange.Operators = TokenRange.FromRange(80 /* SemicolonToken */, 121 /* SlashEqualsToken */);
                    TokenRange.BinaryOperators = TokenRange.FromRange(82 /* LessThanToken */, 121 /* SlashEqualsToken */);
                    TokenRange.BinaryKeywordOperators = TokenRange.FromTokens([31 /* InKeyword */, 32 /* InstanceOfKeyword */]);
                    TokenRange.ReservedKeywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword, TypeScript.SyntaxKind.LastFutureReservedStrictKeyword);
                    TokenRange.UnaryPrefixOperators = TokenRange.FromTokens([95 /* PlusPlusToken */, 96 /* MinusMinusToken */, 104 /* TildeToken */, 103 /* ExclamationToken */]);
                    TokenRange.UnaryPrefixExpressions = TokenRange.FromTokens([11 /* NumericLiteral */, 9 /* IdentifierName */, 74 /* OpenParenToken */, 76 /* OpenBracketToken */, 72 /* OpenBraceToken */, 37 /* ThisKeyword */, 33 /* NewKeyword */]);
                    TokenRange.UnaryPreincrementExpressions = TokenRange.FromTokens([9 /* IdentifierName */, 74 /* OpenParenToken */, 37 /* ThisKeyword */, 33 /* NewKeyword */]);
                    TokenRange.UnaryPostincrementExpressions = TokenRange.FromTokens([9 /* IdentifierName */, 75 /* CloseParenToken */, 77 /* CloseBracketToken */, 33 /* NewKeyword */]);
                    TokenRange.UnaryPredecrementExpressions = TokenRange.FromTokens([9 /* IdentifierName */, 74 /* OpenParenToken */, 37 /* ThisKeyword */, 33 /* NewKeyword */]);
                    TokenRange.UnaryPostdecrementExpressions = TokenRange.FromTokens([9 /* IdentifierName */, 75 /* CloseParenToken */, 77 /* CloseBracketToken */, 33 /* NewKeyword */]);
                    TokenRange.Comments = TokenRange.FromTokens([5 /* SingleLineCommentTrivia */, 4 /* MultiLineCommentTrivia */]);
                    TokenRange.TypeNames = TokenRange.FromTokens([9 /* IdentifierName */, 69 /* NumberKeyword */, 71 /* StringKeyword */, 63 /* BooleanKeyword */, 43 /* VoidKeyword */, 62 /* AnyKeyword */]);
                    return TokenRange;
                })();
                Shared.TokenRange = TokenRange;
            })(Shared = Formatting.Shared || (Formatting.Shared = {}));
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TokenSpan = (function (_super) {
                __extends(TokenSpan, _super);
                function TokenSpan(kind, start, length) {
                    _super.call(this, start, length);
                    this.kind = kind;
                }
                return TokenSpan;
            })(TypeScript.TextSpan);
            Formatting.TokenSpan = TokenSpan;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationNodeContext = (function () {
                function IndentationNodeContext(parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this.update(parent, node, fullStart, indentationAmount, childIndentationAmountDelta);
                }
                IndentationNodeContext.prototype.parent = function () {
                    return this._parent;
                };
                IndentationNodeContext.prototype.node = function () {
                    return this._node;
                };
                IndentationNodeContext.prototype.fullStart = function () {
                    return this._fullStart;
                };
                IndentationNodeContext.prototype.fullWidth = function () {
                    return TypeScript.fullWidth(this._node);
                };
                IndentationNodeContext.prototype.start = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node);
                };
                IndentationNodeContext.prototype.end = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node) + TypeScript.width(this._node);
                };
                IndentationNodeContext.prototype.indentationAmount = function () {
                    return this._indentationAmount;
                };
                IndentationNodeContext.prototype.childIndentationAmountDelta = function () {
                    return this._childIndentationAmountDelta;
                };
                IndentationNodeContext.prototype.depth = function () {
                    return this._depth;
                };
                IndentationNodeContext.prototype.kind = function () {
                    return this._node.kind;
                };
                IndentationNodeContext.prototype.hasSkippedOrMissingTokenChild = function () {
                    if (this._hasSkippedOrMissingTokenChild === null) {
                        this._hasSkippedOrMissingTokenChild = TypeScript.Syntax.nodeHasSkippedOrMissingTokens(this._node);
                    }
                    return this._hasSkippedOrMissingTokenChild;
                };
                IndentationNodeContext.prototype.clone = function (pool) {
                    var parent = null;
                    if (this._parent) {
                        parent = this._parent.clone(pool);
                    }
                    return pool.getNode(parent, this._node, this._fullStart, this._indentationAmount, this._childIndentationAmountDelta);
                };
                IndentationNodeContext.prototype.update = function (parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this._parent = parent;
                    this._node = node;
                    this._fullStart = fullStart;
                    this._indentationAmount = indentationAmount;
                    this._childIndentationAmountDelta = childIndentationAmountDelta;
                    this._hasSkippedOrMissingTokenChild = null;
                    if (parent) {
                        this._depth = parent.depth() + 1;
                    }
                    else {
                        this._depth = 0;
                    }
                };
                return IndentationNodeContext;
            })();
            Formatting.IndentationNodeContext = IndentationNodeContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationNodeContextPool = (function () {
                function IndentationNodeContextPool() {
                    this.nodes = [];
                }
                IndentationNodeContextPool.prototype.getNode = function (parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                    if (this.nodes.length > 0) {
                        var cachedNode = this.nodes.pop();
                        cachedNode.update(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                        return cachedNode;
                    }
                    return new Formatting.IndentationNodeContext(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                };
                IndentationNodeContextPool.prototype.releaseNode = function (node, recursive) {
                    if (recursive === void 0) { recursive = false; }
                    this.nodes.push(node);
                    if (recursive) {
                        var parent = node.parent();
                        if (parent) {
                            this.releaseNode(parent, recursive);
                        }
                    }
                };
                return IndentationNodeContextPool;
            })();
            Formatting.IndentationNodeContextPool = IndentationNodeContextPool;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationTrackingWalker = (function () {
                function IndentationTrackingWalker(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    this.options = options;
                    this._position = 0;
                    this._parent = null;
                    // Create a pool object to manage context nodes while walking the tree
                    this._indentationNodeContextPool = new Formatting.IndentationNodeContextPool();
                    this._textSpan = textSpan;
                    this._text = sourceUnit.syntaxTree.text;
                    this._snapshot = snapshot;
                    this._parent = this._indentationNodeContextPool.getNode(null, sourceUnit, 0, 0, 0);
                    // Is the first token in the span at the start of a new line.
                    this._lastTriviaWasNewLine = indentFirstToken;
                }
                IndentationTrackingWalker.prototype.position = function () {
                    return this._position;
                };
                IndentationTrackingWalker.prototype.parent = function () {
                    return this._parent;
                };
                IndentationTrackingWalker.prototype.textSpan = function () {
                    return this._textSpan;
                };
                IndentationTrackingWalker.prototype.snapshot = function () {
                    return this._snapshot;
                };
                IndentationTrackingWalker.prototype.indentationNodeContextPool = function () {
                    return this._indentationNodeContextPool;
                };
                IndentationTrackingWalker.prototype.forceIndentNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = true;
                    this.forceRecomputeIndentationOfParent(tokenStart, true);
                };
                IndentationTrackingWalker.prototype.forceSkipIndentingNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = false;
                    this.forceRecomputeIndentationOfParent(tokenStart, false);
                };
                IndentationTrackingWalker.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    throw TypeScript.Errors.abstract();
                };
                IndentationTrackingWalker.prototype.visitTokenInSpan = function (token) {
                    if (this._lastTriviaWasNewLine) {
                        // Compute the indentation level at the current token
                        var indentationAmount = this.getTokenIndentationAmount(token);
                        var commentIndentationAmount = this.getCommentIndentationAmount(token);
                        // Process the token
                        this.indentToken(token, indentationAmount, commentIndentationAmount);
                    }
                };
                IndentationTrackingWalker.prototype.visitToken = function (token) {
                    var tokenSpan = new TypeScript.TextSpan(this._position, token.fullWidth());
                    if (tokenSpan.intersectsWithTextSpan(this._textSpan)) {
                        this.visitTokenInSpan(token);
                        // Only track new lines on tokens within the range. Make sure to check that the last trivia is a newline, and not just one of the trivia
                        var _nextToken = TypeScript.nextToken(token);
                        if (_nextToken && _nextToken.hasLeadingTrivia()) {
                            var trivia = _nextToken.leadingTrivia();
                            this._lastTriviaWasNewLine = trivia.hasNewLine();
                        }
                        else {
                            this._lastTriviaWasNewLine = false;
                        }
                    }
                    // Update the position
                    this._position += token.fullWidth();
                };
                IndentationTrackingWalker.prototype.walk = function (element) {
                    if (element) {
                        if (TypeScript.isToken(element)) {
                            this.visitToken(element);
                        }
                        else if (element.kind === 1 /* List */) {
                            for (var i = 0, n = TypeScript.childCount(element); i < n; i++) {
                                this.walk(TypeScript.childAt(element, i));
                            }
                        }
                        else {
                            this.visitNode(element);
                        }
                    }
                };
                IndentationTrackingWalker.prototype.visitNode = function (node) {
                    var nodeSpan = new TypeScript.TextSpan(this._position, TypeScript.fullWidth(node));
                    if (nodeSpan.intersectsWithTextSpan(this._textSpan)) {
                        // Update indentation level
                        var indentation = this.getNodeIndentation(node);
                        // Update the parent
                        var currentParent = this._parent;
                        this._parent = this._indentationNodeContextPool.getNode(currentParent, node, this._position, indentation.indentationAmount, indentation.indentationAmountDelta);
                        for (var i = 0, n = TypeScript.childCount(node); i < n; i++) {
                            this.walk(TypeScript.childAt(node, i));
                        }
                        // Reset state
                        this._indentationNodeContextPool.releaseNode(this._parent);
                        this._parent = currentParent;
                    }
                    else {
                        // We're skipping the node, so update our position accordingly.
                        this._position += TypeScript.fullWidth(node);
                    }
                };
                IndentationTrackingWalker.prototype.getTokenIndentationAmount = function (token) {
                    // If this is the first token of a node, it should follow the node indentation and not the child indentation; 
                    // (e.g.class in a class declaration or module in module declariotion).
                    // Open and close braces should follow the indentation of thier parent as well(e.g.
                    // class {
                    // }
                    // Also in a do-while statement, the while should be indented like the parent.
                    if (TypeScript.firstToken(this._parent.node()) === token || token.kind === 72 /* OpenBraceToken */ || token.kind === 73 /* CloseBraceToken */ || token.kind === 76 /* OpenBracketToken */ || token.kind === 77 /* CloseBracketToken */ || (token.kind === 44 /* WhileKeyword */ && this._parent.node().kind == 166 /* DoStatement */)) {
                        return this._parent.indentationAmount();
                    }
                    return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                };
                IndentationTrackingWalker.prototype.getCommentIndentationAmount = function (token) {
                    // If this is token terminating an indentation scope, leading comments should be indented to follow the children 
                    // indentation level and not the node
                    if (token.kind === 73 /* CloseBraceToken */ || token.kind === 77 /* CloseBracketToken */) {
                        return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                    }
                    return this._parent.indentationAmount();
                };
                IndentationTrackingWalker.prototype.getNodeIndentation = function (node, newLineInsertedByFormatting) {
                    var parent = this._parent;
                    // We need to get the parent's indentation, which could be one of 2 things. If first token of the parent is in the span, use the parent's computed indentation.
                    // If the parent was outside the span, use the actual indentation of the parent.
                    var parentIndentationAmount;
                    if (this._textSpan.containsPosition(parent.start())) {
                        parentIndentationAmount = parent.indentationAmount();
                    }
                    else {
                        if (parent.kind() === 151 /* Block */ && !this.shouldIndentBlockInParent(this._parent.parent())) {
                            // Blocks preserve the indentation of their containing node (unless they're a 
                            // standalone block in a list).  i.e. if you have:
                            //
                            //  function foo(
                            //      a: number) {
                            //
                            // Then we expect the indentation of the block to be tied to the function, not to
                            // the line that the block is defined on.  If we were to do the latter, then the 
                            // indentation would be here:
                            //
                            //  function foo(
                            //      a: number) {
                            //          |
                            //
                            // Instead of:
                            //
                            //  function foo(
                            //      a: number) {
                            //      |
                            parent = this._parent.parent();
                        }
                        var line = this._snapshot.getLineFromPosition(parent.start()).getText();
                        var firstNonWhiteSpacePosition = TypeScript.Indentation.firstNonWhitespacePosition(line);
                        parentIndentationAmount = TypeScript.Indentation.columnForPositionInString(line, firstNonWhiteSpacePosition, this.options);
                    }
                    var parentIndentationAmountDelta = parent.childIndentationAmountDelta();
                    // The indentation level of the node
                    var indentationAmount;
                    // The delta it adds to its children. 
                    var indentationAmountDelta;
                    var parentNode = parent.node();
                    switch (node.kind) {
                        default:
                            // General case
                            // This node should follow the child indentation set by its parent
                            // This node does not introduce any new indentation scope, indent any decendants of this node (tokens or child nodes)
                            // using the same indentation level
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = 0;
                            break;
                        case 136 /* ClassDeclaration */:
                        case 135 /* ModuleDeclaration */:
                        case 124 /* ObjectType */:
                        case 137 /* EnumDeclaration */:
                        case 156 /* SwitchStatement */:
                        case 179 /* ObjectLiteralExpression */:
                        case 142 /* ConstructorDeclaration */:
                        case 134 /* FunctionDeclaration */:
                        case 186 /* FunctionExpression */:
                        case 140 /* MemberFunctionDeclaration */:
                        case 144 /* GetAccessor */:
                        case 145 /* SetAccessor */:
                        case 143 /* IndexMemberDeclaration */:
                        case 201 /* CatchClause */:
                        case 178 /* ArrayLiteralExpression */:
                        case 126 /* ArrayType */:
                        case 185 /* ElementAccessExpression */:
                        case 149 /* IndexSignature */:
                        case 159 /* ForStatement */:
                        case 160 /* ForInStatement */:
                        case 163 /* WhileStatement */:
                        case 166 /* DoStatement */:
                        case 168 /* WithStatement */:
                        case 198 /* CaseSwitchClause */:
                        case 199 /* DefaultSwitchClause */:
                        case 155 /* ReturnStatement */:
                        case 162 /* ThrowStatement */:
                        case 183 /* SimpleArrowFunctionExpression */:
                        case 182 /* ParenthesizedArrowFunctionExpression */:
                        case 190 /* VariableDeclaration */:
                        case 139 /* ExportAssignment */:
                        case 177 /* InvocationExpression */:
                        case 180 /* ObjectCreationExpression */:
                        case 147 /* CallSignature */:
                        case 148 /* ConstructSignature */:
                            // These nodes should follow the child indentation set by its parent;
                            // they introduce a new indenation scope; children should be indented at one level deeper
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 152 /* IfStatement */:
                            if (parent.kind() === 200 /* ElseClause */ && !TypeScript.SyntaxUtilities.isLastTokenOnLine(parentNode.elseKeyword, this._text)) {
                                // This is an else if statement with the if on the same line as the else, do not indent the if statmement.
                                // Note: Children indentation has already been set by the parent if statement, so no need to increment
                                indentationAmount = parentIndentationAmount;
                            }
                            else {
                                // Otherwise introduce a new indenation scope; children should be indented at one level deeper
                                indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            }
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 200 /* ElseClause */:
                            // Else should always follow its parent if statement indentation.
                            // Note: Children indentation has already been set by the parent if statement, so no need to increment
                            indentationAmount = parentIndentationAmount;
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 151 /* Block */:
                            // Check if the block is a member in a list of statements (if the parent is a source unit, module, or block, or switch clause)
                            if (this.shouldIndentBlockInParent(parent)) {
                                indentationAmount = parentIndentationAmount + parentIndentationAmountDelta;
                            }
                            else {
                                indentationAmount = parentIndentationAmount;
                            }
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                    }
                    // If the parent happens to start on the same line as this node, then override the current node indenation with that 
                    // of the parent. This avoid having to add an extra level of indentation for the children. e.g.:
                    //	return {
                    //	    a:1
                    //	};
                    // instead of:
                    //	return {
                    //	        a:1
                    //	    };
                    // We also need to pass the delta (if it is nonzero) to the children, so that subsequent lines get indented. Essentially, if any node starting on the given line
                    // has a nonzero delta , the resulting delta should be inherited from this node. This is to indent cases like the following:
                    //  return a
                    //      || b;
                    // Lastly, it is possible the node indentation needs to be recomputed because the formatter inserted a newline before its first token.
                    // If this is the case, we know the node no longer starts on the same line as its parent (or at least we shouldn't treat it as such).
                    if (parentNode) {
                        if (!newLineInsertedByFormatting) {
                            var parentStartLine = this._snapshot.getLineNumberFromPosition(parent.start());
                            var currentNodeStartLine = this._snapshot.getLineNumberFromPosition(this._position + TypeScript.leadingTriviaWidth(node));
                            if (parentStartLine === currentNodeStartLine || newLineInsertedByFormatting === false) {
                                indentationAmount = parentIndentationAmount;
                                indentationAmountDelta = Math.min(this.options.indentSpaces, parentIndentationAmountDelta + indentationAmountDelta);
                            }
                        }
                    }
                    return {
                        indentationAmount: indentationAmount,
                        indentationAmountDelta: indentationAmountDelta
                    };
                };
                IndentationTrackingWalker.prototype.shouldIndentBlockInParent = function (parent) {
                    switch (parent.kind()) {
                        case 122 /* SourceUnit */:
                        case 135 /* ModuleDeclaration */:
                        case 151 /* Block */:
                        case 198 /* CaseSwitchClause */:
                        case 199 /* DefaultSwitchClause */:
                            return true;
                        default:
                            return false;
                    }
                };
                IndentationTrackingWalker.prototype.forceRecomputeIndentationOfParent = function (tokenStart, newLineAdded /*as opposed to removed*/) {
                    var parent = this._parent;
                    if (TypeScript.start(parent.node()) === tokenStart) {
                        // Temporarily pop the parent before recomputing
                        this._parent = parent.parent();
                        var indentation = this.getNodeIndentation(parent.node(), newLineAdded);
                        parent.update(parent.parent(), parent.node(), parent.fullStart(), indentation.indentationAmount, indentation.indentationAmountDelta);
                        this._parent = parent;
                    }
                };
                return IndentationTrackingWalker;
            })();
            Formatting.IndentationTrackingWalker = IndentationTrackingWalker;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var MultipleTokenIndenter = (function (_super) {
                __extends(MultipleTokenIndenter, _super);
                function MultipleTokenIndenter(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this._edits = [];
                }
                MultipleTokenIndenter.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    // Ignore generated tokens
                    if (token.fullWidth() === 0) {
                        return;
                    }
                    // If we have any skipped tokens as children, do not process this node for indentation or formatting
                    if (this.parent().hasSkippedOrMissingTokenChild()) {
                        return;
                    }
                    // Be strict, and only consider nodes that fall inside the span. This avoids indenting a multiline string
                    // on enter at the end of, as the whole token was not included in the span
                    var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                    if (!this.textSpan().containsTextSpan(tokenSpan)) {
                        return;
                    }
                    // Compute an indentation string for this token
                    var indentationString = TypeScript.Indentation.indentationString(indentationAmount, this.options);
                    var commentIndentationString = TypeScript.Indentation.indentationString(commentIndentationAmount, this.options);
                    // Record any needed indentation edits
                    this.recordIndentationEditsForToken(token, indentationString, commentIndentationString);
                };
                MultipleTokenIndenter.prototype.edits = function () {
                    return this._edits;
                };
                MultipleTokenIndenter.prototype.recordEdit = function (position, length, replaceWith) {
                    this._edits.push(new Formatting.TextEditInfo(position, length, replaceWith));
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForToken = function (token, indentationString, commentIndentationString) {
                    var position = this.position();
                    var indentNextTokenOrTrivia = true;
                    var leadingWhiteSpace = ""; // We need to track the whitespace before a multiline comment
                    // Process any leading trivia if any
                    var triviaList = token.leadingTrivia();
                    if (triviaList) {
                        var seenNewLine = position === 0;
                        for (var i = 0, length = triviaList.count(); i < length; i++, position += trivia.fullWidth()) {
                            var trivia = triviaList.syntaxTriviaAt(i);
                            // Skip all trivia up to the first newline we see.  We consider this trivia to 
                            // 'belong' to the previous token.
                            if (!seenNewLine) {
                                if (trivia.kind !== 3 /* NewLineTrivia */) {
                                    continue;
                                }
                                else {
                                    seenNewLine = true;
                                    continue;
                                }
                            }
                            // Skip this trivia if it is not in the span
                            if (!this.textSpan().containsTextSpan(new TypeScript.TextSpan(position, trivia.fullWidth()))) {
                                continue;
                            }
                            switch (trivia.kind) {
                                case 4 /* MultiLineCommentTrivia */:
                                    // We will only indent the first line of the multiline comment if we were planning to indent the next trivia. However,
                                    // subsequent lines will always be indented
                                    this.recordIndentationEditsForMultiLineComment(trivia, position, commentIndentationString, leadingWhiteSpace, !indentNextTokenOrTrivia);
                                    indentNextTokenOrTrivia = false;
                                    leadingWhiteSpace = "";
                                    break;
                                case 5 /* SingleLineCommentTrivia */:
                                case 6 /* SkippedTokenTrivia */:
                                    if (indentNextTokenOrTrivia) {
                                        this.recordIndentationEditsForSingleLineOrSkippedText(trivia, position, commentIndentationString);
                                        indentNextTokenOrTrivia = false;
                                    }
                                    break;
                                case 2 /* WhitespaceTrivia */:
                                    // If the next trivia is a comment, use the comment indentation level instead of the regular indentation level
                                    // If the next trivia is a newline, this whole line is just whitespace, so don't do anything (trimming will take care of it)
                                    var nextTrivia = length > i + 1 && triviaList.syntaxTriviaAt(i + 1);
                                    var whiteSpaceIndentationString = nextTrivia && nextTrivia.isComment() ? commentIndentationString : indentationString;
                                    if (indentNextTokenOrTrivia) {
                                        if (!(nextTrivia && nextTrivia.isNewLine())) {
                                            this.recordIndentationEditsForWhitespace(trivia, position, whiteSpaceIndentationString);
                                        }
                                        indentNextTokenOrTrivia = false;
                                    }
                                    leadingWhiteSpace += trivia.fullText();
                                    break;
                                case 3 /* NewLineTrivia */:
                                    // We hit a newline processing the trivia.  We need to add the indentation to the 
                                    // next line as well.  Note: don't bother indenting the newline itself.  This will 
                                    // just insert ugly whitespace that most users probably will not want.
                                    indentNextTokenOrTrivia = true;
                                    leadingWhiteSpace = "";
                                    break;
                                default:
                                    throw TypeScript.Errors.invalidOperation();
                            }
                        }
                    }
                    if (token.kind !== 8 /* EndOfFileToken */ && indentNextTokenOrTrivia) {
                        // If the last trivia item was a new line, or no trivia items were encounterd record the 
                        // indentation edit at the token position
                        if (indentationString.length > 0) {
                            this.recordEdit(position, 0, indentationString);
                        }
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForSingleLineOrSkippedText = function (trivia, fullStart, indentationString) {
                    // Record the edit
                    if (indentationString.length > 0) {
                        this.recordEdit(fullStart, 0, indentationString);
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForWhitespace = function (trivia, fullStart, indentationString) {
                    var text = trivia.fullText();
                    // Check if the current indentation matches the desired indentation or not
                    if (indentationString === text) {
                        return;
                    }
                    // Record the edit 
                    this.recordEdit(fullStart, text.length, indentationString);
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForMultiLineComment = function (trivia, fullStart, indentationString, leadingWhiteSpace, firstLineAlreadyIndented) {
                    // If the multiline comment spans multiple lines, we need to add the right indent amount to
                    // each successive line segment as well.
                    var position = fullStart;
                    var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    if (segments.length <= 1) {
                        if (!firstLineAlreadyIndented) {
                            // Process the one-line multiline comment just like a single line comment
                            this.recordIndentationEditsForSingleLineOrSkippedText(trivia, fullStart, indentationString);
                        }
                        return;
                    }
                    // Find number of columns in first segment
                    var whiteSpaceColumnsInFirstSegment = TypeScript.Indentation.columnForPositionInString(leadingWhiteSpace, leadingWhiteSpace.length, this.options);
                    var indentationColumns = TypeScript.Indentation.columnForPositionInString(indentationString, indentationString.length, this.options);
                    var startIndex = 0;
                    if (firstLineAlreadyIndented) {
                        startIndex = 1;
                        position += segments[0].length;
                    }
                    for (var i = startIndex; i < segments.length; i++) {
                        var segment = segments[i];
                        this.recordIndentationEditsForSegment(segment, position, indentationColumns, whiteSpaceColumnsInFirstSegment);
                        position += segment.length;
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForSegment = function (segment, fullStart, indentationColumns, whiteSpaceColumnsInFirstSegment) {
                    // Indent subsequent lines using a column delta of the actual indentation relative to the first line
                    var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
                    var leadingWhiteSpaceColumns = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
                    var deltaFromFirstSegment = leadingWhiteSpaceColumns - whiteSpaceColumnsInFirstSegment;
                    var finalColumns = indentationColumns + deltaFromFirstSegment;
                    if (finalColumns < 0) {
                        finalColumns = 0;
                    }
                    var indentationString = TypeScript.Indentation.indentationString(finalColumns, this.options);
                    if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                        // If this segment was just a newline, then don't bother indenting it.  That will just
                        // leave the user with an ugly indent in their output that they probably do not want.
                        return;
                    }
                    if (indentationString === segment.substring(0, firstNonWhitespacePosition)) {
                        return;
                    }
                    // Record the edit 
                    this.recordEdit(fullStart, firstNonWhitespacePosition, indentationString);
                };
                return MultipleTokenIndenter;
            })(Formatting.IndentationTrackingWalker);
            Formatting.MultipleTokenIndenter = MultipleTokenIndenter;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Formatter = (function (_super) {
                __extends(Formatter, _super);
                function Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this.previousTokenSpan = null;
                    this.previousTokenParent = null;
                    // TODO: implement it with skipped tokens in Fidelity
                    this.scriptHasErrors = false;
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    this.rulesProvider = rulesProvider;
                    this.formattingRequestKind = formattingRequestKind;
                    this.formattingContext = new Formatting.FormattingContext(this.snapshot(), this.formattingRequestKind);
                }
                Formatter.getEdits = function (textSpan, sourceUnit, options, indentFirstToken, snapshot, rulesProvider, formattingRequestKind) {
                    var walker = new Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind);
                    walker.walk(sourceUnit);
                    return walker.edits();
                };
                Formatter.prototype.visitTokenInSpan = function (token) {
                    if (token.fullWidth() !== 0) {
                        var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                        if (this.textSpan().containsTextSpan(tokenSpan)) {
                            this.processToken(token);
                        }
                    }
                    // Call the base class to process the token and indent it if needed
                    _super.prototype.visitTokenInSpan.call(this, token);
                };
                Formatter.prototype.processToken = function (token) {
                    var position = this.position();
                    // Extract any leading comments
                    if (token.leadingTriviaWidth() !== 0) {
                        this.processTrivia(token.leadingTrivia(), position);
                        position += token.leadingTriviaWidth();
                    }
                    // Push the token
                    var currentTokenSpan = new Formatting.TokenSpan(token.kind, position, TypeScript.width(token));
                    if (!this.parent().hasSkippedOrMissingTokenChild()) {
                        if (this.previousTokenSpan) {
                            // Note that formatPair calls TrimWhitespaceInLineRange in between the 2 tokens
                            this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                        }
                        else {
                            // We still want to trim whitespace even if it is the first trivia of the first token. Trim from the beginning of the span to the trivia
                            this.trimWhitespaceInLineRange(this.getLineNumber(this.textSpan()), this.getLineNumber(currentTokenSpan));
                        }
                    }
                    this.previousTokenSpan = currentTokenSpan;
                    if (this.previousTokenParent) {
                        // Make sure to clear the previous parent before assigning a new value to it
                        this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                    }
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    position += TypeScript.width(token);
                };
                Formatter.prototype.processTrivia = function (triviaList, fullStart) {
                    var position = fullStart;
                    for (var i = 0, n = triviaList.count(); i < n; i++) {
                        var trivia = triviaList.syntaxTriviaAt(i);
                        // For a comment, format it like it is a token. For skipped text, eat it up as a token, but skip the formatting
                        if (trivia.isComment() || trivia.isSkippedToken()) {
                            var currentTokenSpan = new Formatting.TokenSpan(trivia.kind, position, trivia.fullWidth());
                            if (this.textSpan().containsTextSpan(currentTokenSpan)) {
                                if (trivia.isComment() && this.previousTokenSpan) {
                                    // Note that formatPair calls TrimWhitespaceInLineRange in between the 2 tokens
                                    this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                                }
                                else {
                                    // We still want to trim whitespace even if it is the first trivia of the first token. Trim from the beginning of the span to the trivia
                                    var startLine = this.getLineNumber(this.previousTokenSpan || this.textSpan());
                                    this.trimWhitespaceInLineRange(startLine, this.getLineNumber(currentTokenSpan));
                                }
                                this.previousTokenSpan = currentTokenSpan;
                                if (this.previousTokenParent) {
                                    // Make sure to clear the previous parent before assigning a new value to it
                                    this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                                }
                                this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                            }
                        }
                        position += trivia.fullWidth();
                    }
                };
                Formatter.prototype.findCommonParents = function (parent1, parent2) {
                    // TODO: disable debug assert message
                    var shallowParent;
                    var shallowParentDepth;
                    var deepParent;
                    var deepParentDepth;
                    if (parent1.depth() < parent2.depth()) {
                        shallowParent = parent1;
                        shallowParentDepth = parent1.depth();
                        deepParent = parent2;
                        deepParentDepth = parent2.depth();
                    }
                    else {
                        shallowParent = parent2;
                        shallowParentDepth = parent2.depth();
                        deepParent = parent1;
                        deepParentDepth = parent1.depth();
                    }
                    TypeScript.Debug.assert(shallowParentDepth >= 0, "Expected shallowParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= 0, "Expected deepParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= shallowParentDepth, "Expected deepParentDepth >= shallowParentDepth");
                    while (deepParentDepth > shallowParentDepth) {
                        deepParent = deepParent.parent();
                        deepParentDepth--;
                    }
                    TypeScript.Debug.assert(deepParentDepth === shallowParentDepth, "Expected deepParentDepth === shallowParentDepth");
                    while (deepParent.node() && shallowParent.node()) {
                        if (deepParent.node() === shallowParent.node()) {
                            return deepParent;
                        }
                        deepParent = deepParent.parent();
                        shallowParent = shallowParent.parent();
                    }
                    throw TypeScript.Errors.invalidOperation();
                };
                Formatter.prototype.formatPair = function (t1, t1Parent, t2, t2Parent) {
                    var token1Line = this.getLineNumber(t1);
                    var token2Line = this.getLineNumber(t2);
                    // Find common parent
                    var commonParent = this.findCommonParents(t1Parent, t2Parent);
                    // Update the context
                    this.formattingContext.updateContext(t1, t1Parent, t2, t2Parent, commonParent);
                    // Find rules matching the current context
                    var rule = this.rulesProvider.getRulesMap().GetRule(this.formattingContext);
                    if (rule != null) {
                        // Record edits from the rule
                        this.RecordRuleEdits(rule, t1, t2);
                        // Handle the case where the next line is moved to be the end of this line. 
                        // In this case we don't indent the next line in the next pass.
                        if ((rule.Operation.Action == 1 /* Space */ || rule.Operation.Action == 3 /* Delete */) && token1Line != token2Line) {
                            this.forceSkipIndentingNextToken(t2.start());
                        }
                        // Handle the case where token2 is moved to the new line. 
                        // In this case we indent token2 in the next pass but we set
                        // sameLineIndent flag to notify the indenter that the indentation is within the line.
                        if (rule.Operation.Action == 2 /* NewLine */ && token1Line == token2Line) {
                            this.forceIndentNextToken(t2.start());
                        }
                    }
                    // We need to trim trailing whitespace between the tokens if they were on different lines, and no rule was applied to put them on the same line
                    if (token1Line != token2Line && (!rule || (rule.Operation.Action != 3 /* Delete */ && rule.Flag != 1 /* CanDeleteNewLines */))) {
                        this.trimWhitespaceInLineRange(token1Line, token2Line, t1);
                    }
                };
                Formatter.prototype.getLineNumber = function (span) {
                    return this.snapshot().getLineNumberFromPosition(span.start());
                };
                Formatter.prototype.trimWhitespaceInLineRange = function (startLine, endLine, token) {
                    for (var lineNumber = startLine; lineNumber < endLine; ++lineNumber) {
                        var line = this.snapshot().getLineFromLineNumber(lineNumber);
                        this.trimWhitespace(line, token);
                    }
                };
                Formatter.prototype.trimWhitespace = function (line, token) {
                    // Don't remove the trailing spaces inside comments (this includes line comments and block comments)
                    if (token && (token.kind == 4 /* MultiLineCommentTrivia */ || token.kind == 5 /* SingleLineCommentTrivia */) && token.start() <= line.endPosition() && token.end() >= line.endPosition())
                        return;
                    var text = line.getText();
                    var index = 0;
                    for (index = text.length - 1; index >= 0; --index) {
                        if (!TypeScript.CharacterInfo.isWhitespace(text.charCodeAt(index))) {
                            break;
                        }
                    }
                    ++index;
                    if (index < text.length) {
                        this.recordEdit(line.startPosition() + index, line.length() - index, "");
                    }
                };
                Formatter.prototype.RecordRuleEdits = function (rule, t1, t2) {
                    if (rule.Operation.Action == 0 /* Ignore */) {
                        return;
                    }
                    var betweenSpan;
                    switch (rule.Operation.Action) {
                        case 3 /* Delete */:
                            {
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                if (betweenSpan.length() > 0) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), "");
                                    return;
                                }
                            }
                            break;
                        case 2 /* NewLine */:
                            {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                var doEdit = false;
                                var betweenText = this.snapshot().getText(betweenSpan);
                                var lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter);
                                if (lineFeedLoc < 0) {
                                    // no linefeeds, do the edit
                                    doEdit = true;
                                }
                                else {
                                    // We only require one line feed. If there is another one, do the edit
                                    lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter, lineFeedLoc + 1);
                                    if (lineFeedLoc >= 0) {
                                        doEdit = true;
                                    }
                                }
                                if (doEdit) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), this.options.newLineCharacter);
                                    return;
                                }
                            }
                            break;
                        case 1 /* Space */:
                            {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                if (betweenSpan.length() > 1 || this.snapshot().getText(betweenSpan) != " ") {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), " ");
                                    return;
                                }
                            }
                            break;
                    }
                };
                return Formatter;
            })(Formatting.MultipleTokenIndenter);
            Formatting.Formatter = Formatter;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='..\services.ts' />
var ts;
(function (ts) {
    var formatting;
    (function (formatting) {
        var SmartIndenter;
        (function (SmartIndenter) {
            function getIndentation(position, sourceFile, options) {
                if (position > sourceFile.text.length) {
                    return 0; // past EOF
                }
                var precedingToken = ts.findPrecedingToken(position, sourceFile);
                if (!precedingToken) {
                    return 0;
                }
                // no indentation in string \regex literals
                if ((precedingToken.kind === 7 /* StringLiteral */ || precedingToken.kind === 8 /* RegularExpressionLiteral */) && precedingToken.getStart(sourceFile) <= position && precedingToken.end > position) {
                    return 0;
                }
                var lineAtPosition = sourceFile.getLineAndCharacterFromPosition(position).line;
                if (precedingToken.kind === 22 /* CommaToken */ && precedingToken.parent.kind !== 153 /* BinaryExpression */) {
                    // previous token is comma that separates items in list - find the previous item and try to derive indentation from it
                    var actualIndentation = getActualIndentationForListItemBeforeComma(precedingToken, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation;
                    }
                }
                // try to find node that can contribute to indentation and includes 'position' starting from 'precedingToken'
                // if such node is found - compute initial indentation for 'position' inside this node
                var previous;
                var current = precedingToken;
                var currentStart;
                var indentationDelta;
                while (current) {
                    if (positionBelongsToNode(current, position, sourceFile) && nodeContentIsIndented(current, previous)) {
                        currentStart = getStartLineAndCharacterForNode(current, sourceFile);
                        if (nextTokenIsCurlyBraceOnSameLineAsCursor(precedingToken, current, lineAtPosition, sourceFile)) {
                            indentationDelta = 0;
                        }
                        else {
                            indentationDelta = lineAtPosition !== currentStart.line ? options.indentSpaces : 0;
                        }
                        break;
                    }
                    // check if current node is a list item - if yes, take indentation from it
                    var actualIndentation = getActualIndentationForListItem(current, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation;
                    }
                    previous = current;
                    current = current.parent;
                }
                if (!current) {
                    // no parent was found - return 0 to be indented on the level of SourceFile
                    return 0;
                }
                var parent = current.parent;
                var parentStart;
                while (parent) {
                    // check if current node is a list item - if yes, take indentation from it
                    var actualIndentation = getActualIndentationForListItem(current, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation + indentationDelta;
                    }
                    parentStart = sourceFile.getLineAndCharacterFromPosition(parent.getStart(sourceFile));
                    var parentAndChildShareLine = parentStart.line === currentStart.line || childStartsOnTheSameLineWithElseInIfStatement(parent, current, currentStart.line, sourceFile);
                    // try to fetch actual indentation for current node from source text
                    var actualIndentation = getActualIndentationForNode(current, parent, currentStart, parentAndChildShareLine, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation + indentationDelta;
                    }
                    // increase indentation if parent node wants its content to be indented and parent and child nodes don't start on the same line
                    if (nodeContentIsIndented(parent, current) && !parentAndChildShareLine) {
                        indentationDelta += options.indentSpaces;
                    }
                    current = parent;
                    currentStart = parentStart;
                    parent = current.parent;
                }
                return indentationDelta;
            }
            SmartIndenter.getIndentation = getIndentation;
            /*
             * Function returns -1 if indentation cannot be determined
             */
            function getActualIndentationForListItemBeforeComma(commaToken, sourceFile, options) {
                // previous token is comma that separates items in list - find the previous item and try to derive indentation from it
                var commaItemInfo = ts.findListItemInfo(commaToken);
                ts.Debug.assert(commaItemInfo && commaItemInfo.listItemIndex > 0);
                // The item we're interested in is right before the comma
                return deriveActualIndentationFromList(commaItemInfo.list.getChildren(), commaItemInfo.listItemIndex - 1, sourceFile, options);
            }
            /*
             * Function returns -1 if actual indentation for node should not be used (i.e because node is nested expression)
             */
            function getActualIndentationForNode(current, parent, currentLineAndChar, parentAndChildShareLine, sourceFile, options) {
                // actual indentation is used for statements\declarations if one of cases below is true:
                // - parent is SourceFile - by default immediate children of SourceFile are not indented except when user indents them manually
                // - parent and child are not on the same line
                var useActualIndentation = (ts.isDeclaration(current) || ts.isStatement(current)) && (parent.kind === 193 /* SourceFile */ || !parentAndChildShareLine);
                if (!useActualIndentation) {
                    return -1;
                }
                return findColumnForFirstNonWhitespaceCharacterInLine(currentLineAndChar, sourceFile, options);
            }
            function nextTokenIsCurlyBraceOnSameLineAsCursor(precedingToken, current, lineAtPosition, sourceFile) {
                var nextToken = ts.findNextToken(precedingToken, current);
                if (!nextToken) {
                    return false;
                }
                if (nextToken.kind === 13 /* OpenBraceToken */) {
                    // open braces are always indented at the parent level
                    return true;
                }
                else if (nextToken.kind === 14 /* CloseBraceToken */) {
                    // close braces are indented at the parent level if they are located on the same line with cursor
                    // this means that if new line will be added at $ position, this case will be indented
                    // class A {
                    //    $
                    // }
                    /// and this one - not
                    // class A {
                    // $}
                    var nextTokenStartLine = getStartLineAndCharacterForNode(nextToken, sourceFile).line;
                    return lineAtPosition === nextTokenStartLine;
                }
                return false;
            }
            function getStartLineAndCharacterForNode(n, sourceFile) {
                return sourceFile.getLineAndCharacterFromPosition(n.getStart(sourceFile));
            }
            function positionBelongsToNode(candidate, position, sourceFile) {
                return candidate.end > position || !isCompletedNode(candidate, sourceFile);
            }
            function childStartsOnTheSameLineWithElseInIfStatement(parent, child, childStartLine, sourceFile) {
                if (parent.kind === 162 /* IfStatement */ && parent.elseStatement === child) {
                    var elseKeyword = ts.findChildOfKind(parent, 74 /* ElseKeyword */, sourceFile);
                    ts.Debug.assert(elseKeyword !== undefined);
                    var elseKeywordStartLine = getStartLineAndCharacterForNode(elseKeyword, sourceFile).line;
                    return elseKeywordStartLine === childStartLine;
                }
            }
            function getActualIndentationForListItem(node, sourceFile, options) {
                if (node.parent) {
                    switch (node.parent.kind) {
                        case 132 /* TypeReference */:
                            if (node.parent.typeArguments) {
                                return getActualIndentationFromList(node.parent.typeArguments);
                            }
                            break;
                        case 140 /* ObjectLiteral */:
                            return getActualIndentationFromList(node.parent.properties);
                        case 134 /* TypeLiteral */:
                            return getActualIndentationFromList(node.parent.members);
                        case 139 /* ArrayLiteral */:
                            return getActualIndentationFromList(node.parent.elements);
                        case 182 /* FunctionDeclaration */:
                        case 149 /* FunctionExpression */:
                        case 150 /* ArrowFunction */:
                        case 125 /* Method */:
                        case 129 /* CallSignature */:
                        case 130 /* ConstructSignature */:
                            if (node.parent.typeParameters && node.end < node.parent.typeParameters.end) {
                                return getActualIndentationFromList(node.parent.typeParameters);
                            }
                            return getActualIndentationFromList(node.parent.parameters);
                        case 145 /* NewExpression */:
                        case 144 /* CallExpression */:
                            if (node.parent.typeArguments && node.end < node.parent.typeArguments.end) {
                                return getActualIndentationFromList(node.parent.typeArguments);
                            }
                            return getActualIndentationFromList(node.parent.arguments);
                    }
                }
                return -1;
                function getActualIndentationFromList(list) {
                    var index = ts.indexOf(list, node);
                    return index !== -1 ? deriveActualIndentationFromList(list, index, sourceFile, options) : -1;
                }
            }
            function deriveActualIndentationFromList(list, index, sourceFile, options) {
                ts.Debug.assert(index >= 0 && index < list.length);
                var node = list[index];
                // walk toward the start of the list starting from current node and check if the line is the same for all items.
                // if end line for item [i - 1] differs from the start line for item [i] - find column of the first non-whitespace character on the line of item [i]
                var lineAndCharacter = getStartLineAndCharacterForNode(node, sourceFile);
                for (var i = index - 1; i >= 0; --i) {
                    if (list[i].kind === 22 /* CommaToken */) {
                        continue;
                    }
                    // skip list items that ends on the same line with the current list element
                    var prevEndLine = sourceFile.getLineAndCharacterFromPosition(list[i].end).line;
                    if (prevEndLine !== lineAndCharacter.line) {
                        return findColumnForFirstNonWhitespaceCharacterInLine(lineAndCharacter, sourceFile, options);
                    }
                    lineAndCharacter = getStartLineAndCharacterForNode(list[i], sourceFile);
                }
                return -1;
            }
            function findColumnForFirstNonWhitespaceCharacterInLine(lineAndCharacter, sourceFile, options) {
                var lineStart = sourceFile.getPositionFromLineAndCharacter(lineAndCharacter.line, 1);
                var column = 0;
                for (var i = 0; i < lineAndCharacter.character; ++i) {
                    var charCode = sourceFile.text.charCodeAt(lineStart + i);
                    if (!ts.isWhiteSpace(charCode)) {
                        return column;
                    }
                    if (charCode === 9 /* tab */) {
                        column += options.spacesPerTab;
                    }
                    else {
                        column++;
                    }
                }
                return column;
            }
            function nodeContentIsIndented(parent, child) {
                switch (parent.kind) {
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                        return true;
                    case 188 /* ModuleDeclaration */:
                        // ModuleBlock should take care of indentation
                        return false;
                    case 182 /* FunctionDeclaration */:
                    case 125 /* Method */:
                    case 149 /* FunctionExpression */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 126 /* Constructor */:
                        // FunctionBlock should take care of indentation
                        return false;
                    case 163 /* DoStatement */:
                    case 164 /* WhileStatement */:
                    case 166 /* ForInStatement */:
                    case 165 /* ForStatement */:
                        return child && child.kind !== 158 /* Block */;
                    case 162 /* IfStatement */:
                        return child && child.kind !== 158 /* Block */;
                    case 176 /* TryStatement */:
                        // TryBlock\CatchBlock\FinallyBlock should take care of indentation
                        return false;
                    case 139 /* ArrayLiteral */:
                    case 158 /* Block */:
                    case 183 /* FunctionBlock */:
                    case 177 /* TryBlock */:
                    case 178 /* CatchBlock */:
                    case 179 /* FinallyBlock */:
                    case 189 /* ModuleBlock */:
                    case 140 /* ObjectLiteral */:
                    case 134 /* TypeLiteral */:
                    case 171 /* SwitchStatement */:
                    case 173 /* DefaultClause */:
                    case 172 /* CaseClause */:
                    case 148 /* ParenExpression */:
                    case 144 /* CallExpression */:
                    case 145 /* NewExpression */:
                    case 159 /* VariableStatement */:
                    case 181 /* VariableDeclaration */:
                        return true;
                    default:
                        return false;
                }
            }
            /*
             * Checks if node ends with 'expectedLastToken'.
             * If child at position 'length - 1' is 'SemicolonToken' it is skipped and 'expectedLastToken' is compared with child at position 'length - 2'.
             */
            function nodeEndsWith(n, expectedLastToken, sourceFile) {
                var children = n.getChildren(sourceFile);
                if (children.length) {
                    var last = children[children.length - 1];
                    if (last.kind === expectedLastToken) {
                        return true;
                    }
                    else if (last.kind === 21 /* SemicolonToken */ && children.length !== 1) {
                        return children[children.length - 2].kind === expectedLastToken;
                    }
                }
                return false;
            }
            /*
             * This function is always called when position of the cursor is located after the node
             */
            function isCompletedNode(n, sourceFile) {
                switch (n.kind) {
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                    case 140 /* ObjectLiteral */:
                    case 158 /* Block */:
                    case 178 /* CatchBlock */:
                    case 179 /* FinallyBlock */:
                    case 183 /* FunctionBlock */:
                    case 189 /* ModuleBlock */:
                    case 171 /* SwitchStatement */:
                        return nodeEndsWith(n, 14 /* CloseBraceToken */, sourceFile);
                    case 148 /* ParenExpression */:
                    case 129 /* CallSignature */:
                    case 144 /* CallExpression */:
                    case 130 /* ConstructSignature */:
                        return nodeEndsWith(n, 16 /* CloseParenToken */, sourceFile);
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                    case 125 /* Method */:
                    case 150 /* ArrowFunction */:
                        return !n.body || isCompletedNode(n.body, sourceFile);
                    case 188 /* ModuleDeclaration */:
                        return n.body && isCompletedNode(n.body, sourceFile);
                    case 162 /* IfStatement */:
                        if (n.elseStatement) {
                            return isCompletedNode(n.elseStatement, sourceFile);
                        }
                        return isCompletedNode(n.thenStatement, sourceFile);
                    case 161 /* ExpressionStatement */:
                        return isCompletedNode(n.expression, sourceFile);
                    case 139 /* ArrayLiteral */:
                        return nodeEndsWith(n, 18 /* CloseBracketToken */, sourceFile);
                    case 120 /* Missing */:
                        return false;
                    case 172 /* CaseClause */:
                    case 173 /* DefaultClause */:
                        // there is no such thing as terminator token for CaseClause\DefaultClause so for simplicitly always consider them non-completed
                        return false;
                    case 164 /* WhileStatement */:
                        return isCompletedNode(n.statement, sourceFile);
                    case 163 /* DoStatement */:
                        // rough approximation: if DoStatement has While keyword - then if node is completed is checking the presence of ')';
                        var hasWhileKeyword = ts.findChildOfKind(n, 98 /* WhileKeyword */, sourceFile);
                        if (hasWhileKeyword) {
                            return nodeEndsWith(n, 16 /* CloseParenToken */, sourceFile);
                        }
                        return isCompletedNode(n.statement, sourceFile);
                    default:
                        return true;
                }
            }
        })(SmartIndenter = formatting.SmartIndenter || (formatting.SmartIndenter = {}));
    })(formatting = ts.formatting || (ts.formatting = {}));
})(ts || (ts = {}));
/////<reference path='resources\references.ts' />
/////<reference path='core\references.ts' />
/////<reference path='text\references.ts' />
/////<reference path='syntax\references.ts' />
/////<reference path='diagnostics.ts' />
/////<reference path='document.ts' />
/////<reference path='flags.ts' />
/////<reference path='hashTable.ts' />
/////<reference path='ast.ts' />
/////<reference path='astHelpers.ts' />
/////<reference path='astWalker.ts' />
/////<reference path='base64.ts' />
/////<reference path='sourceMapping.ts' />
/////<reference path='emitter.ts' />
/////<reference path='pathUtils.ts' />
/////<reference path='referenceResolution.ts' />
/////<reference path='precompile.ts' />
/////<reference path='referenceResolver.ts' />
/////<reference path='declarationEmitter.ts' />
/////<reference path='identifierWalker.ts' />
/////<reference path='settings.ts' />
/////<reference path='typecheck\pullFlags.ts' />
/////<reference path='typecheck\pullDecls.ts' />
/////<reference path='typecheck\pullSymbols.ts' />
/////<reference path='typecheck\pullTypeEnclosingTypeWalker.ts' />
/////<reference path='typecheck\pullTypeResolutionContext.ts' />
/////<reference path='typecheck\pullTypeResolution.ts' />
/////<reference path='typecheck\pullSemanticInfo.ts' />
/////<reference path='typecheck\pullDeclCollection.ts' />
/////<reference path='typecheck\pullSymbolBinder.ts' />
/////<reference path='typecheck\pullHelpers.ts' />
/////<reference path='typecheck\pullInstantiationHelpers.ts' />
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var proto = "__proto__";
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            // initialize the 'constructor' field
            this["constructor"] = undefined;
            // First we set it to null, because that's the only way to erase the value in node. Then we set it to undefined in case we are not in node, since
            // in StringHashTable below, we check for undefined explicitly.
            this[proto] = null;
            this[proto] = undefined;
        }
        return BlockIntrinsics;
    })();
    function createIntrinsicsObject() {
        return new BlockIntrinsics();
    }
    TypeScript.createIntrinsicsObject = createIntrinsicsObject;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function stripStartAndEndQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
            return str.substring(1, str.length - 1);
        }
        return str;
    }
    TypeScript.stripStartAndEndQuotes = stripStartAndEndQuotes;
    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;
    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }
    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;
    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;
    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        // If it's a UNC style path (i.e. \\server\share), convert to a URI style (i.e. file://server/share)
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }
            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }
            normalizedParts.push(part);
        }
        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
/// <reference path="..\compiler\types.ts"/>
/// <reference path="..\compiler\core.ts"/>
/// <reference path="..\compiler\scanner.ts"/>
/// <reference path="..\compiler\parser.ts"/>
/// <reference path="..\compiler\checker.ts"/>
/// <reference path='syntax\incrementalParser.ts' />
/// <reference path='outliningElementsCollector.ts' />
/// <reference path='navigationBar.ts' />
/// <reference path='breakpoints.ts' />
/// <reference path='indentation.ts' />
/// <reference path='signatureHelp.ts' />
/// <reference path='utilities.ts' />
/// <reference path='formatting\formatting.ts' />
/// <reference path='formatting\smartIndenter.ts' />
/// <reference path='core\references.ts' />
/// <reference path='resources\references.ts' />
/// <reference path='text\references.ts' />
/// <reference path='syntax\references.ts' />
/// <reference path='compiler\diagnostics.ts' />
/// <reference path='compiler\hashTable.ts' />
/// <reference path='compiler\ast.ts' />
/// <reference path='compiler\astWalker.ts' />
/// <reference path='compiler\astHelpers.ts' />
/// <reference path='compiler\pathUtils.ts' />
var ts;
(function (ts) {
    var scanner = ts.createScanner(2 /* Latest */, true);
    var emptyArray = [];
    function createNode(kind, pos, end, flags, parent) {
        var node = new (ts.getNodeConstructor(kind))();
        node.pos = pos;
        node.end = end;
        node.flags = flags;
        node.parent = parent;
        return node;
    }
    var NodeObject = (function () {
        function NodeObject() {
        }
        NodeObject.prototype.getSourceFile = function () {
            return ts.getSourceFileOfNode(this);
        };
        NodeObject.prototype.getStart = function (sourceFile) {
            return ts.getTokenPosOfNode(this, sourceFile);
        };
        NodeObject.prototype.getFullStart = function () {
            return this.pos;
        };
        NodeObject.prototype.getEnd = function () {
            return this.end;
        };
        NodeObject.prototype.getWidth = function (sourceFile) {
            return this.getEnd() - this.getStart(sourceFile);
        };
        NodeObject.prototype.getFullWidth = function () {
            return this.end - this.getFullStart();
        };
        NodeObject.prototype.getLeadingTriviaWidth = function (sourceFile) {
            return this.getStart(sourceFile) - this.pos;
        };
        NodeObject.prototype.getFullText = function (sourceFile) {
            return (sourceFile || this.getSourceFile()).text.substring(this.pos, this.end);
        };
        NodeObject.prototype.getText = function (sourceFile) {
            return (sourceFile || this.getSourceFile()).text.substring(this.getStart(), this.getEnd());
        };
        NodeObject.prototype.addSyntheticNodes = function (nodes, pos, end) {
            scanner.setTextPos(pos);
            while (pos < end) {
                var token = scanner.scan();
                var textPos = scanner.getTextPos();
                var node = nodes.push(createNode(token, pos, textPos, 512 /* Synthetic */, this));
                pos = textPos;
            }
            return pos;
        };
        NodeObject.prototype.createSyntaxList = function (nodes) {
            var list = createNode(195 /* SyntaxList */, nodes.pos, nodes.end, 512 /* Synthetic */, this);
            list._children = [];
            var pos = nodes.pos;
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                if (pos < node.pos) {
                    pos = this.addSyntheticNodes(list._children, pos, node.pos);
                }
                list._children.push(node);
                pos = node.end;
            }
            if (pos < nodes.end) {
                this.addSyntheticNodes(list._children, pos, nodes.end);
            }
            return list;
        };
        NodeObject.prototype.createChildren = function (sourceFile) {
            var _this = this;
            if (this.kind > 120 /* Missing */) {
                scanner.setText((sourceFile || this.getSourceFile()).text);
                var children = [];
                var pos = this.pos;
                var processNode = function (node) {
                    if (pos < node.pos) {
                        pos = _this.addSyntheticNodes(children, pos, node.pos);
                    }
                    children.push(node);
                    pos = node.end;
                };
                var processNodes = function (nodes) {
                    if (pos < nodes.pos) {
                        pos = _this.addSyntheticNodes(children, pos, nodes.pos);
                    }
                    children.push(_this.createSyntaxList(nodes));
                    pos = nodes.end;
                };
                ts.forEachChild(this, processNode, processNodes);
                if (pos < this.end) {
                    this.addSyntheticNodes(children, pos, this.end);
                }
                scanner.setText(undefined);
            }
            this._children = children || emptyArray;
        };
        NodeObject.prototype.getChildCount = function (sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children.length;
        };
        NodeObject.prototype.getChildAt = function (index, sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children[index];
        };
        NodeObject.prototype.getChildren = function (sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children;
        };
        NodeObject.prototype.getFirstToken = function (sourceFile) {
            var children = this.getChildren();
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.kind < 120 /* Missing */)
                    return child;
                if (child.kind > 120 /* Missing */)
                    return child.getFirstToken(sourceFile);
            }
        };
        NodeObject.prototype.getLastToken = function (sourceFile) {
            var children = this.getChildren(sourceFile);
            for (var i = children.length - 1; i >= 0; i--) {
                var child = children[i];
                if (child.kind < 120 /* Missing */)
                    return child;
                if (child.kind > 120 /* Missing */)
                    return child.getLastToken(sourceFile);
            }
        };
        return NodeObject;
    })();
    var SymbolObject = (function () {
        function SymbolObject(flags, name) {
            this.flags = flags;
            this.name = name;
        }
        SymbolObject.prototype.getFlags = function () {
            return this.flags;
        };
        SymbolObject.prototype.getName = function () {
            return this.name;
        };
        SymbolObject.prototype.getDeclarations = function () {
            return this.declarations;
        };
        SymbolObject.prototype.getDocumentationComment = function () {
            if (this.documentationComment === undefined) {
                this.documentationComment = getJsDocCommentsFromDeclarations(this.declarations, this.name, !(this.flags & 4 /* Property */));
            }
            return this.documentationComment;
        };
        return SymbolObject;
    })();
    function getJsDocCommentsFromDeclarations(declarations, name, canUseParsedParamTagComments) {
        var documentationComment = [];
        var docComments = getJsDocCommentsSeparatedByNewLines();
        ts.forEach(docComments, function (docComment) {
            if (documentationComment.length) {
                documentationComment.push(lineBreakPart());
            }
            documentationComment.push(docComment);
        });
        return documentationComment;
        function getJsDocCommentsSeparatedByNewLines() {
            var paramTag = "@param";
            var jsDocCommentParts = [];
            ts.forEach(declarations, function (declaration) {
                var sourceFileOfDeclaration = ts.getSourceFileOfNode(declaration);
                // If it is parameter - try and get the jsDoc comment with @param tag from function declaration's jsDoc comments
                if (canUseParsedParamTagComments && declaration.kind === 123 /* Parameter */) {
                    ts.forEach(getJsDocCommentTextRange(declaration.parent, sourceFileOfDeclaration), function (jsDocCommentTextRange) {
                        var cleanedParamJsDocComment = getCleanedParamJsDocComment(jsDocCommentTextRange.pos, jsDocCommentTextRange.end, sourceFileOfDeclaration);
                        if (cleanedParamJsDocComment) {
                            jsDocCommentParts.push.apply(jsDocCommentParts, cleanedParamJsDocComment);
                        }
                    });
                }
                // If this is left side of dotted module declaration, there is no doc comments associated with this node
                if (declaration.kind === 188 /* ModuleDeclaration */ && declaration.body.kind === 188 /* ModuleDeclaration */) {
                    return;
                }
                while (declaration.kind === 188 /* ModuleDeclaration */ && declaration.parent.kind === 188 /* ModuleDeclaration */) {
                    declaration = declaration.parent;
                }
                // Get the cleaned js doc comment text from the declaration
                ts.forEach(getJsDocCommentTextRange(declaration.kind === 181 /* VariableDeclaration */ ? declaration.parent : declaration, sourceFileOfDeclaration), function (jsDocCommentTextRange) {
                    var cleanedJsDocComment = getCleanedJsDocComment(jsDocCommentTextRange.pos, jsDocCommentTextRange.end, sourceFileOfDeclaration);
                    if (cleanedJsDocComment) {
                        jsDocCommentParts.push.apply(jsDocCommentParts, cleanedJsDocComment);
                    }
                });
            });
            return jsDocCommentParts;
            function getJsDocCommentTextRange(node, sourceFile) {
                return ts.map(ts.getJsDocComments(node, sourceFile), function (jsDocComment) {
                    return {
                        pos: jsDocComment.pos + "/*".length,
                        end: jsDocComment.end - "*/".length // Trim off comment end indicator 
                    };
                });
            }
            function consumeWhiteSpacesOnTheLine(pos, end, sourceFile, maxSpacesToRemove) {
                if (maxSpacesToRemove !== undefined) {
                    end = Math.min(end, pos + maxSpacesToRemove);
                }
                for (; pos < end; pos++) {
                    var ch = sourceFile.text.charCodeAt(pos);
                    if (!ts.isWhiteSpace(ch) || ts.isLineBreak(ch)) {
                        // Either found lineBreak or non whiteSpace
                        return pos;
                    }
                }
                return end;
            }
            function consumeLineBreaks(pos, end, sourceFile) {
                while (pos < end && ts.isLineBreak(sourceFile.text.charCodeAt(pos))) {
                    pos++;
                }
                return pos;
            }
            function isName(pos, end, sourceFile, name) {
                return pos + name.length < end && sourceFile.text.substr(pos, name.length) === name && (ts.isWhiteSpace(sourceFile.text.charCodeAt(pos + name.length)) || ts.isLineBreak(sourceFile.text.charCodeAt(pos + name.length)));
            }
            function isParamTag(pos, end, sourceFile) {
                // If it is @param tag
                return isName(pos, end, sourceFile, paramTag);
            }
            function pushDocCommentLineText(docComments, text, blankLineCount) {
                while (blankLineCount--)
                    docComments.push(textPart(""));
                docComments.push(textPart(text));
            }
            function getCleanedJsDocComment(pos, end, sourceFile) {
                var spacesToRemoveAfterAsterisk;
                var docComments = [];
                var blankLineCount = 0;
                var isInParamTag = false;
                while (pos < end) {
                    var docCommentTextOfLine = "";
                    // First consume leading white space
                    pos = consumeWhiteSpacesOnTheLine(pos, end, sourceFile);
                    // If the comment starts with '*' consume the spaces on this line
                    if (pos < end && sourceFile.text.charCodeAt(pos) === 42 /* asterisk */) {
                        var lineStartPos = pos + 1;
                        pos = consumeWhiteSpacesOnTheLine(pos + 1, end, sourceFile, spacesToRemoveAfterAsterisk);
                        // Set the spaces to remove after asterisk as margin if not already set
                        if (spacesToRemoveAfterAsterisk === undefined && pos < end && !ts.isLineBreak(sourceFile.text.charCodeAt(pos))) {
                            spacesToRemoveAfterAsterisk = pos - lineStartPos;
                        }
                    }
                    else if (spacesToRemoveAfterAsterisk === undefined) {
                        spacesToRemoveAfterAsterisk = 0;
                    }
                    while (pos < end && !ts.isLineBreak(sourceFile.text.charCodeAt(pos))) {
                        var ch = sourceFile.text.charAt(pos);
                        if (ch === "@") {
                            // If it is @param tag
                            if (isParamTag(pos, end, sourceFile)) {
                                isInParamTag = true;
                                pos += paramTag.length;
                                continue;
                            }
                            else {
                                isInParamTag = false;
                            }
                        }
                        // Add the ch to doc text if we arent in param tag
                        if (!isInParamTag) {
                            docCommentTextOfLine += ch;
                        }
                        // Scan next character
                        pos++;
                    }
                    // Continue with next line
                    pos = consumeLineBreaks(pos, end, sourceFile);
                    if (docCommentTextOfLine) {
                        pushDocCommentLineText(docComments, docCommentTextOfLine, blankLineCount);
                        blankLineCount = 0;
                    }
                    else if (!isInParamTag && docComments.length) {
                        // This is blank line when there is text already parsed
                        blankLineCount++;
                    }
                }
                return docComments;
            }
            function getCleanedParamJsDocComment(pos, end, sourceFile) {
                var paramHelpStringMargin;
                var paramDocComments = [];
                while (pos < end) {
                    if (isParamTag(pos, end, sourceFile)) {
                        var blankLineCount = 0;
                        var recordedParamTag = false;
                        // Consume leading spaces 
                        pos = consumeWhiteSpaces(pos + paramTag.length);
                        if (pos >= end) {
                            break;
                        }
                        // Ignore type expression
                        if (sourceFile.text.charCodeAt(pos) === 123 /* openBrace */) {
                            pos++;
                            for (var curlies = 1; pos < end; pos++) {
                                var charCode = sourceFile.text.charCodeAt(pos);
                                // { character means we need to find another } to match the found one
                                if (charCode === 123 /* openBrace */) {
                                    curlies++;
                                    continue;
                                }
                                // } char
                                if (charCode === 125 /* closeBrace */) {
                                    curlies--;
                                    if (curlies === 0) {
                                        // We do not have any more } to match the type expression is ignored completely
                                        pos++;
                                        break;
                                    }
                                    else {
                                        continue;
                                    }
                                }
                                // Found start of another tag
                                if (charCode === 64 /* at */) {
                                    break;
                                }
                            }
                            // Consume white spaces
                            pos = consumeWhiteSpaces(pos);
                            if (pos >= end) {
                                break;
                            }
                        }
                        // Parameter name
                        if (isName(pos, end, sourceFile, name)) {
                            // Found the parameter we are looking for consume white spaces
                            pos = consumeWhiteSpaces(pos + name.length);
                            if (pos >= end) {
                                break;
                            }
                            var paramHelpString = "";
                            var firstLineParamHelpStringPos = pos;
                            while (pos < end) {
                                var ch = sourceFile.text.charCodeAt(pos);
                                // at line break, set this comment line text and go to next line 
                                if (ts.isLineBreak(ch)) {
                                    if (paramHelpString) {
                                        pushDocCommentLineText(paramDocComments, paramHelpString, blankLineCount);
                                        paramHelpString = "";
                                        blankLineCount = 0;
                                        recordedParamTag = true;
                                    }
                                    else if (recordedParamTag) {
                                        blankLineCount++;
                                    }
                                    // Get the pos after cleaning start of the line
                                    setPosForParamHelpStringOnNextLine(firstLineParamHelpStringPos);
                                    continue;
                                }
                                // Done scanning param help string - next tag found
                                if (ch === 64 /* at */) {
                                    break;
                                }
                                paramHelpString += sourceFile.text.charAt(pos);
                                // Go to next character
                                pos++;
                            }
                            // If there is param help text, add it top the doc comments
                            if (paramHelpString) {
                                pushDocCommentLineText(paramDocComments, paramHelpString, blankLineCount);
                            }
                            paramHelpStringMargin = undefined;
                        }
                        // If this is the start of another tag, continue with the loop in seach of param tag with symbol name
                        if (sourceFile.text.charCodeAt(pos) === 64 /* at */) {
                            continue;
                        }
                    }
                    // Next character
                    pos++;
                }
                return paramDocComments;
                function consumeWhiteSpaces(pos) {
                    while (pos < end && ts.isWhiteSpace(sourceFile.text.charCodeAt(pos))) {
                        pos++;
                    }
                    return pos;
                }
                function setPosForParamHelpStringOnNextLine(firstLineParamHelpStringPos) {
                    // Get the pos after consuming line breaks
                    pos = consumeLineBreaks(pos, end, sourceFile);
                    if (pos >= end) {
                        return;
                    }
                    if (paramHelpStringMargin === undefined) {
                        paramHelpStringMargin = sourceFile.getLineAndCharacterFromPosition(firstLineParamHelpStringPos).character - 1;
                    }
                    // Now consume white spaces max 
                    var startOfLinePos = pos;
                    pos = consumeWhiteSpacesOnTheLine(pos, end, sourceFile, paramHelpStringMargin);
                    if (pos >= end) {
                        return;
                    }
                    var consumedSpaces = pos - startOfLinePos;
                    if (consumedSpaces < paramHelpStringMargin) {
                        var ch = sourceFile.text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */) {
                            // Consume more spaces after asterisk
                            pos = consumeWhiteSpacesOnTheLine(pos + 1, end, sourceFile, paramHelpStringMargin - consumedSpaces - 1);
                        }
                    }
                }
            }
        }
    }
    var TypeObject = (function () {
        function TypeObject(checker, flags) {
            this.checker = checker;
            this.flags = flags;
        }
        TypeObject.prototype.getFlags = function () {
            return this.flags;
        };
        TypeObject.prototype.getSymbol = function () {
            return this.symbol;
        };
        TypeObject.prototype.getProperties = function () {
            return this.checker.getPropertiesOfType(this);
        };
        TypeObject.prototype.getProperty = function (propertyName) {
            return this.checker.getPropertyOfType(this, propertyName);
        };
        TypeObject.prototype.getApparentProperties = function () {
            return this.checker.getAugmentedPropertiesOfType(this);
        };
        TypeObject.prototype.getCallSignatures = function () {
            return this.checker.getSignaturesOfType(this, 0 /* Call */);
        };
        TypeObject.prototype.getConstructSignatures = function () {
            return this.checker.getSignaturesOfType(this, 1 /* Construct */);
        };
        TypeObject.prototype.getStringIndexType = function () {
            return this.checker.getIndexTypeOfType(this, 0 /* String */);
        };
        TypeObject.prototype.getNumberIndexType = function () {
            return this.checker.getIndexTypeOfType(this, 1 /* Number */);
        };
        return TypeObject;
    })();
    var SignatureObject = (function () {
        function SignatureObject(checker) {
            this.checker = checker;
        }
        SignatureObject.prototype.getDeclaration = function () {
            return this.declaration;
        };
        SignatureObject.prototype.getTypeParameters = function () {
            return this.typeParameters;
        };
        SignatureObject.prototype.getParameters = function () {
            return this.parameters;
        };
        SignatureObject.prototype.getReturnType = function () {
            return this.checker.getReturnTypeOfSignature(this);
        };
        SignatureObject.prototype.getDocumentationComment = function () {
            if (this.documentationComment === undefined) {
                this.documentationComment = this.declaration ? getJsDocCommentsFromDeclarations([this.declaration], undefined, false) : [];
            }
            return this.documentationComment;
        };
        return SignatureObject;
    })();
    var incrementalParse = TypeScript.IncrementalParser.parse;
    var SourceFileObject = (function (_super) {
        __extends(SourceFileObject, _super);
        function SourceFileObject() {
            _super.apply(this, arguments);
        }
        SourceFileObject.prototype.getLineAndCharacterFromPosition = function (position) {
            return null;
        };
        SourceFileObject.prototype.getPositionFromLineAndCharacter = function (line, character) {
            return -1;
        };
        SourceFileObject.prototype.getScriptSnapshot = function () {
            return this.scriptSnapshot;
        };
        SourceFileObject.prototype.getNamedDeclarations = function () {
            if (!this.namedDeclarations) {
                var sourceFile = this;
                var namedDeclarations = [];
                ts.forEachChild(sourceFile, function visit(node) {
                    switch (node.kind) {
                        case 182 /* FunctionDeclaration */:
                        case 125 /* Method */:
                            var functionDeclaration = node;
                            if (functionDeclaration.name && functionDeclaration.name.kind !== 120 /* Missing */) {
                                var lastDeclaration = namedDeclarations.length > 0 ? namedDeclarations[namedDeclarations.length - 1] : undefined;
                                // Check whether this declaration belongs to an "overload group".
                                if (lastDeclaration && functionDeclaration.symbol === lastDeclaration.symbol) {
                                    // Overwrite the last declaration if it was an overload
                                    // and this one is an implementation.
                                    if (functionDeclaration.body && !lastDeclaration.body) {
                                        namedDeclarations[namedDeclarations.length - 1] = functionDeclaration;
                                    }
                                }
                                else {
                                    namedDeclarations.push(node);
                                }
                                ts.forEachChild(node, visit);
                            }
                            break;
                        case 184 /* ClassDeclaration */:
                        case 185 /* InterfaceDeclaration */:
                        case 186 /* TypeAliasDeclaration */:
                        case 187 /* EnumDeclaration */:
                        case 188 /* ModuleDeclaration */:
                        case 190 /* ImportDeclaration */:
                        case 127 /* GetAccessor */:
                        case 128 /* SetAccessor */:
                        case 134 /* TypeLiteral */:
                            if (node.name) {
                                namedDeclarations.push(node);
                            }
                        case 126 /* Constructor */:
                        case 159 /* VariableStatement */:
                        case 189 /* ModuleBlock */:
                        case 183 /* FunctionBlock */:
                            ts.forEachChild(node, visit);
                            break;
                        case 123 /* Parameter */:
                            // Only consider properties defined as constructor parameters
                            if (!(node.flags & 112 /* AccessibilityModifier */)) {
                                break;
                            }
                        case 181 /* VariableDeclaration */:
                        case 192 /* EnumMember */:
                        case 124 /* Property */:
                            namedDeclarations.push(node);
                            break;
                    }
                });
                this.namedDeclarations = namedDeclarations;
            }
            return this.namedDeclarations;
        };
        SourceFileObject.prototype.isDeclareFile = function () {
            return TypeScript.isDTSFile(this.filename);
        };
        SourceFileObject.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange) {
            if (textChangeRange && ts.Debug.shouldAssert(1 /* Normal */)) {
                var oldText = this.scriptSnapshot;
                var newText = scriptSnapshot;
                TypeScript.Debug.assert((oldText.getLength() - textChangeRange.span().length() + textChangeRange.newLength()) === newText.getLength());
                if (ts.Debug.shouldAssert(3 /* VeryAggressive */)) {
                    var oldTextPrefix = oldText.getText(0, textChangeRange.span().start());
                    var newTextPrefix = newText.getText(0, textChangeRange.span().start());
                    TypeScript.Debug.assert(oldTextPrefix === newTextPrefix);
                    var oldTextSuffix = oldText.getText(textChangeRange.span().end(), oldText.getLength());
                    var newTextSuffix = newText.getText(textChangeRange.newSpan().end(), newText.getLength());
                    TypeScript.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }
            return SourceFileObject.createSourceFileObject(this.filename, scriptSnapshot, this.languageVersion, version, isOpen);
        };
        SourceFileObject.createSourceFileObject = function (filename, scriptSnapshot, languageVersion, version, isOpen) {
            var newSourceFile = ts.createSourceFile(filename, scriptSnapshot.getText(0, scriptSnapshot.getLength()), languageVersion, version, isOpen);
            newSourceFile.scriptSnapshot = scriptSnapshot;
            return newSourceFile;
        };
        return SourceFileObject;
    })(NodeObject);
    var TextChange = (function () {
        function TextChange() {
        }
        return TextChange;
    })();
    ts.TextChange = TextChange;
    (function (SymbolDisplayPartKind) {
        SymbolDisplayPartKind[SymbolDisplayPartKind["aliasName"] = 0] = "aliasName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["className"] = 1] = "className";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumName"] = 2] = "enumName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["fieldName"] = 3] = "fieldName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["interfaceName"] = 4] = "interfaceName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["keyword"] = 5] = "keyword";
        SymbolDisplayPartKind[SymbolDisplayPartKind["lineBreak"] = 6] = "lineBreak";
        SymbolDisplayPartKind[SymbolDisplayPartKind["numericLiteral"] = 7] = "numericLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["stringLiteral"] = 8] = "stringLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["localName"] = 9] = "localName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["methodName"] = 10] = "methodName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["moduleName"] = 11] = "moduleName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["operator"] = 12] = "operator";
        SymbolDisplayPartKind[SymbolDisplayPartKind["parameterName"] = 13] = "parameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["propertyName"] = 14] = "propertyName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["punctuation"] = 15] = "punctuation";
        SymbolDisplayPartKind[SymbolDisplayPartKind["space"] = 16] = "space";
        SymbolDisplayPartKind[SymbolDisplayPartKind["text"] = 17] = "text";
        SymbolDisplayPartKind[SymbolDisplayPartKind["typeParameterName"] = 18] = "typeParameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumMemberName"] = 19] = "enumMemberName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["functionName"] = 20] = "functionName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["regularExpressionLiteral"] = 21] = "regularExpressionLiteral";
    })(ts.SymbolDisplayPartKind || (ts.SymbolDisplayPartKind = {}));
    var SymbolDisplayPartKind = ts.SymbolDisplayPartKind;
    (function (TokenClass) {
        TokenClass[TokenClass["Punctuation"] = 0] = "Punctuation";
        TokenClass[TokenClass["Keyword"] = 1] = "Keyword";
        TokenClass[TokenClass["Operator"] = 2] = "Operator";
        TokenClass[TokenClass["Comment"] = 3] = "Comment";
        TokenClass[TokenClass["Whitespace"] = 4] = "Whitespace";
        TokenClass[TokenClass["Identifier"] = 5] = "Identifier";
        TokenClass[TokenClass["NumberLiteral"] = 6] = "NumberLiteral";
        TokenClass[TokenClass["StringLiteral"] = 7] = "StringLiteral";
        TokenClass[TokenClass["RegExpLiteral"] = 8] = "RegExpLiteral";
    })(ts.TokenClass || (ts.TokenClass = {}));
    var TokenClass = ts.TokenClass;
    // TODO: move these to enums
    var ScriptElementKind = (function () {
        function ScriptElementKind() {
        }
        ScriptElementKind.unknown = "";
        // predefined type (void) or keyword (class)
        ScriptElementKind.keyword = "keyword";
        // top level script node
        ScriptElementKind.scriptElement = "script";
        // module foo {}
        ScriptElementKind.moduleElement = "module";
        // class X {}
        ScriptElementKind.classElement = "class";
        // interface Y {}
        ScriptElementKind.interfaceElement = "interface";
        // type T = ...
        ScriptElementKind.typeElement = "type";
        // enum E
        ScriptElementKind.enumElement = "enum";
        // Inside module and script only
        // var v = ..
        ScriptElementKind.variableElement = "var";
        // Inside function
        ScriptElementKind.localVariableElement = "local var";
        // Inside module and script only
        // function f() { }
        ScriptElementKind.functionElement = "function";
        // Inside function
        ScriptElementKind.localFunctionElement = "local function";
        // class X { [public|private]* foo() {} }
        ScriptElementKind.memberFunctionElement = "method";
        // class X { [public|private]* [get|set] foo:number; }
        ScriptElementKind.memberGetAccessorElement = "getter";
        ScriptElementKind.memberSetAccessorElement = "setter";
        // class X { [public|private]* foo:number; }
        // interface Y { foo:number; }
        ScriptElementKind.memberVariableElement = "property";
        // class X { constructor() { } }
        ScriptElementKind.constructorImplementationElement = "constructor";
        // interface Y { ():number; }
        ScriptElementKind.callSignatureElement = "call";
        // interface Y { []:number; }
        ScriptElementKind.indexSignatureElement = "index";
        // interface Y { new():Y; }
        ScriptElementKind.constructSignatureElement = "construct";
        // function foo(*Y*: string)
        ScriptElementKind.parameterElement = "parameter";
        ScriptElementKind.typeParameterElement = "type parameter";
        ScriptElementKind.primitiveType = "primitive type";
        ScriptElementKind.label = "label";
        ScriptElementKind.alias = "alias";
        ScriptElementKind.constantElement = "constant";
        return ScriptElementKind;
    })();
    ts.ScriptElementKind = ScriptElementKind;
    var ScriptElementKindModifier = (function () {
        function ScriptElementKindModifier() {
        }
        ScriptElementKindModifier.none = "";
        ScriptElementKindModifier.publicMemberModifier = "public";
        ScriptElementKindModifier.privateMemberModifier = "private";
        ScriptElementKindModifier.protectedMemberModifier = "protected";
        ScriptElementKindModifier.exportedModifier = "export";
        ScriptElementKindModifier.ambientModifier = "declare";
        ScriptElementKindModifier.staticModifier = "static";
        return ScriptElementKindModifier;
    })();
    ts.ScriptElementKindModifier = ScriptElementKindModifier;
    var ClassificationTypeNames = (function () {
        function ClassificationTypeNames() {
        }
        ClassificationTypeNames.comment = "comment";
        ClassificationTypeNames.identifier = "identifier";
        ClassificationTypeNames.keyword = "keyword";
        ClassificationTypeNames.numericLiteral = "number";
        ClassificationTypeNames.operator = "operator";
        ClassificationTypeNames.stringLiteral = "string";
        ClassificationTypeNames.whiteSpace = "whitespace";
        ClassificationTypeNames.text = "text";
        ClassificationTypeNames.punctuation = "punctuation";
        ClassificationTypeNames.className = "class name";
        ClassificationTypeNames.enumName = "enum name";
        ClassificationTypeNames.interfaceName = "interface name";
        ClassificationTypeNames.moduleName = "module name";
        ClassificationTypeNames.typeParameterName = "type parameter name";
        return ClassificationTypeNames;
    })();
    ts.ClassificationTypeNames = ClassificationTypeNames;
    var MatchKind;
    (function (MatchKind) {
        MatchKind[MatchKind["none"] = 0] = "none";
        MatchKind[MatchKind["exact"] = 1] = "exact";
        MatchKind[MatchKind["substring"] = 2] = "substring";
        MatchKind[MatchKind["prefix"] = 3] = "prefix";
    })(MatchKind || (MatchKind = {}));
    function displayPartsToString(displayParts) {
        if (displayParts) {
            return ts.map(displayParts, function (displayPart) { return displayPart.text; }).join("");
        }
        return "";
    }
    ts.displayPartsToString = displayPartsToString;
    var displayPartWriter = getDisplayPartWriter();
    function getDisplayPartWriter() {
        var displayParts;
        var lineStart;
        var indent;
        resetWriter();
        return {
            displayParts: function () { return displayParts; },
            writeKeyword: function (text) { return writeKind(text, 5 /* keyword */); },
            writeOperator: function (text) { return writeKind(text, 12 /* operator */); },
            writePunctuation: function (text) { return writeKind(text, 15 /* punctuation */); },
            writeSpace: function (text) { return writeKind(text, 16 /* space */); },
            writeStringLiteral: function (text) { return writeKind(text, 8 /* stringLiteral */); },
            writeParameter: function (text) { return writeKind(text, 13 /* parameterName */); },
            writeSymbol: writeSymbol,
            writeLine: writeLine,
            increaseIndent: function () {
                indent++;
            },
            decreaseIndent: function () {
                indent--;
            },
            clear: resetWriter,
            trackSymbol: function () {
            }
        };
        function writeIndent() {
            if (lineStart) {
                displayParts.push(displayPart(ts.getIndentString(indent), 16 /* space */));
                lineStart = false;
            }
        }
        function writeKind(text, kind) {
            writeIndent();
            displayParts.push(displayPart(text, kind));
        }
        function writeSymbol(text, symbol) {
            writeIndent();
            displayParts.push(symbolPart(text, symbol));
        }
        function writeLine() {
            displayParts.push(lineBreakPart());
            lineStart = true;
        }
        function resetWriter() {
            displayParts = [];
            lineStart = true;
            indent = 0;
        }
    }
    function displayPart(text, kind, symbol) {
        return {
            text: text,
            kind: SymbolDisplayPartKind[kind]
        };
    }
    function spacePart() {
        return displayPart(" ", 16 /* space */);
    }
    ts.spacePart = spacePart;
    function keywordPart(kind) {
        return displayPart(ts.tokenToString(kind), 5 /* keyword */);
    }
    ts.keywordPart = keywordPart;
    function punctuationPart(kind) {
        return displayPart(ts.tokenToString(kind), 15 /* punctuation */);
    }
    ts.punctuationPart = punctuationPart;
    function operatorPart(kind) {
        return displayPart(ts.tokenToString(kind), 12 /* operator */);
    }
    ts.operatorPart = operatorPart;
    function textPart(text) {
        return displayPart(text, 17 /* text */);
    }
    ts.textPart = textPart;
    function lineBreakPart() {
        return displayPart("\n", 6 /* lineBreak */);
    }
    ts.lineBreakPart = lineBreakPart;
    function isFirstDeclarationOfSymbolParameter(symbol) {
        return symbol.declarations && symbol.declarations.length > 0 && symbol.declarations[0].kind === 123 /* Parameter */;
    }
    function isLocalVariableOrFunction(symbol) {
        if (symbol.parent) {
            return false; // This is exported symbol
        }
        return ts.forEach(symbol.declarations, function (declaration) {
            // Function expressions are local
            if (declaration.kind === 149 /* FunctionExpression */) {
                return true;
            }
            if (declaration.kind !== 181 /* VariableDeclaration */ && declaration.kind !== 182 /* FunctionDeclaration */) {
                return false;
            }
            for (var parent = declaration.parent; parent.kind !== 183 /* FunctionBlock */; parent = parent.parent) {
                // Reached source file or module block
                if (parent.kind === 193 /* SourceFile */ || parent.kind === 189 /* ModuleBlock */) {
                    return false;
                }
            }
            // parent is in function block
            return true;
        });
    }
    function symbolPart(text, symbol) {
        return displayPart(text, displayPartKind(symbol), symbol);
        function displayPartKind(symbol) {
            var flags = symbol.flags;
            if (flags & 3 /* Variable */) {
                return isFirstDeclarationOfSymbolParameter(symbol) ? 13 /* parameterName */ : 9 /* localName */;
            }
            else if (flags & 4 /* Property */) {
                return 14 /* propertyName */;
            }
            else if (flags & 8 /* EnumMember */) {
                return 19 /* enumMemberName */;
            }
            else if (flags & 16 /* Function */) {
                return 20 /* functionName */;
            }
            else if (flags & 32 /* Class */) {
                return 1 /* className */;
            }
            else if (flags & 64 /* Interface */) {
                return 4 /* interfaceName */;
            }
            else if (flags & 384 /* Enum */) {
                return 2 /* enumName */;
            }
            else if (flags & 1536 /* Module */) {
                return 11 /* moduleName */;
            }
            else if (flags & 8192 /* Method */) {
                return 10 /* methodName */;
            }
            else if (flags & 1048576 /* TypeParameter */) {
                return 18 /* typeParameterName */;
            }
            return 17 /* text */;
        }
    }
    ts.symbolPart = symbolPart;
    function mapToDisplayParts(writeDisplayParts) {
        writeDisplayParts(displayPartWriter);
        var result = displayPartWriter.displayParts();
        displayPartWriter.clear();
        return result;
    }
    ts.mapToDisplayParts = mapToDisplayParts;
    function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
        return mapToDisplayParts(function (writer) {
            typechecker.getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
        });
    }
    ts.typeToDisplayParts = typeToDisplayParts;
    function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
        return mapToDisplayParts(function (writer) {
            typeChecker.getSymbolDisplayBuilder().buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags);
        });
    }
    ts.symbolToDisplayParts = symbolToDisplayParts;
    function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
        return mapToDisplayParts(function (writer) {
            typechecker.getSymbolDisplayBuilder().buildSignatureDisplay(signature, writer, enclosingDeclaration, flags);
        });
    }
    function getDefaultCompilerOptions() {
        // Set "ScriptTarget.Latest" target by default for language service
        return {
            target: 2 /* Latest */,
            module: 0 /* None */
        };
    }
    ts.getDefaultCompilerOptions = getDefaultCompilerOptions;
    function compareDataObjects(dst, src) {
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e]))
                    return false;
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e])
                    return false;
            }
        }
        return true;
    }
    ts.compareDataObjects = compareDataObjects;
    var OperationCanceledException = (function () {
        function OperationCanceledException() {
        }
        return OperationCanceledException;
    })();
    ts.OperationCanceledException = OperationCanceledException;
    var CancellationTokenObject = (function () {
        function CancellationTokenObject(cancellationToken) {
            this.cancellationToken = cancellationToken;
        }
        CancellationTokenObject.prototype.isCancellationRequested = function () {
            return this.cancellationToken && this.cancellationToken.isCancellationRequested();
        };
        CancellationTokenObject.prototype.throwIfCancellationRequested = function () {
            if (this.isCancellationRequested()) {
                throw new OperationCanceledException();
            }
        };
        CancellationTokenObject.None = new CancellationTokenObject(null);
        return CancellationTokenObject;
    })();
    ts.CancellationTokenObject = CancellationTokenObject;
    // Cache host information about scrip Should be refreshed 
    // at each language service public entry point, since we don't know when 
    // set of scripts handled by the host changes.
    var HostCache = (function () {
        function HostCache(host) {
            this.host = host;
            // script id => script index
            this.filenameToEntry = {};
            var filenames = host.getScriptFileNames();
            for (var i = 0, n = filenames.length; i < n; i++) {
                var filename = filenames[i];
                this.filenameToEntry[ts.switchToForwardSlashes(filename)] = {
                    filename: filename,
                    version: host.getScriptVersion(filename),
                    isOpen: host.getScriptIsOpen(filename)
                };
            }
            this._compilationSettings = host.getCompilationSettings() || getDefaultCompilerOptions();
        }
        HostCache.prototype.compilationSettings = function () {
            return this._compilationSettings;
        };
        HostCache.prototype.getEntry = function (filename) {
            filename = ts.switchToForwardSlashes(filename);
            return ts.lookUp(this.filenameToEntry, filename);
        };
        HostCache.prototype.contains = function (filename) {
            return !!this.getEntry(filename);
        };
        HostCache.prototype.getHostfilename = function (filename) {
            var hostCacheEntry = this.getEntry(filename);
            if (hostCacheEntry) {
                return hostCacheEntry.filename;
            }
            return filename;
        };
        HostCache.prototype.getFilenames = function () {
            var _this = this;
            var fileNames = [];
            ts.forEachKey(this.filenameToEntry, function (key) {
                if (ts.hasProperty(_this.filenameToEntry, key))
                    fileNames.push(key);
            });
            return fileNames;
        };
        HostCache.prototype.getVersion = function (filename) {
            return this.getEntry(filename).version;
        };
        HostCache.prototype.isOpen = function (filename) {
            return this.getEntry(filename).isOpen;
        };
        HostCache.prototype.getScriptSnapshot = function (filename) {
            var file = this.getEntry(filename);
            if (!file.sourceText) {
                file.sourceText = this.host.getScriptSnapshot(file.filename);
            }
            return file.sourceText;
        };
        HostCache.prototype.getChangeRange = function (filename, lastKnownVersion, oldScriptSnapshot) {
            var currentVersion = this.getVersion(filename);
            if (lastKnownVersion === currentVersion) {
                return TypeScript.TextChangeRange.unchanged; // "No changes"
            }
            var scriptSnapshot = this.getScriptSnapshot(filename);
            return scriptSnapshot.getChangeRange(oldScriptSnapshot);
        };
        return HostCache;
    })();
    var SyntaxTreeCache = (function () {
        function SyntaxTreeCache(host) {
            this.host = host;
            // For our syntactic only features, we also keep a cache of the syntax tree for the 
            // currently edited file.  
            this.currentFilename = "";
            this.currentFileVersion = null;
            this.currentSourceFile = null;
            this.currentFileSyntaxTree = null;
            this.hostCache = new HostCache(host);
        }
        SyntaxTreeCache.prototype.initialize = function (filename) {
            // ensure that both source file and syntax tree are either initialized or not initialized
            ts.Debug.assert(!!this.currentFileSyntaxTree === !!this.currentSourceFile);
            var start = new Date().getTime();
            this.hostCache = new HostCache(this.host);
            this.host.log("SyntaxTreeCache.Initialize: new HostCache: " + (new Date().getTime() - start));
            var version = this.hostCache.getVersion(filename);
            var syntaxTree = null;
            var sourceFile;
            if (this.currentFileSyntaxTree === null || this.currentFilename !== filename) {
                var scriptSnapshot = this.hostCache.getScriptSnapshot(filename);
                var start = new Date().getTime();
                syntaxTree = this.createSyntaxTree(filename, scriptSnapshot);
                this.host.log("SyntaxTreeCache.Initialize: createSyntaxTree: " + (new Date().getTime() - start));
                var start = new Date().getTime();
                sourceFile = createSourceFileFromScriptSnapshot(filename, scriptSnapshot, getDefaultCompilerOptions(), version, true);
                this.host.log("SyntaxTreeCache.Initialize: createSourceFile: " + (new Date().getTime() - start));
                var start = new Date().getTime();
                fixupParentReferences(sourceFile);
                this.host.log("SyntaxTreeCache.Initialize: fixupParentRefs : " + (new Date().getTime() - start));
            }
            else if (this.currentFileVersion !== version) {
                var scriptSnapshot = this.hostCache.getScriptSnapshot(filename);
                var start = new Date().getTime();
                syntaxTree = this.updateSyntaxTree(filename, scriptSnapshot, this.currentSourceFile.getScriptSnapshot(), this.currentFileSyntaxTree, this.currentFileVersion);
                this.host.log("SyntaxTreeCache.Initialize: updateSyntaxTree: " + (new Date().getTime() - start));
                var editRange = this.hostCache.getChangeRange(filename, this.currentFileVersion, this.currentSourceFile.getScriptSnapshot());
                var start = new Date().getTime();
                sourceFile = !editRange ? createSourceFileFromScriptSnapshot(filename, scriptSnapshot, getDefaultCompilerOptions(), version, true) : this.currentSourceFile.update(scriptSnapshot, version, true, editRange);
                this.host.log("SyntaxTreeCache.Initialize: updateSourceFile: " + (new Date().getTime() - start));
                var start = new Date().getTime();
                fixupParentReferences(sourceFile);
                this.host.log("SyntaxTreeCache.Initialize: fixupParentRefs : " + (new Date().getTime() - start));
            }
            if (syntaxTree !== null) {
                ts.Debug.assert(sourceFile !== undefined);
                // All done, ensure state is up to date
                this.currentFileVersion = version;
                this.currentFilename = filename;
                this.currentFileSyntaxTree = syntaxTree;
                this.currentSourceFile = sourceFile;
            }
            function fixupParentReferences(sourceFile) {
                // normally parent references are set during binding.
                // however here SourceFile data is used only for syntactic features so running the whole binding process is an overhead.
                // walk over the nodes and set parent references
                var parent = sourceFile;
                function walk(n) {
                    n.parent = parent;
                    var saveParent = parent;
                    parent = n;
                    ts.forEachChild(n, walk);
                    parent = saveParent;
                }
                ts.forEachChild(sourceFile, walk);
            }
        };
        SyntaxTreeCache.prototype.getCurrentFileSyntaxTree = function (filename) {
            this.initialize(filename);
            return this.currentFileSyntaxTree;
        };
        SyntaxTreeCache.prototype.getCurrentSourceFile = function (filename) {
            this.initialize(filename);
            return this.currentSourceFile;
        };
        SyntaxTreeCache.prototype.getCurrentScriptSnapshot = function (filename) {
            // update currentFileScriptSnapshot as a part of 'getCurrentFileSyntaxTree' call
            this.getCurrentFileSyntaxTree(filename);
            return this.getCurrentSourceFile(filename).getScriptSnapshot();
        };
        SyntaxTreeCache.prototype.createSyntaxTree = function (filename, scriptSnapshot) {
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            // For the purposes of features that use this syntax tree, we can just use the default
            // compilation settings.  The features only use the syntax (and not the diagnostics),
            // and the syntax isn't affected by the compilation settings.
            var syntaxTree = TypeScript.Parser.parse(filename, text, getDefaultCompilerOptions().target, TypeScript.isDTSFile(filename));
            return syntaxTree;
        };
        SyntaxTreeCache.prototype.updateSyntaxTree = function (filename, scriptSnapshot, previousScriptSnapshot, previousSyntaxTree, previousFileVersion) {
            var editRange = this.hostCache.getChangeRange(filename, previousFileVersion, previousScriptSnapshot);
            // Debug.assert(newLength >= 0);
            // The host considers the entire buffer changed.  So parse a completely new tree.
            if (editRange === null) {
                return this.createSyntaxTree(filename, scriptSnapshot);
            }
            var nextSyntaxTree = TypeScript.IncrementalParser.parse(previousSyntaxTree, editRange, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot));
            this.ensureInvariants(filename, editRange, nextSyntaxTree, previousScriptSnapshot, scriptSnapshot);
            return nextSyntaxTree;
        };
        SyntaxTreeCache.prototype.ensureInvariants = function (filename, editRange, incrementalTree, oldScriptSnapshot, newScriptSnapshot) {
            // First, verify that the edit range and the script snapshots make sense.
            // If this fires, then the edit range is completely bogus.  Somehow the lengths of the
            // old snapshot, the change range and the new snapshot aren't in sync.  This is very
            // bad.
            var expectedNewLength = oldScriptSnapshot.getLength() - editRange.span().length() + editRange.newLength();
            var actualNewLength = newScriptSnapshot.getLength();
            function provideMoreDebugInfo() {
                var debugInformation = ["expected length:", expectedNewLength, "and actual length:", actualNewLength, "are not equal\r\n"];
                var oldSpan = editRange.span();
                function prettyPrintString(s) {
                    return '"' + s.replace(/\r/g, '\\r').replace(/\n/g, '\\n') + '"';
                }
                debugInformation.push('Edit range (old text) (start: ' + oldSpan.start() + ', end: ' + oldSpan.end() + ') \r\n');
                debugInformation.push('Old text edit range contents: ' + prettyPrintString(oldScriptSnapshot.getText(oldSpan.start(), oldSpan.end())));
                var newSpan = editRange.newSpan();
                debugInformation.push('Edit range (new text) (start: ' + newSpan.start() + ', end: ' + newSpan.end() + ') \r\n');
                debugInformation.push('New text edit range contents: ' + prettyPrintString(newScriptSnapshot.getText(newSpan.start(), newSpan.end())));
                return debugInformation.join(' ');
            }
            ts.Debug.assert(expectedNewLength === actualNewLength, "Expected length is different from actual!", provideMoreDebugInfo);
            if (ts.Debug.shouldAssert(3 /* VeryAggressive */)) {
                // If this fires, the text change range is bogus.  It says the change starts at point 
                // 'X', but we can see a text difference *before* that point.
                var oldPrefixText = oldScriptSnapshot.getText(0, editRange.span().start());
                var newPrefixText = newScriptSnapshot.getText(0, editRange.span().start());
                ts.Debug.assert(oldPrefixText === newPrefixText, 'Expected equal prefix texts!');
                // If this fires, the text change range is bogus.  It says the change goes only up to
                // point 'X', but we can see a text difference *after* that point.
                var oldSuffixText = oldScriptSnapshot.getText(editRange.span().end(), oldScriptSnapshot.getLength());
                var newSuffixText = newScriptSnapshot.getText(editRange.newSpan().end(), newScriptSnapshot.getLength());
                ts.Debug.assert(oldSuffixText === newSuffixText, 'Expected equal suffix texts!');
                // Ok, text change range and script snapshots look ok.  Let's verify that our 
                // incremental parsing worked properly.
                //var normalTree = this.createSyntaxTree(filename, newScriptSnapshot);
                //Debug.assert(normalTree.structuralEquals(incrementalTree), 'Expected equal incremental and normal trees');
                // Ok, the trees looked good.  So at least our incremental parser agrees with the 
                // normal parser.  Now, verify that the incremental tree matches the contents of the 
                // script snapshot.
                var incrementalTreeText = TypeScript.fullText(incrementalTree.sourceUnit());
                var actualSnapshotText = newScriptSnapshot.getText(0, newScriptSnapshot.getLength());
                ts.Debug.assert(incrementalTreeText === actualSnapshotText, 'Expected full texts to be equal');
            }
        };
        return SyntaxTreeCache;
    })();
    function createSourceFileFromScriptSnapshot(filename, scriptSnapshot, settings, version, isOpen) {
        return SourceFileObject.createSourceFileObject(filename, scriptSnapshot, settings.target, version, isOpen);
    }
    function createDocumentRegistry() {
        var buckets = {};
        function getKeyFromCompilationSettings(settings) {
            return "_" + settings.target; //  + "|" + settings.propagateEnumConstantoString()
        }
        function getBucketForCompilationSettings(settings, createIfMissing) {
            var key = getKeyFromCompilationSettings(settings);
            var bucket = ts.lookUp(buckets, key);
            if (!bucket && createIfMissing) {
                buckets[key] = bucket = {};
            }
            return bucket;
        }
        function reportStats() {
            var bucketInfoArray = Object.keys(buckets).filter(function (name) { return name && name.charAt(0) === '_'; }).map(function (name) {
                var entries = ts.lookUp(buckets, name);
                var sourceFiles = [];
                for (var i in entries) {
                    var entry = entries[i];
                    sourceFiles.push({
                        name: i,
                        refCount: entry.refCount,
                        references: entry.owners.slice(0)
                    });
                }
                sourceFiles.sort(function (x, y) { return y.refCount - x.refCount; });
                return {
                    bucket: name,
                    sourceFiles: sourceFiles
                };
            });
            return JSON.stringify(bucketInfoArray, null, 2);
        }
        function acquireDocument(filename, compilationSettings, scriptSnapshot, version, isOpen) {
            var bucket = getBucketForCompilationSettings(compilationSettings, true);
            var entry = ts.lookUp(bucket, filename);
            if (!entry) {
                var sourceFile = createSourceFileFromScriptSnapshot(filename, scriptSnapshot, compilationSettings, version, isOpen);
                bucket[filename] = entry = {
                    sourceFile: sourceFile,
                    refCount: 0,
                    owners: []
                };
            }
            entry.refCount++;
            return entry.sourceFile;
        }
        function updateDocument(sourceFile, filename, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange) {
            var bucket = getBucketForCompilationSettings(compilationSettings, false);
            ts.Debug.assert(bucket !== undefined);
            var entry = ts.lookUp(bucket, filename);
            ts.Debug.assert(entry !== undefined);
            if (entry.sourceFile.isOpen === isOpen && entry.sourceFile.version === version) {
                return entry.sourceFile;
            }
            entry.sourceFile = entry.sourceFile.update(scriptSnapshot, version, isOpen, textChangeRange);
            return entry.sourceFile;
        }
        function releaseDocument(filename, compilationSettings) {
            var bucket = getBucketForCompilationSettings(compilationSettings, false);
            ts.Debug.assert(bucket !== undefined);
            var entry = ts.lookUp(bucket, filename);
            entry.refCount--;
            ts.Debug.assert(entry.refCount >= 0);
            if (entry.refCount === 0) {
                delete bucket[filename];
            }
        }
        return {
            acquireDocument: acquireDocument,
            updateDocument: updateDocument,
            releaseDocument: releaseDocument,
            reportStats: reportStats
        };
    }
    ts.createDocumentRegistry = createDocumentRegistry;
    function preProcessFile(sourceText, readImportFiles) {
        if (readImportFiles === void 0) { readImportFiles = true; }
        var referencedFiles = [];
        var importedFiles = [];
        var isNoDefaultLib = false;
        function processTripleSlashDirectives() {
            var commentRanges = ts.getLeadingCommentRanges(sourceText, 0);
            ts.forEach(commentRanges, function (commentRange) {
                var comment = sourceText.substring(commentRange.pos, commentRange.end);
                var referencePathMatchResult = ts.getFileReferenceFromReferencePath(comment, commentRange);
                if (referencePathMatchResult) {
                    isNoDefaultLib = referencePathMatchResult.isNoDefaultLib;
                    var fileReference = referencePathMatchResult.fileReference;
                    if (fileReference) {
                        referencedFiles.push(fileReference);
                    }
                }
            });
        }
        function processImport() {
            scanner.setText(sourceText);
            var token = scanner.scan();
            while (token !== 1 /* EndOfFileToken */) {
                if (token === 83 /* ImportKeyword */) {
                    token = scanner.scan();
                    if (token === 63 /* Identifier */) {
                        token = scanner.scan();
                        if (token === 51 /* EqualsToken */) {
                            token = scanner.scan();
                            if (token === 115 /* RequireKeyword */) {
                                token = scanner.scan();
                                if (token === 15 /* OpenParenToken */) {
                                    token = scanner.scan();
                                    if (token === 7 /* StringLiteral */) {
                                        var importPath = scanner.getTokenValue();
                                        var pos = scanner.getTokenPos();
                                        importedFiles.push({
                                            filename: importPath,
                                            pos: pos,
                                            end: pos + importPath.length
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                token = scanner.scan();
            }
            scanner.setText(undefined);
        }
        if (readImportFiles) {
            processImport();
        }
        processTripleSlashDirectives();
        return { referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: isNoDefaultLib };
    }
    ts.preProcessFile = preProcessFile;
    /// Helpers
    function getNodeModifiers(node) {
        var flags = node.flags;
        var result = [];
        if (flags & 32 /* Private */)
            result.push(ScriptElementKindModifier.privateMemberModifier);
        if (flags & 64 /* Protected */)
            result.push(ScriptElementKindModifier.protectedMemberModifier);
        if (flags & 16 /* Public */)
            result.push(ScriptElementKindModifier.publicMemberModifier);
        if (flags & 128 /* Static */)
            result.push(ScriptElementKindModifier.staticModifier);
        if (flags & 1 /* Export */)
            result.push(ScriptElementKindModifier.exportedModifier);
        if (ts.isInAmbientContext(node))
            result.push(ScriptElementKindModifier.ambientModifier);
        return result.length > 0 ? result.join(',') : ScriptElementKindModifier.none;
    }
    ts.getNodeModifiers = getNodeModifiers;
    function getTargetLabel(referenceNode, labelName) {
        while (referenceNode) {
            if (referenceNode.kind === 174 /* LabeledStatement */ && referenceNode.label.text === labelName) {
                return referenceNode.label;
            }
            referenceNode = referenceNode.parent;
        }
        return undefined;
    }
    function isJumpStatementTarget(node) {
        return node.kind === 63 /* Identifier */ && (node.parent.kind === 168 /* BreakStatement */ || node.parent.kind === 167 /* ContinueStatement */) && node.parent.label === node;
    }
    function isLabelOfLabeledStatement(node) {
        return node.kind === 63 /* Identifier */ && node.parent.kind === 174 /* LabeledStatement */ && node.parent.label === node;
    }
    /**
     * Whether or not a 'node' is preceded by a label of the given string.
     * Note: 'node' cannot be a SourceFile.
     */
    function isLabeledBy(node, labelName) {
        for (var owner = node.parent; owner.kind === 174 /* LabeledStatement */; owner = owner.parent) {
            if (owner.label.text === labelName) {
                return true;
            }
        }
        return false;
    }
    function isLabelName(node) {
        return isLabelOfLabeledStatement(node) || isJumpStatementTarget(node);
    }
    function isRightSideOfQualifiedName(node) {
        return node.parent.kind === 121 /* QualifiedName */ && node.parent.right === node;
    }
    function isRightSideOfPropertyAccess(node) {
        return node && node.parent && node.parent.kind === 142 /* PropertyAccess */ && node.parent.right === node;
    }
    function isCallExpressionTarget(node) {
        if (isRightSideOfPropertyAccess(node)) {
            node = node.parent;
        }
        return node && node.parent && node.parent.kind === 144 /* CallExpression */ && node.parent.func === node;
    }
    function isNewExpressionTarget(node) {
        if (isRightSideOfPropertyAccess(node)) {
            node = node.parent;
        }
        return node && node.parent && node.parent.kind === 145 /* NewExpression */ && node.parent.func === node;
    }
    function isNameOfModuleDeclaration(node) {
        return node.parent.kind === 188 /* ModuleDeclaration */ && node.parent.name === node;
    }
    function isNameOfFunctionDeclaration(node) {
        return node.kind === 63 /* Identifier */ && ts.isAnyFunction(node.parent) && node.parent.name === node;
    }
    /** Returns true if node is a name of an object literal property, e.g. "a" in x = { "a": 1 } */
    function isNameOfPropertyAssignment(node) {
        return (node.kind === 63 /* Identifier */ || node.kind === 7 /* StringLiteral */ || node.kind === 6 /* NumericLiteral */) && node.parent.kind === 141 /* PropertyAssignment */ && node.parent.name === node;
    }
    function isLiteralNameOfPropertyDeclarationOrIndexAccess(node) {
        if (node.kind === 7 /* StringLiteral */ || node.kind === 6 /* NumericLiteral */) {
            switch (node.parent.kind) {
                case 124 /* Property */:
                case 141 /* PropertyAssignment */:
                case 192 /* EnumMember */:
                case 125 /* Method */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 188 /* ModuleDeclaration */:
                    return node.parent.name === node;
                case 143 /* IndexedAccess */:
                    return node.parent.index === node;
            }
        }
        return false;
    }
    function isNameOfExternalModuleImportOrDeclaration(node) {
        return node.kind === 7 /* StringLiteral */ && (isNameOfModuleDeclaration(node) || (node.parent.kind === 190 /* ImportDeclaration */ && node.parent.externalModuleName === node));
    }
    /** Returns true if the position is within a comment */
    function isInsideComment(sourceFile, token, position) {
        // The position has to be: 1. in the leading trivia (before token.getStart()), and 2. within a comment
        return position <= token.getStart(sourceFile) && (isInsideCommentRange(ts.getTrailingCommentRanges(sourceFile.text, token.getFullStart())) || isInsideCommentRange(ts.getLeadingCommentRanges(sourceFile.text, token.getFullStart())));
        function isInsideCommentRange(comments) {
            return ts.forEach(comments, function (comment) {
                // either we are 1. completely inside the comment, or 2. at the end of the comment
                if (comment.pos < position && position < comment.end) {
                    return true;
                }
                else if (position === comment.end) {
                    var text = sourceFile.text;
                    var width = comment.end - comment.pos;
                    // is single line comment or just /*
                    if (width <= 2 || text.charCodeAt(comment.pos + 1) === 47 /* slash */) {
                        return true;
                    }
                    else {
                        // is unterminated multi-line comment
                        return !(text.charCodeAt(comment.end - 1) === 47 /* slash */ && text.charCodeAt(comment.end - 2) === 42 /* asterisk */);
                    }
                }
                return false;
            });
        }
    }
    // A cache of completion entries for keywords, these do not change between sessions
    var keywordCompletions = [];
    for (var i = 64 /* FirstKeyword */; i <= 119 /* LastKeyword */; i++) {
        keywordCompletions.push({
            name: ts.tokenToString(i),
            kind: ScriptElementKind.keyword,
            kindModifiers: ScriptElementKindModifier.none
        });
    }
    function createLanguageService(host, documentRegistry) {
        var syntaxTreeCache = new SyntaxTreeCache(host);
        var formattingRulesProvider;
        var hostCache; // A cache of all the information about the files on the host side.
        var program;
        // this checker is used to answer all LS questions except errors 
        var typeInfoResolver;
        // the sole purpose of this checker is to return semantic diagnostics
        // creation is deferred - use getFullTypeCheckChecker to get instance
        var fullTypeCheckChecker_doNotAccessDirectly;
        var useCaseSensitivefilenames = false;
        var sourceFilesByName = {};
        var documentRegistry = documentRegistry;
        var cancellationToken = new CancellationTokenObject(host.getCancellationToken());
        var activeCompletionSession; // The current active completion session, used to get the completion entry details
        var writer = undefined;
        // Check if the localized messages json is set, otherwise query the host for it
        if (!ts.localizedDiagnosticMessages) {
            ts.localizedDiagnosticMessages = host.getLocalizedDiagnosticMessages();
        }
        function getSourceFile(filename) {
            return ts.lookUp(sourceFilesByName, filename);
        }
        function getFullTypeCheckChecker() {
            return fullTypeCheckChecker_doNotAccessDirectly || (fullTypeCheckChecker_doNotAccessDirectly = program.getTypeChecker(true));
        }
        function createCompilerHost() {
            return {
                getSourceFile: function (filename, languageVersion) {
                    var sourceFile = getSourceFile(filename);
                    return sourceFile && sourceFile.getSourceFile();
                },
                getCancellationToken: function () { return cancellationToken; },
                getCanonicalFileName: function (filename) { return useCaseSensitivefilenames ? filename : filename.toLowerCase(); },
                useCaseSensitiveFileNames: function () { return useCaseSensitivefilenames; },
                getNewLine: function () { return "\r\n"; },
                getDefaultLibFilename: function () {
                    return host.getDefaultLibFilename();
                },
                writeFile: function (filename, data, writeByteOrderMark) {
                    writer(filename, data, writeByteOrderMark);
                },
                getCurrentDirectory: function () {
                    return host.getCurrentDirectory();
                }
            };
        }
        function sourceFileUpToDate(sourceFile) {
            return sourceFile && sourceFile.version === hostCache.getVersion(sourceFile.filename) && sourceFile.isOpen === hostCache.isOpen(sourceFile.filename);
        }
        function programUpToDate() {
            // If we haven't create a program yet, then it is not up-to-date
            if (!program) {
                return false;
            }
            // If number of files in the program do not match, it is not up-to-date
            var hostFilenames = hostCache.getFilenames();
            if (program.getSourceFiles().length !== hostFilenames.length) {
                return false;
            }
            for (var i = 0, n = hostFilenames.length; i < n; i++) {
                if (!sourceFileUpToDate(program.getSourceFile(hostFilenames[i]))) {
                    return false;
                }
            }
            // If the compilation settings do no match, then the program is not up-to-date
            return compareDataObjects(program.getCompilerOptions(), hostCache.compilationSettings());
        }
        function synchronizeHostData() {
            // Reset the cache at start of every refresh
            hostCache = new HostCache(host);
            // If the program is already up-to-date, we can reuse it
            if (programUpToDate()) {
                return;
            }
            var compilationSettings = hostCache.compilationSettings();
            // Now, remove any files from the compiler that are no longer in the host.
            var oldProgram = program;
            if (oldProgram) {
                var oldSettings = program.getCompilerOptions();
                // If the language version changed, then that affects what types of things we parse. So
                // we have to dump all syntax trees.
                // TODO: handle propagateEnumConstants
                // TODO: is module still needed
                var settingsChangeAffectsSyntax = oldSettings.target !== compilationSettings.target || oldSettings.module !== compilationSettings.module;
                var changesInCompilationSettingsAffectSyntax = oldSettings && compilationSettings && !compareDataObjects(oldSettings, compilationSettings) && settingsChangeAffectsSyntax;
                var oldSourceFiles = program.getSourceFiles();
                for (var i = 0, n = oldSourceFiles.length; i < n; i++) {
                    cancellationToken.throwIfCancellationRequested();
                    var filename = oldSourceFiles[i].filename;
                    if (!hostCache.contains(filename) || changesInCompilationSettingsAffectSyntax) {
                        documentRegistry.releaseDocument(filename, oldSettings);
                        delete sourceFilesByName[filename];
                    }
                }
            }
            // Now, for every file the host knows about, either add the file (if the compiler
            // doesn't know about it.).  Or notify the compiler about any changes (if it does
            // know about it.)
            var hostfilenames = hostCache.getFilenames();
            for (var i = 0, n = hostfilenames.length; i < n; i++) {
                var filename = hostfilenames[i];
                var version = hostCache.getVersion(filename);
                var isOpen = hostCache.isOpen(filename);
                var scriptSnapshot = hostCache.getScriptSnapshot(filename);
                var sourceFile = getSourceFile(filename);
                if (sourceFile) {
                    //
                    // If the sourceFile is the same, assume no update
                    //
                    if (sourceFileUpToDate(sourceFile)) {
                        continue;
                    }
                    // Only perform incremental parsing on open files that are being edited.  If a file was
                    // open, but is now closed, we want to re-parse entirely so we don't have any tokens that
                    // are holding onto expensive script snapshot instances on the host.  Similarly, if a 
                    // file was closed, then we always want to re-parse.  This is so our tree doesn't keep 
                    // the old buffer alive that represented the file on disk (as the host has moved to a 
                    // new text buffer).
                    var textChangeRange = null;
                    if (sourceFile.isOpen && isOpen) {
                        textChangeRange = hostCache.getChangeRange(filename, sourceFile.version, sourceFile.getScriptSnapshot());
                    }
                    sourceFile = documentRegistry.updateDocument(sourceFile, filename, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange);
                }
                else {
                    sourceFile = documentRegistry.acquireDocument(filename, compilationSettings, scriptSnapshot, version, isOpen);
                }
                // Remember the new sourceFile
                sourceFilesByName[filename] = sourceFile;
            }
            // Now create a new compiler
            program = ts.createProgram(hostfilenames, compilationSettings, createCompilerHost());
            typeInfoResolver = program.getTypeChecker(false);
            fullTypeCheckChecker_doNotAccessDirectly = undefined;
        }
        /**
         * Clean up any semantic caches that are not needed.
         * The host can call this method if it wants to jettison unused memory.
         * We will just dump the typeChecker and recreate a new one. this should have the effect of destroying all the semantic caches.
         */
        function cleanupSemanticCache() {
            if (program) {
                typeInfoResolver = program.getTypeChecker(false);
                fullTypeCheckChecker_doNotAccessDirectly = undefined;
            }
        }
        function dispose() {
            if (program) {
                ts.forEach(program.getSourceFiles(), function (f) {
                    documentRegistry.releaseDocument(f.filename, program.getCompilerOptions());
                });
            }
        }
        /// Diagnostics
        function getSyntacticDiagnostics(filename) {
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            return program.getDiagnostics(getSourceFile(filename).getSourceFile());
        }
        /**
         * getSemanticDiagnostiscs return array of Diagnostics. If '-d' is not enabled, only report semantic errors
         * If '-d' enabled, report both semantic and emitter errors
         */
        function getSemanticDiagnostics(filename) {
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            var compilerOptions = program.getCompilerOptions();
            var checker = getFullTypeCheckChecker();
            var targetSourceFile = getSourceFile(filename);
            // Only perform the action per file regardless of '-out' flag as LanguageServiceHost is expected to call this function per file.
            // Therefore only get diagnostics for given file.
            var allDiagnostics = checker.getDiagnostics(targetSourceFile);
            if (compilerOptions.declaration) {
                // If '-d' is enabled, check for emitter error. One example of emitter error is export class implements non-export interface
                // Get emitter-diagnostics requires calling TypeChecker.emitFiles so we have to define CompilerHost.writer which does nothing because emitFiles function has side effects defined by CompilerHost.writer
                var savedWriter = writer;
                writer = function (filename, data, writeByteOrderMark) {
                };
                allDiagnostics = allDiagnostics.concat(checker.emitFiles(targetSourceFile).errors);
                writer = savedWriter;
            }
            return allDiagnostics;
        }
        function getCompilerOptionsDiagnostics() {
            synchronizeHostData();
            return program.getGlobalDiagnostics();
        }
        /// Completion
        function getValidCompletionEntryDisplayName(symbol, target) {
            var displayName = symbol.getName();
            if (displayName && displayName.length > 0) {
                var firstCharCode = displayName.charCodeAt(0);
                // First check of the displayName is not external module; if it is an external module, it is not valid entry
                if ((symbol.flags & 1536 /* Namespace */) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
                    // If the symbol is external module, don't show it in the completion list
                    // (i.e declare module "http" { var x; } | // <= request completion here, "http" should not be there)
                    return undefined;
                }
                if (displayName && displayName.length >= 2 && firstCharCode === displayName.charCodeAt(displayName.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
                    // If the user entered name for the symbol was quoted, removing the quotes is not enough, as the name could be an
                    // invalid identifier name. We need to check if whatever was inside the quotes is actually a valid identifier name.
                    displayName = displayName.substring(1, displayName.length - 1);
                }
                var isValid = ts.isIdentifierStart(displayName.charCodeAt(0), target);
                for (var i = 1, n = displayName.length; isValid && i < n; i++) {
                    isValid = ts.isIdentifierPart(displayName.charCodeAt(i), target);
                }
                if (isValid) {
                    return displayName;
                }
            }
            return undefined;
        }
        function createCompletionEntry(symbol, typeChecker, location) {
            // Try to get a valid display name for this symbol, if we could not find one, then ignore it. 
            // We would like to only show things that can be added after a dot, so for instance numeric properties can
            // not be accessed with a dot (a.1 <- invalid)
            var displayName = getValidCompletionEntryDisplayName(symbol, program.getCompilerOptions().target);
            if (!displayName) {
                return undefined;
            }
            // TODO(drosen): Right now we just permit *all* semantic meanings when calling 'getSymbolKind'
            //               which is permissible given that it is backwards compatible; but really we should consider
            //               passing the meaning for the node so that we don't report that a suggestion for a value is an interface.
            //               We COULD also just do what 'getSymbolModifiers' does, which is to use the first declaration.
            return {
                name: displayName,
                kind: getSymbolKind(symbol, typeChecker, location),
                kindModifiers: getSymbolModifiers(symbol)
            };
        }
        function getCompletionsAtPosition(filename, position, isMemberCompletion) {
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            var syntacticStart = new Date().getTime();
            var sourceFile = getSourceFile(filename);
            var start = new Date().getTime();
            var currentToken = ts.getTokenAtPosition(sourceFile, position);
            host.log("getCompletionsAtPosition: Get current token: " + (new Date().getTime() - start));
            var start = new Date().getTime();
            // Completion not allowed inside comments, bail out if this is the case
            var insideComment = isInsideComment(sourceFile, currentToken, position);
            host.log("getCompletionsAtPosition: Is inside comment: " + (new Date().getTime() - start));
            if (insideComment) {
                host.log("Returning an empty list because completion was inside a comment.");
                return undefined;
            }
            // The decision to provide completion depends on the previous token, so find it
            // Note: previousToken can be undefined if we are the beginning of the file
            var start = new Date().getTime();
            var previousToken = ts.findPrecedingToken(position, sourceFile);
            host.log("getCompletionsAtPosition: Get previous token 1: " + (new Date().getTime() - start));
            // The caret is at the end of an identifier; this is a partial identifier that we want to complete: e.g. a.toS|
            // Skip this partial identifier to the previous token
            if (previousToken && position <= previousToken.end && previousToken.kind === 63 /* Identifier */) {
                var start = new Date().getTime();
                previousToken = ts.findPrecedingToken(previousToken.pos, sourceFile);
                host.log("getCompletionsAtPosition: Get previous token 2: " + (new Date().getTime() - start));
            }
            // Check if this is a valid completion location
            if (previousToken && isCompletionListBlocker(previousToken)) {
                host.log("Returning an empty list because completion was requested in an invalid position.");
                return undefined;
            }
            // Find the node where completion is requested on, in the case of a completion after a dot, it is the member access expression
            // other wise, it is a request for all visible symbols in the scope, and the node is the current location
            var node;
            var isRightOfDot;
            if (previousToken && previousToken.kind === 19 /* DotToken */ && (previousToken.parent.kind === 142 /* PropertyAccess */ || previousToken.parent.kind === 121 /* QualifiedName */)) {
                node = previousToken.parent.left;
                isRightOfDot = true;
            }
            else {
                node = currentToken;
                isRightOfDot = false;
            }
            // Clear the current activeCompletionSession for this session
            activeCompletionSession = {
                filename: filename,
                position: position,
                entries: [],
                symbols: {},
                typeChecker: typeInfoResolver
            };
            host.log("getCompletionsAtPosition: Syntactic work: " + (new Date().getTime() - syntacticStart));
            var location = ts.getTouchingPropertyName(sourceFile, position);
            // Populate the completion list
            var semanticStart = new Date().getTime();
            if (isRightOfDot) {
                // Right of dot member completion list
                var symbols = [];
                isMemberCompletion = true;
                if (node.kind === 63 /* Identifier */ || node.kind === 121 /* QualifiedName */ || node.kind === 142 /* PropertyAccess */) {
                    var symbol = typeInfoResolver.getSymbolInfo(node);
                    // This is an alias, follow what it aliases
                    if (symbol && symbol.flags & 33554432 /* Import */) {
                        symbol = typeInfoResolver.getAliasedSymbol(symbol);
                    }
                    if (symbol && symbol.flags & 1952 /* HasExports */) {
                        // Extract module or enum members
                        ts.forEachValue(symbol.exports, function (symbol) {
                            if (typeInfoResolver.isValidPropertyAccess((node.parent), symbol.name)) {
                                symbols.push(symbol);
                            }
                        });
                    }
                }
                var type = typeInfoResolver.getTypeOfNode(node);
                if (type) {
                    // Filter private properties
                    ts.forEach(type.getApparentProperties(), function (symbol) {
                        if (typeInfoResolver.isValidPropertyAccess((node.parent), symbol.name)) {
                            symbols.push(symbol);
                        }
                    });
                }
                getCompletionEntriesFromSymbols(symbols, activeCompletionSession);
            }
            else {
                var containingObjectLiteral = getContainingObjectLiteralApplicableForCompletion(previousToken);
                if (containingObjectLiteral) {
                    // Object literal expression, look up possible property names from contextual type
                    isMemberCompletion = true;
                    var contextualType = typeInfoResolver.getContextualType(containingObjectLiteral);
                    if (!contextualType) {
                        return undefined;
                    }
                    var contextualTypeMembers = typeInfoResolver.getPropertiesOfType(contextualType);
                    if (contextualTypeMembers && contextualTypeMembers.length > 0) {
                        // Add filtered items to the completion list
                        var filteredMembers = filterContextualMembersList(contextualTypeMembers, containingObjectLiteral.properties);
                        getCompletionEntriesFromSymbols(filteredMembers, activeCompletionSession);
                    }
                }
                else {
                    // Get scope members
                    isMemberCompletion = false;
                    /// TODO filter meaning based on the current context
                    var symbolMeanings = 3152352 /* Type */ | 107455 /* Value */ | 1536 /* Namespace */ | 33554432 /* Import */;
                    var symbols = typeInfoResolver.getSymbolsInScope(node, symbolMeanings);
                    getCompletionEntriesFromSymbols(symbols, activeCompletionSession);
                }
            }
            // Add keywords if this is not a member completion list
            if (!isMemberCompletion) {
                Array.prototype.push.apply(activeCompletionSession.entries, keywordCompletions);
            }
            host.log("getCompletionsAtPosition: Semantic work: " + (new Date().getTime() - semanticStart));
            return {
                isMemberCompletion: isMemberCompletion,
                entries: activeCompletionSession.entries
            };
            function getCompletionEntriesFromSymbols(symbols, session) {
                var start = new Date().getTime();
                ts.forEach(symbols, function (symbol) {
                    var entry = createCompletionEntry(symbol, session.typeChecker, location);
                    if (entry && !ts.lookUp(session.symbols, entry.name)) {
                        session.entries.push(entry);
                        session.symbols[entry.name] = symbol;
                    }
                });
                host.log("getCompletionsAtPosition: getCompletionEntriesFromSymbols: " + (new Date().getTime() - semanticStart));
            }
            function isCompletionListBlocker(previousToken) {
                var start = new Date().getTime();
                var result = isInStringOrRegularExpressionOrTemplateLiteral(previousToken) || isIdentifierDefinitionLocation(previousToken) || isRightOfIllegalDot(previousToken);
                host.log("getCompletionsAtPosition: isCompletionListBlocker: " + (new Date().getTime() - semanticStart));
                return result;
            }
            function isInStringOrRegularExpressionOrTemplateLiteral(previousToken) {
                if (previousToken.kind === 7 /* StringLiteral */ || ts.isTemplateLiteralKind(previousToken.kind)) {
                    // The position has to be either: 1. entirely within the token text, or 
                    // 2. at the end position, and the string literal is not terminated
                    var start = previousToken.getStart();
                    var end = previousToken.getEnd();
                    if (start < position && position < end) {
                        return true;
                    }
                    else if (position === end) {
                        var width = end - start;
                        var text = previousToken.getSourceFile().text;
                        // If the token is a single character, or its second-to-last charcter indicates an escape code,
                        // then we can immediately say that we are in the middle of an unclosed string.
                        if (width <= 1 || text.charCodeAt(end - 2) === 92 /* backslash */) {
                            return true;
                        }
                        switch (previousToken.kind) {
                            case 7 /* StringLiteral */:
                            case 9 /* NoSubstitutionTemplateLiteral */:
                                return text.charCodeAt(start) !== text.charCodeAt(end - 1);
                            case 10 /* TemplateHead */:
                            case 11 /* TemplateMiddle */:
                                return text.charCodeAt(end - 1) !== 123 /* openBrace */ || text.charCodeAt(end - 2) !== 36 /* $ */;
                            case 12 /* TemplateTail */:
                                return text.charCodeAt(end - 1) !== 96 /* backtick */;
                        }
                        return false;
                    }
                }
                else if (previousToken.kind === 8 /* RegularExpressionLiteral */) {
                    return previousToken.getStart() < position && position < previousToken.getEnd();
                }
                return false;
            }
            function getContainingObjectLiteralApplicableForCompletion(previousToken) {
                // The locations in an object literal expression that are applicable for completion are property name definition locations.
                if (previousToken) {
                    var parent = previousToken.parent;
                    switch (previousToken.kind) {
                        case 13 /* OpenBraceToken */:
                        case 22 /* CommaToken */:
                            if (parent && parent.kind === 140 /* ObjectLiteral */) {
                                return parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            function isFunction(kind) {
                switch (kind) {
                    case 149 /* FunctionExpression */:
                    case 150 /* ArrowFunction */:
                    case 182 /* FunctionDeclaration */:
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 129 /* CallSignature */:
                    case 130 /* ConstructSignature */:
                    case 131 /* IndexSignature */:
                        return true;
                }
                return false;
            }
            function isIdentifierDefinitionLocation(previousToken) {
                if (previousToken) {
                    var containingNodeKind = previousToken.parent.kind;
                    switch (previousToken.kind) {
                        case 22 /* CommaToken */:
                            return containingNodeKind === 181 /* VariableDeclaration */ || containingNodeKind === 159 /* VariableStatement */ || containingNodeKind === 187 /* EnumDeclaration */ || isFunction(containingNodeKind);
                        case 15 /* OpenParenToken */:
                            return containingNodeKind === 178 /* CatchBlock */ || isFunction(containingNodeKind);
                        case 13 /* OpenBraceToken */:
                            return containingNodeKind === 187 /* EnumDeclaration */ || containingNodeKind === 185 /* InterfaceDeclaration */;
                        case 21 /* SemicolonToken */:
                            return containingNodeKind === 124 /* Property */ && previousToken.parent.parent.kind === 185 /* InterfaceDeclaration */;
                        case 106 /* PublicKeyword */:
                        case 104 /* PrivateKeyword */:
                        case 107 /* StaticKeyword */:
                        case 20 /* DotDotDotToken */:
                            return containingNodeKind === 123 /* Parameter */;
                        case 67 /* ClassKeyword */:
                        case 114 /* ModuleKeyword */:
                        case 75 /* EnumKeyword */:
                        case 101 /* InterfaceKeyword */:
                        case 81 /* FunctionKeyword */:
                        case 96 /* VarKeyword */:
                        case 113 /* GetKeyword */:
                        case 117 /* SetKeyword */:
                        case 83 /* ImportKeyword */:
                            return true;
                    }
                    switch (previousToken.getText()) {
                        case "class":
                        case "interface":
                        case "enum":
                        case "module":
                        case "function":
                        case "var":
                            // TODO: add let and const
                            return true;
                    }
                }
                return false;
            }
            function isRightOfIllegalDot(previousToken) {
                if (previousToken && previousToken.kind === 6 /* NumericLiteral */) {
                    var text = previousToken.getFullText();
                    return text.charAt(text.length - 1) === ".";
                }
                return false;
            }
            function filterContextualMembersList(contextualMemberSymbols, existingMembers) {
                if (!existingMembers || existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var existingMemberNames = {};
                ts.forEach(existingMembers, function (m) {
                    if (m.kind !== 141 /* PropertyAssignment */) {
                        // Ignore omitted expressions for missing members in the object literal
                        return;
                    }
                    if (m.getStart() <= position && position <= m.getEnd()) {
                        // If this is the current item we are editing right now, do not filter it out
                        return;
                    }
                    // TODO(jfreeman): Account for computed property name
                    existingMemberNames[m.name.text] = true;
                });
                var filteredMembers = [];
                ts.forEach(contextualMemberSymbols, function (s) {
                    if (!existingMemberNames[s.name]) {
                        filteredMembers.push(s);
                    }
                });
                return filteredMembers;
            }
        }
        function getCompletionEntryDetails(filename, position, entryName) {
            // Note: No need to call synchronizeHostData, as we have captured all the data we need
            //       in the getCompletionsAtPosition earlier
            filename = ts.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var session = activeCompletionSession;
            // Ensure that the current active completion session is still valid for this request
            if (!session || session.filename !== filename || session.position !== position) {
                return undefined;
            }
            var symbol = ts.lookUp(activeCompletionSession.symbols, entryName);
            if (symbol) {
                var location = ts.getTouchingPropertyName(sourceFile, position);
                var completionEntry = createCompletionEntry(symbol, session.typeChecker, location);
                // TODO(drosen): Right now we just permit *all* semantic meanings when calling 'getSymbolKind'
                //               which is permissible given that it is backwards compatible; but really we should consider
                //               passing the meaning for the node so that we don't report that a suggestion for a value is an interface.
                //               We COULD also just do what 'getSymbolModifiers' does, which is to use the first declaration.
                ts.Debug.assert(session.typeChecker.getNarrowedTypeOfSymbol(symbol, location) !== undefined, "Could not find type for symbol");
                var displayPartsDocumentationsAndSymbolKind = getSymbolDisplayPartsDocumentationAndSymbolKind(symbol, getSourceFile(filename), location, session.typeChecker, location, 7 /* All */);
                return {
                    name: entryName,
                    kind: displayPartsDocumentationsAndSymbolKind.symbolKind,
                    kindModifiers: completionEntry.kindModifiers,
                    displayParts: displayPartsDocumentationsAndSymbolKind.displayParts,
                    documentation: displayPartsDocumentationsAndSymbolKind.documentation
                };
            }
            else {
                // No symbol, it is a keyword
                return {
                    name: entryName,
                    kind: ScriptElementKind.keyword,
                    kindModifiers: ScriptElementKindModifier.none,
                    displayParts: [displayPart(entryName, 5 /* keyword */)],
                    documentation: undefined
                };
            }
        }
        function getContainerNode(node) {
            while (true) {
                node = node.parent;
                if (!node) {
                    return node;
                }
                switch (node.kind) {
                    case 193 /* SourceFile */:
                    case 125 /* Method */:
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                    case 184 /* ClassDeclaration */:
                    case 185 /* InterfaceDeclaration */:
                    case 187 /* EnumDeclaration */:
                    case 188 /* ModuleDeclaration */:
                        return node;
                }
            }
        }
        // TODO(drosen): use contextual SemanticMeaning.
        function getSymbolKind(symbol, typeResolver, location) {
            var flags = symbol.getFlags();
            if (flags & 32 /* Class */)
                return ScriptElementKind.classElement;
            if (flags & 384 /* Enum */)
                return ScriptElementKind.enumElement;
            if (flags & 2097152 /* TypeAlias */)
                return ScriptElementKind.typeElement;
            if (flags & 64 /* Interface */)
                return ScriptElementKind.interfaceElement;
            if (flags & 1048576 /* TypeParameter */)
                return ScriptElementKind.typeParameterElement;
            var result = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(symbol, flags, typeResolver, location);
            if (result === ScriptElementKind.unknown) {
                if (flags & 1048576 /* TypeParameter */)
                    return ScriptElementKind.typeParameterElement;
                if (flags & 8 /* EnumMember */)
                    return ScriptElementKind.variableElement;
                if (flags & 33554432 /* Import */)
                    return ScriptElementKind.alias;
            }
            return result;
        }
        function getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(symbol, flags, typeResolver, location) {
            if (typeResolver.isUndefinedSymbol(symbol)) {
                return ScriptElementKind.variableElement;
            }
            if (typeResolver.isArgumentsSymbol(symbol)) {
                return ScriptElementKind.localVariableElement;
            }
            if (flags & 3 /* Variable */) {
                if (isFirstDeclarationOfSymbolParameter(symbol)) {
                    return ScriptElementKind.parameterElement;
                }
                else if (symbol.valueDeclaration && symbol.valueDeclaration.flags & 4096 /* Const */) {
                    return ScriptElementKind.constantElement;
                }
                return isLocalVariableOrFunction(symbol) ? ScriptElementKind.localVariableElement : ScriptElementKind.variableElement;
            }
            if (flags & 16 /* Function */)
                return isLocalVariableOrFunction(symbol) ? ScriptElementKind.localFunctionElement : ScriptElementKind.functionElement;
            if (flags & 32768 /* GetAccessor */)
                return ScriptElementKind.memberGetAccessorElement;
            if (flags & 65536 /* SetAccessor */)
                return ScriptElementKind.memberSetAccessorElement;
            if (flags & 8192 /* Method */)
                return ScriptElementKind.memberFunctionElement;
            if (flags & 16384 /* Constructor */)
                return ScriptElementKind.constructorImplementationElement;
            if (flags & 4 /* Property */) {
                if (flags & 1073741824 /* UnionProperty */) {
                    // If union property is result of union of non method (property/accessors/variables), it is labeled as property
                    var unionPropertyKind = ts.forEach(typeInfoResolver.getRootSymbols(symbol), function (rootSymbol) {
                        var rootSymbolFlags = rootSymbol.getFlags();
                        if (rootSymbolFlags & (98308 /* PropertyOrAccessor */ | 3 /* Variable */)) {
                            return ScriptElementKind.memberVariableElement;
                        }
                        ts.Debug.assert(!!(rootSymbolFlags & 8192 /* Method */));
                    });
                    if (!unionPropertyKind) {
                        // If this was union of all methods, 
                        //make sure it has call signatures before we can label it as method
                        var typeOfUnionProperty = typeInfoResolver.getNarrowedTypeOfSymbol(symbol, location);
                        if (typeOfUnionProperty.getCallSignatures().length) {
                            return ScriptElementKind.memberFunctionElement;
                        }
                        return ScriptElementKind.memberVariableElement;
                    }
                    return unionPropertyKind;
                }
                return ScriptElementKind.memberVariableElement;
            }
            return ScriptElementKind.unknown;
        }
        function getTypeKind(type) {
            var flags = type.getFlags();
            if (flags & 128 /* Enum */)
                return ScriptElementKind.enumElement;
            if (flags & 1024 /* Class */)
                return ScriptElementKind.classElement;
            if (flags & 2048 /* Interface */)
                return ScriptElementKind.interfaceElement;
            if (flags & 512 /* TypeParameter */)
                return ScriptElementKind.typeParameterElement;
            if (flags & 127 /* Intrinsic */)
                return ScriptElementKind.primitiveType;
            if (flags & 256 /* StringLiteral */)
                return ScriptElementKind.primitiveType;
            return ScriptElementKind.unknown;
        }
        function getNodeKind(node) {
            switch (node.kind) {
                case 188 /* ModuleDeclaration */: return ScriptElementKind.moduleElement;
                case 184 /* ClassDeclaration */: return ScriptElementKind.classElement;
                case 185 /* InterfaceDeclaration */: return ScriptElementKind.interfaceElement;
                case 186 /* TypeAliasDeclaration */: return ScriptElementKind.typeElement;
                case 187 /* EnumDeclaration */: return ScriptElementKind.enumElement;
                case 181 /* VariableDeclaration */: return node.flags & 4096 /* Const */ ? ScriptElementKind.constantElement : ScriptElementKind.variableElement;
                case 182 /* FunctionDeclaration */: return ScriptElementKind.functionElement;
                case 127 /* GetAccessor */: return ScriptElementKind.memberGetAccessorElement;
                case 128 /* SetAccessor */: return ScriptElementKind.memberSetAccessorElement;
                case 125 /* Method */: return ScriptElementKind.memberFunctionElement;
                case 124 /* Property */: return ScriptElementKind.memberVariableElement;
                case 131 /* IndexSignature */: return ScriptElementKind.indexSignatureElement;
                case 130 /* ConstructSignature */: return ScriptElementKind.constructSignatureElement;
                case 129 /* CallSignature */: return ScriptElementKind.callSignatureElement;
                case 126 /* Constructor */: return ScriptElementKind.constructorImplementationElement;
                case 122 /* TypeParameter */: return ScriptElementKind.typeParameterElement;
                case 192 /* EnumMember */: return ScriptElementKind.variableElement;
                case 123 /* Parameter */: return (node.flags & 112 /* AccessibilityModifier */) ? ScriptElementKind.memberVariableElement : ScriptElementKind.parameterElement;
            }
            return ScriptElementKind.unknown;
        }
        function getSymbolModifiers(symbol) {
            return symbol && symbol.declarations && symbol.declarations.length > 0 ? getNodeModifiers(symbol.declarations[0]) : ScriptElementKindModifier.none;
        }
        function getSymbolDisplayPartsDocumentationAndSymbolKind(symbol, sourceFile, enclosingDeclaration, typeResolver, location, 
            // TODO(drosen): Currently completion entry details passes the SemanticMeaning.All instead of using semanticMeaning of location
            semanticMeaning) {
            if (semanticMeaning === void 0) { semanticMeaning = getMeaningFromLocation(location); }
            var displayParts = [];
            var documentation;
            var symbolFlags = symbol.flags;
            var symbolKind = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(symbol, symbolFlags, typeResolver, location);
            var hasAddedSymbolInfo;
            // Class at constructor site need to be shown as constructor apart from property,method, vars
            if (symbolKind !== ScriptElementKind.unknown || symbolFlags & 32 /* Class */ || symbolFlags & 33554432 /* Import */) {
                // If it is accessor they are allowed only if location is at name of the accessor
                if (symbolKind === ScriptElementKind.memberGetAccessorElement || symbolKind === ScriptElementKind.memberSetAccessorElement) {
                    symbolKind = ScriptElementKind.memberVariableElement;
                }
                var type = typeResolver.getNarrowedTypeOfSymbol(symbol, location);
                if (type) {
                    if (location.parent && location.parent.kind === 142 /* PropertyAccess */) {
                        var right = location.parent.right;
                        // Either the location is on the right of a property access, or on the left and the right is missing
                        if (right === location || (right && right.kind === 120 /* Missing */)) {
                            location = location.parent;
                        }
                    }
                    // try get the call/construct signature from the type if it matches
                    var callExpression;
                    if (location.kind === 144 /* CallExpression */ || location.kind === 145 /* NewExpression */) {
                        callExpression = location;
                    }
                    else if (isCallExpressionTarget(location) || isNewExpressionTarget(location)) {
                        callExpression = location.parent;
                    }
                    if (callExpression) {
                        var candidateSignatures = [];
                        signature = typeResolver.getResolvedSignature(callExpression, candidateSignatures);
                        if (!signature && candidateSignatures.length) {
                            // Use the first candidate:
                            signature = candidateSignatures[0];
                        }
                        var useConstructSignatures = callExpression.kind === 145 /* NewExpression */ || callExpression.func.kind === 89 /* SuperKeyword */;
                        var allSignatures = useConstructSignatures ? type.getConstructSignatures() : type.getCallSignatures();
                        if (!ts.contains(allSignatures, signature.target || signature)) {
                            // Get the first signature if there 
                            signature = allSignatures.length ? allSignatures[0] : undefined;
                        }
                        if (signature) {
                            if (useConstructSignatures && (symbolFlags & 32 /* Class */)) {
                                // Constructor
                                symbolKind = ScriptElementKind.constructorImplementationElement;
                                addPrefixForAnyFunctionOrVar(type.symbol, symbolKind);
                            }
                            else if (symbolFlags & 33554432 /* Import */) {
                                symbolKind = ScriptElementKind.alias;
                                displayParts.push(punctuationPart(15 /* OpenParenToken */));
                                displayParts.push(textPart(symbolKind));
                                displayParts.push(punctuationPart(16 /* CloseParenToken */));
                                displayParts.push(spacePart());
                                if (useConstructSignatures) {
                                    displayParts.push(keywordPart(86 /* NewKeyword */));
                                    displayParts.push(spacePart());
                                }
                                addFullSymbolName(symbol);
                            }
                            else {
                                addPrefixForAnyFunctionOrVar(symbol, symbolKind);
                            }
                            switch (symbolKind) {
                                case ScriptElementKind.memberVariableElement:
                                case ScriptElementKind.variableElement:
                                case ScriptElementKind.constantElement:
                                case ScriptElementKind.parameterElement:
                                case ScriptElementKind.localVariableElement:
                                    // If it is call or construct signature of lambda's write type name
                                    displayParts.push(punctuationPart(50 /* ColonToken */));
                                    displayParts.push(spacePart());
                                    if (useConstructSignatures) {
                                        displayParts.push(keywordPart(86 /* NewKeyword */));
                                        displayParts.push(spacePart());
                                    }
                                    if (!(type.flags & 32768 /* Anonymous */)) {
                                        displayParts.push.apply(displayParts, symbolToDisplayParts(typeResolver, type.symbol, enclosingDeclaration, undefined, 1 /* WriteTypeParametersOrArguments */));
                                    }
                                    addSignatureDisplayParts(signature, allSignatures, 8 /* WriteArrowStyleSignature */);
                                    break;
                                default:
                                    // Just signature
                                    addSignatureDisplayParts(signature, allSignatures);
                            }
                            hasAddedSymbolInfo = true;
                        }
                    }
                    else if ((isNameOfFunctionDeclaration(location) && !(symbol.flags & 98304 /* Accessor */)) || (location.kind === 111 /* ConstructorKeyword */ && location.parent.kind === 126 /* Constructor */)) {
                        // get the signature from the declaration and write it
                        var signature;
                        var functionDeclaration = location.parent;
                        var allSignatures = functionDeclaration.kind === 126 /* Constructor */ ? type.getConstructSignatures() : type.getCallSignatures();
                        if (!typeResolver.isImplementationOfOverload(functionDeclaration)) {
                            signature = typeResolver.getSignatureFromDeclaration(functionDeclaration);
                        }
                        else {
                            signature = allSignatures[0];
                        }
                        if (functionDeclaration.kind === 126 /* Constructor */) {
                            // show (constructor) Type(...) signature
                            addPrefixForAnyFunctionOrVar(type.symbol, ScriptElementKind.constructorImplementationElement);
                        }
                        else {
                            // (function/method) symbol(..signature)
                            addPrefixForAnyFunctionOrVar(functionDeclaration.kind === 129 /* CallSignature */ && !(type.symbol.flags & 2048 /* TypeLiteral */ || type.symbol.flags & 4096 /* ObjectLiteral */) ? type.symbol : symbol, symbolKind);
                        }
                        addSignatureDisplayParts(signature, allSignatures);
                        hasAddedSymbolInfo = true;
                    }
                }
            }
            if (symbolFlags & 32 /* Class */ && !hasAddedSymbolInfo) {
                displayParts.push(keywordPart(67 /* ClassKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
                writeTypeParametersOfSymbol(symbol, sourceFile);
            }
            if ((symbolFlags & 64 /* Interface */) && (semanticMeaning & 2 /* Type */)) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(keywordPart(101 /* InterfaceKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
                writeTypeParametersOfSymbol(symbol, sourceFile);
            }
            if (symbolFlags & 2097152 /* TypeAlias */) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(keywordPart(119 /* TypeKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
                displayParts.push(spacePart());
                displayParts.push(punctuationPart(51 /* EqualsToken */));
                displayParts.push(spacePart());
                displayParts.push.apply(displayParts, typeToDisplayParts(typeResolver, typeResolver.getDeclaredTypeOfSymbol(symbol), enclosingDeclaration));
            }
            if (symbolFlags & 384 /* Enum */) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(keywordPart(75 /* EnumKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
            }
            if (symbolFlags & 1536 /* Module */) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(keywordPart(114 /* ModuleKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
            }
            if ((symbolFlags & 1048576 /* TypeParameter */) && (semanticMeaning & 2 /* Type */)) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(punctuationPart(15 /* OpenParenToken */));
                displayParts.push(textPart("type parameter"));
                displayParts.push(punctuationPart(16 /* CloseParenToken */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
                displayParts.push(spacePart());
                displayParts.push(keywordPart(84 /* InKeyword */));
                displayParts.push(spacePart());
                if (symbol.parent) {
                    // Class/Interface type parameter
                    addFullSymbolName(symbol.parent, enclosingDeclaration);
                    writeTypeParametersOfSymbol(symbol.parent, enclosingDeclaration);
                }
                else {
                    // Method/function type parameter
                    var signatureDeclaration = ts.getDeclarationOfKind(symbol, 122 /* TypeParameter */).parent;
                    var signature = typeResolver.getSignatureFromDeclaration(signatureDeclaration);
                    if (signatureDeclaration.kind === 130 /* ConstructSignature */) {
                        displayParts.push(keywordPart(86 /* NewKeyword */));
                        displayParts.push(spacePart());
                    }
                    else if (signatureDeclaration.kind !== 129 /* CallSignature */ && signatureDeclaration.name) {
                        addFullSymbolName(signatureDeclaration.symbol);
                    }
                    displayParts.push.apply(displayParts, signatureToDisplayParts(typeResolver, signature, sourceFile, 32 /* WriteTypeArgumentsOfSignature */));
                }
            }
            if (symbolFlags & 8 /* EnumMember */) {
                addPrefixForAnyFunctionOrVar(symbol, "enum member");
                var declaration = symbol.declarations[0];
                if (declaration.kind === 192 /* EnumMember */) {
                    var constantValue = typeResolver.getEnumMemberValue(declaration);
                    if (constantValue !== undefined) {
                        displayParts.push(spacePart());
                        displayParts.push(operatorPart(51 /* EqualsToken */));
                        displayParts.push(spacePart());
                        displayParts.push(displayPart(constantValue.toString(), 7 /* numericLiteral */));
                    }
                }
            }
            if (symbolFlags & 33554432 /* Import */) {
                addNewLineIfDisplayPartsExist();
                displayParts.push(keywordPart(83 /* ImportKeyword */));
                displayParts.push(spacePart());
                addFullSymbolName(symbol);
                ts.forEach(symbol.declarations, function (declaration) {
                    if (declaration.kind === 190 /* ImportDeclaration */) {
                        var importDeclaration = declaration;
                        if (importDeclaration.externalModuleName) {
                            displayParts.push(spacePart());
                            displayParts.push(punctuationPart(51 /* EqualsToken */));
                            displayParts.push(spacePart());
                            displayParts.push(keywordPart(115 /* RequireKeyword */));
                            displayParts.push(punctuationPart(15 /* OpenParenToken */));
                            displayParts.push(displayPart(ts.getTextOfNode(importDeclaration.externalModuleName), 8 /* stringLiteral */));
                            displayParts.push(punctuationPart(16 /* CloseParenToken */));
                        }
                        else {
                            var internalAliasSymbol = typeResolver.getSymbolInfo(importDeclaration.entityName);
                            if (internalAliasSymbol) {
                                displayParts.push(spacePart());
                                displayParts.push(punctuationPart(51 /* EqualsToken */));
                                displayParts.push(spacePart());
                                addFullSymbolName(internalAliasSymbol, enclosingDeclaration);
                            }
                        }
                        return true;
                    }
                });
            }
            if (!hasAddedSymbolInfo) {
                if (symbolKind !== ScriptElementKind.unknown) {
                    if (type) {
                        addPrefixForAnyFunctionOrVar(symbol, symbolKind);
                        // For properties, variables and local vars: show the type
                        if (symbolKind === ScriptElementKind.memberVariableElement || symbolFlags & 3 /* Variable */ || symbolKind === ScriptElementKind.localVariableElement) {
                            displayParts.push(punctuationPart(50 /* ColonToken */));
                            displayParts.push(spacePart());
                            // If the type is type parameter, format it specially
                            if (type.symbol && type.symbol.flags & 1048576 /* TypeParameter */) {
                                var typeParameterParts = mapToDisplayParts(function (writer) {
                                    typeResolver.getSymbolDisplayBuilder().buildTypeParameterDisplay(type, writer, enclosingDeclaration);
                                });
                                displayParts.push.apply(displayParts, typeParameterParts);
                            }
                            else {
                                displayParts.push.apply(displayParts, typeToDisplayParts(typeResolver, type, enclosingDeclaration));
                            }
                        }
                        else if (symbolFlags & 16 /* Function */ || symbolFlags & 8192 /* Method */ || symbolFlags & 16384 /* Constructor */ || symbolFlags & 917504 /* Signature */ || symbolFlags & 98304 /* Accessor */ || symbolKind === ScriptElementKind.memberFunctionElement) {
                            var allSignatures = type.getCallSignatures();
                            addSignatureDisplayParts(allSignatures[0], allSignatures);
                        }
                    }
                }
                else {
                    symbolKind = getSymbolKind(symbol, typeResolver, location);
                }
            }
            if (!documentation) {
                documentation = symbol.getDocumentationComment();
            }
            return { displayParts: displayParts, documentation: documentation, symbolKind: symbolKind };
            function addNewLineIfDisplayPartsExist() {
                if (displayParts.length) {
                    displayParts.push(lineBreakPart());
                }
            }
            function addFullSymbolName(symbol, enclosingDeclaration) {
                var fullSymbolDisplayParts = symbolToDisplayParts(typeResolver, symbol, enclosingDeclaration || sourceFile, undefined, 1 /* WriteTypeParametersOrArguments */ | 2 /* UseOnlyExternalAliasing */);
                displayParts.push.apply(displayParts, fullSymbolDisplayParts);
            }
            function addPrefixForAnyFunctionOrVar(symbol, symbolKind) {
                addNewLineIfDisplayPartsExist();
                if (symbolKind) {
                    displayParts.push(punctuationPart(15 /* OpenParenToken */));
                    displayParts.push(textPart(symbolKind));
                    displayParts.push(punctuationPart(16 /* CloseParenToken */));
                    displayParts.push(spacePart());
                    addFullSymbolName(symbol);
                }
            }
            function addSignatureDisplayParts(signature, allSignatures, flags) {
                displayParts.push.apply(displayParts, signatureToDisplayParts(typeResolver, signature, enclosingDeclaration, flags | 32 /* WriteTypeArgumentsOfSignature */));
                if (allSignatures.length > 1) {
                    displayParts.push(spacePart());
                    displayParts.push(punctuationPart(15 /* OpenParenToken */));
                    displayParts.push(operatorPart(32 /* PlusToken */));
                    displayParts.push(displayPart((allSignatures.length - 1).toString(), 7 /* numericLiteral */));
                    displayParts.push(spacePart());
                    displayParts.push(textPart(allSignatures.length === 2 ? "overload" : "overloads"));
                    displayParts.push(punctuationPart(16 /* CloseParenToken */));
                }
                documentation = signature.getDocumentationComment();
            }
            function writeTypeParametersOfSymbol(symbol, enclosingDeclaration) {
                var typeParameterParts = mapToDisplayParts(function (writer) {
                    typeResolver.getSymbolDisplayBuilder().buildTypeParameterDisplayFromSymbol(symbol, writer, enclosingDeclaration);
                });
                displayParts.push.apply(displayParts, typeParameterParts);
            }
        }
        function getQuickInfoAtPosition(fileName, position) {
            synchronizeHostData();
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (!node) {
                return undefined;
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            if (!symbol) {
                switch (node.kind) {
                    case 63 /* Identifier */:
                    case 142 /* PropertyAccess */:
                    case 121 /* QualifiedName */:
                    case 91 /* ThisKeyword */:
                    case 89 /* SuperKeyword */:
                        // For the identifiers/this/super etc get the type at position
                        var type = typeInfoResolver.getTypeOfNode(node);
                        if (type) {
                            return {
                                kind: ScriptElementKind.unknown,
                                kindModifiers: ScriptElementKindModifier.none,
                                textSpan: new TypeScript.TextSpan(node.getStart(), node.getWidth()),
                                displayParts: typeToDisplayParts(typeInfoResolver, type, getContainerNode(node)),
                                documentation: type.symbol ? type.symbol.getDocumentationComment() : undefined
                            };
                        }
                }
                return undefined;
            }
            var displayPartsDocumentationsAndKind = getSymbolDisplayPartsDocumentationAndSymbolKind(symbol, sourceFile, getContainerNode(node), typeInfoResolver, node);
            return {
                kind: displayPartsDocumentationsAndKind.symbolKind,
                kindModifiers: getSymbolModifiers(symbol),
                textSpan: new TypeScript.TextSpan(node.getStart(), node.getWidth()),
                displayParts: displayPartsDocumentationsAndKind.displayParts,
                documentation: displayPartsDocumentationsAndKind.documentation
            };
        }
        /// Goto definition
        function getDefinitionAtPosition(filename, position) {
            function getDefinitionInfo(node, symbolKind, symbolName, containerName) {
                return {
                    fileName: node.getSourceFile().filename,
                    textSpan: TypeScript.TextSpan.fromBounds(node.getStart(), node.getEnd()),
                    kind: symbolKind,
                    name: symbolName,
                    containerKind: undefined,
                    containerName: containerName
                };
            }
            function tryAddSignature(signatureDeclarations, selectConstructors, symbolKind, symbolName, containerName, result) {
                var declarations = [];
                var definition;
                ts.forEach(signatureDeclarations, function (d) {
                    if ((selectConstructors && d.kind === 126 /* Constructor */) || (!selectConstructors && (d.kind === 182 /* FunctionDeclaration */ || d.kind === 125 /* Method */))) {
                        declarations.push(d);
                        if (d.body)
                            definition = d;
                    }
                });
                if (definition) {
                    result.push(getDefinitionInfo(definition, symbolKind, symbolName, containerName));
                    return true;
                }
                else if (declarations.length) {
                    result.push(getDefinitionInfo(declarations[declarations.length - 1], symbolKind, symbolName, containerName));
                    return true;
                }
                return false;
            }
            function tryAddConstructSignature(symbol, location, symbolKind, symbolName, containerName, result) {
                // Applicable only if we are in a new expression, or we are on a constructor declaration
                // and in either case the symbol has a construct signature definition, i.e. class
                if (isNewExpressionTarget(location) || location.kind === 111 /* ConstructorKeyword */) {
                    if (symbol.flags & 32 /* Class */) {
                        var classDeclaration = symbol.getDeclarations()[0];
                        ts.Debug.assert(classDeclaration && classDeclaration.kind === 184 /* ClassDeclaration */);
                        return tryAddSignature(classDeclaration.members, true, symbolKind, symbolName, containerName, result);
                    }
                }
                return false;
            }
            function tryAddCallSignature(symbol, location, symbolKind, symbolName, containerName, result) {
                if (isCallExpressionTarget(location) || isNewExpressionTarget(location) || isNameOfFunctionDeclaration(location)) {
                    return tryAddSignature(symbol.declarations, false, symbolKind, symbolName, containerName, result);
                }
                return false;
            }
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (!node) {
                return undefined;
            }
            // Labels
            if (isJumpStatementTarget(node)) {
                var labelName = node.text;
                var label = getTargetLabel(node.parent, node.text);
                return label ? [getDefinitionInfo(label, ScriptElementKind.label, labelName, undefined)] : undefined;
            }
            /// Triple slash reference comments
            var comment = ts.forEach(sourceFile.referencedFiles, function (r) { return (r.pos <= position && position < r.end) ? r : undefined; });
            if (comment) {
                var targetFilename = ts.isRootedDiskPath(comment.filename) ? comment.filename : ts.combinePaths(ts.getDirectoryPath(filename), comment.filename);
                targetFilename = ts.normalizePath(targetFilename);
                if (program.getSourceFile(targetFilename)) {
                    return [{
                        fileName: targetFilename,
                        textSpan: TypeScript.TextSpan.fromBounds(0, 0),
                        kind: ScriptElementKind.scriptElement,
                        name: comment.filename,
                        containerName: undefined,
                        containerKind: undefined
                    }];
                }
                return undefined;
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            // Could not find a symbol e.g. node is string or number keyword,
            // or the symbol was an internal symbol and does not have a declaration e.g. undefined symbol
            if (!symbol) {
                return undefined;
            }
            var result = [];
            var declarations = symbol.getDeclarations();
            var symbolName = typeInfoResolver.symbolToString(symbol); // Do not get scoped name, just the name of the symbol
            var symbolKind = getSymbolKind(symbol, typeInfoResolver);
            var containerSymbol = symbol.parent;
            var containerName = containerSymbol ? typeInfoResolver.symbolToString(containerSymbol, node) : "";
            if (!tryAddConstructSignature(symbol, node, symbolKind, symbolName, containerName, result) && !tryAddCallSignature(symbol, node, symbolKind, symbolName, containerName, result)) {
                // Just add all the declarations. 
                ts.forEach(declarations, function (declaration) {
                    result.push(getDefinitionInfo(declaration, symbolKind, symbolName, containerName));
                });
            }
            return result;
        }
        /// References and Occurrences
        function getOccurrencesAtPosition(filename, position) {
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var node = ts.getTouchingWord(sourceFile, position);
            if (!node) {
                return undefined;
            }
            if (node.kind === 63 /* Identifier */ || node.kind === 91 /* ThisKeyword */ || node.kind === 89 /* SuperKeyword */ || isLiteralNameOfPropertyDeclarationOrIndexAccess(node) || isNameOfExternalModuleImportOrDeclaration(node)) {
                return getReferencesForNode(node, [sourceFile], false, false);
            }
            switch (node.kind) {
                case 82 /* IfKeyword */:
                case 74 /* ElseKeyword */:
                    if (hasKind(node.parent, 162 /* IfStatement */)) {
                        return getIfElseOccurrences(node.parent);
                    }
                    break;
                case 88 /* ReturnKeyword */:
                    if (hasKind(node.parent, 169 /* ReturnStatement */)) {
                        return getReturnOccurrences(node.parent);
                    }
                    break;
                case 92 /* ThrowKeyword */:
                    if (hasKind(node.parent, 175 /* ThrowStatement */)) {
                        return getThrowOccurrences(node.parent);
                    }
                    break;
                case 94 /* TryKeyword */:
                case 66 /* CatchKeyword */:
                case 79 /* FinallyKeyword */:
                    if (hasKind(parent(parent(node)), 176 /* TryStatement */)) {
                        return getTryCatchFinallyOccurrences(node.parent.parent);
                    }
                    break;
                case 90 /* SwitchKeyword */:
                    if (hasKind(node.parent, 171 /* SwitchStatement */)) {
                        return getSwitchCaseDefaultOccurrences(node.parent);
                    }
                    break;
                case 65 /* CaseKeyword */:
                case 71 /* DefaultKeyword */:
                    if (hasKind(parent(parent(node)), 171 /* SwitchStatement */)) {
                        return getSwitchCaseDefaultOccurrences(node.parent.parent);
                    }
                    break;
                case 64 /* BreakKeyword */:
                case 69 /* ContinueKeyword */:
                    if (hasKind(node.parent, 168 /* BreakStatement */) || hasKind(node.parent, 167 /* ContinueStatement */)) {
                        return getBreakOrContinueStatementOccurences(node.parent);
                    }
                    break;
                case 80 /* ForKeyword */:
                    if (hasKind(node.parent, 165 /* ForStatement */) || hasKind(node.parent, 166 /* ForInStatement */)) {
                        return getLoopBreakContinueOccurrences(node.parent);
                    }
                    break;
                case 98 /* WhileKeyword */:
                case 73 /* DoKeyword */:
                    if (hasKind(node.parent, 164 /* WhileStatement */) || hasKind(node.parent, 163 /* DoStatement */)) {
                        return getLoopBreakContinueOccurrences(node.parent);
                    }
                    break;
                case 111 /* ConstructorKeyword */:
                    if (hasKind(node.parent, 126 /* Constructor */)) {
                        return getConstructorOccurrences(node.parent);
                    }
                    break;
                case 113 /* GetKeyword */:
                case 117 /* SetKeyword */:
                    if (hasKind(node.parent, 127 /* GetAccessor */) || hasKind(node.parent, 128 /* SetAccessor */)) {
                        return getGetAndSetOccurrences(node.parent);
                    }
            }
            return undefined;
            function getIfElseOccurrences(ifStatement) {
                var keywords = [];
                while (hasKind(ifStatement.parent, 162 /* IfStatement */) && ifStatement.parent.elseStatement === ifStatement) {
                    ifStatement = ifStatement.parent;
                }
                while (ifStatement) {
                    var children = ifStatement.getChildren();
                    pushKeywordIf(keywords, children[0], 82 /* IfKeyword */);
                    for (var i = children.length - 1; i >= 0; i--) {
                        if (pushKeywordIf(keywords, children[i], 74 /* ElseKeyword */)) {
                            break;
                        }
                    }
                    if (!hasKind(ifStatement.elseStatement, 162 /* IfStatement */)) {
                        break;
                    }
                    ifStatement = ifStatement.elseStatement;
                }
                var result = [];
                for (var i = 0; i < keywords.length; i++) {
                    if (keywords[i].kind === 74 /* ElseKeyword */ && i < keywords.length - 1) {
                        var elseKeyword = keywords[i];
                        var ifKeyword = keywords[i + 1]; // this *should* always be an 'if' keyword.
                        var shouldHighlightNextKeyword = true;
                        for (var j = ifKeyword.getStart() - 1; j >= elseKeyword.end; j--) {
                            if (!ts.isWhiteSpace(sourceFile.text.charCodeAt(j))) {
                                shouldHighlightNextKeyword = false;
                                break;
                            }
                        }
                        if (shouldHighlightNextKeyword) {
                            result.push({
                                fileName: filename,
                                textSpan: TypeScript.TextSpan.fromBounds(elseKeyword.getStart(), ifKeyword.end),
                                isWriteAccess: false
                            });
                            i++; // skip the next keyword
                            continue;
                        }
                    }
                    // Ordinary case: just highlight the keyword.
                    result.push(getReferenceEntryFromNode(keywords[i]));
                }
                return result;
            }
            function getReturnOccurrences(returnStatement) {
                var func = ts.getContainingFunction(returnStatement);
                // If we didn't find a containing function with a block body, bail out.
                if (!(func && hasKind(func.body, 183 /* FunctionBlock */))) {
                    return undefined;
                }
                var keywords = [];
                ts.forEachReturnStatement(func.body, function (returnStatement) {
                    pushKeywordIf(keywords, returnStatement.getFirstToken(), 88 /* ReturnKeyword */);
                });
                // Include 'throw' statements that do not occur within a try block.
                ts.forEach(aggregateOwnedThrowStatements(func.body), function (throwStatement) {
                    pushKeywordIf(keywords, throwStatement.getFirstToken(), 92 /* ThrowKeyword */);
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getThrowOccurrences(throwStatement) {
                var owner = getThrowStatementOwner(throwStatement);
                if (!owner) {
                    return undefined;
                }
                var keywords = [];
                ts.forEach(aggregateOwnedThrowStatements(owner), function (throwStatement) {
                    pushKeywordIf(keywords, throwStatement.getFirstToken(), 92 /* ThrowKeyword */);
                });
                // If the "owner" is a function, then we equate 'return' and 'throw' statements in their
                // ability to "jump out" of the function, and include occurrences for both.
                if (owner.kind === 183 /* FunctionBlock */) {
                    ts.forEachReturnStatement(owner, function (returnStatement) {
                        pushKeywordIf(keywords, returnStatement.getFirstToken(), 88 /* ReturnKeyword */);
                    });
                }
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            /**
             * Aggregates all throw-statements within this node *without* crossing
             * into function boundaries and try-blocks with catch-clauses.
             */
            function aggregateOwnedThrowStatements(node) {
                var statementAccumulator = [];
                aggregate(node);
                return statementAccumulator;
                function aggregate(node) {
                    if (node.kind === 175 /* ThrowStatement */) {
                        statementAccumulator.push(node);
                    }
                    else if (node.kind === 176 /* TryStatement */) {
                        var tryStatement = node;
                        if (tryStatement.catchBlock) {
                            aggregate(tryStatement.catchBlock);
                        }
                        else {
                            // Exceptions thrown within a try block lacking a catch clause
                            // are "owned" in the current context.
                            aggregate(tryStatement.tryBlock);
                        }
                        if (tryStatement.finallyBlock) {
                            aggregate(tryStatement.finallyBlock);
                        }
                    }
                    else if (!ts.isAnyFunction(node)) {
                        ts.forEachChild(node, aggregate);
                    }
                }
                ;
            }
            /**
             * For lack of a better name, this function takes a throw statement and returns the
             * nearest ancestor that is a try-block (whose try statement has a catch clause),
             * function-block, or source file.
             */
            function getThrowStatementOwner(throwStatement) {
                var child = throwStatement;
                while (child.parent) {
                    var parent = child.parent;
                    if (parent.kind === 183 /* FunctionBlock */ || parent.kind === 193 /* SourceFile */) {
                        return parent;
                    }
                    // A throw-statement is only owned by a try-statement if the try-statement has
                    // a catch clause, and if the throw-statement occurs within the try block.
                    if (parent.kind === 176 /* TryStatement */) {
                        var tryStatement = parent;
                        if (tryStatement.tryBlock === child && tryStatement.catchBlock) {
                            return child;
                        }
                    }
                    child = parent;
                }
                return undefined;
            }
            function getTryCatchFinallyOccurrences(tryStatement) {
                var keywords = [];
                pushKeywordIf(keywords, tryStatement.getFirstToken(), 94 /* TryKeyword */);
                if (tryStatement.catchBlock) {
                    pushKeywordIf(keywords, tryStatement.catchBlock.getFirstToken(), 66 /* CatchKeyword */);
                }
                if (tryStatement.finallyBlock) {
                    pushKeywordIf(keywords, tryStatement.finallyBlock.getFirstToken(), 79 /* FinallyKeyword */);
                }
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getLoopBreakContinueOccurrences(loopNode) {
                var keywords = [];
                if (pushKeywordIf(keywords, loopNode.getFirstToken(), 80 /* ForKeyword */, 98 /* WhileKeyword */, 73 /* DoKeyword */)) {
                    // If we succeeded and got a do-while loop, then start looking for a 'while' keyword.
                    if (loopNode.kind === 163 /* DoStatement */) {
                        var loopTokens = loopNode.getChildren();
                        for (var i = loopTokens.length - 1; i >= 0; i--) {
                            if (pushKeywordIf(keywords, loopTokens[i], 98 /* WhileKeyword */)) {
                                break;
                            }
                        }
                    }
                }
                var breaksAndContinues = aggregateAllBreakAndContinueStatements(loopNode.statement);
                ts.forEach(breaksAndContinues, function (statement) {
                    if (ownsBreakOrContinueStatement(loopNode, statement)) {
                        pushKeywordIf(keywords, statement.getFirstToken(), 64 /* BreakKeyword */, 69 /* ContinueKeyword */);
                    }
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getSwitchCaseDefaultOccurrences(switchStatement) {
                var keywords = [];
                pushKeywordIf(keywords, switchStatement.getFirstToken(), 90 /* SwitchKeyword */);
                // Types of break statements we can grab on to.
                var breakSearchType = 3 /* All */;
                // Go through each clause in the switch statement, collecting the 'case'/'default' keywords.
                ts.forEach(switchStatement.clauses, function (clause) {
                    pushKeywordIf(keywords, clause.getFirstToken(), 65 /* CaseKeyword */, 71 /* DefaultKeyword */);
                    var breaksAndContinues = aggregateAllBreakAndContinueStatements(clause);
                    ts.forEach(breaksAndContinues, function (statement) {
                        if (ownsBreakOrContinueStatement(switchStatement, statement)) {
                            pushKeywordIf(keywords, statement.getFirstToken(), 64 /* BreakKeyword */);
                        }
                    });
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getBreakOrContinueStatementOccurences(breakOrContinueStatement) {
                var owner = getBreakOrContinueOwner(breakOrContinueStatement);
                if (owner) {
                    switch (owner.kind) {
                        case 165 /* ForStatement */:
                        case 166 /* ForInStatement */:
                        case 163 /* DoStatement */:
                        case 164 /* WhileStatement */:
                            return getLoopBreakContinueOccurrences(owner);
                        case 171 /* SwitchStatement */:
                            return getSwitchCaseDefaultOccurrences(owner);
                    }
                }
                return undefined;
            }
            function aggregateAllBreakAndContinueStatements(node) {
                var statementAccumulator = [];
                aggregate(node);
                return statementAccumulator;
                function aggregate(node) {
                    if (node.kind === 168 /* BreakStatement */ || node.kind === 167 /* ContinueStatement */) {
                        statementAccumulator.push(node);
                    }
                    else if (!ts.isAnyFunction(node)) {
                        ts.forEachChild(node, aggregate);
                    }
                }
                ;
            }
            function ownsBreakOrContinueStatement(owner, statement) {
                var actualOwner = getBreakOrContinueOwner(statement);
                return actualOwner && actualOwner === owner;
            }
            function getBreakOrContinueOwner(statement) {
                for (var node = statement.parent; node; node = node.parent) {
                    switch (node.kind) {
                        case 171 /* SwitchStatement */:
                            if (statement.kind === 167 /* ContinueStatement */) {
                                continue;
                            }
                        case 165 /* ForStatement */:
                        case 166 /* ForInStatement */:
                        case 164 /* WhileStatement */:
                        case 163 /* DoStatement */:
                            if (!statement.label || isLabeledBy(node, statement.label.text)) {
                                return node;
                            }
                            break;
                        default:
                            // Don't cross function boundaries.
                            if (ts.isAnyFunction(node)) {
                                return undefined;
                            }
                            break;
                    }
                }
                return undefined;
            }
            function getConstructorOccurrences(constructorDeclaration) {
                var declarations = constructorDeclaration.symbol.getDeclarations();
                var keywords = [];
                ts.forEach(declarations, function (declaration) {
                    ts.forEach(declaration.getChildren(), function (token) {
                        return pushKeywordIf(keywords, token, 111 /* ConstructorKeyword */);
                    });
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getGetAndSetOccurrences(accessorDeclaration) {
                var keywords = [];
                tryPushAccessorKeyword(accessorDeclaration.symbol, 127 /* GetAccessor */);
                tryPushAccessorKeyword(accessorDeclaration.symbol, 128 /* SetAccessor */);
                return ts.map(keywords, getReferenceEntryFromNode);
                function tryPushAccessorKeyword(accessorSymbol, accessorKind) {
                    var accessor = ts.getDeclarationOfKind(accessorSymbol, accessorKind);
                    if (accessor) {
                        ts.forEach(accessor.getChildren(), function (child) { return pushKeywordIf(keywords, child, 113 /* GetKeyword */, 117 /* SetKeyword */); });
                    }
                }
            }
            // returns true if 'node' is defined and has a matching 'kind'.
            function hasKind(node, kind) {
                return node !== undefined && node.kind === kind;
            }
            // Null-propagating 'parent' function.
            function parent(node) {
                return node && node.parent;
            }
            function pushKeywordIf(keywordList, token) {
                var expected = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    expected[_i - 2] = arguments[_i];
                }
                if (token && ts.contains(expected, token.kind)) {
                    keywordList.push(token);
                    return true;
                }
                return false;
            }
        }
        function findRenameLocations(fileName, position, findInStrings, findInComments) {
            return findReferences(fileName, position, findInStrings, findInComments);
        }
        function getReferencesAtPosition(fileName, position) {
            return findReferences(fileName, position, false, false);
        }
        function findReferences(fileName, position, findInStrings, findInComments) {
            synchronizeHostData();
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (!node) {
                return undefined;
            }
            if (node.kind !== 63 /* Identifier */ && !isLiteralNameOfPropertyDeclarationOrIndexAccess(node) && !isNameOfExternalModuleImportOrDeclaration(node)) {
                return undefined;
            }
            ts.Debug.assert(node.kind === 63 /* Identifier */ || node.kind === 6 /* NumericLiteral */ || node.kind === 7 /* StringLiteral */);
            return getReferencesForNode(node, program.getSourceFiles(), findInStrings, findInComments);
        }
        function getReferencesForNode(node, sourceFiles, findInStrings, findInComments) {
            // Labels
            if (isLabelName(node)) {
                if (isJumpStatementTarget(node)) {
                    var labelDefinition = getTargetLabel(node.parent, node.text);
                    // if we have a label definition, look within its statement for references, if not, then
                    // the label is undefined, just return a set of one for the current node.
                    return labelDefinition ? getLabelReferencesInNode(labelDefinition.parent, labelDefinition) : [getReferenceEntryFromNode(node)];
                }
                else {
                    // it is a label definition and not a target, search within the parent labeledStatement
                    return getLabelReferencesInNode(node.parent, node);
                }
            }
            if (node.kind === 91 /* ThisKeyword */) {
                return getReferencesForThisKeyword(node, sourceFiles);
            }
            if (node.kind === 89 /* SuperKeyword */) {
                return getReferencesForSuperKeyword(node);
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            // Could not find a symbol e.g. unknown identifier
            if (!symbol) {
                // Even if we did not find a symbol, we have an identifier, so there is at least
                // one reference that we know of. return that instead of undefined.
                return [getReferenceEntryFromNode(node)];
            }
            var declarations = symbol.declarations;
            // The symbol was an internal symbol and does not have a declaration e.g.undefined symbol
            if (!declarations || !declarations.length) {
                return undefined;
            }
            var result;
            // Compute the meaning from the location and the symbol it references
            var searchMeaning = getIntersectingMeaningFromDeclarations(getMeaningFromLocation(node), declarations);
            // Get the text to search for, we need to normalize it as external module names will have quote
            var symbolName = getNormalizedSymbolName(symbol.name, declarations);
            // Get syntactic diagnostics
            var scope = getSymbolScope(symbol);
            if (scope) {
                result = [];
                getReferencesInNode(scope, symbol, symbolName, node, searchMeaning, findInStrings, findInComments, result);
            }
            else {
                ts.forEach(sourceFiles, function (sourceFile) {
                    cancellationToken.throwIfCancellationRequested();
                    if (ts.lookUp(sourceFile.identifiers, symbolName)) {
                        result = result || [];
                        getReferencesInNode(sourceFile, symbol, symbolName, node, searchMeaning, findInStrings, findInComments, result);
                    }
                });
            }
            return result;
            function getNormalizedSymbolName(symbolName, declarations) {
                // Special case for function expressions, whose names are solely local to their bodies.
                var functionExpression = ts.forEach(declarations, function (d) { return d.kind === 149 /* FunctionExpression */ ? d : undefined; });
                if (functionExpression && functionExpression.name) {
                    var name = functionExpression.name.text;
                }
                else {
                    var name = symbolName;
                }
                var length = name.length;
                if (length >= 2 && name.charCodeAt(0) === 34 /* doubleQuote */ && name.charCodeAt(length - 1) === 34 /* doubleQuote */) {
                    return name.substring(1, length - 1);
                }
                ;
                return name;
            }
            function getSymbolScope(symbol) {
                // If this is private property or method, the scope is the containing class
                if (symbol.getFlags() && (4 /* Property */ | 8192 /* Method */)) {
                    var privateDeclaration = ts.forEach(symbol.getDeclarations(), function (d) { return (d.flags & 32 /* Private */) ? d : undefined; });
                    if (privateDeclaration) {
                        return ts.getAncestor(privateDeclaration, 184 /* ClassDeclaration */);
                    }
                }
                // if this symbol is visible from its parent container, e.g. exported, then bail out
                if (symbol.parent) {
                    return undefined;
                }
                var scope = undefined;
                var declarations = symbol.getDeclarations();
                if (declarations) {
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var container = getContainerNode(declarations[i]);
                        if (scope && scope !== container) {
                            // Different declarations have different containers, bail out
                            return undefined;
                        }
                        if (container.kind === 193 /* SourceFile */ && !ts.isExternalModule(container)) {
                            // This is a global variable and not an external module, any declaration defined
                            // within this scope is visible outside the file
                            return undefined;
                        }
                        // The search scope is the container node
                        scope = container;
                    }
                }
                return scope;
            }
            function getPossibleSymbolReferencePositions(sourceFile, symbolName, start, end) {
                var positions = [];
                /// TODO: Cache symbol existence for files to save text search
                // Also, need to make this work for unicode escapes.
                // Be resilient in the face of a symbol with no name or zero length name
                if (!symbolName || !symbolName.length) {
                    return positions;
                }
                var text = sourceFile.text;
                var sourceLength = text.length;
                var symbolNameLength = symbolName.length;
                var position = text.indexOf(symbolName, start);
                while (position >= 0) {
                    cancellationToken.throwIfCancellationRequested();
                    // If we are past the end, stop looking
                    if (position > end)
                        break;
                    // We found a match.  Make sure it's not part of a larger word (i.e. the char 
                    // before and after it have to be a non-identifier char).
                    var endPosition = position + symbolNameLength;
                    if ((position === 0 || !ts.isIdentifierPart(text.charCodeAt(position - 1), 2 /* Latest */)) && (endPosition === sourceLength || !ts.isIdentifierPart(text.charCodeAt(endPosition), 2 /* Latest */))) {
                        // Found a real match.  Keep searching.  
                        positions.push(position);
                    }
                    position = text.indexOf(symbolName, position + symbolNameLength + 1);
                }
                return positions;
            }
            function getLabelReferencesInNode(container, targetLabel) {
                var result = [];
                var sourceFile = container.getSourceFile();
                var labelName = targetLabel.text;
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, labelName, container.getStart(), container.getEnd());
                ts.forEach(possiblePositions, function (position) {
                    cancellationToken.throwIfCancellationRequested();
                    var node = ts.getTouchingWord(sourceFile, position);
                    if (!node || node.getWidth() !== labelName.length) {
                        return;
                    }
                    // Only pick labels that are either the target label, or have a target that is the target label
                    if (node === targetLabel || (isJumpStatementTarget(node) && getTargetLabel(node, labelName) === targetLabel)) {
                        result.push(getReferenceEntryFromNode(node));
                    }
                });
                return result;
            }
            function isValidReferencePosition(node, searchSymbolName) {
                if (node) {
                    switch (node.kind) {
                        case 63 /* Identifier */:
                            return node.getWidth() === searchSymbolName.length;
                        case 7 /* StringLiteral */:
                            if (isLiteralNameOfPropertyDeclarationOrIndexAccess(node) || isNameOfExternalModuleImportOrDeclaration(node)) {
                                // For string literals we have two additional chars for the quotes
                                return node.getWidth() === searchSymbolName.length + 2;
                            }
                            break;
                        case 6 /* NumericLiteral */:
                            if (isLiteralNameOfPropertyDeclarationOrIndexAccess(node)) {
                                return node.getWidth() === searchSymbolName.length;
                            }
                            break;
                    }
                }
                return false;
            }
            /** Search within node "container" for references for a search value, where the search value is defined as a
              * tuple of(searchSymbol, searchText, searchLocation, and searchMeaning).
              * searchLocation: a node where the search value
              */
            function getReferencesInNode(container, searchSymbol, searchText, searchLocation, searchMeaning, findInStrings, findInComments, result) {
                var sourceFile = container.getSourceFile();
                var tripleSlashDirectivePrefixRegex = /^\/\/\/\s*</;
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, searchText, container.getStart(), container.getEnd());
                if (possiblePositions.length) {
                    // Build the set of symbols to search for, initially it has only the current symbol
                    var searchSymbols = populateSearchSymbolSet(searchSymbol, searchLocation);
                    ts.forEach(possiblePositions, function (position) {
                        cancellationToken.throwIfCancellationRequested();
                        var referenceLocation = ts.getTouchingPropertyName(sourceFile, position);
                        if (!isValidReferencePosition(referenceLocation, searchText)) {
                            // This wasn't the start of a token.  Check to see if it might be a 
                            // match in a comment or string if that's what the caller is asking
                            // for.
                            if ((findInStrings && isInString(position)) || (findInComments && isInComment(position))) {
                                result.push({
                                    fileName: sourceFile.filename,
                                    textSpan: new TypeScript.TextSpan(position, searchText.length),
                                    isWriteAccess: false
                                });
                            }
                            return;
                        }
                        if (!(getMeaningFromLocation(referenceLocation) & searchMeaning)) {
                            return;
                        }
                        var referenceSymbol = typeInfoResolver.getSymbolInfo(referenceLocation);
                        if (referenceSymbol && isRelatableToSearchSet(searchSymbols, referenceSymbol, referenceLocation)) {
                            result.push(getReferenceEntryFromNode(referenceLocation));
                        }
                    });
                }
                function isInString(position) {
                    var token = ts.getTokenAtPosition(sourceFile, position);
                    return token && token.kind === 7 /* StringLiteral */ && position > token.getStart();
                }
                function isInComment(position) {
                    var token = ts.getTokenAtPosition(sourceFile, position);
                    if (token && position < token.getStart()) {
                        // First, we have to see if this position actually landed in a comment.
                        var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
                        // Then we want to make sure that it wasn't in a "///<" directive comment
                        // We don't want to unintentionally update a file name.
                        return ts.forEach(commentRanges, function (c) {
                            if (c.pos < position && position < c.end) {
                                var commentText = sourceFile.text.substring(c.pos, c.end);
                                if (!tripleSlashDirectivePrefixRegex.test(commentText)) {
                                    return true;
                                }
                            }
                        });
                    }
                    return false;
                }
            }
            function getReferencesForSuperKeyword(superKeyword) {
                var searchSpaceNode = ts.getSuperContainer(superKeyword);
                if (!searchSpaceNode) {
                    return undefined;
                }
                // Whether 'super' occurs in a static context within a class.
                var staticFlag = 128 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 124 /* Property */:
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                        staticFlag &= searchSpaceNode.flags;
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    default:
                        return undefined;
                }
                var result = [];
                var sourceFile = searchSpaceNode.getSourceFile();
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "super", searchSpaceNode.getStart(), searchSpaceNode.getEnd());
                ts.forEach(possiblePositions, function (position) {
                    cancellationToken.throwIfCancellationRequested();
                    var node = ts.getTouchingWord(sourceFile, position);
                    if (!node || node.kind !== 89 /* SuperKeyword */) {
                        return;
                    }
                    var container = ts.getSuperContainer(node);
                    // If we have a 'super' container, we must have an enclosing class.
                    // Now make sure the owning class is the same as the search-space
                    // and has the same static qualifier as the original 'super's owner.
                    if (container && (128 /* Static */ & container.flags) === staticFlag && container.parent.symbol === searchSpaceNode.symbol) {
                        result.push(getReferenceEntryFromNode(node));
                    }
                });
                return result;
            }
            function getReferencesForThisKeyword(thisOrSuperKeyword, sourceFiles) {
                var searchSpaceNode = ts.getThisContainer(thisOrSuperKeyword, false);
                // Whether 'this' occurs in a static context within a class.
                var staticFlag = 128 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 124 /* Property */:
                    case 125 /* Method */:
                    case 126 /* Constructor */:
                    case 127 /* GetAccessor */:
                    case 128 /* SetAccessor */:
                        staticFlag &= searchSpaceNode.flags;
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    case 193 /* SourceFile */:
                        if (ts.isExternalModule(searchSpaceNode)) {
                            return undefined;
                        }
                    case 182 /* FunctionDeclaration */:
                    case 149 /* FunctionExpression */:
                        break;
                    default:
                        return undefined;
                }
                var result = [];
                if (searchSpaceNode.kind === 193 /* SourceFile */) {
                    ts.forEach(sourceFiles, function (sourceFile) {
                        var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "this", sourceFile.getStart(), sourceFile.getEnd());
                        getThisReferencesInFile(sourceFile, sourceFile, possiblePositions, result);
                    });
                }
                else {
                    var sourceFile = searchSpaceNode.getSourceFile();
                    var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "this", searchSpaceNode.getStart(), searchSpaceNode.getEnd());
                    getThisReferencesInFile(sourceFile, searchSpaceNode, possiblePositions, result);
                }
                return result;
                function getThisReferencesInFile(sourceFile, searchSpaceNode, possiblePositions, result) {
                    ts.forEach(possiblePositions, function (position) {
                        cancellationToken.throwIfCancellationRequested();
                        var node = ts.getTouchingWord(sourceFile, position);
                        if (!node || node.kind !== 91 /* ThisKeyword */) {
                            return;
                        }
                        var container = ts.getThisContainer(node, false);
                        switch (searchSpaceNode.kind) {
                            case 149 /* FunctionExpression */:
                            case 182 /* FunctionDeclaration */:
                                if (searchSpaceNode.symbol === container.symbol) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                            case 184 /* ClassDeclaration */:
                                // Make sure the container belongs to the same class
                                // and has the appropriate static modifier from the original container.
                                if (container.parent && searchSpaceNode.symbol === container.parent.symbol && (container.flags & 128 /* Static */) === staticFlag) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                            case 193 /* SourceFile */:
                                if (container.kind === 193 /* SourceFile */ && !ts.isExternalModule(container)) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                        }
                    });
                }
            }
            function populateSearchSymbolSet(symbol, location) {
                // The search set contains at least the current symbol
                var result = [symbol];
                // If the location is in a context sensitive location (i.e. in an object literal) try
                // to get a contextual type for it, and add the property symbol from the contextual
                // type to the search set
                if (isNameOfPropertyAssignment(location)) {
                    ts.forEach(getPropertySymbolsFromContextualType(location), function (contextualSymbol) {
                        result.push.apply(result, typeInfoResolver.getRootSymbols(contextualSymbol));
                    });
                }
                // If this is a union property, add all the symbols from all its source symbols in all unioned types.
                // If the symbol is an instantiation from a another symbol (e.g. widened symbol) , add the root the list
                ts.forEach(typeInfoResolver.getRootSymbols(symbol), function (rootSymbol) {
                    if (rootSymbol !== symbol) {
                        result.push(rootSymbol);
                    }
                    // Add symbol of properties/methods of the same name in base classes and implemented interfaces definitions
                    if (rootSymbol.parent && rootSymbol.parent.flags & (32 /* Class */ | 64 /* Interface */)) {
                        getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result);
                    }
                });
                return result;
            }
            function getPropertySymbolsFromBaseTypes(symbol, propertyName, result) {
                if (symbol && symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
                    ts.forEach(symbol.getDeclarations(), function (declaration) {
                        if (declaration.kind === 184 /* ClassDeclaration */) {
                            getPropertySymbolFromTypeReference(declaration.baseType);
                            ts.forEach(declaration.implementedTypes, getPropertySymbolFromTypeReference);
                        }
                        else if (declaration.kind === 185 /* InterfaceDeclaration */) {
                            ts.forEach(declaration.baseTypes, getPropertySymbolFromTypeReference);
                        }
                    });
                }
                return;
                function getPropertySymbolFromTypeReference(typeReference) {
                    if (typeReference) {
                        var type = typeInfoResolver.getTypeOfNode(typeReference);
                        if (type) {
                            var propertySymbol = typeInfoResolver.getPropertyOfType(type, propertyName);
                            if (propertySymbol) {
                                result.push(propertySymbol);
                            }
                            // Visit the typeReference as well to see if it directly or indirectly use that property
                            getPropertySymbolsFromBaseTypes(type.symbol, propertyName, result);
                        }
                    }
                }
            }
            function isRelatableToSearchSet(searchSymbols, referenceSymbol, referenceLocation) {
                if (searchSymbols.indexOf(referenceSymbol) >= 0) {
                    return true;
                }
                // If the reference location is in an object literal, try to get the contextual type for the 
                // object literal, lookup the property symbol in the contextual type, and use this symbol to
                // compare to our searchSymbol
                if (isNameOfPropertyAssignment(referenceLocation)) {
                    return ts.forEach(getPropertySymbolsFromContextualType(referenceLocation), function (contextualSymbol) {
                        return ts.forEach(typeInfoResolver.getRootSymbols(contextualSymbol), function (s) { return searchSymbols.indexOf(s) >= 0; });
                    });
                }
                // Unwrap symbols to get to the root (e.g. transient symbols as a result of widening)
                // Or a union property, use its underlying unioned symbols
                return ts.forEach(typeInfoResolver.getRootSymbols(referenceSymbol), function (rootSymbol) {
                    // if it is in the list, then we are done
                    if (searchSymbols.indexOf(rootSymbol) >= 0) {
                        return true;
                    }
                    // Finally, try all properties with the same name in any type the containing type extended or implemented, and 
                    // see if any is in the list
                    if (rootSymbol.parent && rootSymbol.parent.flags & (32 /* Class */ | 64 /* Interface */)) {
                        var result = [];
                        getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.getName(), result);
                        return ts.forEach(result, function (s) { return searchSymbols.indexOf(s) >= 0; });
                    }
                    return false;
                });
            }
            function getPropertySymbolsFromContextualType(node) {
                if (isNameOfPropertyAssignment(node)) {
                    var objectLiteral = node.parent.parent;
                    var contextualType = typeInfoResolver.getContextualType(objectLiteral);
                    var name = node.text;
                    if (contextualType) {
                        if (contextualType.flags & 16384 /* Union */) {
                            // This is a union type, first see if the property we are looking for is a union property (i.e. exists in all types)
                            // if not, search the constituent types for the property
                            var unionProperty = contextualType.getProperty(name);
                            if (unionProperty) {
                                return [unionProperty];
                            }
                            else {
                                var result = [];
                                ts.forEach(contextualType.types, function (t) {
                                    var symbol = t.getProperty(name);
                                    if (symbol) {
                                        result.push(symbol);
                                    }
                                });
                                return result;
                            }
                        }
                        else {
                            var symbol = contextualType.getProperty(name);
                            if (symbol) {
                                return [symbol];
                            }
                        }
                    }
                }
                return undefined;
            }
            /** Given an initial searchMeaning, extracted from a location, widen the search scope based on the declarations
              * of the corresponding symbol. e.g. if we are searching for "Foo" in value position, but "Foo" references a class
              * then we need to widen the search to include type positions as well.
              * On the contrary, if we are searching for "Bar" in type position and we trace bar to an interface, and an uninstantiated
              * module, we want to keep the search limited to only types, as the two declarations (interface and uninstantiated module)
              * do not intersect in any of the three spaces.
              */
            function getIntersectingMeaningFromDeclarations(meaning, declarations) {
                if (declarations) {
                    do {
                        // The result is order-sensitive, for instance if initialMeaning === Namespace, and declarations = [class, instantiated module]
                        // we need to consider both as they initialMeaning intersects with the module in the namespace space, and the module
                        // intersects with the class in the value space.
                        // To achieve that we will keep iterating until the result stabilizes.
                        // Remember the last meaning
                        var lastIterationMeaning = meaning;
                        for (var i = 0, n = declarations.length; i < n; i++) {
                            var declarationMeaning = getMeaningFromDeclaration(declarations[i]);
                            if (declarationMeaning & meaning) {
                                meaning |= declarationMeaning;
                            }
                        }
                    } while (meaning !== lastIterationMeaning);
                }
                return meaning;
            }
        }
        function getReferenceEntryFromNode(node) {
            var start = node.getStart();
            var end = node.getEnd();
            if (node.kind === 7 /* StringLiteral */) {
                start += 1;
                end -= 1;
            }
            return {
                fileName: node.getSourceFile().filename,
                textSpan: TypeScript.TextSpan.fromBounds(start, end),
                isWriteAccess: isWriteAccess(node)
            };
        }
        /** A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment */
        function isWriteAccess(node) {
            if (node.kind === 63 /* Identifier */ && ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                return true;
            }
            var parent = node.parent;
            if (parent) {
                if (parent.kind === 152 /* PostfixOperator */ || parent.kind === 151 /* PrefixOperator */) {
                    return true;
                }
                else if (parent.kind === 153 /* BinaryExpression */ && parent.left === node) {
                    var operator = parent.operator;
                    return 51 /* FirstAssignment */ <= operator && operator <= 62 /* LastAssignment */;
                }
            }
            return false;
        }
        /// NavigateTo
        function getNavigateToItems(searchValue) {
            synchronizeHostData();
            // Split search value in terms array
            var terms = searchValue.split(" ");
            // default NavigateTo approach: if search term contains only lower-case chars - use case-insensitive search, otherwise switch to case-sensitive version
            var searchTerms = ts.map(terms, function (t) { return ({ caseSensitive: hasAnyUpperCaseCharacter(t), term: t }); });
            var items = [];
            // Search the declarations in all files and output matched NavigateToItem into array of NavigateToItem[] 
            ts.forEach(program.getSourceFiles(), function (sourceFile) {
                cancellationToken.throwIfCancellationRequested();
                var filename = sourceFile.filename;
                var declarations = sourceFile.getNamedDeclarations();
                for (var i = 0, n = declarations.length; i < n; i++) {
                    var declaration = declarations[i];
                    // TODO(jfreeman): Skip this declaration if it has a computed name
                    var name = declaration.name.text;
                    var matchKind = getMatchKind(searchTerms, name);
                    if (matchKind !== 0 /* none */) {
                        var container = getContainerNode(declaration);
                        items.push({
                            name: name,
                            kind: getNodeKind(declaration),
                            kindModifiers: getNodeModifiers(declaration),
                            matchKind: MatchKind[matchKind],
                            fileName: filename,
                            textSpan: TypeScript.TextSpan.fromBounds(declaration.getStart(), declaration.getEnd()),
                            // TODO(jfreeman): What should be the containerName when the container has a computed name?
                            containerName: container.name ? container.name.text : "",
                            containerKind: container.name ? getNodeKind(container) : ""
                        });
                    }
                }
            });
            return items;
            function hasAnyUpperCaseCharacter(s) {
                for (var i = 0, n = s.length; i < n; i++) {
                    var c = s.charCodeAt(i);
                    if ((65 /* A */ <= c && c <= 90 /* Z */) || (c >= 127 /* maxAsciiCharacter */ && s.charAt(i).toLocaleLowerCase() !== s.charAt(i))) {
                        return true;
                    }
                }
                return false;
            }
            function getMatchKind(searchTerms, name) {
                var matchKind = 0 /* none */;
                if (name) {
                    for (var j = 0, n = searchTerms.length; j < n; j++) {
                        var searchTerm = searchTerms[j];
                        var nameToSearch = searchTerm.caseSensitive ? name : name.toLocaleLowerCase();
                        // in case of case-insensitive search searchTerm.term will already be lower-cased
                        var index = nameToSearch.indexOf(searchTerm.term);
                        if (index < 0) {
                            // Didn't match.
                            return 0 /* none */;
                        }
                        var termKind = 2 /* substring */;
                        if (index === 0) {
                            // here we know that match occur at the beginning of the string.
                            // if search term and declName has the same length - we have an exact match, otherwise declName have longer length and this will be prefix match
                            termKind = name.length === searchTerm.term.length ? 1 /* exact */ : 3 /* prefix */;
                        }
                        // Update our match kind if we don't have one, or if this match is better.
                        if (matchKind === 0 /* none */ || termKind < matchKind) {
                            matchKind = termKind;
                        }
                    }
                }
                return matchKind;
            }
        }
        function containErrors(diagnostics) {
            return ts.forEach(diagnostics, function (diagnostic) { return diagnostic.category === 1 /* Error */; });
        }
        function getEmitOutput(filename) {
            synchronizeHostData();
            filename = ts.switchToForwardSlashes(filename);
            var compilerOptions = program.getCompilerOptions();
            var targetSourceFile = program.getSourceFile(filename); // Current selected file to be output
            // If --out flag is not specified, shouldEmitToOwnFile is true. Otherwise shouldEmitToOwnFile is false.
            var shouldEmitToOwnFile = ts.shouldEmitToOwnFile(targetSourceFile, compilerOptions);
            var emitDeclaration = compilerOptions.declaration;
            var emitOutput = {
                outputFiles: [],
                emitOutputStatus: undefined
            };
            function getEmitOutputWriter(filename, data, writeByteOrderMark) {
                emitOutput.outputFiles.push({
                    name: filename,
                    writeByteOrderMark: writeByteOrderMark,
                    text: data
                });
            }
            // Initialize writer for CompilerHost.writeFile
            writer = getEmitOutputWriter;
            var syntacticDiagnostics = [];
            var containSyntacticErrors = false;
            if (shouldEmitToOwnFile) {
                // Check only the file we want to emit
                containSyntacticErrors = containErrors(program.getDiagnostics(targetSourceFile));
            }
            else {
                // Check the syntactic of only sourceFiles that will get emitted into single output
                // Terminate the process immediately if we encounter a syntax error from one of the sourceFiles
                containSyntacticErrors = ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!ts.isExternalModuleOrDeclarationFile(sourceFile)) {
                        // If emit to a single file then we will check all files that do not have external module
                        return containErrors(program.getDiagnostics(sourceFile));
                    }
                    return false;
                });
            }
            if (containSyntacticErrors) {
                // If there is a syntax error, terminate the process and report outputStatus
                emitOutput.emitOutputStatus = 1 /* AllOutputGenerationSkipped */;
                // Reset writer back to undefined to make sure that we produce an error message
                // if CompilerHost.writeFile is called when we are not in getEmitOutput
                writer = undefined;
                return emitOutput;
            }
            // Perform semantic and force a type check before emit to ensure that all symbols are updated
            // EmitFiles will report if there is an error from TypeChecker and Emitter
            // Depend whether we will have to emit into a single file or not either emit only selected file in the project, emit all files into a single file
            var emitFilesResult = getFullTypeCheckChecker().emitFiles(targetSourceFile);
            emitOutput.emitOutputStatus = emitFilesResult.emitResultStatus;
            // Reset writer back to undefined to make sure that we produce an error message if CompilerHost.writeFile method is called when we are not in getEmitOutput
            writer = undefined;
            return emitOutput;
        }
        function getMeaningFromDeclaration(node) {
            switch (node.kind) {
                case 123 /* Parameter */:
                case 181 /* VariableDeclaration */:
                case 124 /* Property */:
                case 141 /* PropertyAssignment */:
                case 192 /* EnumMember */:
                case 125 /* Method */:
                case 126 /* Constructor */:
                case 127 /* GetAccessor */:
                case 128 /* SetAccessor */:
                case 182 /* FunctionDeclaration */:
                case 149 /* FunctionExpression */:
                case 150 /* ArrowFunction */:
                case 178 /* CatchBlock */:
                    return 1 /* Value */;
                case 122 /* TypeParameter */:
                case 185 /* InterfaceDeclaration */:
                case 186 /* TypeAliasDeclaration */:
                case 134 /* TypeLiteral */:
                    return 2 /* Type */;
                case 184 /* ClassDeclaration */:
                case 187 /* EnumDeclaration */:
                    return 1 /* Value */ | 2 /* Type */;
                case 188 /* ModuleDeclaration */:
                    if (node.name.kind === 7 /* StringLiteral */) {
                        return 4 /* Namespace */ | 1 /* Value */;
                    }
                    else if (ts.getModuleInstanceState(node) === 1 /* Instantiated */) {
                        return 4 /* Namespace */ | 1 /* Value */;
                    }
                    else {
                        return 4 /* Namespace */;
                    }
                    break;
                case 190 /* ImportDeclaration */:
                    return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
            }
            ts.Debug.fail("Unknown declaration type");
        }
        function isTypeReference(node) {
            if (isRightSideOfQualifiedName(node)) {
                node = node.parent;
            }
            return node.parent.kind === 132 /* TypeReference */;
        }
        function isNamespaceReference(node) {
            var root = node;
            var isLastClause = true;
            if (root.parent.kind === 121 /* QualifiedName */) {
                while (root.parent && root.parent.kind === 121 /* QualifiedName */)
                    root = root.parent;
                isLastClause = root.right === node;
            }
            return root.parent.kind === 132 /* TypeReference */ && !isLastClause;
        }
        function isInRightSideOfImport(node) {
            while (node.parent.kind === 121 /* QualifiedName */) {
                node = node.parent;
            }
            return node.parent.kind === 190 /* ImportDeclaration */ && node.parent.entityName === node;
        }
        function getMeaningFromRightHandSideOfImport(node) {
            ts.Debug.assert(node.kind === 63 /* Identifier */);
            //     import a = |b|; // Namespace
            //     import a = |b.c|; // Value, type, namespace
            //     import a = |b.c|.d; // Namespace
            if (node.parent.kind === 121 /* QualifiedName */ && node.parent.right === node && node.parent.parent.kind === 190 /* ImportDeclaration */) {
                return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
            }
            return 4 /* Namespace */;
        }
        function getMeaningFromLocation(node) {
            if (node.parent.kind === 191 /* ExportAssignment */) {
                return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
            }
            else if (isInRightSideOfImport(node)) {
                return getMeaningFromRightHandSideOfImport(node);
            }
            else if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                return getMeaningFromDeclaration(node.parent);
            }
            else if (isTypeReference(node)) {
                return 2 /* Type */;
            }
            else if (isNamespaceReference(node)) {
                return 4 /* Namespace */;
            }
            else {
                return 1 /* Value */;
            }
        }
        // Signature help
        /**
         * This is a semantic operation.
         */
        function getSignatureHelpItems(fileName, position) {
            synchronizeHostData();
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            return ts.SignatureHelp.getSignatureHelpItems(sourceFile, position, typeInfoResolver, cancellationToken);
        }
        function getSignatureAtPosition(filename, position) {
            var signatureHelpItems = getSignatureHelpItems(filename, position);
            if (!signatureHelpItems) {
                return undefined;
            }
            var currentArgumentState = { argumentIndex: signatureHelpItems.argumentIndex, argumentCount: signatureHelpItems.argumentCount };
            var formalSignatures = [];
            ts.forEach(signatureHelpItems.items, function (signature) {
                var signatureInfoString = displayPartsToString(signature.prefixDisplayParts);
                var parameters = [];
                if (signature.parameters) {
                    for (var i = 0, n = signature.parameters.length; i < n; i++) {
                        var parameter = signature.parameters[i];
                        // add the parameter to the string
                        if (i) {
                            signatureInfoString += displayPartsToString(signature.separatorDisplayParts);
                        }
                        var start = signatureInfoString.length;
                        signatureInfoString += displayPartsToString(parameter.displayParts);
                        var end = signatureInfoString.length - 1;
                        // add the parameter to the list
                        parameters.push({
                            name: parameter.name,
                            isVariable: i === n - 1 && signature.isVariadic,
                            docComment: displayPartsToString(parameter.documentation),
                            minChar: start,
                            limChar: end
                        });
                    }
                }
                signatureInfoString += displayPartsToString(signature.suffixDisplayParts);
                formalSignatures.push({
                    signatureInfo: signatureInfoString,
                    docComment: displayPartsToString(signature.documentation),
                    parameters: parameters,
                    typeParameters: []
                });
            });
            var actualSignature = {
                parameterMinChar: signatureHelpItems.applicableSpan.start(),
                parameterLimChar: signatureHelpItems.applicableSpan.end(),
                currentParameterIsTypeParameter: false,
                currentParameter: currentArgumentState.argumentIndex
            };
            return {
                actual: actualSignature,
                formal: formalSignatures,
                activeFormal: 0
            };
        }
        /// Syntactic features
        function getSyntaxTree(filename) {
            filename = ts.switchToForwardSlashes(filename);
            return syntaxTreeCache.getCurrentFileSyntaxTree(filename);
        }
        function getCurrentSourceFile(filename) {
            filename = ts.switchToForwardSlashes(filename);
            var currentSourceFile = syntaxTreeCache.getCurrentSourceFile(filename);
            return currentSourceFile;
        }
        function getNameOrDottedNameSpan(filename, startPos, endPos) {
            filename = ts.normalizeSlashes(filename);
            // Get node at the location
            var node = ts.getTouchingPropertyName(getCurrentSourceFile(filename), startPos);
            if (!node) {
                return;
            }
            switch (node.kind) {
                case 142 /* PropertyAccess */:
                case 121 /* QualifiedName */:
                case 7 /* StringLiteral */:
                case 78 /* FalseKeyword */:
                case 93 /* TrueKeyword */:
                case 87 /* NullKeyword */:
                case 89 /* SuperKeyword */:
                case 91 /* ThisKeyword */:
                case 63 /* Identifier */:
                    break;
                default:
                    return;
            }
            var nodeForStartPos = node;
            while (true) {
                if (isRightSideOfPropertyAccess(nodeForStartPos) || isRightSideOfQualifiedName(nodeForStartPos)) {
                    // If on the span is in right side of the the property or qualified name, return the span from the qualified name pos to end of this node
                    nodeForStartPos = nodeForStartPos.parent;
                }
                else if (isNameOfModuleDeclaration(nodeForStartPos)) {
                    // If this is name of a module declarations, check if this is right side of dotted module name
                    // If parent of the module declaration which is parent of this node is module declaration and its body is the module declaration that this node is name of 
                    // Then this name is name from dotted module
                    if (nodeForStartPos.parent.parent.kind === 188 /* ModuleDeclaration */ && nodeForStartPos.parent.parent.body === nodeForStartPos.parent) {
                        // Use parent module declarations name for start pos
                        nodeForStartPos = nodeForStartPos.parent.parent.name;
                    }
                    else {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            return TypeScript.TextSpan.fromBounds(nodeForStartPos.getStart(), node.getEnd());
        }
        function getBreakpointStatementAtPosition(filename, position) {
            // doesn't use compiler - no need to synchronize with host
            filename = ts.normalizeSlashes(filename);
            return ts.BreakpointResolver.spanInSourceFileAtLocation(getCurrentSourceFile(filename), position);
        }
        function getNavigationBarItems(filename) {
            filename = ts.switchToForwardSlashes(filename);
            return ts.NavigationBar.getNavigationBarItems(getCurrentSourceFile(filename));
        }
        function getSemanticClassifications(fileName, span) {
            synchronizeHostData();
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var result = [];
            processNode(sourceFile);
            return result;
            function classifySymbol(symbol, meaningAtPosition) {
                var flags = symbol.getFlags();
                if (flags & 32 /* Class */) {
                    return ClassificationTypeNames.className;
                }
                else if (flags & 384 /* Enum */) {
                    return ClassificationTypeNames.enumName;
                }
                else if (meaningAtPosition & 2 /* Type */) {
                    if (flags & 64 /* Interface */) {
                        return ClassificationTypeNames.interfaceName;
                    }
                    else if (flags & 1048576 /* TypeParameter */) {
                        return ClassificationTypeNames.typeParameterName;
                    }
                }
                else if (flags & 1536 /* Module */) {
                    // Only classify a module as such if
                    //  - It appears in a namespace context.
                    //  - There exists a module declaration which actually impacts the value side.
                    if (meaningAtPosition & 4 /* Namespace */ || (meaningAtPosition & 1 /* Value */ && hasValueSideModule(symbol))) {
                        return ClassificationTypeNames.moduleName;
                    }
                }
                return undefined;
                /**
                 * Returns true if there exists a module that introduces entities on the value side.
                 */
                function hasValueSideModule(symbol) {
                    return ts.forEach(symbol.declarations, function (declaration) {
                        return declaration.kind === 188 /* ModuleDeclaration */ && ts.getModuleInstanceState(declaration) == 1 /* Instantiated */;
                    });
                }
            }
            function processNode(node) {
                // Only walk into nodes that intersect the requested span.
                if (node && span.intersectsWith(node.getStart(), node.getWidth())) {
                    if (node.kind === 63 /* Identifier */ && node.getWidth() > 0) {
                        var symbol = typeInfoResolver.getSymbolInfo(node);
                        if (symbol) {
                            var type = classifySymbol(symbol, getMeaningFromLocation(node));
                            if (type) {
                                result.push({
                                    textSpan: new TypeScript.TextSpan(node.getStart(), node.getWidth()),
                                    classificationType: type
                                });
                            }
                        }
                    }
                    ts.forEachChild(node, processNode);
                }
            }
        }
        function getSyntacticClassifications(fileName, span) {
            // doesn't use compiler - no need to synchronize with host
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getCurrentSourceFile(fileName);
            var result = [];
            processElement(sourceFile);
            return result;
            function classifyComment(comment) {
                var width = comment.end - comment.pos;
                if (span.intersectsWith(comment.pos, width)) {
                    result.push({
                        textSpan: new TypeScript.TextSpan(comment.pos, width),
                        classificationType: ClassificationTypeNames.comment
                    });
                }
            }
            function classifyToken(token) {
                ts.forEach(ts.getLeadingCommentRanges(sourceFile.text, token.getFullStart()), classifyComment);
                if (token.getWidth() > 0) {
                    var type = classifyTokenType(token);
                    if (type) {
                        result.push({
                            textSpan: new TypeScript.TextSpan(token.getStart(), token.getWidth()),
                            classificationType: type
                        });
                    }
                }
                ts.forEach(ts.getTrailingCommentRanges(sourceFile.text, token.getEnd()), classifyComment);
            }
            function classifyTokenType(token) {
                var tokenKind = token.kind;
                if (ts.isKeyword(tokenKind)) {
                    return ClassificationTypeNames.keyword;
                }
                // Special case < and >  If they appear in a generic context they are punctuation,
                // not operators.
                if (tokenKind === 23 /* LessThanToken */ || tokenKind === 24 /* GreaterThanToken */) {
                    // If the node owning the token has a type argument list or type parameter list, then
                    // we can effectively assume that a '<' and '>' belong to those lists.
                    if (ts.getTypeArgumentOrTypeParameterList(token.parent)) {
                        return ClassificationTypeNames.punctuation;
                    }
                }
                if (ts.isPunctuation(token)) {
                    // the '=' in a variable declaration is special cased here.
                    if (token.parent.kind === 153 /* BinaryExpression */ || token.parent.kind === 181 /* VariableDeclaration */ || token.parent.kind === 151 /* PrefixOperator */ || token.parent.kind === 152 /* PostfixOperator */ || token.parent.kind === 154 /* ConditionalExpression */) {
                        return ClassificationTypeNames.operator;
                    }
                    else {
                        return ClassificationTypeNames.punctuation;
                    }
                }
                else if (tokenKind === 6 /* NumericLiteral */) {
                    return ClassificationTypeNames.numericLiteral;
                }
                else if (tokenKind === 7 /* StringLiteral */) {
                    return ClassificationTypeNames.stringLiteral;
                }
                else if (tokenKind === 8 /* RegularExpressionLiteral */) {
                    // TODO: we should get another classification type for these literals.
                    return ClassificationTypeNames.stringLiteral;
                }
                else if (ts.isTemplateLiteralKind(tokenKind)) {
                    // TODO (drosen): we should *also* get another classification type for these literals.
                    return ClassificationTypeNames.stringLiteral;
                }
                else if (tokenKind === 63 /* Identifier */) {
                    switch (token.parent.kind) {
                        case 184 /* ClassDeclaration */:
                            if (token.parent.name === token) {
                                return ClassificationTypeNames.className;
                            }
                            return;
                        case 122 /* TypeParameter */:
                            if (token.parent.name === token) {
                                return ClassificationTypeNames.typeParameterName;
                            }
                            return;
                        case 185 /* InterfaceDeclaration */:
                            if (token.parent.name === token) {
                                return ClassificationTypeNames.interfaceName;
                            }
                            return;
                        case 187 /* EnumDeclaration */:
                            if (token.parent.name === token) {
                                return ClassificationTypeNames.enumName;
                            }
                            return;
                        case 188 /* ModuleDeclaration */:
                            if (token.parent.name === token) {
                                return ClassificationTypeNames.moduleName;
                            }
                            return;
                        default:
                            return ClassificationTypeNames.text;
                    }
                }
            }
            function processElement(element) {
                // Ignore nodes that don't intersect the original span to classify.
                if (span.intersectsWith(element.getFullStart(), element.getFullWidth())) {
                    var children = element.getChildren();
                    for (var i = 0, n = children.length; i < n; i++) {
                        var child = children[i];
                        if (ts.isToken(child)) {
                            classifyToken(child);
                        }
                        else {
                            // Recurse into our child nodes.
                            processElement(child);
                        }
                    }
                }
            }
        }
        function getOutliningSpans(filename) {
            // doesn't use compiler - no need to synchronize with host
            filename = ts.switchToForwardSlashes(filename);
            var sourceFile = getCurrentSourceFile(filename);
            return ts.OutliningElementsCollector.collectElements(sourceFile);
        }
        function getBraceMatchingAtPosition(filename, position) {
            var sourceFile = getCurrentSourceFile(filename);
            var result = [];
            var token = ts.getTouchingToken(sourceFile, position);
            if (token.getStart(sourceFile) === position) {
                var matchKind = getMatchingTokenKind(token);
                // Ensure that there is a corresponding token to match ours.
                if (matchKind) {
                    var parentElement = token.parent;
                    var childNodes = parentElement.getChildren(sourceFile);
                    for (var i = 0, n = childNodes.length; i < n; i++) {
                        var current = childNodes[i];
                        if (current.kind === matchKind) {
                            var range1 = new TypeScript.TextSpan(token.getStart(sourceFile), token.getWidth(sourceFile));
                            var range2 = new TypeScript.TextSpan(current.getStart(sourceFile), current.getWidth(sourceFile));
                            // We want to order the braces when we return the result.
                            if (range1.start() < range2.start()) {
                                result.push(range1, range2);
                            }
                            else {
                                result.push(range2, range1);
                            }
                            break;
                        }
                    }
                }
            }
            return result;
            function getMatchingTokenKind(token) {
                switch (token.kind) {
                    case 13 /* OpenBraceToken */: return 14 /* CloseBraceToken */;
                    case 15 /* OpenParenToken */: return 16 /* CloseParenToken */;
                    case 17 /* OpenBracketToken */: return 18 /* CloseBracketToken */;
                    case 23 /* LessThanToken */: return 24 /* GreaterThanToken */;
                    case 14 /* CloseBraceToken */: return 13 /* OpenBraceToken */;
                    case 16 /* CloseParenToken */: return 15 /* OpenParenToken */;
                    case 18 /* CloseBracketToken */: return 17 /* OpenBracketToken */;
                    case 24 /* GreaterThanToken */: return 23 /* LessThanToken */;
                }
                return undefined;
            }
        }
        function getIndentationAtPosition(filename, position, editorOptions) {
            filename = ts.switchToForwardSlashes(filename);
            var start = new Date().getTime();
            var sourceFile = getCurrentSourceFile(filename);
            host.log("getIndentationAtPosition: getCurrentSourceFile: " + (new Date().getTime() - start));
            var start = new Date().getTime();
            var options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
            var result = ts.formatting.SmartIndenter.getIndentation(position, sourceFile, options);
            host.log("getIndentationAtPosition: computeIndentation  : " + (new Date().getTime() - start));
            return result;
        }
        function getFormattingManager(filename, options) {
            // Ensure rules are initialized and up to date wrt to formatting options
            if (formattingRulesProvider == null) {
                formattingRulesProvider = new TypeScript.Services.Formatting.RulesProvider(host);
            }
            formattingRulesProvider.ensureUpToDate(options);
            // Get the Syntax Tree
            var syntaxTree = getSyntaxTree(filename);
            // Convert IScriptSnapshot to ITextSnapshot
            var scriptSnapshot = syntaxTreeCache.getCurrentScriptSnapshot(filename);
            var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var textSnapshot = new TypeScript.Services.Formatting.TextSnapshot(scriptText);
            var manager = new TypeScript.Services.Formatting.FormattingManager(syntaxTree, textSnapshot, formattingRulesProvider, options);
            return manager;
        }
        function getFormattingEditsForRange(fileName, start, end, options) {
            fileName = ts.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            return manager.formatSelection(start, end);
        }
        function getFormattingEditsForDocument(fileName, options) {
            fileName = ts.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            return manager.formatDocument();
        }
        function getFormattingEditsAfterKeystroke(fileName, position, key, options) {
            fileName = ts.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            if (key === "}") {
                return manager.formatOnClosingCurlyBrace(position);
            }
            else if (key === ";") {
                return manager.formatOnSemicolon(position);
            }
            else if (key === "\n") {
                return manager.formatOnEnter(position);
            }
            return [];
        }
        function getTodoComments(filename, descriptors) {
            // Note: while getting todo comments seems like a syntactic operation, we actually 
            // treat it as a semantic operation here.  This is because we expect our host to call
            // this on every single file.  If we treat this syntactically, then that will cause
            // us to populate and throw away the tree in our syntax tree cache for each file.  By
            // treating this as a semantic operation, we can access any tree without throwing 
            // anything away.
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            cancellationToken.throwIfCancellationRequested();
            var fileContents = sourceFile.text;
            cancellationToken.throwIfCancellationRequested();
            var result = [];
            if (descriptors.length > 0) {
                var regExp = getTodoCommentsRegExp();
                var matchArray;
                while (matchArray = regExp.exec(fileContents)) {
                    cancellationToken.throwIfCancellationRequested();
                    // If we got a match, here is what the match array will look like.  Say the source text is:
                    //
                    //      "    // hack   1"
                    //
                    // The result array with the regexp:    will be:
                    //
                    //      ["// hack   1", "// ", "hack   1", undefined, "hack"]
                    //
                    // Here are the relevant capture groups:
                    //  0) The full match for the entire regexp.
                    //  1) The preamble to the message portion.
                    //  2) The message portion.
                    //  3...N) The descriptor that was matched - by index.  'undefined' for each 
                    //         descriptor that didn't match.  an actual value if it did match.
                    //
                    //  i.e. 'undefined' in position 3 above means TODO(jason) didn't match.
                    //       "hack"      in position 4 means HACK did match.
                    var firstDescriptorCaptureIndex = 3;
                    ts.Debug.assert(matchArray.length === descriptors.length + firstDescriptorCaptureIndex);
                    var preamble = matchArray[1];
                    var matchPosition = matchArray.index + preamble.length;
                    // OK, we have found a match in the file.  This is only an acceptable match if
                    // it is contained within a comment.
                    var token = ts.getTokenAtPosition(sourceFile, matchPosition);
                    if (!isInsideComment(sourceFile, token, matchPosition)) {
                        continue;
                    }
                    var descriptor = undefined;
                    for (var i = 0, n = descriptors.length; i < n; i++) {
                        if (matchArray[i + firstDescriptorCaptureIndex]) {
                            descriptor = descriptors[i];
                        }
                    }
                    ts.Debug.assert(descriptor !== undefined);
                    // We don't want to match something like 'TODOBY', so we make sure a non 
                    // letter/digit follows the match.
                    if (isLetterOrDigit(fileContents.charCodeAt(matchPosition + descriptor.text.length))) {
                        continue;
                    }
                    var message = matchArray[2];
                    result.push({
                        descriptor: descriptor,
                        message: message,
                        position: matchPosition
                    });
                }
            }
            return result;
            function escapeRegExp(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
            function getTodoCommentsRegExp() {
                // NOTE: ?:  means 'non-capture group'.  It allows us to have groups without having to
                // filter them out later in the final result array.
                // TODO comments can appear in one of the following forms:
                //
                //  1)      // TODO     or  /////////// TODO
                //
                //  2)      /* TODO     or  /********** TODO
                //
                //  3)      /*
                //           *   TODO
                //           */
                //
                // The following three regexps are used to match the start of the text up to the TODO
                // comment portion.
                var singleLineCommentStart = /(?:\/\/+\s*)/.source;
                var multiLineCommentStart = /(?:\/\*+\s*)/.source;
                var anyNumberOfSpacesAndAsterixesAtStartOfLine = /(?:^(?:\s|\*)*)/.source;
                // Match any of the above three TODO comment start regexps.
                // Note that the outermost group *is* a capture group.  We want to capture the preamble
                // so that we can determine the starting position of the TODO comment match.
                var preamble = "(" + anyNumberOfSpacesAndAsterixesAtStartOfLine + "|" + singleLineCommentStart + "|" + multiLineCommentStart + ")";
                // Takes the descriptors and forms a regexp that matches them as if they were literals.
                // For example, if the descriptors are "TODO(jason)" and "HACK", then this will be:
                //
                //      (?:(TODO\(jason\))|(HACK))
                //
                // Note that the outermost group is *not* a capture group, but the innermost groups
                // *are* capture groups.  By capturing the inner literals we can determine after 
                // matching which descriptor we are dealing with.
                var literals = "(?:" + ts.map(descriptors, function (d) { return "(" + escapeRegExp(d.text) + ")"; }).join("|") + ")";
                // After matching a descriptor literal, the following regexp matches the rest of the 
                // text up to the end of the line (or */).
                var endOfLineOrEndOfComment = /(?:$|\*\/)/.source;
                var messageRemainder = /(?:.*?)/.source;
                // This is the portion of the match we'll return as part of the TODO comment result. We
                // match the literal portion up to the end of the line or end of comment.
                var messagePortion = "(" + literals + messageRemainder + ")";
                var regExpString = preamble + messagePortion + endOfLineOrEndOfComment;
                // The final regexp will look like this:
                // /((?:\/\/+\s*)|(?:\/\*+\s*)|(?:^(?:\s|\*)*))((?:(TODO\(jason\))|(HACK))(?:.*?))(?:$|\*\/)/gim
                // The flags of the regexp are important here.
                //  'g' is so that we are doing a global search and can find matches several times
                //  in the input.
                //
                //  'i' is for case insensitivity (We do this to match C# TODO comment code).
                //
                //  'm' is so we can find matches in a multi-line input.
                return new RegExp(regExpString, "gim");
            }
            function getContainingComment(comments, position) {
                if (comments) {
                    for (var i = 0, n = comments.length; i < n; i++) {
                        var comment = comments[i];
                        if (comment.pos <= position && position < comment.end) {
                            return comment;
                        }
                    }
                }
                return undefined;
            }
            function isLetterOrDigit(char) {
                return (char >= 97 /* a */ && char <= 122 /* z */) || (char >= 65 /* A */ && char <= 90 /* Z */) || (char >= 48 /* _0 */ && char <= 57 /* _9 */);
            }
        }
        function getRenameInfo(fileName, position) {
            synchronizeHostData();
            fileName = ts.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = ts.getTouchingWord(sourceFile, position);
            // Can only rename an identifier.
            if (node && node.kind === 63 /* Identifier */) {
                var symbol = typeInfoResolver.getSymbolInfo(node);
                // Only allow a symbol to be renamed if it actually has at least one declaration.
                if (symbol && symbol.getDeclarations() && symbol.getDeclarations().length > 0) {
                    var kind = getSymbolKind(symbol, typeInfoResolver);
                    if (kind) {
                        return getRenameInfo(symbol.name, typeInfoResolver.getFullyQualifiedName(symbol), kind, getSymbolModifiers(symbol), new TypeScript.TextSpan(node.getStart(), node.getWidth()));
                    }
                }
            }
            return getRenameInfoError(ts.getLocaleSpecificMessage(ts.Diagnostics.You_cannot_rename_this_element.key));
            function getRenameInfoError(localizedErrorMessage) {
                return {
                    canRename: false,
                    localizedErrorMessage: ts.getLocaleSpecificMessage(ts.Diagnostics.You_cannot_rename_this_element.key),
                    displayName: undefined,
                    fullDisplayName: undefined,
                    kind: undefined,
                    kindModifiers: undefined,
                    triggerSpan: undefined
                };
            }
            function getRenameInfo(displayName, fullDisplayName, kind, kindModifiers, triggerSpan) {
                return {
                    canRename: true,
                    localizedErrorMessage: undefined,
                    displayName: displayName,
                    fullDisplayName: fullDisplayName,
                    kind: kind,
                    kindModifiers: kindModifiers,
                    triggerSpan: triggerSpan
                };
            }
        }
        return {
            dispose: dispose,
            cleanupSemanticCache: cleanupSemanticCache,
            getSyntacticDiagnostics: getSyntacticDiagnostics,
            getSemanticDiagnostics: getSemanticDiagnostics,
            getCompilerOptionsDiagnostics: getCompilerOptionsDiagnostics,
            getSyntacticClassifications: getSyntacticClassifications,
            getSemanticClassifications: getSemanticClassifications,
            getCompletionsAtPosition: getCompletionsAtPosition,
            getCompletionEntryDetails: getCompletionEntryDetails,
            getSignatureHelpItems: getSignatureHelpItems,
            getQuickInfoAtPosition: getQuickInfoAtPosition,
            getDefinitionAtPosition: getDefinitionAtPosition,
            getReferencesAtPosition: getReferencesAtPosition,
            getOccurrencesAtPosition: getOccurrencesAtPosition,
            getImplementorsAtPosition: function (filename, position) { return []; },
            getNameOrDottedNameSpan: getNameOrDottedNameSpan,
            getBreakpointStatementAtPosition: getBreakpointStatementAtPosition,
            getNavigateToItems: getNavigateToItems,
            getRenameInfo: getRenameInfo,
            findRenameLocations: findRenameLocations,
            getNavigationBarItems: getNavigationBarItems,
            getOutliningSpans: getOutliningSpans,
            getTodoComments: getTodoComments,
            getBraceMatchingAtPosition: getBraceMatchingAtPosition,
            getIndentationAtPosition: getIndentationAtPosition,
            getFormattingEditsForRange: getFormattingEditsForRange,
            getFormattingEditsForDocument: getFormattingEditsForDocument,
            getFormattingEditsAfterKeystroke: getFormattingEditsAfterKeystroke,
            getEmitOutput: getEmitOutput,
            getSignatureAtPosition: getSignatureAtPosition
        };
    }
    ts.createLanguageService = createLanguageService;
    /// Classifier
    function createClassifier(host) {
        var scanner = ts.createScanner(2 /* Latest */, false);
        /// We do not have a full parser support to know when we should parse a regex or not
        /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
        /// we have a series of divide operator. this list allows us to be more accurate by ruling out 
        /// locations where a regexp cannot exist.
        var noRegexTable = [];
        noRegexTable[63 /* Identifier */] = true;
        noRegexTable[7 /* StringLiteral */] = true;
        noRegexTable[6 /* NumericLiteral */] = true;
        noRegexTable[8 /* RegularExpressionLiteral */] = true;
        noRegexTable[91 /* ThisKeyword */] = true;
        noRegexTable[37 /* PlusPlusToken */] = true;
        noRegexTable[38 /* MinusMinusToken */] = true;
        noRegexTable[16 /* CloseParenToken */] = true;
        noRegexTable[18 /* CloseBracketToken */] = true;
        noRegexTable[14 /* CloseBraceToken */] = true;
        noRegexTable[93 /* TrueKeyword */] = true;
        noRegexTable[78 /* FalseKeyword */] = true;
        function isAccessibilityModifier(kind) {
            switch (kind) {
                case 106 /* PublicKeyword */:
                case 104 /* PrivateKeyword */:
                case 105 /* ProtectedKeyword */:
                    return true;
            }
            return false;
        }
        /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
        function canFollow(keyword1, keyword2) {
            if (isAccessibilityModifier(keyword1)) {
                if (keyword2 === 113 /* GetKeyword */ || keyword2 === 117 /* SetKeyword */ || keyword2 === 111 /* ConstructorKeyword */ || keyword2 === 107 /* StaticKeyword */) {
                    // Allow things like  "public get", "public constructor" and "public static".  
                    // These are all legal.
                    return true;
                }
                // Any other keyword following "public" is actually an identifier an not a real
                // keyword.
                return false;
            }
            // Assume any other keyword combination is legal.  This can be refined in the future
            // if there are more cases we want the classifier to be better at.
            return true;
        }
        function getClassificationsForLine(text, lexState) {
            var offset = 0;
            var lastTokenOrCommentEnd = 0;
            var token = 0 /* Unknown */;
            var lastNonTriviaToken = 0 /* Unknown */;
            switch (lexState) {
                case 3 /* InDoubleQuoteStringLiteral */:
                    text = '"\\\n' + text;
                    offset = 3;
                    break;
                case 2 /* InSingleQuoteStringLiteral */:
                    text = "'\\\n" + text;
                    offset = 3;
                    break;
                case 1 /* InMultiLineCommentTrivia */:
                    text = "/*\n" + text;
                    offset = 3;
                    break;
            }
            scanner.setText(text);
            var result = {
                finalLexState: 0 /* Start */,
                entries: []
            };
            // We can run into an unfortunate interaction between the lexical and syntactic classifier
            // when the user is typing something generic.  Consider the case where the user types:
            //
            //      Foo<number
            //
            // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
            // be classified as such.  However, from the syntactic classifier's tree-based perspective
            // this is simply an expression with the identifier 'number' on the RHS of the less than
            // token.  So the classification will go back to being an identifier.  The moment the user
            // types again, number will become a keyword, then an identifier, etc. etc.
            //
            // To try to avoid this problem, we avoid classifying contextual keywords as keywords 
            // when the user is potentially typing something generic.  We just can't do a good enough
            // job at the lexical level, and so well leave it up to the syntactic classifier to make
            // the determination.
            //
            // In order to determine if the user is potentially typing something generic, we use a 
            // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
            // work well enough in practice.
            var angleBracketStack = 0;
            do {
                token = scanner.scan();
                if (!ts.isTrivia(token)) {
                    if ((token === 35 /* SlashToken */ || token === 55 /* SlashEqualsToken */) && !noRegexTable[lastNonTriviaToken]) {
                        if (scanner.reScanSlashToken() === 8 /* RegularExpressionLiteral */) {
                            token = 8 /* RegularExpressionLiteral */;
                        }
                    }
                    else if (lastNonTriviaToken === 19 /* DotToken */ && isKeyword(token)) {
                        token = 63 /* Identifier */;
                    }
                    else if (isKeyword(lastNonTriviaToken) && isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
                        // We have two keywords in a row.  Only treat the second as a keyword if 
                        // it's a sequence that could legally occur in the language.  Otherwise
                        // treat it as an identifier.  This way, if someone writes "private var"
                        // we recognize that 'var' is actually an identifier here.
                        token = 63 /* Identifier */;
                    }
                    else if (lastNonTriviaToken === 63 /* Identifier */ && token === 23 /* LessThanToken */) {
                        // Could be the start of something generic.  Keep track of that by bumping 
                        // up the current count of generic contexts we may be in.
                        angleBracketStack++;
                    }
                    else if (token === 24 /* GreaterThanToken */ && angleBracketStack > 0) {
                        // If we think we're currently in something generic, then mark that that
                        // generic entity is complete.
                        angleBracketStack--;
                    }
                    else if (token === 109 /* AnyKeyword */ || token === 118 /* StringKeyword */ || token === 116 /* NumberKeyword */ || token === 110 /* BooleanKeyword */) {
                        if (angleBracketStack > 0) {
                            // If it looks like we're could be in something generic, don't classify this 
                            // as a keyword.  We may just get overwritten by the syntactic classifier,
                            // causing a noisy experience for the user.
                            token = 63 /* Identifier */;
                        }
                    }
                    lastNonTriviaToken = token;
                }
                processToken();
            } while (token !== 1 /* EndOfFileToken */);
            return result;
            function processToken() {
                var start = scanner.getTokenPos();
                var end = scanner.getTextPos();
                // add the token
                addResult(end - start, classFromKind(token));
                if (end >= text.length) {
                    // We're at the end.
                    if (token === 7 /* StringLiteral */) {
                        // Check to see if we finished up on a multiline string literal.
                        var tokenText = scanner.getTokenText();
                        if (tokenText.length > 0 && tokenText.charCodeAt(tokenText.length - 1) === 92 /* backslash */) {
                            var quoteChar = tokenText.charCodeAt(0);
                            result.finalLexState = quoteChar === 34 /* doubleQuote */ ? 3 /* InDoubleQuoteStringLiteral */ : 2 /* InSingleQuoteStringLiteral */;
                        }
                    }
                    else if (token === 3 /* MultiLineCommentTrivia */) {
                        // Check to see if the multiline comment was unclosed.
                        var tokenText = scanner.getTokenText();
                        if (!(tokenText.length > 3 && tokenText.charCodeAt(tokenText.length - 2) === 42 /* asterisk */ && tokenText.charCodeAt(tokenText.length - 1) === 47 /* slash */)) {
                            result.finalLexState = 1 /* InMultiLineCommentTrivia */;
                        }
                    }
                }
            }
            function addResult(length, classification) {
                if (length > 0) {
                    // If this is the first classification we're adding to the list, then remove any 
                    // offset we have if we were continuing a construct from the previous line.
                    if (result.entries.length === 0) {
                        length -= offset;
                    }
                    result.entries.push({ length: length, classification: classification });
                }
            }
        }
        function isBinaryExpressionOperatorToken(token) {
            switch (token) {
                case 34 /* AsteriskToken */:
                case 35 /* SlashToken */:
                case 36 /* PercentToken */:
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                case 39 /* LessThanLessThanToken */:
                case 40 /* GreaterThanGreaterThanToken */:
                case 41 /* GreaterThanGreaterThanGreaterThanToken */:
                case 23 /* LessThanToken */:
                case 24 /* GreaterThanToken */:
                case 25 /* LessThanEqualsToken */:
                case 26 /* GreaterThanEqualsToken */:
                case 85 /* InstanceOfKeyword */:
                case 84 /* InKeyword */:
                case 27 /* EqualsEqualsToken */:
                case 28 /* ExclamationEqualsToken */:
                case 29 /* EqualsEqualsEqualsToken */:
                case 30 /* ExclamationEqualsEqualsToken */:
                case 42 /* AmpersandToken */:
                case 44 /* CaretToken */:
                case 43 /* BarToken */:
                case 47 /* AmpersandAmpersandToken */:
                case 48 /* BarBarToken */:
                case 61 /* BarEqualsToken */:
                case 60 /* AmpersandEqualsToken */:
                case 62 /* CaretEqualsToken */:
                case 57 /* LessThanLessThanEqualsToken */:
                case 58 /* GreaterThanGreaterThanEqualsToken */:
                case 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 52 /* PlusEqualsToken */:
                case 53 /* MinusEqualsToken */:
                case 54 /* AsteriskEqualsToken */:
                case 55 /* SlashEqualsToken */:
                case 56 /* PercentEqualsToken */:
                case 51 /* EqualsToken */:
                case 22 /* CommaToken */:
                    return true;
                default: return false;
            }
        }
        function isPrefixUnaryExpressionOperatorToken(token) {
            switch (token) {
                case 32 /* PlusToken */:
                case 33 /* MinusToken */:
                case 46 /* TildeToken */:
                case 45 /* ExclamationToken */:
                case 37 /* PlusPlusToken */:
                case 38 /* MinusMinusToken */:
                    return true;
                default:
                    return false;
            }
        }
        function isKeyword(token) {
            return token >= 64 /* FirstKeyword */ && token <= 119 /* LastKeyword */;
        }
        function classFromKind(token) {
            if (isKeyword(token)) {
                return 1 /* Keyword */;
            }
            else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
                return 2 /* Operator */;
            }
            else if (token >= 13 /* FirstPunctuation */ && token <= 62 /* LastPunctuation */) {
                return 0 /* Punctuation */;
            }
            switch (token) {
                case 6 /* NumericLiteral */:
                    return 6 /* NumberLiteral */;
                case 7 /* StringLiteral */:
                    return 7 /* StringLiteral */;
                case 8 /* RegularExpressionLiteral */:
                    return 8 /* RegExpLiteral */;
                case 3 /* MultiLineCommentTrivia */:
                case 2 /* SingleLineCommentTrivia */:
                    return 3 /* Comment */;
                case 5 /* WhitespaceTrivia */:
                    return 4 /* Whitespace */;
                case 63 /* Identifier */:
                default:
                    return 5 /* Identifier */;
            }
        }
        return {
            getClassificationsForLine: getClassificationsForLine
        };
    }
    ts.createClassifier = createClassifier;
    function initializeServices() {
        ts.objectAllocator = {
            getNodeConstructor: function (kind) {
                function Node() {
                }
                var proto = kind === 193 /* SourceFile */ ? new SourceFileObject() : new NodeObject();
                proto.kind = kind;
                proto.pos = 0;
                proto.end = 0;
                proto.flags = 0;
                proto.parent = undefined;
                Node.prototype = proto;
                return Node;
            },
            getSymbolConstructor: function () { return SymbolObject; },
            getTypeConstructor: function () { return TypeObject; },
            getSignatureConstructor: function () { return SignatureObject; }
        };
    }
    initializeServices();
})(ts || (ts = {}));
var sys = (function () {
    function getWScriptSystem() {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var fileStream = new ActiveXObject("ADODB.Stream");
        fileStream.Type = 2;
        var binaryStream = new ActiveXObject("ADODB.Stream");
        binaryStream.Type = 1;
        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }
        function readFile(fileName, encoding) {
            if (!fso.FileExists(fileName)) {
                return undefined;
            }
            fileStream.Open();
            try {
                if (encoding) {
                    fileStream.Charset = encoding;
                    fileStream.LoadFromFile(fileName);
                }
                else {
                    // Load file and read the first two bytes into a string with no interpretation
                    fileStream.Charset = "x-ansi";
                    fileStream.LoadFromFile(fileName);
                    var bom = fileStream.ReadText(2) || "";
                    // Position must be at 0 before encoding can be changed
                    fileStream.Position = 0;
                    // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8
                    fileStream.Charset = bom.length >= 2 && (bom.charCodeAt(0) === 0xFF && bom.charCodeAt(1) === 0xFE || bom.charCodeAt(0) === 0xFE && bom.charCodeAt(1) === 0xFF) ? "unicode" : "utf-8";
                }
                // ReadText method always strips byte order mark from resulting string
                return fileStream.ReadText();
            }
            catch (e) {
                throw e;
            }
            finally {
                fileStream.Close();
            }
        }
        function writeFile(fileName, data, writeByteOrderMark) {
            fileStream.Open();
            binaryStream.Open();
            try {
                // Write characters in UTF-8 encoding
                fileStream.Charset = "utf-8";
                fileStream.WriteText(data);
                // If we don't want the BOM, then skip it by setting the starting location to 3 (size of BOM).
                // If not, start from position 0, as the BOM will be added automatically when charset==utf8.
                if (writeByteOrderMark) {
                    fileStream.Position = 0;
                }
                else {
                    fileStream.Position = 3;
                }
                fileStream.CopyTo(binaryStream);
                binaryStream.SaveToFile(fileName, 2);
            }
            finally {
                binaryStream.Close();
                fileStream.Close();
            }
        }
        return {
            args: args,
            newLine: "\r\n",
            useCaseSensitiveFileNames: false,
            write: function (s) {
                WScript.StdOut.Write(s);
            },
            readFile: readFile,
            writeFile: writeFile,
            resolvePath: function (path) {
                return fso.GetAbsolutePathName(path);
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            createDirectory: function (directoryName) {
                if (!this.directoryExists(directoryName)) {
                    fso.CreateFolder(directoryName);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            getCurrentDirectory: function () {
                return new ActiveXObject("WScript.Shell").CurrentDirectory;
            },
            exit: function (exitCode) {
                try {
                    WScript.Quit(exitCode);
                }
                catch (e) {
                }
            }
        };
    }
    function getNodeSystem() {
        var _fs = require("fs");
        var _path = require("path");
        var _os = require('os');
        var platform = _os.platform();
        // win32\win64 are case insensitive platforms, MacOS (darwin) by default is also case insensitive
        var useCaseSensitiveFileNames = platform !== "win32" && platform !== "win64" && platform !== "darwin";
        function readFile(fileName, encoding) {
            if (!_fs.existsSync(fileName)) {
                return undefined;
            }
            var buffer = _fs.readFileSync(fileName);
            var len = buffer.length;
            if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {
                // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,
                // flip all byte pairs and treat as little endian.
                len &= ~1;
                for (var i = 0; i < len; i += 2) {
                    var temp = buffer[i];
                    buffer[i] = buffer[i + 1];
                    buffer[i + 1] = temp;
                }
                return buffer.toString("utf16le", 2);
            }
            if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {
                // Little endian UTF-16 byte order mark detected
                return buffer.toString("utf16le", 2);
            }
            if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                // UTF-8 byte order mark detected
                return buffer.toString("utf8", 3);
            }
            // Default is UTF-8 with no byte order mark
            return buffer.toString("utf8");
        }
        function writeFile(fileName, data, writeByteOrderMark) {
            // If a BOM is required, emit one
            if (writeByteOrderMark) {
                data = '\uFEFF' + data;
            }
            _fs.writeFileSync(fileName, data, "utf8");
        }
        return {
            args: process.argv.slice(2),
            newLine: _os.EOL,
            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
            write: function (s) {
                // 1 is a standard descriptor for stdout
                _fs.writeSync(1, s);
            },
            readFile: readFile,
            writeFile: writeFile,
            watchFile: function (fileName, callback) {
                // watchFile polls a file every 250ms, picking up file notifications.
                _fs.watchFile(fileName, { persistent: true, interval: 250 }, fileChanged);
                return {
                    close: function () {
                        _fs.unwatchFile(fileName, fileChanged);
                    }
                };
                function fileChanged(curr, prev) {
                    if (+curr.mtime <= +prev.mtime) {
                        return;
                    }
                    callback(fileName);
                }
                ;
            },
            resolvePath: function (path) {
                return _path.resolve(path);
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            createDirectory: function (directoryName) {
                if (!this.directoryExists(directoryName)) {
                    _fs.mkdirSync(directoryName);
                }
            },
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            getCurrentDirectory: function () {
                return process.cwd();
            },
            getMemoryUsage: function () {
                if (global.gc) {
                    global.gc();
                }
                return process.memoryUsage().heapUsed;
            },
            exit: function (exitCode) {
                process.exit(exitCode);
            }
        };
    }
    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
        return getWScriptSystem();
    }
    else if (typeof module !== "undefined" && module.exports) {
        return getNodeSystem();
    }
    else {
        return undefined; // Unsupported host
    }
})();
/// <reference path="..\src\compiler\types.ts" />
/// <reference path="..\src\compiler\parser.ts" />
/// <reference path="..\src\compiler\checker.ts" />
/// <reference path="..\src\services\services.ts" />
/// <reference path="..\src\services\syntax\incrementalParser.ts" />
/// <reference path="..\src\compiler\sys.ts" />
function createNewString(s) {
    var result = {};
    result[s] = "";
    for (var i in result) {
        if (result.hasOwnProperty(i)) {
            return i;
        }
    }
    /*
    var result: string = undefined;
    var chars: number[] = [];
    for (var i = 0, n = s.length; i < n; i++) {
        chars.push(s.charCodeAt(i));

        if (((i + 1) % 65536) === 0) {
            var chunk = String.fromCharCode.apply(null, chars);
            result = result ? result + chunk : chunk;
            chars = [];
        }
    }

    if (chars.length) {
        var chunk = String.fromCharCode.apply(null, chars);
        result = result ? result + chunk : chunk;
    }

    return result;
    */
}
function prepareTestRunner(text, writeOutput) {
    var start = new Date().getTime();
    var oldSyntaxTree = TypeScript.Parser.parse("file.ts", TypeScript.SimpleText.fromString(text), 1 /* ES5 */, false);
    writeOutput("initial:" + (new Date().getTime() - start) + "\r\n");
    var insertIndex = text.indexOf("/**  */") + "/** ".length;
    return run;
    function run() {
        var incrementalTotal = 0;
        var oldParseTotal = 0;
        var newParseTotal = 0;
        for (var i = 0; i < 100; i++) {
            var textChangeRange = new TypeScript.TextChangeRange(new TypeScript.TextSpan(insertIndex, 0), 1);
            var newText = createNewString(text.substring(0, insertIndex) + " " + text.substring(insertIndex));
            var simpleText = TypeScript.SimpleText.fromString(newText);
            //var start = new Date().getTime();
            //ts.createSourceFile("x", newText, ts.ScriptTarget.ES6, "0");
            //newParseTotal += (new Date().getTime() - start);
            // simpleText.lineMap().lineStarts();
            //var start = new Date().getTime();
            //TypeScript.Parser.parse("x", simpleText, ts.ScriptTarget.ES6, false);
            //oldParseTotal += (new Date().getTime() - start);
            var start = new Date().getTime();
            var newSyntaxTree = TypeScript.IncrementalParser.parse(oldSyntaxTree, textChangeRange, simpleText);
            incrementalTotal += (new Date().getTime() - start);
            //var start = new Date().getTime();
            //ts.createSourceFile("checker.ts", newText, ts.ScriptTarget.ES5, "0", true);
            //writeOutput("full: " + (new Date().getTime() - start) + "\r\n");
            text = newText;
            oldSyntaxTree = newSyntaxTree;
        }
        if (oldParseTotal) {
            writeOutput("old parse  : " + oldParseTotal + "\r\n");
        }
        if (newParseTotal) {
            writeOutput("new parse  : " + newParseTotal + "\r\n");
        }
        writeOutput("incremental: " + incrementalTotal + "\r\n");
    }
}
if (sys && sys.args.length) {
    var file = sys.readFile(sys.args[0]);
    var json = JSON.stringify({ text: file });
    sys.writeFile(ts.combinePaths(sys.getCurrentDirectory(), "file.ts.js"), "var text = " + json);
}
